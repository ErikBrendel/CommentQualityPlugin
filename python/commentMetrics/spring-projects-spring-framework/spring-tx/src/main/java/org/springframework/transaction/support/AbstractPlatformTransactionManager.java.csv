# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1328020251;Actually invoke the <code>afterCompletion</code> methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the <code>registerAfterCompletionWithExistingTransaction</code> callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,code,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,code,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1356735495;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1357119239;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1368482696;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1407763209;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1413473170;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1425660345;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1437567612;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1486062666;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1486719573;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1487371244;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1495868221;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1496242568;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1496259743;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1496837955;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1498780456;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1506842603;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1517867503;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1530174524;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations a List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,a,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus);1530174524;Actually invoke the {@code afterCompletion} methods of the_given Spring TransactionSynchronization objects._<p>To be called by this abstract manager itself, or by special implementations_of the {@code registerAfterCompletionWithExistingTransaction} callback._@param synchronizations a List of TransactionSynchronization objects_@param completionStatus the completion status according to the_constants in the TransactionSynchronization interface_@see #registerAfterCompletionWithExistingTransaction(Object, java.util.List)_@see TransactionSynchronization#STATUS_COMMITTED_@see TransactionSynchronization#STATUS_ROLLED_BACK_@see TransactionSynchronization#STATUS_UNKNOWN;protected final void invokeAfterCompletion(List<TransactionSynchronization> synchronizations, int completionStatus) {_		TransactionSynchronizationUtils.invokeAfterCompletion(synchronizations, completionStatus)__	};actually,invoke,the,code,after,completion,methods,of,the,given,spring,transaction,synchronization,objects,p,to,be,called,by,this,abstract,manager,itself,or,by,special,implementations,of,the,code,register,after,completion,with,existing,transaction,callback,param,synchronizations,a,list,of,transaction,synchronization,objects,param,completion,status,the,completion,status,according,to,the,constants,in,the,transaction,synchronization,interface,see,register,after,completion,with,existing,transaction,object,java,util,list,see,transaction,synchronization,see,transaction,synchronization,see,transaction,synchronization;protected,final,void,invoke,after,completion,list,transaction,synchronization,synchronizations,int,completion,status,transaction,synchronization,utils,invoke,after,completion,synchronizations,completion,status
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1328020251;Trigger <code>beforeCompletion</code> callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,code,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1356735495;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1357119239;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1368482696;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1407763209;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1413473170;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1425660345;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1437567612;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1486062666;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1486719573;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1487371244;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1495868221;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1496242568;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1496259743;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1496837955;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1498780456;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1506842603;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1517867503;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1530174524;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> protected final void triggerBeforeCompletion(DefaultTransactionStatus status);1530174524;Trigger {@code beforeCompletion} callbacks._@param status object representing the transaction;protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCompletion synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCompletion()__		}_	};trigger,code,before,completion,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,completion,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,completion,synchronization,transaction,synchronization,utils,trigger,before,completion
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1328020251;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1356735495;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1357119239;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1368482696;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1407763209;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1413473170;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1425660345;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1437567612;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1486062666;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1486719573;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1487371244;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1495868221;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1496242568;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1496259743;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1496837955;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1498780456;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1506842603;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1517867503;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1530174524;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final int getTransactionSynchronization();1530174524;Return if this transaction manager should activate the thread-bound_transaction synchronization support.;public final int getTransactionSynchronization() {_		return this.transactionSynchronization__	};return,if,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support;public,final,int,get,transaction,synchronization,return,this,transaction,synchronization
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1328020251;Return whether <code>doRollback</code> should be performed on failure of the_<code>doCommit</code> call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,code,should,be,performed,on,failure,of,the,code,do,commit,code,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1356735495;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1357119239;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1368482696;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1407763209;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1413473170;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1425660345;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1437567612;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1486062666;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1486719573;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1487371244;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1495868221;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1496242568;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1496259743;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1496837955;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1498780456;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1506842603;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1517867503;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1530174524;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final boolean isRollbackOnCommitFailure();1530174524;Return whether {@code doRollback} should be performed on failure of the_{@code doCommit} call.;public final boolean isRollbackOnCommitFailure() {_		return this.rollbackOnCommitFailure__	};return,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call;public,final,boolean,is,rollback,on,commit,failure,return,this,rollback,on,commit,failure
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1328020251;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1356735495;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1357119239;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1368482696;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1407763209;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1413473170;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1425660345;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1437567612;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1486062666;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1486719573;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1487371244;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1495868221;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1496242568;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1496259743;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1496837955;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1498780456;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1506842603;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1517867503;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1530174524;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations a List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,a,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations);1530174524;Reactivate transaction synchronization for the current thread_and resume all given synchronizations._@param suspendedSynchronizations a List of TransactionSynchronization objects;private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {_		TransactionSynchronizationManager.initSynchronization()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.resume()__			TransactionSynchronizationManager.registerSynchronization(synchronization)__		}_	};reactivate,transaction,synchronization,for,the,current,thread,and,resume,all,given,synchronizations,param,suspended,synchronizations,a,list,of,transaction,synchronization,objects;private,void,do,resume,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,init,synchronization,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,resume,transaction,synchronization,manager,register,synchronization,synchronization
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx);1496837955;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,nullable,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx);1498780456;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,nullable,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx);1506842603;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,nullable,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx);1517867503;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,nullable,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx);1530174524;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,nullable,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx);1530174524;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,nullable,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1328020251;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by <code>doGetTransaction</code>_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,code,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1356735495;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1357119239;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1368482696;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1407763209;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1413473170;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1425660345;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1437567612;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1486062666;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1486719573;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1487371244;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1495868221;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1496242568;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1496259743;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1496837955;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1498780456;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1506842603;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1517867503;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1530174524;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected Object doSuspend(Object transaction) throws TransactionException;1530174524;Suspend the resources of the current transaction._Transaction synchronization will already have been suspended._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@return an object that holds suspended resources_(will be kept unexamined for passing it into doResume)_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if suspending is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doResume;protected Object doSuspend(Object transaction) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};suspend,the,resources,of,the,current,transaction,transaction,synchronization,will,already,have,been,suspended,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,return,an,object,that,holds,suspended,resources,will,be,kept,unexamined,for,passing,it,into,do,resume,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,suspending,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,resume;protected,object,do,suspend,object,transaction,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> @Nullable 	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException;1495868221;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;@Nullable_	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;nullable,protected,final,suspended,resources,holder,suspend,nullable,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> @Nullable 	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException;1496242568;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;@Nullable_	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;nullable,protected,final,suspended,resources,holder,suspend,nullable,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> @Nullable 	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException;1496259743;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;@Nullable_	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;nullable,protected,final,suspended,resources,holder,suspend,nullable,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> @Nullable 	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException;1496837955;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;@Nullable_	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;nullable,protected,final,suspended,resources,holder,suspend,nullable,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> @Nullable 	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException;1498780456;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;@Nullable_	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;nullable,protected,final,suspended,resources,holder,suspend,nullable,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> @Nullable 	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException;1506842603;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;@Nullable_	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;nullable,protected,final,suspended,resources,holder,suspend,nullable,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> @Nullable 	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException;1517867503;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;@Nullable_	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;nullable,protected,final,suspended,resources,holder,suspend,nullable,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> @Nullable 	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException;1530174524;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;@Nullable_	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;nullable,protected,final,suspended,resources,holder,suspend,nullable,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> @Nullable 	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException;1530174524;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;@Nullable_	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;nullable,protected,final,suspended,resources,holder,suspend,nullable,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1328020251;Resume the given transaction. Delegates to the <code>doResume</code>_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by <code>suspend</code> (or <code>null</code> to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,code,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,code,or,code,null,code,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1356735495;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1357119239;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1368482696;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1407763209;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1413473170;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1425660345;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1437567612;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1486062666;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1486719573;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1487371244;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1328020251;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1356735495;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1357119239;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1368482696;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1407763209;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1413473170;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1425660345;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1437567612;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1486062666;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1486719573;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1487371244;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1495868221;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1496242568;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1496259743;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1496837955;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1498780456;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1506842603;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1517867503;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1530174524;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed);1530174524;Set whether nested transactions are allowed. Default is "false"._<p>Typically initialized with an appropriate default by the_concrete transaction manager subclass.;public final void setNestedTransactionAllowed(boolean nestedTransactionAllowed) {_		this.nestedTransactionAllowed = nestedTransactionAllowed__	};set,whether,nested,transactions,are,allowed,default,is,false,p,typically,initialized,with,an,appropriate,default,by,the,concrete,transaction,manager,subclass;public,final,void,set,nested,transaction,allowed,boolean,nested,transaction,allowed,this,nested,transaction,allowed,nested,transaction,allowed
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1328020251;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1356735495;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1357119239;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1368482696;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1407763209;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1413473170;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1425660345;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1437567612;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1486062666;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1486719573;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1487371244;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1495868221;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1496242568;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1496259743;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1496837955;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1498780456;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1506842603;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1517867503;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1530174524;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> private List<TransactionSynchronization> doSuspendSynchronization();1530174524;Suspend all current synchronizations and deactivate transaction_synchronization for the current thread._@return the List of suspended TransactionSynchronization objects;private List<TransactionSynchronization> doSuspendSynchronization() {_		List<TransactionSynchronization> suspendedSynchronizations =_				TransactionSynchronizationManager.getSynchronizations()__		for (TransactionSynchronization synchronization : suspendedSynchronizations) {_			synchronization.suspend()__		}_		TransactionSynchronizationManager.clearSynchronization()__		return suspendedSynchronizations__	};suspend,all,current,synchronizations,and,deactivate,transaction,synchronization,for,the,current,thread,return,the,list,of,suspended,transaction,synchronization,objects;private,list,transaction,synchronization,do,suspend,synchronization,list,transaction,synchronization,suspended,synchronizations,transaction,synchronization,manager,get,synchronizations,for,transaction,synchronization,synchronization,suspended,synchronizations,synchronization,suspend,transaction,synchronization,manager,clear,synchronization,return,suspended,synchronizations
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1328020251;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1356735495;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1357119239;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1368482696;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1407763209;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1413473170;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1425660345;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1437567612;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1486062666;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1486719573;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1487371244;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1495868221;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1496242568;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1496259743;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1496837955;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1498780456;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1506842603;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1517867503;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1530174524;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final void setTransactionSynchronizationName(String constantName);1530174524;Set the transaction synchronization by the name of the corresponding constant_in this class, e.g. "SYNCHRONIZATION_ALWAYS"._@param constantName name of the constant_@see #SYNCHRONIZATION_ALWAYS;public final void setTransactionSynchronizationName(String constantName) {_		setTransactionSynchronization(constants.asNumber(constantName).intValue())__	};set,the,transaction,synchronization,by,the,name,of,the,corresponding,constant,in,this,class,e,g,param,constant,name,name,of,the,constant,see;public,final,void,set,transaction,synchronization,name,string,constant,name,set,transaction,synchronization,constants,as,number,constant,name,int,value
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1328020251;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1356735495;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1357119239;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1368482696;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1407763209;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1413473170;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1425660345;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1437567612;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1486062666;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1486719573;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1487371244;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1495868221;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1496242568;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1496259743;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1496837955;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1498780456;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1506842603;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1517867503;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1530174524;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> public final boolean isNestedTransactionAllowed();1530174524;Return whether nested transactions are allowed.;public final boolean isNestedTransactionAllowed() {_		return this.nestedTransactionAllowed__	};return,whether,nested,transactions,are,allowed;public,final,boolean,is,nested,transaction,allowed,return,this,nested,transaction,allowed
AbstractPlatformTransactionManager -> protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1496259743;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,nullable,object,transaction,nullable,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1496837955;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,nullable,object,transaction,nullable,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1498780456;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,nullable,object,transaction,nullable,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1506842603;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,nullable,object,transaction,nullable,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1517867503;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,nullable,object,transaction,nullable,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1530174524;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,nullable,object,transaction,nullable,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1530174524;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,nullable,object,transaction,nullable,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1328020251;Set whether <code>doRollback</code> should be performed on failure of the_<code>doCommit</code> call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,code,should,be,performed,on,failure,of,the,code,do,commit,code,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1356735495;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1357119239;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1368482696;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1407763209;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1413473170;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1425660345;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1437567612;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1486062666;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1486719573;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1487371244;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1495868221;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1496242568;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1496259743;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1496837955;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1498780456;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1506842603;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1517867503;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1530174524;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure);1530174524;Set whether {@code doRollback} should be performed on failure of the_{@code doCommit} call. Typically not necessary and thus to be avoided,_as it can potentially override the commit exception with a subsequent_rollback exception._<p>Default is "false"._@see #doCommit_@see #doRollback;public final void setRollbackOnCommitFailure(boolean rollbackOnCommitFailure) {_		this.rollbackOnCommitFailure = rollbackOnCommitFailure__	};set,whether,code,do,rollback,should,be,performed,on,failure,of,the,code,do,commit,call,typically,not,necessary,and,thus,to,be,avoided,as,it,can,potentially,override,the,commit,exception,with,a,subsequent,rollback,exception,p,default,is,false,see,do,commit,see,do,rollback;public,final,void,set,rollback,on,commit,failure,boolean,rollback,on,commit,failure,this,rollback,on,commit,failure,rollback,on,commit,failure
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1496837955;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1498780456;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1506842603;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1517867503;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1530174524;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1530174524;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1328020251;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_<code>TransactionDefinition.TIMEOUT_DEFAULT</code> value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,code,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1356735495;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1357119239;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1368482696;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1407763209;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1413473170;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1425660345;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1437567612;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1486062666;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1486719573;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1487371244;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1495868221;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1496242568;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1496259743;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1496837955;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1498780456;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1506842603;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1517867503;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1530174524;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> public final void setDefaultTimeout(int defaultTimeout);1530174524;Specify the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Default is the underlying transaction infrastructure's default timeout,_e.g. typically 30 seconds in case of a JTA provider, indicated by the_{@code TransactionDefinition.TIMEOUT_DEFAULT} value._@see org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT;public final void setDefaultTimeout(int defaultTimeout) {_		if (defaultTimeout < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid default timeout", defaultTimeout)__		}_		this.defaultTimeout = defaultTimeout__	};specify,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,default,is,the,underlying,transaction,infrastructure,s,default,timeout,e,g,typically,30,seconds,in,case,of,a,jta,provider,indicated,by,the,code,transaction,definition,value,see,org,springframework,transaction,transaction,definition;public,final,void,set,default,timeout,int,default,timeout,if,default,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,default,timeout,default,timeout,this,default,timeout,default,timeout
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status, boolean unexpected);1487371244;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status, boolean unexpected) {_		try {_			boolean unexpectedRollback = unexpected___			try {_				triggerBeforeCompletion(status)___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else {_					_					if (status.hasTransaction()) {_						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__							}_							doSetRollbackOnly(status)__						}_						else {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__							}_						}_					}_					else {_						logger.debug("Should roll back transaction but cannot - no transaction available")__					}_					_					if (!isFailEarlyOnGlobalRollbackOnly()) {_						unexpectedRollback = false__					}_				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)___			_			if (unexpectedRollback) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,boolean,unexpected,try,boolean,unexpected,rollback,unexpected,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,if,is,fail,early,on,global,rollback,only,unexpected,rollback,false,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status, boolean unexpected);1495868221;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status, boolean unexpected) {_		try {_			boolean unexpectedRollback = unexpected___			try {_				triggerBeforeCompletion(status)___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else {_					_					if (status.hasTransaction()) {_						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__							}_							doSetRollbackOnly(status)__						}_						else {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__							}_						}_					}_					else {_						logger.debug("Should roll back transaction but cannot - no transaction available")__					}_					_					if (!isFailEarlyOnGlobalRollbackOnly()) {_						unexpectedRollback = false__					}_				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)___			_			if (unexpectedRollback) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,boolean,unexpected,try,boolean,unexpected,rollback,unexpected,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,if,is,fail,early,on,global,rollback,only,unexpected,rollback,false,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status, boolean unexpected);1496242568;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status, boolean unexpected) {_		try {_			boolean unexpectedRollback = unexpected___			try {_				triggerBeforeCompletion(status)___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else {_					_					if (status.hasTransaction()) {_						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__							}_							doSetRollbackOnly(status)__						}_						else {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__							}_						}_					}_					else {_						logger.debug("Should roll back transaction but cannot - no transaction available")__					}_					_					if (!isFailEarlyOnGlobalRollbackOnly()) {_						unexpectedRollback = false__					}_				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)___			_			if (unexpectedRollback) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,boolean,unexpected,try,boolean,unexpected,rollback,unexpected,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,if,is,fail,early,on,global,rollback,only,unexpected,rollback,false,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status, boolean unexpected);1496259743;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status, boolean unexpected) {_		try {_			boolean unexpectedRollback = unexpected___			try {_				triggerBeforeCompletion(status)___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else {_					_					if (status.hasTransaction()) {_						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__							}_							doSetRollbackOnly(status)__						}_						else {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__							}_						}_					}_					else {_						logger.debug("Should roll back transaction but cannot - no transaction available")__					}_					_					if (!isFailEarlyOnGlobalRollbackOnly()) {_						unexpectedRollback = false__					}_				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)___			_			if (unexpectedRollback) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,boolean,unexpected,try,boolean,unexpected,rollback,unexpected,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,if,is,fail,early,on,global,rollback,only,unexpected,rollback,false,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status, boolean unexpected);1496837955;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status, boolean unexpected) {_		try {_			boolean unexpectedRollback = unexpected___			try {_				triggerBeforeCompletion(status)___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else {_					_					if (status.hasTransaction()) {_						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__							}_							doSetRollbackOnly(status)__						}_						else {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__							}_						}_					}_					else {_						logger.debug("Should roll back transaction but cannot - no transaction available")__					}_					_					if (!isFailEarlyOnGlobalRollbackOnly()) {_						unexpectedRollback = false__					}_				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)___			_			if (unexpectedRollback) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,boolean,unexpected,try,boolean,unexpected,rollback,unexpected,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,if,is,fail,early,on,global,rollback,only,unexpected,rollback,false,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status, boolean unexpected);1498780456;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status, boolean unexpected) {_		try {_			boolean unexpectedRollback = unexpected___			try {_				triggerBeforeCompletion(status)___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else {_					_					if (status.hasTransaction()) {_						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__							}_							doSetRollbackOnly(status)__						}_						else {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__							}_						}_					}_					else {_						logger.debug("Should roll back transaction but cannot - no transaction available")__					}_					_					if (!isFailEarlyOnGlobalRollbackOnly()) {_						unexpectedRollback = false__					}_				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)___			_			if (unexpectedRollback) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,boolean,unexpected,try,boolean,unexpected,rollback,unexpected,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,if,is,fail,early,on,global,rollback,only,unexpected,rollback,false,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status, boolean unexpected);1506842603;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status, boolean unexpected) {_		try {_			boolean unexpectedRollback = unexpected___			try {_				triggerBeforeCompletion(status)___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else {_					_					if (status.hasTransaction()) {_						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__							}_							doSetRollbackOnly(status)__						}_						else {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__							}_						}_					}_					else {_						logger.debug("Should roll back transaction but cannot - no transaction available")__					}_					_					if (!isFailEarlyOnGlobalRollbackOnly()) {_						unexpectedRollback = false__					}_				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)___			_			if (unexpectedRollback) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,boolean,unexpected,try,boolean,unexpected,rollback,unexpected,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,if,is,fail,early,on,global,rollback,only,unexpected,rollback,false,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status, boolean unexpected);1517867503;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status, boolean unexpected) {_		try {_			boolean unexpectedRollback = unexpected___			try {_				triggerBeforeCompletion(status)___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else {_					_					if (status.hasTransaction()) {_						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__							}_							doSetRollbackOnly(status)__						}_						else {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__							}_						}_					}_					else {_						logger.debug("Should roll back transaction but cannot - no transaction available")__					}_					_					if (!isFailEarlyOnGlobalRollbackOnly()) {_						unexpectedRollback = false__					}_				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)___			_			if (unexpectedRollback) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,boolean,unexpected,try,boolean,unexpected,rollback,unexpected,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,if,is,fail,early,on,global,rollback,only,unexpected,rollback,false,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status, boolean unexpected);1530174524;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status, boolean unexpected) {_		try {_			boolean unexpectedRollback = unexpected___			try {_				triggerBeforeCompletion(status)___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else {_					_					if (status.hasTransaction()) {_						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__							}_							doSetRollbackOnly(status)__						}_						else {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__							}_						}_					}_					else {_						logger.debug("Should roll back transaction but cannot - no transaction available")__					}_					_					if (!isFailEarlyOnGlobalRollbackOnly()) {_						unexpectedRollback = false__					}_				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)___			_			if (unexpectedRollback) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,boolean,unexpected,try,boolean,unexpected,rollback,unexpected,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,if,is,fail,early,on,global,rollback,only,unexpected,rollback,false,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status, boolean unexpected);1530174524;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status, boolean unexpected) {_		try {_			boolean unexpectedRollback = unexpected___			try {_				triggerBeforeCompletion(status)___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else {_					_					if (status.hasTransaction()) {_						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__							}_							doSetRollbackOnly(status)__						}_						else {_							if (status.isDebug()) {_								logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__							}_						}_					}_					else {_						logger.debug("Should roll back transaction but cannot - no transaction available")__					}_					_					if (!isFailEarlyOnGlobalRollbackOnly()) {_						unexpectedRollback = false__					}_				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)___			_			if (unexpectedRollback) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,boolean,unexpected,try,boolean,unexpected,rollback,unexpected,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,if,is,fail,early,on,global,rollback,only,unexpected,rollback,false,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1328020251;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_			catch (Error beginErr) {_				resumeAfterBeginException(transaction, suspendedResources, beginErr)__				throw beginErr__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,catch,error,begin,err,resume,after,begin,exception,transaction,suspended,resources,begin,err,throw,begin,err,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1356735495;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_			catch (Error beginErr) {_				resumeAfterBeginException(transaction, suspendedResources, beginErr)__				throw beginErr__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,catch,error,begin,err,resume,after,begin,exception,transaction,suspended,resources,begin,err,throw,begin,err,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1357119239;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_			catch (Error beginErr) {_				resumeAfterBeginException(transaction, suspendedResources, beginErr)__				throw beginErr__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,catch,error,begin,err,resume,after,begin,exception,transaction,suspended,resources,begin,err,throw,begin,err,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1368482696;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_			catch (Error beginErr) {_				resumeAfterBeginException(transaction, suspendedResources, beginErr)__				throw beginErr__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,catch,error,begin,err,resume,after,begin,exception,transaction,suspended,resources,begin,err,throw,begin,err,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1407763209;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_			catch (Error beginErr) {_				resumeAfterBeginException(transaction, suspendedResources, beginErr)__				throw beginErr__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,catch,error,begin,err,resume,after,begin,exception,transaction,suspended,resources,begin,err,throw,begin,err,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1413473170;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_			catch (Error beginErr) {_				resumeAfterBeginException(transaction, suspendedResources, beginErr)__				throw beginErr__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,catch,error,begin,err,resume,after,begin,exception,transaction,suspended,resources,begin,err,throw,begin,err,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1425660345;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_			catch (Error beginErr) {_				resumeAfterBeginException(transaction, suspendedResources, beginErr)__				throw beginErr__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,catch,error,begin,err,resume,after,begin,exception,transaction,suspended,resources,begin,err,throw,begin,err,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1437567612;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_			catch (Error beginErr) {_				resumeAfterBeginException(transaction, suspendedResources, beginErr)__				throw beginErr__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,catch,error,begin,err,resume,after,begin,exception,transaction,suspended,resources,begin,err,throw,begin,err,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1486062666;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1486719573;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1487371244;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1495868221;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1496242568;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1496259743;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1496837955;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1498780456;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1506842603;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1517867503;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1530174524;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private TransactionStatus handleExistingTransaction( 			TransactionDefinition definition, Object transaction, boolean debugEnabled) 			throws TransactionException;1530174524;Create a TransactionStatus for an existing transaction.;private TransactionStatus handleExistingTransaction(_			TransactionDefinition definition, Object transaction, boolean debugEnabled)_			throws TransactionException {__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {_			throw new IllegalTransactionStateException(_					"Existing transaction found for transaction marked with propagation 'never'")__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction")__			}_			Object suspendedResources = suspend(transaction)__			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(_					definition, null, false, newSynchronization, debugEnabled, suspendedResources)__		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {_			if (debugEnabled) {_				logger.debug("Suspending current transaction, creating new transaction with name [" +_						definition.getName() + "]")__			}_			SuspendedResourcesHolder suspendedResources = suspend(transaction)__			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error beginEx) {_				resumeAfterBeginException(transaction, suspendedResources, beginEx)__				throw beginEx__			}_		}__		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			if (!isNestedTransactionAllowed()) {_				throw new NestedTransactionNotSupportedException(_						"Transaction manager does not allow nested transactions by default - " +_						"specify 'nestedTransactionAllowed' property with value 'true'")__			}_			if (debugEnabled) {_				logger.debug("Creating nested transaction with name [" + definition.getName() + "]")__			}_			if (useSavepointForNestedTransaction()) {_				_				_				_				DefaultTransactionStatus status =_						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null)__				status.createAndHoldSavepoint()__				return status__			}_			else {_				_				_				_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, null)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_		}__		_		if (debugEnabled) {_			logger.debug("Participating in existing transaction")__		}_		if (isValidateExistingTransaction()) {_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {_				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {_					Constants isoConstants = DefaultTransactionDefinition.constants__					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] specifies isolation level which is incompatible with existing transaction: " +_							(currentIsolationLevel != null ?_									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :_									"(unknown)"))__				}_			}_			if (!definition.isReadOnly()) {_				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {_					throw new IllegalTransactionStateException("Participating transaction with definition [" +_							definition + "] is not marked as read-only but existing transaction is")__				}_			}_		}_		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null)__	};create,a,transaction,status,for,an,existing,transaction;private,transaction,status,handle,existing,transaction,transaction,definition,definition,object,transaction,boolean,debug,enabled,throws,transaction,exception,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,existing,transaction,found,for,transaction,marked,with,propagation,never,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,object,suspended,resources,suspend,transaction,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,false,new,synchronization,debug,enabled,suspended,resources,if,definition,get,propagation,behavior,transaction,definition,if,debug,enabled,logger,debug,suspending,current,transaction,creating,new,transaction,with,name,definition,get,name,suspended,resources,holder,suspended,resources,suspend,transaction,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,begin,ex,resume,after,begin,exception,transaction,suspended,resources,begin,ex,throw,begin,ex,if,definition,get,propagation,behavior,transaction,definition,if,is,nested,transaction,allowed,throw,new,nested,transaction,not,supported,exception,transaction,manager,does,not,allow,nested,transactions,by,default,specify,nested,transaction,allowed,property,with,value,true,if,debug,enabled,logger,debug,creating,nested,transaction,with,name,definition,get,name,if,use,savepoint,for,nested,transaction,default,transaction,status,status,prepare,transaction,status,definition,transaction,false,false,debug,enabled,null,status,create,and,hold,savepoint,return,status,else,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,null,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,if,debug,enabled,logger,debug,participating,in,existing,transaction,if,is,validate,existing,transaction,if,definition,get,isolation,level,transaction,definition,integer,current,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,if,current,isolation,level,null,current,isolation,level,definition,get,isolation,level,constants,iso,constants,default,transaction,definition,constants,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,specifies,isolation,level,which,is,incompatible,with,existing,transaction,current,isolation,level,null,iso,constants,to,code,current,isolation,level,default,transaction,definition,unknown,if,definition,is,read,only,if,transaction,synchronization,manager,is,current,transaction,read,only,throw,new,illegal,transaction,state,exception,participating,transaction,with,definition,definition,is,not,marked,as,read,only,but,existing,transaction,is,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,transaction,false,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1328020251;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_		catch (Error resumeErr) {_			logger.error(exMessage, beginEx)__			throw resumeErr__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex,catch,error,resume,err,logger,error,ex,message,begin,ex,throw,resume,err
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1356735495;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_		catch (Error resumeErr) {_			logger.error(exMessage, beginEx)__			throw resumeErr__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex,catch,error,resume,err,logger,error,ex,message,begin,ex,throw,resume,err
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1357119239;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_		catch (Error resumeErr) {_			logger.error(exMessage, beginEx)__			throw resumeErr__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex,catch,error,resume,err,logger,error,ex,message,begin,ex,throw,resume,err
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1368482696;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_		catch (Error resumeErr) {_			logger.error(exMessage, beginEx)__			throw resumeErr__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex,catch,error,resume,err,logger,error,ex,message,begin,ex,throw,resume,err
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1407763209;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_		catch (Error resumeErr) {_			logger.error(exMessage, beginEx)__			throw resumeErr__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex,catch,error,resume,err,logger,error,ex,message,begin,ex,throw,resume,err
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1413473170;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_		catch (Error resumeErr) {_			logger.error(exMessage, beginEx)__			throw resumeErr__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex,catch,error,resume,err,logger,error,ex,message,begin,ex,throw,resume,err
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1425660345;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_		catch (Error resumeErr) {_			logger.error(exMessage, beginEx)__			throw resumeErr__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex,catch,error,resume,err,logger,error,ex,message,begin,ex,throw,resume,err
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1437567612;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_		catch (Error resumeErr) {_			logger.error(exMessage, beginEx)__			throw resumeErr__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex,catch,error,resume,err,logger,error,ex,message,begin,ex,throw,resume,err
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1486062666;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1486719573;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1487371244;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1495868221;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1496242568;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> private void resumeAfterBeginException( 			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx);1496259743;Resume outer transaction after inner transaction begin failed.;private void resumeAfterBeginException(_			Object transaction, SuspendedResourcesHolder suspendedResources, Throwable beginEx) {__		String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception"__		try {_			resume(transaction, suspendedResources)__		}_		catch (RuntimeException | Error resumeEx) {_			logger.error(exMessage, beginEx)__			throw resumeEx__		}_	};resume,outer,transaction,after,inner,transaction,begin,failed;private,void,resume,after,begin,exception,object,transaction,suspended,resources,holder,suspended,resources,throwable,begin,ex,string,ex,message,inner,transaction,begin,exception,overridden,by,outer,transaction,resume,exception,try,resume,transaction,suspended,resources,catch,runtime,exception,error,resume,ex,logger,error,ex,message,begin,ex,throw,resume,ex
AbstractPlatformTransactionManager -> protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException;1496837955;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,nullable,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException;1498780456;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,nullable,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException;1506842603;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,nullable,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException;1517867503;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,nullable,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException;1530174524;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,nullable,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException;1530174524;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(@Nullable Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,nullable,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1328020251;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1356735495;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1357119239;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1368482696;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1407763209;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1413473170;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1425660345;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1437567612;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1486062666;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1486719573;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1487371244;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1495868221;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1496242568;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1496259743;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,resume,status,get,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1496837955;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			Object transaction = (status.hasTransaction() ? status.getTransaction() : null)__			resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,object,transaction,status,has,transaction,status,get,transaction,null,resume,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1498780456;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			Object transaction = (status.hasTransaction() ? status.getTransaction() : null)__			resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,object,transaction,status,has,transaction,status,get,transaction,null,resume,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1506842603;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			Object transaction = (status.hasTransaction() ? status.getTransaction() : null)__			resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,object,transaction,status,has,transaction,status,get,transaction,null,resume,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1517867503;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			Object transaction = (status.hasTransaction() ? status.getTransaction() : null)__			resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,object,transaction,status,has,transaction,status,get,transaction,null,resume,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1530174524;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			Object transaction = (status.hasTransaction() ? status.getTransaction() : null)__			resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,object,transaction,status,has,transaction,status,get,transaction,null,resume,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> private void cleanupAfterCompletion(DefaultTransactionStatus status);1530174524;Clean up after completion, clearing synchronization if necessary,_and invoking doCleanupAfterCompletion._@param status object representing the transaction_@see #doCleanupAfterCompletion;private void cleanupAfterCompletion(DefaultTransactionStatus status) {_		status.setCompleted()__		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.clear()__		}_		if (status.isNewTransaction()) {_			doCleanupAfterCompletion(status.getTransaction())__		}_		if (status.getSuspendedResources() != null) {_			if (status.isDebug()) {_				logger.debug("Resuming suspended transaction after completion of inner transaction")__			}_			Object transaction = (status.hasTransaction() ? status.getTransaction() : null)__			resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources())__		}_	};clean,up,after,completion,clearing,synchronization,if,necessary,and,invoking,do,cleanup,after,completion,param,status,object,representing,the,transaction,see,do,cleanup,after,completion;private,void,cleanup,after,completion,default,transaction,status,status,status,set,completed,if,status,is,new,synchronization,transaction,synchronization,manager,clear,if,status,is,new,transaction,do,cleanup,after,completion,status,get,transaction,if,status,get,suspended,resources,null,if,status,is,debug,logger,debug,resuming,suspended,transaction,after,completion,of,inner,transaction,object,transaction,status,has,transaction,status,get,transaction,null,resume,transaction,suspended,resources,holder,status,get,suspended,resources
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1328020251;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current <code>getTransaction</code> call on the transaction manager._Consequently, a <code>doGetTransaction</code> implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,code,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,code,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1356735495;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1357119239;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1368482696;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1407763209;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1413473170;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1425660345;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1437567612;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1486062666;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1486719573;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1487371244;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1495868221;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1496242568;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1496259743;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1496837955;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1498780456;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1506842603;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1517867503;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1530174524;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract Object doGetTransaction() throws TransactionException_;1530174524;Return a transaction object for the current transaction state._<p>The returned object will usually be specific to the concrete transaction_manager implementation, carrying corresponding transaction state in a_modifiable fashion. This object will be passed into the other template_methods (e.g. doBegin and doCommit), either directly or as part of a_DefaultTransactionStatus instance._<p>The returned object should contain information about any existing_transaction, that is, a transaction that has already started before the_current {@code getTransaction} call on the transaction manager._Consequently, a {@code doGetTransaction} implementation will usually_look for an existing transaction and store corresponding state in the_returned transaction object._@return the current transaction object_@throws org.springframework.transaction.CannotCreateTransactionException_if transaction support is not available_@throws TransactionException in case of lookup or system errors_@see #doBegin_@see #doCommit_@see #doRollback_@see DefaultTransactionStatus#getTransaction;protected abstract Object doGetTransaction() throws TransactionException_;return,a,transaction,object,for,the,current,transaction,state,p,the,returned,object,will,usually,be,specific,to,the,concrete,transaction,manager,implementation,carrying,corresponding,transaction,state,in,a,modifiable,fashion,this,object,will,be,passed,into,the,other,template,methods,e,g,do,begin,and,do,commit,either,directly,or,as,part,of,a,default,transaction,status,instance,p,the,returned,object,should,contain,information,about,any,existing,transaction,that,is,a,transaction,that,has,already,started,before,the,current,code,get,transaction,call,on,the,transaction,manager,consequently,a,code,do,get,transaction,implementation,will,usually,look,for,an,existing,transaction,and,store,corresponding,state,in,the,returned,transaction,object,return,the,current,transaction,object,throws,org,springframework,transaction,cannot,create,transaction,exception,if,transaction,support,is,not,available,throws,transaction,exception,in,case,of,lookup,or,system,errors,see,do,begin,see,do,commit,see,do,rollback,see,default,transaction,status,get,transaction;protected,abstract,object,do,get,transaction,throws,transaction,exception
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1328020251;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns <code>false</code>, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,code,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1356735495;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1357119239;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1368482696;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1407763209;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1413473170;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1425660345;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1437567612;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1486062666;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1486719573;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1487371244;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1495868221;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1496242568;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1496259743;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1496837955;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1498780456;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1506842603;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1517867503;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1530174524;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected boolean isExistingTransaction(Object transaction) throws TransactionException;1530174524;Check if the given transaction object indicates an existing transaction_(that is, a transaction which has already started)._<p>The result will be evaluated according to the specified propagation_behavior for the new transaction. An existing transaction might get_suspended (in case of PROPAGATION_REQUIRES_NEW), or the new transaction_might participate in the existing one (in case of PROPAGATION_REQUIRED)._<p>The default implementation returns {@code false}, assuming that_participating in existing transactions is generally not supported._Subclasses are of course encouraged to provide such support._@param transaction transaction object returned by doGetTransaction_@return if there is an existing transaction_@throws TransactionException in case of system errors_@see #doGetTransaction;protected boolean isExistingTransaction(Object transaction) throws TransactionException {_		return false__	};check,if,the,given,transaction,object,indicates,an,existing,transaction,that,is,a,transaction,which,has,already,started,p,the,result,will,be,evaluated,according,to,the,specified,propagation,behavior,for,the,new,transaction,an,existing,transaction,might,get,suspended,in,case,of,or,the,new,transaction,might,participate,in,the,existing,one,in,case,of,p,the,default,implementation,returns,code,false,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,transaction,transaction,object,returned,by,do,get,transaction,return,if,there,is,an,existing,transaction,throws,transaction,exception,in,case,of,system,errors,see,do,get,transaction;protected,boolean,is,existing,transaction,object,transaction,throws,transaction,exception,return,false
AbstractPlatformTransactionManager -> protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException;1328020251;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the <code>doSuspend</code> template method._@param transaction the current transaction object_(or <code>null</code> to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or <code>null</code> if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_			catch (Error err) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw err__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,code,template,method,param,transaction,the,current,transaction,object,or,code,null,code,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,code,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;protected,final,suspended,resources,holder,suspend,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,catch,error,err,do,resume,synchronization,suspended,synchronizations,throw,err,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException;1356735495;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_			catch (Error err) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw err__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;protected,final,suspended,resources,holder,suspend,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,catch,error,err,do,resume,synchronization,suspended,synchronizations,throw,err,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException;1357119239;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_			catch (Error err) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw err__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;protected,final,suspended,resources,holder,suspend,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,catch,error,err,do,resume,synchronization,suspended,synchronizations,throw,err,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException;1368482696;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_			catch (Error err) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw err__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;protected,final,suspended,resources,holder,suspend,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,catch,error,err,do,resume,synchronization,suspended,synchronizations,throw,err,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException;1407763209;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_			catch (Error err) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw err__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;protected,final,suspended,resources,holder,suspend,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,catch,error,err,do,resume,synchronization,suspended,synchronizations,throw,err,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException;1413473170;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_			catch (Error err) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw err__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;protected,final,suspended,resources,holder,suspend,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,catch,error,err,do,resume,synchronization,suspended,synchronizations,throw,err,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException;1425660345;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_			catch (Error err) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw err__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;protected,final,suspended,resources,holder,suspend,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,catch,error,err,do,resume,synchronization,suspended,synchronizations,throw,err,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException;1437567612;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_			catch (Error err) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw err__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;protected,final,suspended,resources,holder,suspend,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,catch,error,err,do,resume,synchronization,suspended,synchronizations,throw,err,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException;1486062666;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;protected,final,suspended,resources,holder,suspend,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException;1486719573;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;protected,final,suspended,resources,holder,suspend,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException;1487371244;Suspend the given transaction. Suspends transaction synchronization first,_then delegates to the {@code doSuspend} template method._@param transaction the current transaction object_(or {@code null} to just suspend active synchronizations, if any)_@return an object that holds suspended resources_(or {@code null} if neither transaction nor synchronization active)_@see #doSuspend_@see #resume;protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {_		if (TransactionSynchronizationManager.isSynchronizationActive()) {_			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization()__			try {_				Object suspendedResources = null__				if (transaction != null) {_					suspendedResources = doSuspend(transaction)__				}_				String name = TransactionSynchronizationManager.getCurrentTransactionName()__				TransactionSynchronizationManager.setCurrentTransactionName(null)__				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly()__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false)__				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null)__				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive()__				TransactionSynchronizationManager.setActualTransactionActive(false)__				return new SuspendedResourcesHolder(_						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive)__			}_			catch (RuntimeException | Error ex) {_				_				doResumeSynchronization(suspendedSynchronizations)__				throw ex__			}_		}_		else if (transaction != null) {_			_			Object suspendedResources = doSuspend(transaction)__			return new SuspendedResourcesHolder(suspendedResources)__		}_		else {_			_			return null__		}_	};suspend,the,given,transaction,suspends,transaction,synchronization,first,then,delegates,to,the,code,do,suspend,template,method,param,transaction,the,current,transaction,object,or,code,null,to,just,suspend,active,synchronizations,if,any,return,an,object,that,holds,suspended,resources,or,code,null,if,neither,transaction,nor,synchronization,active,see,do,suspend,see,resume;protected,final,suspended,resources,holder,suspend,object,transaction,throws,transaction,exception,if,transaction,synchronization,manager,is,synchronization,active,list,transaction,synchronization,suspended,synchronizations,do,suspend,synchronization,try,object,suspended,resources,null,if,transaction,null,suspended,resources,do,suspend,transaction,string,name,transaction,synchronization,manager,get,current,transaction,name,transaction,synchronization,manager,set,current,transaction,name,null,boolean,read,only,transaction,synchronization,manager,is,current,transaction,read,only,transaction,synchronization,manager,set,current,transaction,read,only,false,integer,isolation,level,transaction,synchronization,manager,get,current,transaction,isolation,level,transaction,synchronization,manager,set,current,transaction,isolation,level,null,boolean,was,active,transaction,synchronization,manager,is,actual,transaction,active,transaction,synchronization,manager,set,actual,transaction,active,false,return,new,suspended,resources,holder,suspended,resources,suspended,synchronizations,name,read,only,isolation,level,was,active,catch,runtime,exception,error,ex,do,resume,synchronization,suspended,synchronizations,throw,ex,else,if,transaction,null,object,suspended,resources,do,suspend,transaction,return,new,suspended,resources,holder,suspended,resources,else,return,null
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1328020251;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1356735495;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1357119239;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1368482696;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1407763209;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1413473170;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1425660345;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1437567612;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1486062666;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1486719573;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1487371244;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1495868221;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1496242568;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1496259743;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1496837955;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1498780456;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1506842603;Return whether to fail early in case of the transaction being globally marked_as rollback-only.;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1517867503;Return whether to fail early in case of the transaction being globally marked_as rollback-only._@since 2.0;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,since,2,0;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1530174524;Return whether to fail early in case of the transaction being globally marked_as rollback-only._@since 2.0;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,since,2,0;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final boolean isFailEarlyOnGlobalRollbackOnly();1530174524;Return whether to fail early in case of the transaction being globally marked_as rollback-only._@since 2.0;public final boolean isFailEarlyOnGlobalRollbackOnly() {_		return this.failEarlyOnGlobalRollbackOnly__	};return,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,since,2,0;public,final,boolean,is,fail,early,on,global,rollback,only,return,this,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1328020251;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					(definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1356735495;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					(definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1357119239;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					(definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1368482696;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					(definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1407763209;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					(definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1413473170;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1425660345;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1437567612;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1486062666;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1486719573;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1487371244;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1495868221;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1496242568;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1496259743;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1496837955;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1498780456;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1506842603;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1517867503;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1530174524;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition);1530174524;Initialize transaction synchronization as appropriate.;protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {_		if (status.isNewSynchronization()) {_			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction())__			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(_					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?_							definition.getIsolationLevel() : null)__			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())__			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName())__			TransactionSynchronizationManager.initSynchronization()__		}_	};initialize,transaction,synchronization,as,appropriate;protected,void,prepare,synchronization,default,transaction,status,status,transaction,definition,definition,if,status,is,new,synchronization,transaction,synchronization,manager,set,actual,transaction,active,status,has,transaction,transaction,synchronization,manager,set,current,transaction,isolation,level,definition,get,isolation,level,transaction,definition,definition,get,isolation,level,null,transaction,synchronization,manager,set,current,transaction,read,only,definition,is,read,only,transaction,synchronization,manager,set,current,transaction,name,definition,get,name,transaction,synchronization,manager,init,synchronization
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1356735495;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1368482696;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1407763209;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1413473170;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1425660345;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1437567612;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1486062666;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1486719573;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1487371244;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus, false)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status,false
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1495868221;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus, false)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status,false
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1496242568;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus, false)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status,false
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1496259743;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus, false)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status,false
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1496837955;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus, false)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status,false
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1498780456;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus, false)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status,false
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1506842603;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus, false)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status,false
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1517867503;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus, false)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status,false
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1530174524;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus, false)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status,false
AbstractPlatformTransactionManager -> @Override 	public final void rollback(TransactionStatus status) throws TransactionException;1530174524;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;@Override_	public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus, false)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;override,public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status,false
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1328020251;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1356735495;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1357119239;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1368482696;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1407763209;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1413473170;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1425660345;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1437567612;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1486062666;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1486719573;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1487371244;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1495868221;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1496242568;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1496259743;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1496837955;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1498780456;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1506842603;Return whether existing transactions should be validated before participating_in them.;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1517867503;Return whether existing transactions should be validated before participating_in them._@since 2.5.1;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them,since,2,5,1;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1530174524;Return whether existing transactions should be validated before participating_in them._@since 2.5.1;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them,since,2,5,1;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> public final boolean isValidateExistingTransaction();1530174524;Return whether existing transactions should be validated before participating_in them._@since 2.5.1;public final boolean isValidateExistingTransaction() {_		return this.validateExistingTransaction__	};return,whether,existing,transactions,should,be,validated,before,participating,in,them,since,2,5,1;public,final,boolean,is,validate,existing,transaction,return,this,validate,existing,transaction
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1328020251;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false__			try {_				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true__				boolean globalRollbackOnly = false__				if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_					globalRollbackOnly = status.isGlobalRollbackOnly()__				}_				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					doCommit(status)__				}_				_				_				if (globalRollbackOnly) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}_			catch (Error err) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, err)__				throw err__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,boolean,global,rollback,only,false,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,global,rollback,only,status,is,global,rollback,only,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,do,commit,status,if,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,catch,error,err,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,err,throw,err,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1356735495;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false__			try {_				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true__				boolean globalRollbackOnly = false__				if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_					globalRollbackOnly = status.isGlobalRollbackOnly()__				}_				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					doCommit(status)__				}_				_				_				if (globalRollbackOnly) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}_			catch (Error err) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, err)__				throw err__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,boolean,global,rollback,only,false,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,global,rollback,only,status,is,global,rollback,only,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,do,commit,status,if,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,catch,error,err,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,err,throw,err,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1357119239;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false__			try {_				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true__				boolean globalRollbackOnly = false__				if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_					globalRollbackOnly = status.isGlobalRollbackOnly()__				}_				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					doCommit(status)__				}_				_				_				if (globalRollbackOnly) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}_			catch (Error err) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, err)__				throw err__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,boolean,global,rollback,only,false,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,global,rollback,only,status,is,global,rollback,only,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,do,commit,status,if,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,catch,error,err,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,err,throw,err,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1368482696;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false__			try {_				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true__				boolean globalRollbackOnly = false__				if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_					globalRollbackOnly = status.isGlobalRollbackOnly()__				}_				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					doCommit(status)__				}_				_				_				if (globalRollbackOnly) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}_			catch (Error err) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, err)__				throw err__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,boolean,global,rollback,only,false,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,global,rollback,only,status,is,global,rollback,only,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,do,commit,status,if,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,catch,error,err,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,err,throw,err,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1407763209;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false__			try {_				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true__				boolean globalRollbackOnly = false__				if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_					globalRollbackOnly = status.isGlobalRollbackOnly()__				}_				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					doCommit(status)__				}_				_				_				if (globalRollbackOnly) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}_			catch (Error err) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, err)__				throw err__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,boolean,global,rollback,only,false,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,global,rollback,only,status,is,global,rollback,only,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,do,commit,status,if,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,catch,error,err,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,err,throw,err,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1413473170;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false__			try {_				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true__				boolean globalRollbackOnly = false__				if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_					globalRollbackOnly = status.isGlobalRollbackOnly()__				}_				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					doCommit(status)__				}_				_				_				if (globalRollbackOnly) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}_			catch (Error err) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, err)__				throw err__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,boolean,global,rollback,only,false,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,global,rollback,only,status,is,global,rollback,only,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,do,commit,status,if,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,catch,error,err,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,err,throw,err,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1425660345;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false__			try {_				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true__				boolean globalRollbackOnly = false__				if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_					globalRollbackOnly = status.isGlobalRollbackOnly()__				}_				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					doCommit(status)__				}_				_				_				if (globalRollbackOnly) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}_			catch (Error err) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, err)__				throw err__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,boolean,global,rollback,only,false,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,global,rollback,only,status,is,global,rollback,only,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,do,commit,status,if,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,catch,error,err,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,err,throw,err,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1437567612;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false__			try {_				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true__				boolean globalRollbackOnly = false__				if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_					globalRollbackOnly = status.isGlobalRollbackOnly()__				}_				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					doCommit(status)__				}_				_				_				if (globalRollbackOnly) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}_			catch (Error err) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, err)__				throw err__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,boolean,global,rollback,only,false,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,global,rollback,only,status,is,global,rollback,only,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,do,commit,status,if,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,catch,error,err,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,err,throw,err,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1486062666;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false__			try {_				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true__				boolean globalRollbackOnly = false__				if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_					globalRollbackOnly = status.isGlobalRollbackOnly()__				}_				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					doCommit(status)__				}_				_				_				if (globalRollbackOnly) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,boolean,global,rollback,only,false,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,global,rollback,only,status,is,global,rollback,only,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,do,commit,status,if,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1486719573;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false__			try {_				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true__				boolean globalRollbackOnly = false__				if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_					globalRollbackOnly = status.isGlobalRollbackOnly()__				}_				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					doCommit(status)__				}_				_				_				if (globalRollbackOnly) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,boolean,global,rollback,only,false,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,global,rollback,only,status,is,global,rollback,only,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,do,commit,status,if,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1487371244;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false___			try {_				boolean unexpectedRollback = false__				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					doCommit(status)__				}_				else if (isFailEarlyOnGlobalRollbackOnly()) {_					unexpectedRollback = status.isGlobalRollbackOnly()__				}__				_				_				if (unexpectedRollback) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,boolean,unexpected,rollback,false,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,unexpected,rollback,status,is,global,rollback,only,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,unexpected,rollback,status,is,global,rollback,only,do,commit,status,else,if,is,fail,early,on,global,rollback,only,unexpected,rollback,status,is,global,rollback,only,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1495868221;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false___			try {_				boolean unexpectedRollback = false__				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					doCommit(status)__				}_				else if (isFailEarlyOnGlobalRollbackOnly()) {_					unexpectedRollback = status.isGlobalRollbackOnly()__				}__				_				_				if (unexpectedRollback) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,boolean,unexpected,rollback,false,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,unexpected,rollback,status,is,global,rollback,only,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,unexpected,rollback,status,is,global,rollback,only,do,commit,status,else,if,is,fail,early,on,global,rollback,only,unexpected,rollback,status,is,global,rollback,only,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1496242568;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false___			try {_				boolean unexpectedRollback = false__				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					doCommit(status)__				}_				else if (isFailEarlyOnGlobalRollbackOnly()) {_					unexpectedRollback = status.isGlobalRollbackOnly()__				}__				_				_				if (unexpectedRollback) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,boolean,unexpected,rollback,false,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,unexpected,rollback,status,is,global,rollback,only,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,unexpected,rollback,status,is,global,rollback,only,do,commit,status,else,if,is,fail,early,on,global,rollback,only,unexpected,rollback,status,is,global,rollback,only,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1496259743;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false___			try {_				boolean unexpectedRollback = false__				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					doCommit(status)__				}_				else if (isFailEarlyOnGlobalRollbackOnly()) {_					unexpectedRollback = status.isGlobalRollbackOnly()__				}__				_				_				if (unexpectedRollback) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,boolean,unexpected,rollback,false,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,unexpected,rollback,status,is,global,rollback,only,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,unexpected,rollback,status,is,global,rollback,only,do,commit,status,else,if,is,fail,early,on,global,rollback,only,unexpected,rollback,status,is,global,rollback,only,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1496837955;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false___			try {_				boolean unexpectedRollback = false__				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					doCommit(status)__				}_				else if (isFailEarlyOnGlobalRollbackOnly()) {_					unexpectedRollback = status.isGlobalRollbackOnly()__				}__				_				_				if (unexpectedRollback) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,boolean,unexpected,rollback,false,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,unexpected,rollback,status,is,global,rollback,only,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,unexpected,rollback,status,is,global,rollback,only,do,commit,status,else,if,is,fail,early,on,global,rollback,only,unexpected,rollback,status,is,global,rollback,only,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1498780456;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false___			try {_				boolean unexpectedRollback = false__				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					doCommit(status)__				}_				else if (isFailEarlyOnGlobalRollbackOnly()) {_					unexpectedRollback = status.isGlobalRollbackOnly()__				}__				_				_				if (unexpectedRollback) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,boolean,unexpected,rollback,false,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,unexpected,rollback,status,is,global,rollback,only,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,unexpected,rollback,status,is,global,rollback,only,do,commit,status,else,if,is,fail,early,on,global,rollback,only,unexpected,rollback,status,is,global,rollback,only,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1506842603;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false___			try {_				boolean unexpectedRollback = false__				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					doCommit(status)__				}_				else if (isFailEarlyOnGlobalRollbackOnly()) {_					unexpectedRollback = status.isGlobalRollbackOnly()__				}__				_				_				if (unexpectedRollback) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,boolean,unexpected,rollback,false,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,unexpected,rollback,status,is,global,rollback,only,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,unexpected,rollback,status,is,global,rollback,only,do,commit,status,else,if,is,fail,early,on,global,rollback,only,unexpected,rollback,status,is,global,rollback,only,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1517867503;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false___			try {_				boolean unexpectedRollback = false__				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					doCommit(status)__				}_				else if (isFailEarlyOnGlobalRollbackOnly()) {_					unexpectedRollback = status.isGlobalRollbackOnly()__				}__				_				_				if (unexpectedRollback) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,boolean,unexpected,rollback,false,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,unexpected,rollback,status,is,global,rollback,only,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,unexpected,rollback,status,is,global,rollback,only,do,commit,status,else,if,is,fail,early,on,global,rollback,only,unexpected,rollback,status,is,global,rollback,only,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1530174524;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false___			try {_				boolean unexpectedRollback = false__				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					doCommit(status)__				}_				else if (isFailEarlyOnGlobalRollbackOnly()) {_					unexpectedRollback = status.isGlobalRollbackOnly()__				}__				_				_				if (unexpectedRollback) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,boolean,unexpected,rollback,false,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,unexpected,rollback,status,is,global,rollback,only,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,unexpected,rollback,status,is,global,rollback,only,do,commit,status,else,if,is,fail,early,on,global,rollback,only,unexpected,rollback,status,is,global,rollback,only,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processCommit(DefaultTransactionStatus status) throws TransactionException;1530174524;Process an actual commit._Rollback-only flags have already been checked and applied._@param status object representing the transaction_@throws TransactionException in case of commit failure;private void processCommit(DefaultTransactionStatus status) throws TransactionException {_		try {_			boolean beforeCompletionInvoked = false___			try {_				boolean unexpectedRollback = false__				prepareForCommit(status)__				triggerBeforeCommit(status)__				triggerBeforeCompletion(status)__				beforeCompletionInvoked = true___				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Releasing transaction savepoint")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					status.releaseHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction commit")__					}_					unexpectedRollback = status.isGlobalRollbackOnly()__					doCommit(status)__				}_				else if (isFailEarlyOnGlobalRollbackOnly()) {_					unexpectedRollback = status.isGlobalRollbackOnly()__				}__				_				_				if (unexpectedRollback) {_					throw new UnexpectedRollbackException(_							"Transaction silently rolled back because it has been marked as rollback-only")__				}_			}_			catch (UnexpectedRollbackException ex) {_				_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__				throw ex__			}_			catch (TransactionException ex) {_				_				if (isRollbackOnCommitFailure()) {_					doRollbackOnCommitException(status, ex)__				}_				else {_					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				}_				throw ex__			}_			catch (RuntimeException | Error ex) {_				if (!beforeCompletionInvoked) {_					triggerBeforeCompletion(status)__				}_				doRollbackOnCommitException(status, ex)__				throw ex__			}__			_			_			try {_				triggerAfterCommit(status)__			}_			finally {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED)__			}__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,commit,rollback,only,flags,have,already,been,checked,and,applied,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,commit,failure;private,void,process,commit,default,transaction,status,status,throws,transaction,exception,try,boolean,before,completion,invoked,false,try,boolean,unexpected,rollback,false,prepare,for,commit,status,trigger,before,commit,status,trigger,before,completion,status,before,completion,invoked,true,if,status,has,savepoint,if,status,is,debug,logger,debug,releasing,transaction,savepoint,unexpected,rollback,status,is,global,rollback,only,status,release,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,commit,unexpected,rollback,status,is,global,rollback,only,do,commit,status,else,if,is,fail,early,on,global,rollback,only,unexpected,rollback,status,is,global,rollback,only,if,unexpected,rollback,throw,new,unexpected,rollback,exception,transaction,silently,rolled,back,because,it,has,been,marked,as,rollback,only,catch,unexpected,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,transaction,exception,ex,if,is,rollback,on,commit,failure,do,rollback,on,commit,exception,status,ex,else,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,runtime,exception,error,ex,if,before,completion,invoked,trigger,before,completion,status,do,rollback,on,commit,exception,status,ex,throw,ex,try,trigger,after,commit,status,finally,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1328020251;Trigger <code>afterCompletion</code> callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,code,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1356735495;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1357119239;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1368482696;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1407763209;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1413473170;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1425660345;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1437567612;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1486062666;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1486719573;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			TransactionSynchronizationManager.clearSynchronization()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,transaction,synchronization,manager,clear,synchronization,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1487371244;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			TransactionSynchronizationManager.clearSynchronization()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,transaction,synchronization,manager,clear,synchronization,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1495868221;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			TransactionSynchronizationManager.clearSynchronization()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,transaction,synchronization,manager,clear,synchronization,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1496242568;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			TransactionSynchronizationManager.clearSynchronization()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,transaction,synchronization,manager,clear,synchronization,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1496259743;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			TransactionSynchronizationManager.clearSynchronization()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,transaction,synchronization,manager,clear,synchronization,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1496837955;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			TransactionSynchronizationManager.clearSynchronization()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,transaction,synchronization,manager,clear,synchronization,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1498780456;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			TransactionSynchronizationManager.clearSynchronization()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,transaction,synchronization,manager,clear,synchronization,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1506842603;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			TransactionSynchronizationManager.clearSynchronization()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,transaction,synchronization,manager,clear,synchronization,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1517867503;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			TransactionSynchronizationManager.clearSynchronization()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,transaction,synchronization,manager,clear,synchronization,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1530174524;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			TransactionSynchronizationManager.clearSynchronization()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,transaction,synchronization,manager,clear,synchronization,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);1530174524;Trigger {@code afterCompletion} callbacks._@param status object representing the transaction_@param completionStatus completion status according to TransactionSynchronization constants;private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {_		if (status.isNewSynchronization()) {_			List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations()__			TransactionSynchronizationManager.clearSynchronization()__			if (!status.hasTransaction() || status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.trace("Triggering afterCompletion synchronization")__				}_				_				_				invokeAfterCompletion(synchronizations, completionStatus)__			}_			else if (!synchronizations.isEmpty()) {_				_				_				_				registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations)__			}_		}_	};trigger,code,after,completion,callbacks,param,status,object,representing,the,transaction,param,completion,status,completion,status,according,to,transaction,synchronization,constants;private,void,trigger,after,completion,default,transaction,status,status,int,completion,status,if,status,is,new,synchronization,list,transaction,synchronization,synchronizations,transaction,synchronization,manager,get,synchronizations,transaction,synchronization,manager,clear,synchronization,if,status,has,transaction,status,is,new,transaction,if,status,is,debug,logger,trace,triggering,after,completion,synchronization,invoke,after,completion,synchronizations,completion,status,else,if,synchronizations,is,empty,register,after,completion,with,existing,transaction,status,get,transaction,synchronizations
AbstractPlatformTransactionManager -> public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1328020251;This implementation handles propagation behavior. Delegates to_<code>doGetTransaction</code>, <code>isExistingTransaction</code>_and <code>doBegin</code>._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_		    definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException ex) {_				resume(null, suspendedResources)__				throw ex__			}_			catch (Error err) {_				resume(null, suspendedResources)__				throw err__			}_		}_		else {_			_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,code,is,existing,transaction,code,and,code,do,begin,code,see,do,get,transaction,see,is,existing,transaction,see,do,begin;public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,ex,resume,null,suspended,resources,throw,ex,catch,error,err,resume,null,suspended,resources,throw,err,else,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1357119239;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException ex) {_				resume(null, suspendedResources)__				throw ex__			}_			catch (Error err) {_				resume(null, suspendedResources)__				throw err__			}_		}_		else {_			_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,ex,resume,null,suspended,resources,throw,ex,catch,error,err,resume,null,suspended,resources,throw,err,else,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;1496242568;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,nullable,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;1496259743;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,nullable,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;1496837955;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,nullable,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;1498780456;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,nullable,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;1506842603;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,nullable,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;1517867503;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,nullable,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;1530174524;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,nullable,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;1530174524;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,nullable,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1328020251;Return whether to call <code>doCommit</code> on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_<code>doCommit</code> call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_<code>UserTransaction.commit</code> will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the <code>doCommit</code> implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,code,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,code,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,code,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,code,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1356735495;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1357119239;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1368482696;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1407763209;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1413473170;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1425660345;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1437567612;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1486062666;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1486719573;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1487371244;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1495868221;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1496242568;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1496259743;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1496837955;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1498780456;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1506842603;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1517867503;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1530174524;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> protected boolean shouldCommitOnGlobalRollbackOnly();1530174524;Return whether to call {@code doCommit} on a transaction that has been_marked as rollback-only in a global fashion._<p>Does not apply if an application locally sets the transaction to rollback-only_via the TransactionStatus, but only to the transaction itself being marked as_rollback-only by the transaction coordinator._<p>Default is "false": Local transaction strategies usually don't hold the rollback-only_marker in the transaction itself, therefore they can't handle rollback-only transactions_as part of transaction commit. Hence, AbstractPlatformTransactionManager will trigger_a rollback in that case, throwing an UnexpectedRollbackException afterwards._<p>Override this to return "true" if the concrete transaction manager expects a_{@code doCommit} call even for a rollback-only transaction, allowing for_special handling there. This will, for example, be the case for JTA, where_{@code UserTransaction.commit} will check the read-only flag itself and_throw a corresponding RollbackException, which might include the specific reason_(such as a transaction timeout)._<p>If this method returns "true" but the {@code doCommit} implementation does not_throw an exception, this transaction manager will throw an UnexpectedRollbackException_itself. This should not be the typical case_ it is mainly checked to cover misbehaving_JTA providers that silently roll back even when the rollback has not been requested_by the calling code._@see #doCommit_@see DefaultTransactionStatus#isGlobalRollbackOnly()_@see DefaultTransactionStatus#isLocalRollbackOnly()_@see org.springframework.transaction.TransactionStatus#setRollbackOnly()_@see org.springframework.transaction.UnexpectedRollbackException_@see javax.transaction.UserTransaction#commit()_@see javax.transaction.RollbackException;protected boolean shouldCommitOnGlobalRollbackOnly() {_		return false__	};return,whether,to,call,code,do,commit,on,a,transaction,that,has,been,marked,as,rollback,only,in,a,global,fashion,p,does,not,apply,if,an,application,locally,sets,the,transaction,to,rollback,only,via,the,transaction,status,but,only,to,the,transaction,itself,being,marked,as,rollback,only,by,the,transaction,coordinator,p,default,is,false,local,transaction,strategies,usually,don,t,hold,the,rollback,only,marker,in,the,transaction,itself,therefore,they,can,t,handle,rollback,only,transactions,as,part,of,transaction,commit,hence,abstract,platform,transaction,manager,will,trigger,a,rollback,in,that,case,throwing,an,unexpected,rollback,exception,afterwards,p,override,this,to,return,true,if,the,concrete,transaction,manager,expects,a,code,do,commit,call,even,for,a,rollback,only,transaction,allowing,for,special,handling,there,this,will,for,example,be,the,case,for,jta,where,code,user,transaction,commit,will,check,the,read,only,flag,itself,and,throw,a,corresponding,rollback,exception,which,might,include,the,specific,reason,such,as,a,transaction,timeout,p,if,this,method,returns,true,but,the,code,do,commit,implementation,does,not,throw,an,exception,this,transaction,manager,will,throw,an,unexpected,rollback,exception,itself,this,should,not,be,the,typical,case,it,is,mainly,checked,to,cover,misbehaving,jta,providers,that,silently,roll,back,even,when,the,rollback,has,not,been,requested,by,the,calling,code,see,do,commit,see,default,transaction,status,is,global,rollback,only,see,default,transaction,status,is,local,rollback,only,see,org,springframework,transaction,transaction,status,set,rollback,only,see,org,springframework,transaction,unexpected,rollback,exception,see,javax,transaction,user,transaction,commit,see,javax,transaction,rollback,exception;protected,boolean,should,commit,on,global,rollback,only,return,false
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1328020251;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1356735495;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1357119239;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1368482696;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1407763209;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1413473170;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1425660345;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1437567612;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1486062666;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1486719573;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1487371244;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1495868221;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1496242568;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1496259743;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1496837955;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1498780456;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1506842603;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRED or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation.;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1517867503;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRED or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation._@since 2.5.1;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation,since,2,5,1;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1530174524;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRED or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation._@since 2.5.1;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation,since,2,5,1;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> public final void setValidateExistingTransaction(boolean validateExistingTransaction);1530174524;Set whether existing transactions should be validated before participating_in them._<p>When participating in an existing transaction (e.g. with_PROPAGATION_REQUIRED or PROPAGATION_SUPPORTS encountering an existing_transaction), this outer transaction's characteristics will apply even_to the inner transaction scope. Validation will detect incompatible_isolation level and read-only settings on the inner transaction definition_and reject participation accordingly through throwing a corresponding exception._<p>Default is "false", leniently ignoring inner transaction settings,_simply overriding them with the outer transaction's characteristics._Switch this flag to "true" in order to enforce strict validation._@since 2.5.1;public final void setValidateExistingTransaction(boolean validateExistingTransaction) {_		this.validateExistingTransaction = validateExistingTransaction__	};set,whether,existing,transactions,should,be,validated,before,participating,in,them,p,when,participating,in,an,existing,transaction,e,g,with,or,encountering,an,existing,transaction,this,outer,transaction,s,characteristics,will,apply,even,to,the,inner,transaction,scope,validation,will,detect,incompatible,isolation,level,and,read,only,settings,on,the,inner,transaction,definition,and,reject,participation,accordingly,through,throwing,a,corresponding,exception,p,default,is,false,leniently,ignoring,inner,transaction,settings,simply,overriding,them,with,the,outer,transaction,s,characteristics,switch,this,flag,to,true,in,order,to,enforce,strict,validation,since,2,5,1;public,final,void,set,validate,existing,transaction,boolean,validate,existing,transaction,this,validate,existing,transaction,validate,existing,transaction
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status);1328020251;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status) {_		try {_			try {_				triggerBeforeCompletion(status)__				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else if (status.hasTransaction()) {_					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__						}_						doSetRollbackOnly(status)__					}_					else {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__						}_					}_				}_				else {_					logger.debug("Should roll back transaction but cannot - no transaction available")__				}_			}_			catch (RuntimeException ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}_			catch (Error err) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw err__			}_			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,try,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,catch,runtime,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,error,err,trigger,after,completion,status,transaction,synchronization,throw,err,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status);1356735495;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status) {_		try {_			try {_				triggerBeforeCompletion(status)__				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else if (status.hasTransaction()) {_					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__						}_						doSetRollbackOnly(status)__					}_					else {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__						}_					}_				}_				else {_					logger.debug("Should roll back transaction but cannot - no transaction available")__				}_			}_			catch (RuntimeException ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}_			catch (Error err) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw err__			}_			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,try,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,catch,runtime,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,error,err,trigger,after,completion,status,transaction,synchronization,throw,err,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status);1357119239;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status) {_		try {_			try {_				triggerBeforeCompletion(status)__				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else if (status.hasTransaction()) {_					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__						}_						doSetRollbackOnly(status)__					}_					else {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__						}_					}_				}_				else {_					logger.debug("Should roll back transaction but cannot - no transaction available")__				}_			}_			catch (RuntimeException ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}_			catch (Error err) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw err__			}_			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,try,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,catch,runtime,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,error,err,trigger,after,completion,status,transaction,synchronization,throw,err,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status);1368482696;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status) {_		try {_			try {_				triggerBeforeCompletion(status)__				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else if (status.hasTransaction()) {_					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__						}_						doSetRollbackOnly(status)__					}_					else {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__						}_					}_				}_				else {_					logger.debug("Should roll back transaction but cannot - no transaction available")__				}_			}_			catch (RuntimeException ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}_			catch (Error err) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw err__			}_			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,try,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,catch,runtime,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,error,err,trigger,after,completion,status,transaction,synchronization,throw,err,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status);1407763209;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status) {_		try {_			try {_				triggerBeforeCompletion(status)__				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else if (status.hasTransaction()) {_					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__						}_						doSetRollbackOnly(status)__					}_					else {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__						}_					}_				}_				else {_					logger.debug("Should roll back transaction but cannot - no transaction available")__				}_			}_			catch (RuntimeException ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}_			catch (Error err) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw err__			}_			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,try,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,catch,runtime,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,error,err,trigger,after,completion,status,transaction,synchronization,throw,err,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status);1413473170;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status) {_		try {_			try {_				triggerBeforeCompletion(status)__				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else if (status.hasTransaction()) {_					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__						}_						doSetRollbackOnly(status)__					}_					else {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__						}_					}_				}_				else {_					logger.debug("Should roll back transaction but cannot - no transaction available")__				}_			}_			catch (RuntimeException ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}_			catch (Error err) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw err__			}_			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,try,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,catch,runtime,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,error,err,trigger,after,completion,status,transaction,synchronization,throw,err,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status);1425660345;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status) {_		try {_			try {_				triggerBeforeCompletion(status)__				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else if (status.hasTransaction()) {_					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__						}_						doSetRollbackOnly(status)__					}_					else {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__						}_					}_				}_				else {_					logger.debug("Should roll back transaction but cannot - no transaction available")__				}_			}_			catch (RuntimeException ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}_			catch (Error err) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw err__			}_			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,try,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,catch,runtime,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,error,err,trigger,after,completion,status,transaction,synchronization,throw,err,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status);1437567612;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status) {_		try {_			try {_				triggerBeforeCompletion(status)__				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else if (status.hasTransaction()) {_					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__						}_						doSetRollbackOnly(status)__					}_					else {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__						}_					}_				}_				else {_					logger.debug("Should roll back transaction but cannot - no transaction available")__				}_			}_			catch (RuntimeException ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}_			catch (Error err) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw err__			}_			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,try,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,catch,runtime,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,catch,error,err,trigger,after,completion,status,transaction,synchronization,throw,err,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status);1486062666;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status) {_		try {_			try {_				triggerBeforeCompletion(status)__				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else if (status.hasTransaction()) {_					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__						}_						doSetRollbackOnly(status)__					}_					else {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__						}_					}_				}_				else {_					logger.debug("Should roll back transaction but cannot - no transaction available")__				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}_			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,try,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> private void processRollback(DefaultTransactionStatus status);1486719573;Process an actual rollback._The completed flag has already been checked._@param status object representing the transaction_@throws TransactionException in case of rollback failure;private void processRollback(DefaultTransactionStatus status) {_		try {_			try {_				triggerBeforeCompletion(status)__				if (status.hasSavepoint()) {_					if (status.isDebug()) {_						logger.debug("Rolling back transaction to savepoint")__					}_					status.rollbackToHeldSavepoint()__				}_				else if (status.isNewTransaction()) {_					if (status.isDebug()) {_						logger.debug("Initiating transaction rollback")__					}_					doRollback(status)__				}_				else if (status.hasTransaction()) {_					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - marking existing transaction as rollback-only")__						}_						doSetRollbackOnly(status)__					}_					else {_						if (status.isDebug()) {_							logger.debug("Participating transaction failed - letting transaction originator decide on rollback")__						}_					}_				}_				else {_					logger.debug("Should roll back transaction but cannot - no transaction available")__				}_			}_			catch (RuntimeException | Error ex) {_				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__				throw ex__			}_			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__		}_		finally {_			cleanupAfterCompletion(status)__		}_	};process,an,actual,rollback,the,completed,flag,has,already,been,checked,param,status,object,representing,the,transaction,throws,transaction,exception,in,case,of,rollback,failure;private,void,process,rollback,default,transaction,status,status,try,try,trigger,before,completion,status,if,status,has,savepoint,if,status,is,debug,logger,debug,rolling,back,transaction,to,savepoint,status,rollback,to,held,savepoint,else,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,do,rollback,status,else,if,status,has,transaction,if,status,is,local,rollback,only,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,participating,transaction,failed,marking,existing,transaction,as,rollback,only,do,set,rollback,only,status,else,if,status,is,debug,logger,debug,participating,transaction,failed,letting,transaction,originator,decide,on,rollback,else,logger,debug,should,roll,back,transaction,but,cannot,no,transaction,available,catch,runtime,exception,error,ex,trigger,after,completion,status,transaction,synchronization,throw,ex,trigger,after,completion,status,transaction,synchronization,finally,cleanup,after,completion,status
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1328020251;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1356735495;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1357119239;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1368482696;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1407763209;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1413473170;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1425660345;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1437567612;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1486062666;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1486719573;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1487371244;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1495868221;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1496242568;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1496259743;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1496837955;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1498780456;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1506842603;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1517867503;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1530174524;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;1530174524;Perform an actual commit of the given transaction._<p>An implementation does not need to check the "new transaction" flag_or the rollback-only flag_ this will already have been handled before._Usually, a straight commit will be performed on the transaction object_contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of commit or system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,commit,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,or,the,rollback,only,flag,this,will,already,have,been,handled,before,usually,a,straight,commit,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,commit,or,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,commit,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1328020251;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1356735495;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1357119239;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1368482696;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1407763209;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1413473170;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1425660345;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1437567612;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1486062666;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1486719573;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1487371244;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1495868221;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1496242568;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1328020251;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1356735495;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1357119239;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1368482696;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1407763209;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1413473170;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1425660345;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1437567612;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1486062666;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1486719573;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1487371244;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1495868221;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1496242568;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1496259743;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1496837955;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1498780456;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1506842603;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1517867503;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1530174524;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> public final void setTransactionSynchronization(int transactionSynchronization);1530174524;Set when this transaction manager should activate the thread-bound_transaction synchronization support. Default is "always"._<p>Note that transaction synchronization isn't supported for_multiple concurrent transactions by different transaction managers._Only one transaction manager is allowed to activate it at any time._@see #SYNCHRONIZATION_ALWAYS_@see #SYNCHRONIZATION_ON_ACTUAL_TRANSACTION_@see #SYNCHRONIZATION_NEVER_@see TransactionSynchronizationManager_@see TransactionSynchronization;public final void setTransactionSynchronization(int transactionSynchronization) {_		this.transactionSynchronization = transactionSynchronization__	};set,when,this,transaction,manager,should,activate,the,thread,bound,transaction,synchronization,support,default,is,always,p,note,that,transaction,synchronization,isn,t,supported,for,multiple,concurrent,transactions,by,different,transaction,managers,only,one,transaction,manager,is,allowed,to,activate,it,at,any,time,see,see,see,see,transaction,synchronization,manager,see,transaction,synchronization;public,final,void,set,transaction,synchronization,int,transaction,synchronization,this,transaction,synchronization,transaction,synchronization
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1328020251;Make preparations for commit, to be performed before the_<code>beforeCommit</code> synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,code,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1356735495;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1357119239;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1368482696;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1407763209;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1413473170;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1425660345;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1437567612;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1486062666;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1486719573;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1487371244;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1495868221;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1496242568;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1496259743;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1496837955;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1498780456;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1506842603;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1517867503;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1530174524;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> protected void prepareForCommit(DefaultTransactionStatus status);1530174524;Make preparations for commit, to be performed before the_{@code beforeCommit} synchronization callbacks occur._<p>Note that exceptions will get propagated to the commit caller_and cause a rollback of the transaction._@param status the status representation of the transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);protected void prepareForCommit(DefaultTransactionStatus status) {_	};make,preparations,for,commit,to,be,performed,before,the,code,before,commit,synchronization,callbacks,occur,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,status,the,status,representation,of,the,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;protected,void,prepare,for,commit,default,transaction,status,status
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1328020251;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1356735495;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1357119239;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1368482696;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1407763209;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1413473170;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1425660345;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1437567612;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1486062666;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1486719573;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1487371244;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1495868221;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1496242568;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1496259743;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1496837955;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1498780456;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1506842603;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1517867503;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@since 2.0_@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,since,2,0,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1530174524;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@since 2.0_@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,since,2,0,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly);1530174524;Set whether to fail early in case of the transaction being globally marked_as rollback-only._<p>Default is "false", only causing an UnexpectedRollbackException at the_outermost transaction boundary. Switch this flag on to cause an_UnexpectedRollbackException as early as the global rollback-only marker_has been first detected, even from within an inner transaction boundary._<p>Note that, as of Spring 2.0, the fail-early behavior for global_rollback-only markers has been unified: All transaction managers will by_default only cause UnexpectedRollbackException at the outermost transaction_boundary. This allows, for example, to continue unit tests even after an_operation failed and the transaction will never be completed. All transaction_managers will only fail earlier if this flag has explicitly been set to "true"._@since 2.0_@see org.springframework.transaction.UnexpectedRollbackException;public final void setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly) {_		this.failEarlyOnGlobalRollbackOnly = failEarlyOnGlobalRollbackOnly__	};set,whether,to,fail,early,in,case,of,the,transaction,being,globally,marked,as,rollback,only,p,default,is,false,only,causing,an,unexpected,rollback,exception,at,the,outermost,transaction,boundary,switch,this,flag,on,to,cause,an,unexpected,rollback,exception,as,early,as,the,global,rollback,only,marker,has,been,first,detected,even,from,within,an,inner,transaction,boundary,p,note,that,as,of,spring,2,0,the,fail,early,behavior,for,global,rollback,only,markers,has,been,unified,all,transaction,managers,will,by,default,only,cause,unexpected,rollback,exception,at,the,outermost,transaction,boundary,this,allows,for,example,to,continue,unit,tests,even,after,an,operation,failed,and,the,transaction,will,never,be,completed,all,transaction,managers,will,only,fail,earlier,if,this,flag,has,explicitly,been,set,to,true,since,2,0,see,org,springframework,transaction,unexpected,rollback,exception;public,final,void,set,fail,early,on,global,rollback,only,boolean,fail,early,on,global,rollback,only,this,fail,early,on,global,rollback,only,fail,early,on,global,rollback,only
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1328020251;Trigger <code>afterCommit</code> callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,code,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1356735495;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1357119239;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1368482696;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1407763209;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1413473170;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1425660345;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1437567612;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1486062666;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1486719573;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1487371244;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1495868221;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1496242568;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1496259743;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1496837955;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1498780456;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1506842603;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1517867503;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1530174524;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> private void triggerAfterCommit(DefaultTransactionStatus status);1530174524;Trigger {@code afterCommit} callbacks._@param status object representing the transaction;private void triggerAfterCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering afterCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerAfterCommit()__		}_	};trigger,code,after,commit,callbacks,param,status,object,representing,the,transaction;private,void,trigger,after,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,after,commit,synchronization,transaction,synchronization,utils,trigger,after,commit
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1328020251;Create a rae TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,rae,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1356735495;Create a rae TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,rae,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1357119239;Create a rae TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,rae,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1368482696;Create a rae TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,rae,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1407763209;Create a rae TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,rae,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1413473170;Create a rae TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,rae,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1425660345;Create a rae TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,rae,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1437567612;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1486062666;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1486719573;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1487371244;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1495868221;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected DefaultTransactionStatus newTransactionStatus( 			TransactionDefinition definition, Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, Object suspendedResources);1496242568;Create a TransactionStatus instance for the given arguments.;protected DefaultTransactionStatus newTransactionStatus(_			TransactionDefinition definition, Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, Object suspendedResources) {__		boolean actualNewSynchronization = newSynchronization &&_				!TransactionSynchronizationManager.isSynchronizationActive()__		return new DefaultTransactionStatus(_				transaction, newTransaction, actualNewSynchronization,_				definition.isReadOnly(), debug, suspendedResources)__	};create,a,transaction,status,instance,for,the,given,arguments;protected,default,transaction,status,new,transaction,status,transaction,definition,definition,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,object,suspended,resources,boolean,actual,new,synchronization,new,synchronization,transaction,synchronization,manager,is,synchronization,active,return,new,default,transaction,status,transaction,new,transaction,actual,new,synchronization,definition,is,read,only,debug,suspended,resources
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1328020251;Return whether to use a savepoint for a nested transaction._<p>Default is <code>true</code>, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return <code>false</code>, causing a further_call to <code>doBegin</code> - within the context of an already existing transaction._The <code>doBegin</code> implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,code,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,code,causing,a,further,call,to,code,do,begin,code,within,the,context,of,an,already,existing,transaction,the,code,do,begin,code,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1356735495;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1357119239;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1368482696;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1407763209;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1413473170;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1425660345;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1437567612;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1486062666;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1486719573;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1487371244;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1495868221;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1496242568;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1496259743;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1496837955;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1498780456;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1506842603;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1517867503;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1530174524;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> protected boolean useSavepointForNestedTransaction();1530174524;Return whether to use a savepoint for a nested transaction._<p>Default is {@code true}, which causes delegation to DefaultTransactionStatus_for creating and holding a savepoint. If the transaction object does not implement_the SavepointManager interface, a NestedTransactionNotSupportedException will be_thrown. Else, the SavepointManager will be asked to create a new savepoint to_demarcate the start of the nested transaction._<p>Subclasses can override this to return {@code false}, causing a further_call to {@code doBegin} - within the context of an already existing transaction._The {@code doBegin} implementation needs to handle this accordingly in such_a scenario. This is appropriate for JTA, for example._@see DefaultTransactionStatus#createAndHoldSavepoint_@see DefaultTransactionStatus#rollbackToHeldSavepoint_@see DefaultTransactionStatus#releaseHeldSavepoint_@see #doBegin;protected boolean useSavepointForNestedTransaction() {_		return true__	};return,whether,to,use,a,savepoint,for,a,nested,transaction,p,default,is,code,true,which,causes,delegation,to,default,transaction,status,for,creating,and,holding,a,savepoint,if,the,transaction,object,does,not,implement,the,savepoint,manager,interface,a,nested,transaction,not,supported,exception,will,be,thrown,else,the,savepoint,manager,will,be,asked,to,create,a,new,savepoint,to,demarcate,the,start,of,the,nested,transaction,p,subclasses,can,override,this,to,return,code,false,causing,a,further,call,to,code,do,begin,within,the,context,of,an,already,existing,transaction,the,code,do,begin,implementation,needs,to,handle,this,accordingly,in,such,a,scenario,this,is,appropriate,for,jta,for,example,see,default,transaction,status,create,and,hold,savepoint,see,default,transaction,status,rollback,to,held,savepoint,see,default,transaction,status,release,held,savepoint,see,do,begin;protected,boolean,use,savepoint,for,nested,transaction,return,true
AbstractPlatformTransactionManager -> public final void rollback(TransactionStatus status) throws TransactionException;1328020251;This implementation of rollback handles participating in existing_transactions. Delegates to <code>doRollback</code> and_<code>doSetRollbackOnly</code>._@see #doRollback_@see #doSetRollbackOnly;public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,code,and,code,do,set,rollback,only,code,see,do,rollback,see,do,set,rollback,only;public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status
AbstractPlatformTransactionManager -> public final void rollback(TransactionStatus status) throws TransactionException;1357119239;This implementation of rollback handles participating in existing_transactions. Delegates to {@code doRollback} and_{@code doSetRollbackOnly}._@see #doRollback_@see #doSetRollbackOnly;public final void rollback(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		processRollback(defStatus)__	};this,implementation,of,rollback,handles,participating,in,existing,transactions,delegates,to,code,do,rollback,and,code,do,set,rollback,only,see,do,rollback,see,do,set,rollback,only;public,final,void,rollback,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,process,rollback,def,status
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1328020251;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a <code>PlatformTransactionManager.rollback()</code>_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit <code>setRollbackOnly</code>_calls on a <code>TransactionStatus</code>, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,code,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,code,calls,on,a,code,transaction,status,code,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1356735495;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1357119239;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1368482696;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1407763209;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1413473170;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1425660345;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1437567612;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1486062666;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1486719573;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1487371244;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1495868221;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1496242568;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1496259743;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1496837955;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1498780456;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRES or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1506842603;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRED or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1517867503;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRED or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1530174524;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRED or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure);1530174524;Set whether to globally mark an existing transaction as rollback-only_after a participating transaction failed._<p>Default is "true": If a participating transaction (e.g. with_PROPAGATION_REQUIRED or PROPAGATION_SUPPORTS encountering an existing_transaction) fails, the transaction will be globally marked as rollback-only._The only possible outcome of such a transaction is a rollback: The_transaction originator <i>cannot</i> make the transaction commit anymore._<p>Switch this to "false" to let the transaction originator make the rollback_decision. If a participating transaction fails with an exception, the caller_can still decide to continue with a different path within the transaction._However, note that this will only work as long as all participating resources_are capable of continuing towards a transaction commit even after a data access_failure: This is generally not the case for a Hibernate Session, for example__neither is it for a sequence of JDBC insert/update/delete operations._<p><b>Note:</b>This flag only applies to an explicit rollback attempt for a_subtransaction, typically caused by an exception thrown by a data access operation_(where TransactionInterceptor will trigger a {@code PlatformTransactionManager.rollback()}_call according to a rollback rule). If the flag is off, the caller can handle the exception_and decide on a rollback, independent of the rollback rules of the subtransaction._This flag does, however, <i>not</i> apply to explicit {@code setRollbackOnly}_calls on a {@code TransactionStatus}, which will always cause an eventual_global rollback (as it might not throw an exception after the rollback-only call)._<p>The recommended solution for handling failure of a subtransaction_is a "nested transaction", where the global transaction can be rolled_back to a savepoint taken at the beginning of the subtransaction._PROPAGATION_NESTED provides exactly those semantics_ however, it will_only work when nested transaction support is available. This is the case_with DataSourceTransactionManager, but not with JtaTransactionManager._@see #setNestedTransactionAllowed_@see org.springframework.transaction.jta.JtaTransactionManager;public final void setGlobalRollbackOnParticipationFailure(boolean globalRollbackOnParticipationFailure) {_		this.globalRollbackOnParticipationFailure = globalRollbackOnParticipationFailure__	};set,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed,p,default,is,true,if,a,participating,transaction,e,g,with,or,encountering,an,existing,transaction,fails,the,transaction,will,be,globally,marked,as,rollback,only,the,only,possible,outcome,of,such,a,transaction,is,a,rollback,the,transaction,originator,i,cannot,i,make,the,transaction,commit,anymore,p,switch,this,to,false,to,let,the,transaction,originator,make,the,rollback,decision,if,a,participating,transaction,fails,with,an,exception,the,caller,can,still,decide,to,continue,with,a,different,path,within,the,transaction,however,note,that,this,will,only,work,as,long,as,all,participating,resources,are,capable,of,continuing,towards,a,transaction,commit,even,after,a,data,access,failure,this,is,generally,not,the,case,for,a,hibernate,session,for,example,neither,is,it,for,a,sequence,of,jdbc,insert,update,delete,operations,p,b,note,b,this,flag,only,applies,to,an,explicit,rollback,attempt,for,a,subtransaction,typically,caused,by,an,exception,thrown,by,a,data,access,operation,where,transaction,interceptor,will,trigger,a,code,platform,transaction,manager,rollback,call,according,to,a,rollback,rule,if,the,flag,is,off,the,caller,can,handle,the,exception,and,decide,on,a,rollback,independent,of,the,rollback,rules,of,the,subtransaction,this,flag,does,however,i,not,i,apply,to,explicit,code,set,rollback,only,calls,on,a,code,transaction,status,which,will,always,cause,an,eventual,global,rollback,as,it,might,not,throw,an,exception,after,the,rollback,only,call,p,the,recommended,solution,for,handling,failure,of,a,subtransaction,is,a,nested,transaction,where,the,global,transaction,can,be,rolled,back,to,a,savepoint,taken,at,the,beginning,of,the,subtransaction,provides,exactly,those,semantics,however,it,will,only,work,when,nested,transaction,support,is,available,this,is,the,case,with,data,source,transaction,manager,but,not,with,jta,transaction,manager,see,set,nested,transaction,allowed,see,org,springframework,transaction,jta,jta,transaction,manager;public,final,void,set,global,rollback,on,participation,failure,boolean,global,rollback,on,participation,failure,this,global,rollback,on,participation,failure,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1328020251;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns <code>TransactionDefinition.TIMEOUT_DEFAULT</code> to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,code,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1356735495;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1357119239;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1368482696;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1407763209;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1413473170;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1425660345;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1437567612;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1486062666;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1486719573;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1487371244;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1495868221;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1496242568;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1496259743;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1496837955;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1498780456;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1506842603;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1517867503;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1530174524;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> public final int getDefaultTimeout();1530174524;Return the default timeout that this transaction manager should apply_if there is no timeout specified at the transaction level, in seconds._<p>Returns {@code TransactionDefinition.TIMEOUT_DEFAULT} to indicate_the underlying transaction infrastructure's default timeout.;public final int getDefaultTimeout() {_		return this.defaultTimeout__	};return,the,default,timeout,that,this,transaction,manager,should,apply,if,there,is,no,timeout,specified,at,the,transaction,level,in,seconds,p,returns,code,transaction,definition,to,indicate,the,underlying,transaction,infrastructure,s,default,timeout;public,final,int,get,default,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1328020251;Trigger <code>beforeCommit</code> callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,code,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1356735495;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1357119239;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1368482696;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1407763209;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1413473170;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1425660345;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1437567612;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1486062666;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1486719573;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1487371244;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1495868221;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1496242568;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1496259743;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1496837955;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1498780456;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1506842603;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1517867503;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1530174524;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected final void triggerBeforeCommit(DefaultTransactionStatus status);1530174524;Trigger {@code beforeCommit} callbacks._@param status object representing the transaction;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {_		if (status.isNewSynchronization()) {_			if (status.isDebug()) {_				logger.trace("Triggering beforeCommit synchronization")__			}_			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly())__		}_	};trigger,code,before,commit,callbacks,param,status,object,representing,the,transaction;protected,final,void,trigger,before,commit,default,transaction,status,status,if,status,is,new,synchronization,if,status,is,debug,logger,trace,triggering,before,commit,synchronization,transaction,synchronization,utils,trigger,before,commit,status,is,read,only
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1328020251;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the <code>afterCompletion</code> methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by <code>doGetTransaction</code>_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,code,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,code,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1356735495;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1357119239;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1368482696;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1407763209;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1413473170;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1425660345;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1437567612;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1486062666;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1486719573;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1487371244;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1495868221;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1496242568;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1496259743;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1496837955;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1498780456;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1506842603;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1517867503;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1530174524;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations a List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,a,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected void registerAfterCompletionWithExistingTransaction( 			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException;1530174524;Register the given list of transaction synchronizations with the existing transaction._<p>Invoked when the control of the Spring transaction manager and thus all Spring_transaction synchronizations end, without the transaction being completed yet. This_is for example the case when participating in an existing JTA or EJB CMT transaction._<p>The default implementation simply invokes the {@code afterCompletion} methods_immediately, passing in "STATUS_UNKNOWN". This is the best we can do if there's no_chance to determine the actual outcome of the outer transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param synchronizations a List of TransactionSynchronization objects_@throws TransactionException in case of system errors_@see #invokeAfterCompletion(java.util.List, int)_@see TransactionSynchronization#afterCompletion(int)_@see TransactionSynchronization#STATUS_UNKNOWN;protected void registerAfterCompletionWithExistingTransaction(_			Object transaction, List<TransactionSynchronization> synchronizations) throws TransactionException {__		logger.debug("Cannot register Spring after-completion synchronization with existing transaction - " +_				"processing Spring after-completion callbacks immediately, with outcome status 'unknown'")__		invokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN)__	};register,the,given,list,of,transaction,synchronizations,with,the,existing,transaction,p,invoked,when,the,control,of,the,spring,transaction,manager,and,thus,all,spring,transaction,synchronizations,end,without,the,transaction,being,completed,yet,this,is,for,example,the,case,when,participating,in,an,existing,jta,or,ejb,cmt,transaction,p,the,default,implementation,simply,invokes,the,code,after,completion,methods,immediately,passing,in,this,is,the,best,we,can,do,if,there,s,no,chance,to,determine,the,actual,outcome,of,the,outer,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,synchronizations,a,list,of,transaction,synchronization,objects,throws,transaction,exception,in,case,of,system,errors,see,invoke,after,completion,java,util,list,int,see,transaction,synchronization,after,completion,int,see,transaction,synchronization;protected,void,register,after,completion,with,existing,transaction,object,transaction,list,transaction,synchronization,synchronizations,throws,transaction,exception,logger,debug,cannot,register,spring,after,completion,synchronization,with,existing,transaction,processing,spring,after,completion,callbacks,immediately,with,outcome,status,unknown,invoke,after,completion,synchronizations,transaction,synchronization
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1328020251;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1356735495;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1357119239;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1368482696;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1407763209;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1413473170;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1425660345;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1437567612;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1486062666;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1486719573;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1487371244;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1495868221;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1496242568;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1496259743;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1496837955;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1498780456;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1506842603;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1517867503;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1530174524;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;1530174524;Perform an actual rollback of the given transaction._<p>An implementation does not need to check the "new transaction" flag__this will already have been handled before. Usually, a straight rollback_will be performed on the transaction object contained in the passed-in status._@param status the status representation of the transaction_@throws TransactionException in case of system errors_@see DefaultTransactionStatus#getTransaction;protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException_;perform,an,actual,rollback,of,the,given,transaction,p,an,implementation,does,not,need,to,check,the,new,transaction,flag,this,will,already,have,been,handled,before,usually,a,straight,rollback,will,be,performed,on,the,transaction,object,contained,in,the,passed,in,status,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors,see,default,transaction,status,get,transaction;protected,abstract,void,do,rollback,default,transaction,status,status,throws,transaction,exception
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1328020251;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by <code>doGetTransaction</code>_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,code,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1356735495;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1357119239;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1368482696;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1407763209;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1413473170;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1425660345;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1437567612;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1486062666;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1486719573;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1487371244;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1495868221;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1496242568;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> protected void doResume(Object transaction, Object suspendedResources) throws TransactionException;1496259743;Resume the resources of the current transaction._Transaction synchronization will be resumed afterwards._<p>The default implementation throws a TransactionSuspensionNotSupportedException,_assuming that transaction suspension is generally not supported._@param transaction transaction object returned by {@code doGetTransaction}_@param suspendedResources the object that holds suspended resources,_as returned by doSuspend_@throws org.springframework.transaction.TransactionSuspensionNotSupportedException_if resuming is not supported by the transaction manager implementation_@throws TransactionException in case of system errors_@see #doSuspend;protected void doResume(Object transaction, Object suspendedResources) throws TransactionException {_		throw new TransactionSuspensionNotSupportedException(_				"Transaction manager [" + getClass().getName() + "] does not support transaction suspension")__	};resume,the,resources,of,the,current,transaction,transaction,synchronization,will,be,resumed,afterwards,p,the,default,implementation,throws,a,transaction,suspension,not,supported,exception,assuming,that,transaction,suspension,is,generally,not,supported,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,suspended,resources,the,object,that,holds,suspended,resources,as,returned,by,do,suspend,throws,org,springframework,transaction,transaction,suspension,not,supported,exception,if,resuming,is,not,supported,by,the,transaction,manager,implementation,throws,transaction,exception,in,case,of,system,errors,see,do,suspend;protected,void,do,resume,object,transaction,object,suspended,resources,throws,transaction,exception,throw,new,transaction,suspension,not,supported,exception,transaction,manager,get,class,get,name,does,not,support,transaction,suspension
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1328020251;Invoke <code>doRollback</code>, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		catch (Error rberr) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rberr__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,code,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,catch,error,rberr,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rberr,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1356735495;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		catch (Error rberr) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rberr__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,catch,error,rberr,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rberr,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1357119239;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		catch (Error rberr) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rberr__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,catch,error,rberr,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rberr,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1368482696;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		catch (Error rberr) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rberr__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,catch,error,rberr,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rberr,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1407763209;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		catch (Error rberr) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rberr__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,catch,error,rberr,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rberr,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1413473170;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		catch (Error rberr) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rberr__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,catch,error,rberr,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rberr,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1425660345;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		catch (Error rberr) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rberr__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,catch,error,rberr,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rberr,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1437567612;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		catch (Error rberr) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rberr__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,catch,error,rberr,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rberr,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1486062666;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1486719573;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1487371244;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1495868221;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1496242568;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1496259743;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1496837955;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1498780456;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1506842603;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1517867503;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1530174524;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException;1530174524;Invoke {@code doRollback}, handling rollback exceptions properly._@param status object representing the transaction_@param ex the thrown application exception or error_@throws TransactionException in case of rollback failure_@see #doRollback;private void doRollbackOnCommitException(DefaultTransactionStatus status, Throwable ex) throws TransactionException {_		try {_			if (status.isNewTransaction()) {_				if (status.isDebug()) {_					logger.debug("Initiating transaction rollback after commit exception", ex)__				}_				doRollback(status)__			}_			else if (status.hasTransaction() && isGlobalRollbackOnParticipationFailure()) {_				if (status.isDebug()) {_					logger.debug("Marking existing transaction as rollback-only after commit exception", ex)__				}_				doSetRollbackOnly(status)__			}_		}_		catch (RuntimeException | Error rbex) {_			logger.error("Commit exception overridden by rollback exception", ex)__			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN)__			throw rbex__		}_		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)__	};invoke,code,do,rollback,handling,rollback,exceptions,properly,param,status,object,representing,the,transaction,param,ex,the,thrown,application,exception,or,error,throws,transaction,exception,in,case,of,rollback,failure,see,do,rollback;private,void,do,rollback,on,commit,exception,default,transaction,status,status,throwable,ex,throws,transaction,exception,try,if,status,is,new,transaction,if,status,is,debug,logger,debug,initiating,transaction,rollback,after,commit,exception,ex,do,rollback,status,else,if,status,has,transaction,is,global,rollback,on,participation,failure,if,status,is,debug,logger,debug,marking,existing,transaction,as,rollback,only,after,commit,exception,ex,do,set,rollback,only,status,catch,runtime,exception,error,rbex,logger,error,commit,exception,overridden,by,rollback,exception,ex,trigger,after,completion,status,transaction,synchronization,throw,rbex,trigger,after,completion,status,transaction,synchronization
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1495868221;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,nullable,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected final void resume(Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder) 			throws TransactionException;1496242568;Resume the given transaction. Delegates to the {@code doResume}_template method first, then resuming transaction synchronization._@param transaction the current transaction object_@param resourcesHolder the object that holds suspended resources,_as returned by {@code suspend} (or {@code null} to just_resume synchronizations, if any)_@see #doResume_@see #suspend;protected final void resume(Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)_			throws TransactionException {__		if (resourcesHolder != null) {_			Object suspendedResources = resourcesHolder.suspendedResources__			if (suspendedResources != null) {_				doResume(transaction, suspendedResources)__			}_			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations__			if (suspendedSynchronizations != null) {_				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive)__				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel)__				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly)__				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name)__				doResumeSynchronization(suspendedSynchronizations)__			}_		}_	};resume,the,given,transaction,delegates,to,the,code,do,resume,template,method,first,then,resuming,transaction,synchronization,param,transaction,the,current,transaction,object,param,resources,holder,the,object,that,holds,suspended,resources,as,returned,by,code,suspend,or,code,null,to,just,resume,synchronizations,if,any,see,do,resume,see,suspend;protected,final,void,resume,object,transaction,nullable,suspended,resources,holder,resources,holder,throws,transaction,exception,if,resources,holder,null,object,suspended,resources,resources,holder,suspended,resources,if,suspended,resources,null,do,resume,transaction,suspended,resources,list,transaction,synchronization,suspended,synchronizations,resources,holder,suspended,synchronizations,if,suspended,synchronizations,null,transaction,synchronization,manager,set,actual,transaction,active,resources,holder,was,active,transaction,synchronization,manager,set,current,transaction,isolation,level,resources,holder,isolation,level,transaction,synchronization,manager,set,current,transaction,read,only,resources,holder,read,only,transaction,synchronization,manager,set,current,transaction,name,resources,holder,name,do,resume,synchronization,suspended,synchronizations
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1328020251;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_<code>useSavepointForNestedTransaction()</code> returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by <code>doGetTransaction</code>_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,code,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,code,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1356735495;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1357119239;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1368482696;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1407763209;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1413473170;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1425660345;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1437567612;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1486062666;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1486719573;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1487371244;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1495868221;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1496242568;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1496259743;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1496837955;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1498780456;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1506842603;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1517867503;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1530174524;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition a TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,a,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected abstract void doBegin(Object transaction, TransactionDefinition definition) 			throws TransactionException_;1530174524;Begin a new transaction with semantics according to the given transaction_definition. Does not have to care about applying the propagation behavior,_as this has already been handled by this abstract manager._<p>This method gets called when the transaction manager has decided to actually_start a new transaction. Either there wasn't any transaction before, or the_previous transaction has been suspended._<p>A special scenario is a nested transaction without savepoint: If_{@code useSavepointForNestedTransaction()} returns "false", this method_will be called to start a nested transaction when necessary. In such a context,_there will be an active transaction: The implementation of this method has_to detect this and start an appropriate nested transaction._@param transaction transaction object returned by {@code doGetTransaction}_@param definition a TransactionDefinition instance, describing propagation_behavior, isolation level, read-only flag, timeout, and transaction name_@throws TransactionException in case of creation or system errors;protected abstract void doBegin(Object transaction, TransactionDefinition definition)_			throws TransactionException_;begin,a,new,transaction,with,semantics,according,to,the,given,transaction,definition,does,not,have,to,care,about,applying,the,propagation,behavior,as,this,has,already,been,handled,by,this,abstract,manager,p,this,method,gets,called,when,the,transaction,manager,has,decided,to,actually,start,a,new,transaction,either,there,wasn,t,any,transaction,before,or,the,previous,transaction,has,been,suspended,p,a,special,scenario,is,a,nested,transaction,without,savepoint,if,code,use,savepoint,for,nested,transaction,returns,false,this,method,will,be,called,to,start,a,nested,transaction,when,necessary,in,such,a,context,there,will,be,an,active,transaction,the,implementation,of,this,method,has,to,detect,this,and,start,an,appropriate,nested,transaction,param,transaction,transaction,object,returned,by,code,do,get,transaction,param,definition,a,transaction,definition,instance,describing,propagation,behavior,isolation,level,read,only,flag,timeout,and,transaction,name,throws,transaction,exception,in,case,of,creation,or,system,errors;protected,abstract,void,do,begin,object,transaction,transaction,definition,definition,throws,transaction,exception
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1328020251;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1356735495;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1357119239;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1368482696;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1407763209;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1413473170;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1425660345;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1437567612;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1486062666;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1486719573;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1487371244;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1495868221;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1496242568;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1496259743;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1496837955;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1498780456;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1506842603;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1517867503;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1530174524;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException;1530174524;Set the given transaction rollback-only. Only called on rollback_if the current transaction participates in an existing one._<p>The default implementation throws an IllegalTransactionStateException,_assuming that participating in existing transactions is generally not_supported. Subclasses are of course encouraged to provide such support._@param status the status representation of the transaction_@throws TransactionException in case of system errors;protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {_		throw new IllegalTransactionStateException(_				"Participating in existing transactions is not supported - when 'isExistingTransaction' " +_				"returns true, appropriate 'doSetRollbackOnly' behavior must be provided")__	};set,the,given,transaction,rollback,only,only,called,on,rollback,if,the,current,transaction,participates,in,an,existing,one,p,the,default,implementation,throws,an,illegal,transaction,state,exception,assuming,that,participating,in,existing,transactions,is,generally,not,supported,subclasses,are,of,course,encouraged,to,provide,such,support,param,status,the,status,representation,of,the,transaction,throws,transaction,exception,in,case,of,system,errors;protected,void,do,set,rollback,only,default,transaction,status,status,throws,transaction,exception,throw,new,illegal,transaction,state,exception,participating,in,existing,transactions,is,not,supported,when,is,existing,transaction,returns,true,appropriate,do,set,rollback,only,behavior,must,be,provided
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1356735495;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus)__			return__		}_		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus)__			_			_			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1368482696;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus)__			return__		}_		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus)__			_			_			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1407763209;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus)__			return__		}_		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus)__			_			_			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1413473170;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus)__			return__		}_		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus)__			_			_			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1425660345;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus)__			return__		}_		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus)__			_			_			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1437567612;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus)__			return__		}_		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus)__			_			_			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1486062666;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus)__			return__		}_		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus)__			_			_			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1486719573;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus)__			return__		}_		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus)__			_			_			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1487371244;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus, false)__			return__		}__		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus, true)__			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,false,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,true,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1495868221;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus, false)__			return__		}__		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus, true)__			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,false,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,true,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1496242568;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus, false)__			return__		}__		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus, true)__			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,false,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,true,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1496259743;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus, false)__			return__		}__		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus, true)__			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,false,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,true,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1496837955;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus, false)__			return__		}__		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus, true)__			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,false,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,true,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1498780456;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus, false)__			return__		}__		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus, true)__			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,false,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,true,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1506842603;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus, false)__			return__		}__		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus, true)__			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,false,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,true,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1517867503;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus, false)__			return__		}__		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus, true)__			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,false,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,true,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1530174524;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus, false)__			return__		}__		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus, true)__			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,false,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,true,return,process,commit,def,status
AbstractPlatformTransactionManager -> @Override 	public final void commit(TransactionStatus status) throws TransactionException;1530174524;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;@Override_	public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus, false)__			return__		}__		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus, true)__			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;override,public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,false,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,true,return,process,commit,def,status
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1328020251;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1356735495;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1357119239;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1368482696;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1407763209;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1413473170;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1425660345;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1437567612;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1486062666;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1486719573;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1487371244;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1495868221;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1496242568;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1496259743;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1496837955;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1498780456;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1506842603;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1517867503;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1530174524;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> public final boolean isGlobalRollbackOnParticipationFailure();1530174524;Return whether to globally mark an existing transaction as rollback-only_after a participating transaction failed.;public final boolean isGlobalRollbackOnParticipationFailure() {_		return this.globalRollbackOnParticipationFailure__	};return,whether,to,globally,mark,an,existing,transaction,as,rollback,only,after,a,participating,transaction,failed;public,final,boolean,is,global,rollback,on,participation,failure,return,this,global,rollback,on,participation,failure
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1356735495;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException ex) {_				resume(null, suspendedResources)__				throw ex__			}_			catch (Error err) {_				resume(null, suspendedResources)__				throw err__			}_		}_		else {_			_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,ex,resume,null,suspended,resources,throw,ex,catch,error,err,resume,null,suspended,resources,throw,err,else,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1368482696;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException ex) {_				resume(null, suspendedResources)__				throw ex__			}_			catch (Error err) {_				resume(null, suspendedResources)__				throw err__			}_		}_		else {_			_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,ex,resume,null,suspended,resources,throw,ex,catch,error,err,resume,null,suspended,resources,throw,err,else,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1407763209;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException ex) {_				resume(null, suspendedResources)__				throw ex__			}_			catch (Error err) {_				resume(null, suspendedResources)__				throw err__			}_		}_		else {_			_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,ex,resume,null,suspended,resources,throw,ex,catch,error,err,resume,null,suspended,resources,throw,err,else,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1413473170;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException ex) {_				resume(null, suspendedResources)__				throw ex__			}_			catch (Error err) {_				resume(null, suspendedResources)__				throw err__			}_		}_		else {_			_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,ex,resume,null,suspended,resources,throw,ex,catch,error,err,resume,null,suspended,resources,throw,err,else,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1425660345;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException ex) {_				resume(null, suspendedResources)__				throw ex__			}_			catch (Error err) {_				resume(null, suspendedResources)__				throw err__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,ex,resume,null,suspended,resources,throw,ex,catch,error,err,resume,null,suspended,resources,throw,err,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1437567612;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException ex) {_				resume(null, suspendedResources)__				throw ex__			}_			catch (Error err) {_				resume(null, suspendedResources)__				throw err__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,ex,resume,null,suspended,resources,throw,ex,catch,error,err,resume,null,suspended,resources,throw,err,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1486062666;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1486719573;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1487371244;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> @Override 	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;1495868221;This implementation handles propagation behavior. Delegates to_{@code doGetTransaction}, {@code isExistingTransaction}_and {@code doBegin}._@see #doGetTransaction_@see #isExistingTransaction_@see #doBegin;@Override_	public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {_		Object transaction = doGetTransaction()___		_		boolean debugEnabled = logger.isDebugEnabled()___		if (definition == null) {_			_			definition = new DefaultTransactionDefinition()__		}__		if (isExistingTransaction(transaction)) {_			_			return handleExistingTransaction(definition, transaction, debugEnabled)__		}__		_		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {_			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout())__		}__		_		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {_			throw new IllegalTransactionStateException(_					"No existing transaction found for transaction marked with propagation 'mandatory'")__		}_		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||_				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {_			SuspendedResourcesHolder suspendedResources = suspend(null)__			if (debugEnabled) {_				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition)__			}_			try {_				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER)__				DefaultTransactionStatus status = newTransactionStatus(_						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources)__				doBegin(transaction, definition)__				prepareSynchronization(status, definition)__				return status__			}_			catch (RuntimeException | Error ex) {_				resume(null, suspendedResources)__				throw ex__			}_		}_		else {_			_			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {_				logger.warn("Custom isolation level specified but no actual transaction initiated_ " +_						"isolation level will effectively be ignored: " + definition)__			}_			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS)__			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null)__		}_	};this,implementation,handles,propagation,behavior,delegates,to,code,do,get,transaction,code,is,existing,transaction,and,code,do,begin,see,do,get,transaction,see,is,existing,transaction,see,do,begin;override,public,final,transaction,status,get,transaction,transaction,definition,definition,throws,transaction,exception,object,transaction,do,get,transaction,boolean,debug,enabled,logger,is,debug,enabled,if,definition,null,definition,new,default,transaction,definition,if,is,existing,transaction,transaction,return,handle,existing,transaction,definition,transaction,debug,enabled,if,definition,get,timeout,transaction,definition,throw,new,invalid,timeout,exception,invalid,transaction,timeout,definition,get,timeout,if,definition,get,propagation,behavior,transaction,definition,throw,new,illegal,transaction,state,exception,no,existing,transaction,found,for,transaction,marked,with,propagation,mandatory,else,if,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,definition,get,propagation,behavior,transaction,definition,suspended,resources,holder,suspended,resources,suspend,null,if,debug,enabled,logger,debug,creating,new,transaction,with,name,definition,get,name,definition,try,boolean,new,synchronization,get,transaction,synchronization,default,transaction,status,status,new,transaction,status,definition,transaction,true,new,synchronization,debug,enabled,suspended,resources,do,begin,transaction,definition,prepare,synchronization,status,definition,return,status,catch,runtime,exception,error,ex,resume,null,suspended,resources,throw,ex,else,if,definition,get,isolation,level,transaction,definition,logger,is,warn,enabled,logger,warn,custom,isolation,level,specified,but,no,actual,transaction,initiated,isolation,level,will,effectively,be,ignored,definition,boolean,new,synchronization,get,transaction,synchronization,return,prepare,transaction,status,definition,null,true,new,synchronization,debug,enabled,null
AbstractPlatformTransactionManager -> public final void commit(TransactionStatus status) throws TransactionException;1328020251;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to <code>isRollbackOnly</code>, <code>doCommit</code>_and <code>rollback</code>._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus)__			return__		}_		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus)__			_			_			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,code,do,commit,code,and,code,rollback,code,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,return,process,commit,def,status
AbstractPlatformTransactionManager -> public final void commit(TransactionStatus status) throws TransactionException;1357119239;This implementation of commit handles participating in existing_transactions and programmatic rollback requests._Delegates to {@code isRollbackOnly}, {@code doCommit}_and {@code rollback}._@see org.springframework.transaction.TransactionStatus#isRollbackOnly()_@see #doCommit_@see #rollback;public final void commit(TransactionStatus status) throws TransactionException {_		if (status.isCompleted()) {_			throw new IllegalTransactionStateException(_					"Transaction is already completed - do not call commit or rollback more than once per transaction")__		}__		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status__		if (defStatus.isLocalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Transactional code has requested rollback")__			}_			processRollback(defStatus)__			return__		}_		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {_			if (defStatus.isDebug()) {_				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit")__			}_			processRollback(defStatus)__			_			_			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {_				throw new UnexpectedRollbackException(_						"Transaction rolled back because it has been marked as rollback-only")__			}_			return__		}__		processCommit(defStatus)__	};this,implementation,of,commit,handles,participating,in,existing,transactions,and,programmatic,rollback,requests,delegates,to,code,is,rollback,only,code,do,commit,and,code,rollback,see,org,springframework,transaction,transaction,status,is,rollback,only,see,do,commit,see,rollback;public,final,void,commit,transaction,status,status,throws,transaction,exception,if,status,is,completed,throw,new,illegal,transaction,state,exception,transaction,is,already,completed,do,not,call,commit,or,rollback,more,than,once,per,transaction,default,transaction,status,def,status,default,transaction,status,status,if,def,status,is,local,rollback,only,if,def,status,is,debug,logger,debug,transactional,code,has,requested,rollback,process,rollback,def,status,return,if,should,commit,on,global,rollback,only,def,status,is,global,rollback,only,if,def,status,is,debug,logger,debug,global,transaction,is,marked,as,rollback,only,but,transactional,code,requested,commit,process,rollback,def,status,if,status,is,new,transaction,is,fail,early,on,global,rollback,only,throw,new,unexpected,rollback,exception,transaction,rolled,back,because,it,has,been,marked,as,rollback,only,return,process,commit,def,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1496259743;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1496837955;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1498780456;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1506842603;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1517867503;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1530174524;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected final DefaultTransactionStatus prepareTransactionStatus( 			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, 			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources);1530174524;Create a new TransactionStatus for the given arguments,_also initializing transaction synchronization as appropriate._@see #newTransactionStatus_@see #prepareTransactionStatus;protected final DefaultTransactionStatus prepareTransactionStatus(_			TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction,_			boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) {__		DefaultTransactionStatus status = newTransactionStatus(_				definition, transaction, newTransaction, newSynchronization, debug, suspendedResources)__		prepareSynchronization(status, definition)__		return status__	};create,a,new,transaction,status,for,the,given,arguments,also,initializing,transaction,synchronization,as,appropriate,see,new,transaction,status,see,prepare,transaction,status;protected,final,default,transaction,status,prepare,transaction,status,transaction,definition,definition,nullable,object,transaction,boolean,new,transaction,boolean,new,synchronization,boolean,debug,nullable,object,suspended,resources,default,transaction,status,status,new,transaction,status,definition,transaction,new,transaction,new,synchronization,debug,suspended,resources,prepare,synchronization,status,definition,return,status
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1328020251;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1356735495;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1357119239;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1368482696;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1407763209;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1413473170;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1425660345;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1437567612;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1486062666;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1486719573;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1487371244;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1495868221;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1496242568;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1496259743;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1496837955;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1498780456;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1506842603;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1517867503;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1530174524;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected int determineTimeout(TransactionDefinition definition);1530174524;Determine the actual timeout to use for the given definition._Will fall back to this manager's default timeout if the_transaction definition doesn't specify a non-default value._@param definition the transaction definition_@return the actual timeout to use_@see org.springframework.transaction.TransactionDefinition#getTimeout()_@see #setDefaultTimeout;protected int determineTimeout(TransactionDefinition definition) {_		if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {_			return definition.getTimeout()__		}_		return this.defaultTimeout__	};determine,the,actual,timeout,to,use,for,the,given,definition,will,fall,back,to,this,manager,s,default,timeout,if,the,transaction,definition,doesn,t,specify,a,non,default,value,param,definition,the,transaction,definition,return,the,actual,timeout,to,use,see,org,springframework,transaction,transaction,definition,get,timeout,see,set,default,timeout;protected,int,determine,timeout,transaction,definition,definition,if,definition,get,timeout,transaction,definition,return,definition,get,timeout,return,this,default,timeout
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1328020251;Cleanup resources after transaction completion._<p>Called after <code>doCommit</code> and <code>doRollback</code> execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by <code>doGetTransaction</code>;protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,code,and,code,do,rollback,code,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction,code;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1356735495;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1357119239;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1368482696;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1407763209;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1413473170;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1425660345;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1437567612;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1486062666;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1486719573;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1487371244;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1495868221;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1496242568;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1496259743;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1496837955;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1498780456;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1506842603;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1517867503;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1530174524;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
AbstractPlatformTransactionManager -> protected void doCleanupAfterCompletion(Object transaction);1530174524;Cleanup resources after transaction completion._<p>Called after {@code doCommit} and {@code doRollback} execution,_on any outcome. The default implementation does nothing._<p>Should not throw any exceptions but just issue warnings on errors._@param transaction transaction object returned by {@code doGetTransaction};protected void doCleanupAfterCompletion(Object transaction) {_	};cleanup,resources,after,transaction,completion,p,called,after,code,do,commit,and,code,do,rollback,execution,on,any,outcome,the,default,implementation,does,nothing,p,should,not,throw,any,exceptions,but,just,issue,warnings,on,errors,param,transaction,transaction,object,returned,by,code,do,get,transaction;protected,void,do,cleanup,after,completion,object,transaction
