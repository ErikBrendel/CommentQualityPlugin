# id;timestamp;commentText;codeText;commentWords;codeWords
TransactionSynchronization -> @Override 	default void flush();1489501133;Flush the underlying session to the datastore, if applicable:_for example, a Hibernate/JPA session._@see org.springframework.transaction.TransactionStatus#flush();@Override_	default void flush() {_	};flush,the,underlying,session,to,the,datastore,if,applicable,for,example,a,hibernate,jpa,session,see,org,springframework,transaction,transaction,status,flush;override,default,void,flush
TransactionSynchronization -> @Override 	default void flush();1530174524;Flush the underlying session to the datastore, if applicable:_for example, a Hibernate/JPA session._@see org.springframework.transaction.TransactionStatus#flush();@Override_	default void flush() {_	};flush,the,underlying,session,to,the,datastore,if,applicable,for,example,a,hibernate,jpa,session,see,org,springframework,transaction,transaction,status,flush;override,default,void,flush
TransactionSynchronization -> void afterCommit()_;1328020251;Invoked after transaction commit. Can perform further operations right_<i>after</i> the main transaction has <i>successfully</i> committed._<p>Can e.g. commit further operations that are supposed to follow on a successful_commit of the main transaction, like confirmation messages or emails._<p><b>NOTE:</b> The transaction will have been committed already, but the_transactional resources might still be active and accessible. As a consequence,_any data access code triggered at this point will still "participate" in the_original transaction, allowing to perform some cleanup (with no commit following_anymore!), unless it explicitly declares that it needs to run in a separate_transaction. Hence: <b>Use <code>PROPAGATION_REQUIRES_NEW</code> for any_transactional operation that is called from here.</b>_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);void afterCommit()_;invoked,after,transaction,commit,can,perform,further,operations,right,i,after,i,the,main,transaction,has,i,successfully,i,committed,p,can,e,g,commit,further,operations,that,are,supposed,to,follow,on,a,successful,commit,of,the,main,transaction,like,confirmation,messages,or,emails,p,b,note,b,the,transaction,will,have,been,committed,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,code,for,any,transactional,operation,that,is,called,from,here,b,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;void,after,commit
TransactionSynchronization -> void afterCommit()_;1356735495;Invoked after transaction commit. Can perform further operations right_<i>after</i> the main transaction has <i>successfully</i> committed._<p>Can e.g. commit further operations that are supposed to follow on a successful_commit of the main transaction, like confirmation messages or emails._<p><b>NOTE:</b> The transaction will have been committed already, but the_transactional resources might still be active and accessible. As a consequence,_any data access code triggered at this point will still "participate" in the_original transaction, allowing to perform some cleanup (with no commit following_anymore!), unless it explicitly declares that it needs to run in a separate_transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW} for any_transactional operation that is called from here.</b>_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);void afterCommit()_;invoked,after,transaction,commit,can,perform,further,operations,right,i,after,i,the,main,transaction,has,i,successfully,i,committed,p,can,e,g,commit,further,operations,that,are,supposed,to,follow,on,a,successful,commit,of,the,main,transaction,like,confirmation,messages,or,emails,p,b,note,b,the,transaction,will,have,been,committed,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,for,any,transactional,operation,that,is,called,from,here,b,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;void,after,commit
TransactionSynchronization -> void afterCommit()_;1381787551;Invoked after transaction commit. Can perform further operations right_<i>after</i> the main transaction has <i>successfully</i> committed._<p>Can e.g. commit further operations that are supposed to follow on a successful_commit of the main transaction, like confirmation messages or emails._<p><b>NOTE:</b> The transaction will have been committed already, but the_transactional resources might still be active and accessible. As a consequence,_any data access code triggered at this point will still "participate" in the_original transaction, allowing to perform some cleanup (with no commit following_anymore!), unless it explicitly declares that it needs to run in a separate_transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW} for any_transactional operation that is called from here.</b>_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);void afterCommit()_;invoked,after,transaction,commit,can,perform,further,operations,right,i,after,i,the,main,transaction,has,i,successfully,i,committed,p,can,e,g,commit,further,operations,that,are,supposed,to,follow,on,a,successful,commit,of,the,main,transaction,like,confirmation,messages,or,emails,p,b,note,b,the,transaction,will,have,been,committed,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,for,any,transactional,operation,that,is,called,from,here,b,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;void,after,commit
TransactionSynchronization -> void afterCommit()_;1391721359;Invoked after transaction commit. Can perform further operations right_<i>after</i> the main transaction has <i>successfully</i> committed._<p>Can e.g. commit further operations that are supposed to follow on a successful_commit of the main transaction, like confirmation messages or emails._<p><b>NOTE:</b> The transaction will have been committed already, but the_transactional resources might still be active and accessible. As a consequence,_any data access code triggered at this point will still "participate" in the_original transaction, allowing to perform some cleanup (with no commit following_anymore!), unless it explicitly declares that it needs to run in a separate_transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW} for any_transactional operation that is called from here.</b>_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);void afterCommit()_;invoked,after,transaction,commit,can,perform,further,operations,right,i,after,i,the,main,transaction,has,i,successfully,i,committed,p,can,e,g,commit,further,operations,that,are,supposed,to,follow,on,a,successful,commit,of,the,main,transaction,like,confirmation,messages,or,emails,p,b,note,b,the,transaction,will,have,been,committed,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,for,any,transactional,operation,that,is,called,from,here,b,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;void,after,commit
TransactionSynchronization -> void beforeCommit(boolean readOnly)_;1328020251;Invoked before transaction commit (before "beforeCompletion")._Can e.g. flush transactional O/R Mapping sessions to the database._<p>This callback does <i>not</i> mean that the transaction will actually be committed._A rollback decision can still occur after this method has been called. This callback_is rather meant to perform work that's only relevant if a commit still has a chance_to happen, such as flushing SQL statements to the database._<p>Note that exceptions will get propagated to the commit caller and cause a_rollback of the transaction._@param readOnly whether the transaction is defined as read-only transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCompletion;void beforeCommit(boolean readOnly)_;invoked,before,transaction,commit,before,before,completion,can,e,g,flush,transactional,o,r,mapping,sessions,to,the,database,p,this,callback,does,i,not,i,mean,that,the,transaction,will,actually,be,committed,a,rollback,decision,can,still,occur,after,this,method,has,been,called,this,callback,is,rather,meant,to,perform,work,that,s,only,relevant,if,a,commit,still,has,a,chance,to,happen,such,as,flushing,sql,statements,to,the,database,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,read,only,whether,the,transaction,is,defined,as,read,only,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,completion;void,before,commit,boolean,read,only
TransactionSynchronization -> void beforeCommit(boolean readOnly)_;1356735495;Invoked before transaction commit (before "beforeCompletion")._Can e.g. flush transactional O/R Mapping sessions to the database._<p>This callback does <i>not</i> mean that the transaction will actually be committed._A rollback decision can still occur after this method has been called. This callback_is rather meant to perform work that's only relevant if a commit still has a chance_to happen, such as flushing SQL statements to the database._<p>Note that exceptions will get propagated to the commit caller and cause a_rollback of the transaction._@param readOnly whether the transaction is defined as read-only transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCompletion;void beforeCommit(boolean readOnly)_;invoked,before,transaction,commit,before,before,completion,can,e,g,flush,transactional,o,r,mapping,sessions,to,the,database,p,this,callback,does,i,not,i,mean,that,the,transaction,will,actually,be,committed,a,rollback,decision,can,still,occur,after,this,method,has,been,called,this,callback,is,rather,meant,to,perform,work,that,s,only,relevant,if,a,commit,still,has,a,chance,to,happen,such,as,flushing,sql,statements,to,the,database,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,read,only,whether,the,transaction,is,defined,as,read,only,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,completion;void,before,commit,boolean,read,only
TransactionSynchronization -> void beforeCommit(boolean readOnly)_;1381787551;Invoked before transaction commit (before "beforeCompletion")._Can e.g. flush transactional O/R Mapping sessions to the database._<p>This callback does <i>not</i> mean that the transaction will actually be committed._A rollback decision can still occur after this method has been called. This callback_is rather meant to perform work that's only relevant if a commit still has a chance_to happen, such as flushing SQL statements to the database._<p>Note that exceptions will get propagated to the commit caller and cause a_rollback of the transaction._@param readOnly whether the transaction is defined as read-only transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCompletion;void beforeCommit(boolean readOnly)_;invoked,before,transaction,commit,before,before,completion,can,e,g,flush,transactional,o,r,mapping,sessions,to,the,database,p,this,callback,does,i,not,i,mean,that,the,transaction,will,actually,be,committed,a,rollback,decision,can,still,occur,after,this,method,has,been,called,this,callback,is,rather,meant,to,perform,work,that,s,only,relevant,if,a,commit,still,has,a,chance,to,happen,such,as,flushing,sql,statements,to,the,database,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,read,only,whether,the,transaction,is,defined,as,read,only,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,completion;void,before,commit,boolean,read,only
TransactionSynchronization -> void beforeCommit(boolean readOnly)_;1391721359;Invoked before transaction commit (before "beforeCompletion")._Can e.g. flush transactional O/R Mapping sessions to the database._<p>This callback does <i>not</i> mean that the transaction will actually be committed._A rollback decision can still occur after this method has been called. This callback_is rather meant to perform work that's only relevant if a commit still has a chance_to happen, such as flushing SQL statements to the database._<p>Note that exceptions will get propagated to the commit caller and cause a_rollback of the transaction._@param readOnly whether the transaction is defined as read-only transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCompletion;void beforeCommit(boolean readOnly)_;invoked,before,transaction,commit,before,before,completion,can,e,g,flush,transactional,o,r,mapping,sessions,to,the,database,p,this,callback,does,i,not,i,mean,that,the,transaction,will,actually,be,committed,a,rollback,decision,can,still,occur,after,this,method,has,been,called,this,callback,is,rather,meant,to,perform,work,that,s,only,relevant,if,a,commit,still,has,a,chance,to,happen,such,as,flushing,sql,statements,to,the,database,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,read,only,whether,the,transaction,is,defined,as,read,only,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,completion;void,before,commit,boolean,read,only
TransactionSynchronization -> void beforeCompletion()_;1328020251;Invoked before transaction commit/rollback._Can perform resource cleanup <i>before</i> transaction completion._<p>This method will be invoked after <code>beforeCommit</code>, even when_<code>beforeCommit</code> threw an exception. This callback allows for_closing resources before transaction completion, for any outcome._@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCommit_@see #afterCompletion;void beforeCompletion()_;invoked,before,transaction,commit,rollback,can,perform,resource,cleanup,i,before,i,transaction,completion,p,this,method,will,be,invoked,after,code,before,commit,code,even,when,code,before,commit,code,threw,an,exception,this,callback,allows,for,closing,resources,before,transaction,completion,for,any,outcome,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,commit,see,after,completion;void,before,completion
TransactionSynchronization -> void beforeCompletion()_;1356735495;Invoked before transaction commit/rollback._Can perform resource cleanup <i>before</i> transaction completion._<p>This method will be invoked after {@code beforeCommit}, even when_{@code beforeCommit} threw an exception. This callback allows for_closing resources before transaction completion, for any outcome._@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCommit_@see #afterCompletion;void beforeCompletion()_;invoked,before,transaction,commit,rollback,can,perform,resource,cleanup,i,before,i,transaction,completion,p,this,method,will,be,invoked,after,code,before,commit,even,when,code,before,commit,threw,an,exception,this,callback,allows,for,closing,resources,before,transaction,completion,for,any,outcome,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,commit,see,after,completion;void,before,completion
TransactionSynchronization -> void beforeCompletion()_;1381787551;Invoked before transaction commit/rollback._Can perform resource cleanup <i>before</i> transaction completion._<p>This method will be invoked after {@code beforeCommit}, even when_{@code beforeCommit} threw an exception. This callback allows for_closing resources before transaction completion, for any outcome._@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCommit_@see #afterCompletion;void beforeCompletion()_;invoked,before,transaction,commit,rollback,can,perform,resource,cleanup,i,before,i,transaction,completion,p,this,method,will,be,invoked,after,code,before,commit,even,when,code,before,commit,threw,an,exception,this,callback,allows,for,closing,resources,before,transaction,completion,for,any,outcome,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,commit,see,after,completion;void,before,completion
TransactionSynchronization -> void beforeCompletion()_;1391721359;Invoked before transaction commit/rollback._Can perform resource cleanup <i>before</i> transaction completion._<p>This method will be invoked after {@code beforeCommit}, even when_{@code beforeCommit} threw an exception. This callback allows for_closing resources before transaction completion, for any outcome._@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCommit_@see #afterCompletion;void beforeCompletion()_;invoked,before,transaction,commit,rollback,can,perform,resource,cleanup,i,before,i,transaction,completion,p,this,method,will,be,invoked,after,code,before,commit,even,when,code,before,commit,threw,an,exception,this,callback,allows,for,closing,resources,before,transaction,completion,for,any,outcome,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,commit,see,after,completion;void,before,completion
TransactionSynchronization -> default void beforeCompletion();1489501133;Invoked before transaction commit/rollback._Can perform resource cleanup <i>before</i> transaction completion._<p>This method will be invoked after {@code beforeCommit}, even when_{@code beforeCommit} threw an exception. This callback allows for_closing resources before transaction completion, for any outcome._@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCommit_@see #afterCompletion;default void beforeCompletion() {_	};invoked,before,transaction,commit,rollback,can,perform,resource,cleanup,i,before,i,transaction,completion,p,this,method,will,be,invoked,after,code,before,commit,even,when,code,before,commit,threw,an,exception,this,callback,allows,for,closing,resources,before,transaction,completion,for,any,outcome,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,commit,see,after,completion;default,void,before,completion
TransactionSynchronization -> default void beforeCompletion();1530174524;Invoked before transaction commit/rollback._Can perform resource cleanup <i>before</i> transaction completion._<p>This method will be invoked after {@code beforeCommit}, even when_{@code beforeCommit} threw an exception. This callback allows for_closing resources before transaction completion, for any outcome._@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCommit_@see #afterCompletion;default void beforeCompletion() {_	};invoked,before,transaction,commit,rollback,can,perform,resource,cleanup,i,before,i,transaction,completion,p,this,method,will,be,invoked,after,code,before,commit,even,when,code,before,commit,threw,an,exception,this,callback,allows,for,closing,resources,before,transaction,completion,for,any,outcome,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,commit,see,after,completion;default,void,before,completion
TransactionSynchronization -> default void suspend();1489501133;Suspend this synchronization._Supposed to unbind resources from TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#unbindResource;default void suspend() {_	};suspend,this,synchronization,supposed,to,unbind,resources,from,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,unbind,resource;default,void,suspend
TransactionSynchronization -> default void suspend();1530174524;Suspend this synchronization._Supposed to unbind resources from TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#unbindResource;default void suspend() {_	};suspend,this,synchronization,supposed,to,unbind,resources,from,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,unbind,resource;default,void,suspend
TransactionSynchronization -> void resume()_;1328020251;Resume this synchronization._Supposed to rebind resources to TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#bindResource;void resume()_;resume,this,synchronization,supposed,to,rebind,resources,to,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,bind,resource;void,resume
TransactionSynchronization -> void resume()_;1356735495;Resume this synchronization._Supposed to rebind resources to TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#bindResource;void resume()_;resume,this,synchronization,supposed,to,rebind,resources,to,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,bind,resource;void,resume
TransactionSynchronization -> void resume()_;1381787551;Resume this synchronization._Supposed to rebind resources to TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#bindResource;void resume()_;resume,this,synchronization,supposed,to,rebind,resources,to,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,bind,resource;void,resume
TransactionSynchronization -> void resume()_;1391721359;Resume this synchronization._Supposed to rebind resources to TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#bindResource;void resume()_;resume,this,synchronization,supposed,to,rebind,resources,to,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,bind,resource;void,resume
TransactionSynchronization -> default void afterCommit();1489501133;Invoked after transaction commit. Can perform further operations right_<i>after</i> the main transaction has <i>successfully</i> committed._<p>Can e.g. commit further operations that are supposed to follow on a successful_commit of the main transaction, like confirmation messages or emails._<p><b>NOTE:</b> The transaction will have been committed already, but the_transactional resources might still be active and accessible. As a consequence,_any data access code triggered at this point will still "participate" in the_original transaction, allowing to perform some cleanup (with no commit following_anymore!), unless it explicitly declares that it needs to run in a separate_transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW} for any_transactional operation that is called from here.</b>_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);default void afterCommit() {_	};invoked,after,transaction,commit,can,perform,further,operations,right,i,after,i,the,main,transaction,has,i,successfully,i,committed,p,can,e,g,commit,further,operations,that,are,supposed,to,follow,on,a,successful,commit,of,the,main,transaction,like,confirmation,messages,or,emails,p,b,note,b,the,transaction,will,have,been,committed,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,for,any,transactional,operation,that,is,called,from,here,b,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;default,void,after,commit
TransactionSynchronization -> default void afterCommit();1530174524;Invoked after transaction commit. Can perform further operations right_<i>after</i> the main transaction has <i>successfully</i> committed._<p>Can e.g. commit further operations that are supposed to follow on a successful_commit of the main transaction, like confirmation messages or emails._<p><b>NOTE:</b> The transaction will have been committed already, but the_transactional resources might still be active and accessible. As a consequence,_any data access code triggered at this point will still "participate" in the_original transaction, allowing to perform some cleanup (with no commit following_anymore!), unless it explicitly declares that it needs to run in a separate_transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW} for any_transactional operation that is called from here.</b>_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!);default void afterCommit() {_	};invoked,after,transaction,commit,can,perform,further,operations,right,i,after,i,the,main,transaction,has,i,successfully,i,committed,p,can,e,g,commit,further,operations,that,are,supposed,to,follow,on,a,successful,commit,of,the,main,transaction,like,confirmation,messages,or,emails,p,b,note,b,the,transaction,will,have,been,committed,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,for,any,transactional,operation,that,is,called,from,here,b,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here;default,void,after,commit
TransactionSynchronization -> void afterCompletion(int status)_;1328020251;Invoked after transaction commit/rollback._Can perform resource cleanup <i>after</i> transaction completion._<p><b>NOTE:</b> The transaction will have been committed or rolled back already,_but the transactional resources might still be active and accessible. As a_consequence, any data access code triggered at this point will still "participate"_in the original transaction, allowing to perform some cleanup (with no commit_following anymore!), unless it explicitly declares that it needs to run in a_separate transaction. Hence: <b>Use <code>PROPAGATION_REQUIRES_NEW</code>_for any transactional operation that is called from here.</b>_@param status completion status according to the <code>STATUS_*</code> constants_@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #STATUS_COMMITTED_@see #STATUS_ROLLED_BACK_@see #STATUS_UNKNOWN_@see #beforeCompletion;void afterCompletion(int status)_;invoked,after,transaction,commit,rollback,can,perform,resource,cleanup,i,after,i,transaction,completion,p,b,note,b,the,transaction,will,have,been,committed,or,rolled,back,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,code,for,any,transactional,operation,that,is,called,from,here,b,param,status,completion,status,according,to,the,code,code,constants,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,see,see,see,before,completion;void,after,completion,int,status
TransactionSynchronization -> void afterCompletion(int status)_;1356735495;Invoked after transaction commit/rollback._Can perform resource cleanup <i>after</i> transaction completion._<p><b>NOTE:</b> The transaction will have been committed or rolled back already,_but the transactional resources might still be active and accessible. As a_consequence, any data access code triggered at this point will still "participate"_in the original transaction, allowing to perform some cleanup (with no commit_following anymore!), unless it explicitly declares that it needs to run in a_separate transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW}_for any transactional operation that is called from here.</b>_@param status completion status according to the {@code STATUS_*} constants_@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #STATUS_COMMITTED_@see #STATUS_ROLLED_BACK_@see #STATUS_UNKNOWN_@see #beforeCompletion;void afterCompletion(int status)_;invoked,after,transaction,commit,rollback,can,perform,resource,cleanup,i,after,i,transaction,completion,p,b,note,b,the,transaction,will,have,been,committed,or,rolled,back,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,for,any,transactional,operation,that,is,called,from,here,b,param,status,completion,status,according,to,the,code,constants,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,see,see,see,before,completion;void,after,completion,int,status
TransactionSynchronization -> void afterCompletion(int status)_;1381787551;Invoked after transaction commit/rollback._Can perform resource cleanup <i>after</i> transaction completion._<p><b>NOTE:</b> The transaction will have been committed or rolled back already,_but the transactional resources might still be active and accessible. As a_consequence, any data access code triggered at this point will still "participate"_in the original transaction, allowing to perform some cleanup (with no commit_following anymore!), unless it explicitly declares that it needs to run in a_separate transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW}_for any transactional operation that is called from here.</b>_@param status completion status according to the {@code STATUS_*} constants_@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #STATUS_COMMITTED_@see #STATUS_ROLLED_BACK_@see #STATUS_UNKNOWN_@see #beforeCompletion;void afterCompletion(int status)_;invoked,after,transaction,commit,rollback,can,perform,resource,cleanup,i,after,i,transaction,completion,p,b,note,b,the,transaction,will,have,been,committed,or,rolled,back,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,for,any,transactional,operation,that,is,called,from,here,b,param,status,completion,status,according,to,the,code,constants,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,see,see,see,before,completion;void,after,completion,int,status
TransactionSynchronization -> void afterCompletion(int status)_;1391721359;Invoked after transaction commit/rollback._Can perform resource cleanup <i>after</i> transaction completion._<p><b>NOTE:</b> The transaction will have been committed or rolled back already,_but the transactional resources might still be active and accessible. As a_consequence, any data access code triggered at this point will still "participate"_in the original transaction, allowing to perform some cleanup (with no commit_following anymore!), unless it explicitly declares that it needs to run in a_separate transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW}_for any transactional operation that is called from here.</b>_@param status completion status according to the {@code STATUS_*} constants_@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #STATUS_COMMITTED_@see #STATUS_ROLLED_BACK_@see #STATUS_UNKNOWN_@see #beforeCompletion;void afterCompletion(int status)_;invoked,after,transaction,commit,rollback,can,perform,resource,cleanup,i,after,i,transaction,completion,p,b,note,b,the,transaction,will,have,been,committed,or,rolled,back,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,for,any,transactional,operation,that,is,called,from,here,b,param,status,completion,status,according,to,the,code,constants,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,see,see,see,before,completion;void,after,completion,int,status
TransactionSynchronization -> default void beforeCommit(boolean readOnly);1489501133;Invoked before transaction commit (before "beforeCompletion")._Can e.g. flush transactional O/R Mapping sessions to the database._<p>This callback does <i>not</i> mean that the transaction will actually be committed._A rollback decision can still occur after this method has been called. This callback_is rather meant to perform work that's only relevant if a commit still has a chance_to happen, such as flushing SQL statements to the database._<p>Note that exceptions will get propagated to the commit caller and cause a_rollback of the transaction._@param readOnly whether the transaction is defined as read-only transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCompletion;default void beforeCommit(boolean readOnly) {_	};invoked,before,transaction,commit,before,before,completion,can,e,g,flush,transactional,o,r,mapping,sessions,to,the,database,p,this,callback,does,i,not,i,mean,that,the,transaction,will,actually,be,committed,a,rollback,decision,can,still,occur,after,this,method,has,been,called,this,callback,is,rather,meant,to,perform,work,that,s,only,relevant,if,a,commit,still,has,a,chance,to,happen,such,as,flushing,sql,statements,to,the,database,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,read,only,whether,the,transaction,is,defined,as,read,only,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,completion;default,void,before,commit,boolean,read,only
TransactionSynchronization -> default void beforeCommit(boolean readOnly);1530174524;Invoked before transaction commit (before "beforeCompletion")._Can e.g. flush transactional O/R Mapping sessions to the database._<p>This callback does <i>not</i> mean that the transaction will actually be committed._A rollback decision can still occur after this method has been called. This callback_is rather meant to perform work that's only relevant if a commit still has a chance_to happen, such as flushing SQL statements to the database._<p>Note that exceptions will get propagated to the commit caller and cause a_rollback of the transaction._@param readOnly whether the transaction is defined as read-only transaction_@throws RuntimeException in case of errors_ will be <b>propagated to the caller</b>_(note: do not throw TransactionException subclasses here!)_@see #beforeCompletion;default void beforeCommit(boolean readOnly) {_	};invoked,before,transaction,commit,before,before,completion,can,e,g,flush,transactional,o,r,mapping,sessions,to,the,database,p,this,callback,does,i,not,i,mean,that,the,transaction,will,actually,be,committed,a,rollback,decision,can,still,occur,after,this,method,has,been,called,this,callback,is,rather,meant,to,perform,work,that,s,only,relevant,if,a,commit,still,has,a,chance,to,happen,such,as,flushing,sql,statements,to,the,database,p,note,that,exceptions,will,get,propagated,to,the,commit,caller,and,cause,a,rollback,of,the,transaction,param,read,only,whether,the,transaction,is,defined,as,read,only,transaction,throws,runtime,exception,in,case,of,errors,will,be,b,propagated,to,the,caller,b,note,do,not,throw,transaction,exception,subclasses,here,see,before,completion;default,void,before,commit,boolean,read,only
TransactionSynchronization -> void suspend()_;1328020251;Suspend this synchronization._Supposed to unbind resources from TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#unbindResource;void suspend()_;suspend,this,synchronization,supposed,to,unbind,resources,from,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,unbind,resource;void,suspend
TransactionSynchronization -> void suspend()_;1356735495;Suspend this synchronization._Supposed to unbind resources from TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#unbindResource;void suspend()_;suspend,this,synchronization,supposed,to,unbind,resources,from,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,unbind,resource;void,suspend
TransactionSynchronization -> void suspend()_;1381787551;Suspend this synchronization._Supposed to unbind resources from TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#unbindResource;void suspend()_;suspend,this,synchronization,supposed,to,unbind,resources,from,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,unbind,resource;void,suspend
TransactionSynchronization -> void suspend()_;1391721359;Suspend this synchronization._Supposed to unbind resources from TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#unbindResource;void suspend()_;suspend,this,synchronization,supposed,to,unbind,resources,from,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,unbind,resource;void,suspend
TransactionSynchronization -> @Override 	void flush()_;1381787551;Flush the underlying session to the datastore, if applicable:_for example, a Hibernate/JPA session._@see org.springframework.transaction.TransactionStatus#flush();@Override_	void flush()_;flush,the,underlying,session,to,the,datastore,if,applicable,for,example,a,hibernate,jpa,session,see,org,springframework,transaction,transaction,status,flush;override,void,flush
TransactionSynchronization -> @Override 	void flush()_;1391721359;Flush the underlying session to the datastore, if applicable:_for example, a Hibernate/JPA session._@see org.springframework.transaction.TransactionStatus#flush();@Override_	void flush()_;flush,the,underlying,session,to,the,datastore,if,applicable,for,example,a,hibernate,jpa,session,see,org,springframework,transaction,transaction,status,flush;override,void,flush
TransactionSynchronization -> void flush()_;1328020251;Flush the underlying session to the datastore, if applicable:_for example, a Hibernate/JPA session._@see org.springframework.transaction.TransactionStatus#flush();void flush()_;flush,the,underlying,session,to,the,datastore,if,applicable,for,example,a,hibernate,jpa,session,see,org,springframework,transaction,transaction,status,flush;void,flush
TransactionSynchronization -> void flush()_;1356735495;Flush the underlying session to the datastore, if applicable:_for example, a Hibernate/JPA session._@see org.springframework.transaction.TransactionStatus#flush();void flush()_;flush,the,underlying,session,to,the,datastore,if,applicable,for,example,a,hibernate,jpa,session,see,org,springframework,transaction,transaction,status,flush;void,flush
TransactionSynchronization -> default void resume();1489501133;Resume this synchronization._Supposed to rebind resources to TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#bindResource;default void resume() {_	};resume,this,synchronization,supposed,to,rebind,resources,to,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,bind,resource;default,void,resume
TransactionSynchronization -> default void resume();1530174524;Resume this synchronization._Supposed to rebind resources to TransactionSynchronizationManager if managing any._@see TransactionSynchronizationManager#bindResource;default void resume() {_	};resume,this,synchronization,supposed,to,rebind,resources,to,transaction,synchronization,manager,if,managing,any,see,transaction,synchronization,manager,bind,resource;default,void,resume
TransactionSynchronization -> default void afterCompletion(int status);1489501133;Invoked after transaction commit/rollback._Can perform resource cleanup <i>after</i> transaction completion._<p><b>NOTE:</b> The transaction will have been committed or rolled back already,_but the transactional resources might still be active and accessible. As a_consequence, any data access code triggered at this point will still "participate"_in the original transaction, allowing to perform some cleanup (with no commit_following anymore!), unless it explicitly declares that it needs to run in a_separate transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW}_for any transactional operation that is called from here.</b>_@param status completion status according to the {@code STATUS_*} constants_@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #STATUS_COMMITTED_@see #STATUS_ROLLED_BACK_@see #STATUS_UNKNOWN_@see #beforeCompletion;default void afterCompletion(int status) {_	};invoked,after,transaction,commit,rollback,can,perform,resource,cleanup,i,after,i,transaction,completion,p,b,note,b,the,transaction,will,have,been,committed,or,rolled,back,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,for,any,transactional,operation,that,is,called,from,here,b,param,status,completion,status,according,to,the,code,constants,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,see,see,see,before,completion;default,void,after,completion,int,status
TransactionSynchronization -> default void afterCompletion(int status);1530174524;Invoked after transaction commit/rollback._Can perform resource cleanup <i>after</i> transaction completion._<p><b>NOTE:</b> The transaction will have been committed or rolled back already,_but the transactional resources might still be active and accessible. As a_consequence, any data access code triggered at this point will still "participate"_in the original transaction, allowing to perform some cleanup (with no commit_following anymore!), unless it explicitly declares that it needs to run in a_separate transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW}_for any transactional operation that is called from here.</b>_@param status completion status according to the {@code STATUS_*} constants_@throws RuntimeException in case of errors_ will be <b>logged but not propagated</b>_(note: do not throw TransactionException subclasses here!)_@see #STATUS_COMMITTED_@see #STATUS_ROLLED_BACK_@see #STATUS_UNKNOWN_@see #beforeCompletion;default void afterCompletion(int status) {_	};invoked,after,transaction,commit,rollback,can,perform,resource,cleanup,i,after,i,transaction,completion,p,b,note,b,the,transaction,will,have,been,committed,or,rolled,back,already,but,the,transactional,resources,might,still,be,active,and,accessible,as,a,consequence,any,data,access,code,triggered,at,this,point,will,still,participate,in,the,original,transaction,allowing,to,perform,some,cleanup,with,no,commit,following,anymore,unless,it,explicitly,declares,that,it,needs,to,run,in,a,separate,transaction,hence,b,use,code,for,any,transactional,operation,that,is,called,from,here,b,param,status,completion,status,according,to,the,code,constants,throws,runtime,exception,in,case,of,errors,will,be,b,logged,but,not,propagated,b,note,do,not,throw,transaction,exception,subclasses,here,see,see,see,see,before,completion;default,void,after,completion,int,status
