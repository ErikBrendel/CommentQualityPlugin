commented;modifiers;parameterAmount;loc;comment;code
true;protected,static;0;4;/**  * Subclasses can use this to return the current TransactionInfo.  * Only subclasses that cannot handle all operations in one method,  * such as an AspectJ aspect involving distinct before and after advice,  * need to use this mechanism to get at the current TransactionInfo.  * An around advice such as an AOP Alliance MethodInterceptor can hold a  * reference to the TransactionInfo throughout the aspect method.  * <p>A TransactionInfo will be returned even if no transaction was created.  * The {@code TransactionInfo.hasTransaction()} method can be used to query this.  * <p>To find out about specific transaction characteristics, consider using  * TransactionSynchronizationManager's {@code isSynchronizationActive()}  * and/or {@code isActualTransactionActive()} methods.  * @return the TransactionInfo bound to this thread, or {@code null} if none  * @see TransactionInfo#hasTransaction()  * @see org.springframework.transaction.support.TransactionSynchronizationManager#isSynchronizationActive()  * @see org.springframework.transaction.support.TransactionSynchronizationManager#isActualTransactionActive()  */ ;/**  * Subclasses can use this to return the current TransactionInfo.  * Only subclasses that cannot handle all operations in one method,  * such as an AspectJ aspect involving distinct before and after advice,  * need to use this mechanism to get at the current TransactionInfo.  * An around advice such as an AOP Alliance MethodInterceptor can hold a  * reference to the TransactionInfo throughout the aspect method.  * <p>A TransactionInfo will be returned even if no transaction was created.  * The {@code TransactionInfo.hasTransaction()} method can be used to query this.  * <p>To find out about specific transaction characteristics, consider using  * TransactionSynchronizationManager's {@code isSynchronizationActive()}  * and/or {@code isActualTransactionActive()} methods.  * @return the TransactionInfo bound to this thread, or {@code null} if none  * @see TransactionInfo#hasTransaction()  * @see org.springframework.transaction.support.TransactionSynchronizationManager#isSynchronizationActive()  * @see org.springframework.transaction.support.TransactionSynchronizationManager#isActualTransactionActive()  */ @Nullable protected static TransactionInfo currentTransactionInfo() throws NoTransactionException {     return transactionInfoHolder.get(). }
true;public,static;0;7;/**  * Return the transaction status of the current method invocation.  * Mainly intended for code that wants to set the current transaction  * rollback-only but not throw an application exception.  * @throws NoTransactionException if the transaction info cannot be found,  * because the method was invoked outside an AOP invocation context  */ ;/**  * Return the transaction status of the current method invocation.  * Mainly intended for code that wants to set the current transaction  * rollback-only but not throw an application exception.  * @throws NoTransactionException if the transaction info cannot be found,  * because the method was invoked outside an AOP invocation context  */ public static TransactionStatus currentTransactionStatus() throws NoTransactionException {     TransactionInfo info = currentTransactionInfo().     if (info == null || info.transactionStatus == null) {         throw new NoTransactionException("No transaction aspect-managed TransactionStatus in scope").     }     return info.transactionStatus. }
true;public;1;3;/**  * Specify the name of the default transaction manager bean.  */ ;/**  * Specify the name of the default transaction manager bean.  */ public void setTransactionManagerBeanName(@Nullable String transactionManagerBeanName) {     this.transactionManagerBeanName = transactionManagerBeanName. }
true;protected,final;0;4;/**  * Return the name of the default transaction manager bean.  */ ;/**  * Return the name of the default transaction manager bean.  */ @Nullable protected final String getTransactionManagerBeanName() {     return this.transactionManagerBeanName. }
true;public;1;3;/**  * Specify the <em>default</em> transaction manager to use to drive transactions.  * <p>The default transaction manager will be used if a <em>qualifier</em>  * has not been declared for a given transaction or if an explicit name for the  * default transaction manager bean has not been specified.  * @see #setTransactionManagerBeanName  */ ;/**  * Specify the <em>default</em> transaction manager to use to drive transactions.  * <p>The default transaction manager will be used if a <em>qualifier</em>  * has not been declared for a given transaction or if an explicit name for the  * default transaction manager bean has not been specified.  * @see #setTransactionManagerBeanName  */ public void setTransactionManager(@Nullable PlatformTransactionManager transactionManager) {     this.transactionManager = transactionManager. }
true;public;0;4;/**  * Return the default transaction manager, or {@code null} if unknown.  */ ;/**  * Return the default transaction manager, or {@code null} if unknown.  */ @Nullable public PlatformTransactionManager getTransactionManager() {     return this.transactionManager. }
true;public;1;5;/**  * Set properties with method names as keys and transaction attribute  * descriptors (parsed via TransactionAttributeEditor) as values:  * e.g. key = "myMethod", value = "PROPAGATION_REQUIRED,readOnly".  * <p>Note: Method names are always applied to the target class,  * no matter if defined in an interface or the class itself.  * <p>Internally, a NameMatchTransactionAttributeSource will be  * created from the given properties.  * @see #setTransactionAttributeSource  * @see TransactionAttributeEditor  * @see NameMatchTransactionAttributeSource  */ ;/**  * Set properties with method names as keys and transaction attribute  * descriptors (parsed via TransactionAttributeEditor) as values:  * e.g. key = "myMethod", value = "PROPAGATION_REQUIRED,readOnly".  * <p>Note: Method names are always applied to the target class,  * no matter if defined in an interface or the class itself.  * <p>Internally, a NameMatchTransactionAttributeSource will be  * created from the given properties.  * @see #setTransactionAttributeSource  * @see TransactionAttributeEditor  * @see NameMatchTransactionAttributeSource  */ public void setTransactionAttributes(Properties transactionAttributes) {     NameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource().     tas.setProperties(transactionAttributes).     this.transactionAttributeSource = tas. }
true;public;1;3;/**  * Set multiple transaction attribute sources which are used to find transaction  * attributes. Will build a CompositeTransactionAttributeSource for the given sources.  * @see CompositeTransactionAttributeSource  * @see MethodMapTransactionAttributeSource  * @see NameMatchTransactionAttributeSource  * @see org.springframework.transaction.annotation.AnnotationTransactionAttributeSource  */ ;/**  * Set multiple transaction attribute sources which are used to find transaction  * attributes. Will build a CompositeTransactionAttributeSource for the given sources.  * @see CompositeTransactionAttributeSource  * @see MethodMapTransactionAttributeSource  * @see NameMatchTransactionAttributeSource  * @see org.springframework.transaction.annotation.AnnotationTransactionAttributeSource  */ public void setTransactionAttributeSources(TransactionAttributeSource... transactionAttributeSources) {     this.transactionAttributeSource = new CompositeTransactionAttributeSource(transactionAttributeSources). }
true;public;1;3;/**  * Set the transaction attribute source which is used to find transaction  * attributes. If specifying a String property value, a PropertyEditor  * will create a MethodMapTransactionAttributeSource from the value.  * @see TransactionAttributeSourceEditor  * @see MethodMapTransactionAttributeSource  * @see NameMatchTransactionAttributeSource  * @see org.springframework.transaction.annotation.AnnotationTransactionAttributeSource  */ ;/**  * Set the transaction attribute source which is used to find transaction  * attributes. If specifying a String property value, a PropertyEditor  * will create a MethodMapTransactionAttributeSource from the value.  * @see TransactionAttributeSourceEditor  * @see MethodMapTransactionAttributeSource  * @see NameMatchTransactionAttributeSource  * @see org.springframework.transaction.annotation.AnnotationTransactionAttributeSource  */ public void setTransactionAttributeSource(@Nullable TransactionAttributeSource transactionAttributeSource) {     this.transactionAttributeSource = transactionAttributeSource. }
true;public;0;4;/**  * Return the transaction attribute source.  */ ;/**  * Return the transaction attribute source.  */ @Nullable public TransactionAttributeSource getTransactionAttributeSource() {     return this.transactionAttributeSource. }
true;public;1;4;/**  * Set the BeanFactory to use for retrieving PlatformTransactionManager beans.  */ ;/**  * Set the BeanFactory to use for retrieving PlatformTransactionManager beans.  */ @Override public void setBeanFactory(@Nullable BeanFactory beanFactory) {     this.beanFactory = beanFactory. }
true;protected,final;0;4;/**  * Return the BeanFactory to use for retrieving PlatformTransactionManager beans.  */ ;/**  * Return the BeanFactory to use for retrieving PlatformTransactionManager beans.  */ @Nullable protected final BeanFactory getBeanFactory() {     return this.beanFactory. }
true;public;0;13;/**  * Check that required properties were set.  */ ;/**  * Check that required properties were set.  */ @Override public void afterPropertiesSet() {     if (getTransactionManager() == null && this.beanFactory == null) {         throw new IllegalStateException("Set the 'transactionManager' property or make sure to run within a BeanFactory " + "containing a PlatformTransactionManager bean!").     }     if (getTransactionAttributeSource() == null) {         throw new IllegalStateException("Either 'transactionAttributeSource' or 'transactionAttributes' is required: " + "If there are no transactional methods, then don't use a transaction aspect.").     } }
true;protected;3;101;/**  * General delegate for around-advice-based subclasses, delegating to several other template  * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager}  * as well as regular {@link PlatformTransactionManager} implementations.  * @param method the Method being invoked  * @param targetClass the target class that we're invoking the method on  * @param invocation the callback to use for proceeding with the target invocation  * @return the return value of the method, if any  * @throws Throwable propagated from the target invocation  */ ;/**  * General delegate for around-advice-based subclasses, delegating to several other template  * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager}  * as well as regular {@link PlatformTransactionManager} implementations.  * @param method the Method being invoked  * @param targetClass the target class that we're invoking the method on  * @param invocation the callback to use for proceeding with the target invocation  * @return the return value of the method, if any  * @throws Throwable propagated from the target invocation  */ @Nullable protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass, final InvocationCallback invocation) throws Throwable {     // If the transaction attribute is null, the method is non-transactional.     TransactionAttributeSource tas = getTransactionAttributeSource().     final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null).     final PlatformTransactionManager tm = determineTransactionManager(txAttr).     final String joinpointIdentification = methodIdentification(method, targetClass, txAttr).     if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {         // Standard transaction demarcation with getTransaction and commit/rollback calls.         TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification).         Object retVal.         try {             // This is an around advice: Invoke the next interceptor in the chain.             // This will normally result in a target object being invoked.             retVal = invocation.proceedWithInvocation().         } catch (Throwable ex) {             // target invocation exception             completeTransactionAfterThrowing(txInfo, ex).             throw ex.         } finally {             cleanupTransactionInfo(txInfo).         }         if (vavrPresent && VavrDelegate.isVavrTry(retVal)) {             // Set rollback-only in case of Vavr failure matching our rollback rules...             TransactionStatus status = txInfo.getTransactionStatus().             if (status != null && txAttr != null) {                 retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status).             }         }         commitTransactionAfterReturning(txInfo).         return retVal.     } else {         final ThrowableHolder throwableHolder = new ThrowableHolder().         // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.         try {             Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -> {                 TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status).                 try {                     Object retVal = invocation.proceedWithInvocation().                     if (vavrPresent && VavrDelegate.isVavrTry(retVal)) {                         // Set rollback-only in case of Vavr failure matching our rollback rules...                         retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status).                     }                     return retVal.                 } catch (Throwable ex) {                     if (txAttr.rollbackOn(ex)) {                         // A RuntimeException: will lead to a rollback.                         if (ex instanceof RuntimeException) {                             throw (RuntimeException) ex.                         } else {                             throw new ThrowableHolderException(ex).                         }                     } else {                         // A normal return value: will lead to a commit.                         throwableHolder.throwable = ex.                         return null.                     }                 } finally {                     cleanupTransactionInfo(txInfo).                 }             }).             // Check result state: It might indicate a Throwable to rethrow.             if (throwableHolder.throwable != null) {                 throw throwableHolder.throwable.             }             return result.         } catch (ThrowableHolderException ex) {             throw ex.getCause().         } catch (TransactionSystemException ex2) {             if (throwableHolder.throwable != null) {                 logger.error("Application exception overridden by commit exception", throwableHolder.throwable).                 ex2.initApplicationException(throwableHolder.throwable).             }             throw ex2.         } catch (Throwable ex2) {             if (throwableHolder.throwable != null) {                 logger.error("Application exception overridden by commit exception", throwableHolder.throwable).             }             throw ex2.         }     } }
true;protected;0;4;/**  * Clear the cache.  */ ;/**  * Clear the cache.  */ protected void clearTransactionManagerCache() {     this.transactionManagerCache.clear().     this.beanFactory = null. }
true;protected;1;27;/**  * Determine the specific transaction manager to use for the given transaction.  */ ;/**  * Determine the specific transaction manager to use for the given transaction.  */ @Nullable protected PlatformTransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr) {     // Do not attempt to lookup tx manager if no tx attributes are set     if (txAttr == null || this.beanFactory == null) {         return getTransactionManager().     }     String qualifier = txAttr.getQualifier().     if (StringUtils.hasText(qualifier)) {         return determineQualifiedTransactionManager(this.beanFactory, qualifier).     } else if (StringUtils.hasText(this.transactionManagerBeanName)) {         return determineQualifiedTransactionManager(this.beanFactory, this.transactionManagerBeanName).     } else {         PlatformTransactionManager defaultTransactionManager = getTransactionManager().         if (defaultTransactionManager == null) {             defaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY).             if (defaultTransactionManager == null) {                 defaultTransactionManager = this.beanFactory.getBean(PlatformTransactionManager.class).                 this.transactionManagerCache.putIfAbsent(DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager).             }         }         return defaultTransactionManager.     } }
false;private;2;9;;private PlatformTransactionManager determineQualifiedTransactionManager(BeanFactory beanFactory, String qualifier) {     PlatformTransactionManager txManager = this.transactionManagerCache.get(qualifier).     if (txManager == null) {         txManager = BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory, PlatformTransactionManager.class, qualifier).         this.transactionManagerCache.putIfAbsent(qualifier, txManager).     }     return txManager. }
false;private;3;14;;private String methodIdentification(Method method, @Nullable Class<?> targetClass, @Nullable TransactionAttribute txAttr) {     String methodIdentification = methodIdentification(method, targetClass).     if (methodIdentification == null) {         if (txAttr instanceof DefaultTransactionAttribute) {             methodIdentification = ((DefaultTransactionAttribute) txAttr).getDescriptor().         }         if (methodIdentification == null) {             methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass).         }     }     return methodIdentification. }
true;protected;2;4;/**  * Convenience method to return a String representation of this Method  * for use in logging. Can be overridden in subclasses to provide a  * different identifier for the given method.  * <p>The default implementation returns {@code null}, indicating the  * use of {@link DefaultTransactionAttribute#getDescriptor()} instead,  * ending up as {@link ClassUtils#getQualifiedMethodName(Method, Class)}.  * @param method the method we're interested in  * @param targetClass the class that the method is being invoked on  * @return a String representation identifying this method  * @see org.springframework.util.ClassUtils#getQualifiedMethodName  */ ;/**  * Convenience method to return a String representation of this Method  * for use in logging. Can be overridden in subclasses to provide a  * different identifier for the given method.  * <p>The default implementation returns {@code null}, indicating the  * use of {@link DefaultTransactionAttribute#getDescriptor()} instead,  * ending up as {@link ClassUtils#getQualifiedMethodName(Method, Class)}.  * @param method the method we're interested in  * @param targetClass the class that the method is being invoked on  * @return a String representation identifying this method  * @see org.springframework.util.ClassUtils#getQualifiedMethodName  */ @Nullable protected String methodIdentification(Method method, @Nullable Class<?> targetClass) {     return null. }
false;public;0;4;;@Override public String getName() {     return joinpointIdentification. }
true;protected;3;28;/**  * Create a transaction if necessary based on the given TransactionAttribute.  * <p>Allows callers to perform custom TransactionAttribute lookups through  * the TransactionAttributeSource.  * @param txAttr the TransactionAttribute (may be {@code null})  * @param joinpointIdentification the fully qualified method name  * (used for monitoring and logging purposes)  * @return a TransactionInfo object, whether or not a transaction was created.  * The {@code hasTransaction()} method on TransactionInfo can be used to  * tell if there was a transaction created.  * @see #getTransactionAttributeSource()  */ ;/**  * Create a transaction if necessary based on the given TransactionAttribute.  * <p>Allows callers to perform custom TransactionAttribute lookups through  * the TransactionAttributeSource.  * @param txAttr the TransactionAttribute (may be {@code null})  * @param joinpointIdentification the fully qualified method name  * (used for monitoring and logging purposes)  * @return a TransactionInfo object, whether or not a transaction was created.  * The {@code hasTransaction()} method on TransactionInfo can be used to  * tell if there was a transaction created.  * @see #getTransactionAttributeSource()  */ @SuppressWarnings("serial") protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm, @Nullable TransactionAttribute txAttr, final String joinpointIdentification) {     // If no name specified, apply method identification as transaction name.     if (txAttr != null && txAttr.getName() == null) {         txAttr = new DelegatingTransactionAttribute(txAttr) {              @Override             public String getName() {                 return joinpointIdentification.             }         }.     }     TransactionStatus status = null.     if (txAttr != null) {         if (tm != null) {             status = tm.getTransaction(txAttr).         } else {             if (logger.isDebugEnabled()) {                 logger.debug("Skipping transactional joinpoint [" + joinpointIdentification + "] because no transaction manager has been configured").             }         }     }     return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status). }
true;protected;4;28;/**  * Prepare a TransactionInfo for the given attribute and status object.  * @param txAttr the TransactionAttribute (may be {@code null})  * @param joinpointIdentification the fully qualified method name  * (used for monitoring and logging purposes)  * @param status the TransactionStatus for the current transaction  * @return the prepared TransactionInfo object  */ ;/**  * Prepare a TransactionInfo for the given attribute and status object.  * @param txAttr the TransactionAttribute (may be {@code null})  * @param joinpointIdentification the fully qualified method name  * (used for monitoring and logging purposes)  * @param status the TransactionStatus for the current transaction  * @return the prepared TransactionInfo object  */ protected TransactionInfo prepareTransactionInfo(@Nullable PlatformTransactionManager tm, @Nullable TransactionAttribute txAttr, String joinpointIdentification, @Nullable TransactionStatus status) {     TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification).     if (txAttr != null) {         // We need a transaction for this method...         if (logger.isTraceEnabled()) {             logger.trace("Getting transaction for [" + txInfo.getJoinpointIdentification() + "]").         }         // The transaction manager will flag an error if an incompatible tx already exists.         txInfo.newTransactionStatus(status).     } else {         // to preserve the integrity of the ThreadLocal stack maintained in this class.         if (logger.isTraceEnabled()) {             logger.trace("Don't need to create transaction for [" + joinpointIdentification + "]: This method isn't transactional.").         }     }     // We always bind the TransactionInfo to the thread, even if we didn't create     // a new transaction here. This guarantees that the TransactionInfo stack     // will be managed correctly even if no transaction was created by this aspect.     txInfo.bindToThread().     return txInfo. }
true;protected;1;8;/**  * Execute after successful completion of call, but not after an exception was handled.  * Do nothing if we didn't create a transaction.  * @param txInfo information about the current transaction  */ ;/**  * Execute after successful completion of call, but not after an exception was handled.  * Do nothing if we didn't create a transaction.  * @param txInfo information about the current transaction  */ protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {     if (txInfo != null && txInfo.getTransactionStatus() != null) {         if (logger.isTraceEnabled()) {             logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() + "]").         }         txInfo.getTransactionManager().commit(txInfo.getTransactionStatus()).     } }
true;protected;2;38;/**  * Handle a throwable, completing the transaction.  * We may commit or roll back, depending on the configuration.  * @param txInfo information about the current transaction  * @param ex throwable encountered  */ ;/**  * Handle a throwable, completing the transaction.  * We may commit or roll back, depending on the configuration.  * @param txInfo information about the current transaction  * @param ex throwable encountered  */ protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {     if (txInfo != null && txInfo.getTransactionStatus() != null) {         if (logger.isTraceEnabled()) {             logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() + "] after exception: " + ex).         }         if (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) {             try {                 txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus()).             } catch (TransactionSystemException ex2) {                 logger.error("Application exception overridden by rollback exception", ex).                 ex2.initApplicationException(ex).                 throw ex2.             } catch (RuntimeException | Error ex2) {                 logger.error("Application exception overridden by rollback exception", ex).                 throw ex2.             }         } else {             // Will still roll back if TransactionStatus.isRollbackOnly() is true.             try {                 txInfo.getTransactionManager().commit(txInfo.getTransactionStatus()).             } catch (TransactionSystemException ex2) {                 logger.error("Application exception overridden by commit exception", ex).                 ex2.initApplicationException(ex).                 throw ex2.             } catch (RuntimeException | Error ex2) {                 logger.error("Application exception overridden by commit exception", ex).                 throw ex2.             }         }     } }
true;protected;1;5;/**  * Reset the TransactionInfo ThreadLocal.  * <p>Call this in all cases: exception or normal return!  * @param txInfo information about the current transaction (may be {@code null})  */ ;/**  * Reset the TransactionInfo ThreadLocal.  * <p>Call this in all cases: exception or normal return!  * @param txInfo information about the current transaction (may be {@code null})  */ protected void cleanupTransactionInfo(@Nullable TransactionInfo txInfo) {     if (txInfo != null) {         txInfo.restoreThreadLocalStatus().     } }
false;public;0;4;;public PlatformTransactionManager getTransactionManager() {     Assert.state(this.transactionManager != null, "No PlatformTransactionManager set").     return this.transactionManager. }
false;public;0;4;;@Nullable public TransactionAttribute getTransactionAttribute() {     return this.transactionAttribute. }
true;public;0;3;/**  * Return a String representation of this joinpoint (usually a Method call)  * for use in logging.  */ ;/**  * Return a String representation of this joinpoint (usually a Method call)  * for use in logging.  */ public String getJoinpointIdentification() {     return this.joinpointIdentification. }
false;public;1;3;;public void newTransactionStatus(@Nullable TransactionStatus status) {     this.transactionStatus = status. }
false;public;0;4;;@Nullable public TransactionStatus getTransactionStatus() {     return this.transactionStatus. }
true;public;0;3;/**  * Return whether a transaction was created by this aspect,  * or whether we just have a placeholder to keep ThreadLocal stack integrity.  */ ;/**  * Return whether a transaction was created by this aspect,  * or whether we just have a placeholder to keep ThreadLocal stack integrity.  */ public boolean hasTransaction() {     return (this.transactionStatus != null). }
false;private;0;6;;private void bindToThread() {     // Expose current TransactionStatus, preserving any existing TransactionStatus     // for restoration after this transaction is complete.     this.oldTransactionInfo = transactionInfoHolder.get().     transactionInfoHolder.set(this). }
false;private;0;5;;private void restoreThreadLocalStatus() {     // Use stack to restore old transaction TransactionInfo.     // Will be null if none was set.     transactionInfoHolder.set(this.oldTransactionInfo). }
false;public;0;4;;@Override public String toString() {     return (this.transactionAttribute != null ? this.transactionAttribute.toString() : "No transaction"). }
false;;0;1;;Object proceedWithInvocation() throws Throwable.
false;public;0;4;;@Override public String toString() {     return getCause().toString(). }
false;public,static;1;3;;public static boolean isVavrTry(Object retVal) {     return (retVal instanceof Try). }
false;public,static;3;7;;public static Object evaluateTryFailure(Object retVal, TransactionAttribute txAttr, TransactionStatus status) {     return ((Try<?>) retVal).onFailure(ex -> {         if (txAttr.rollbackOn(ex)) {             status.setRollbackOnly().         }     }). }
