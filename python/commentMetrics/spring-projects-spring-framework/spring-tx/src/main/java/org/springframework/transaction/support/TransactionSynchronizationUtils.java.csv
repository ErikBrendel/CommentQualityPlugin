commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Check whether the given resource transaction managers refers to the given  * (underlying) resource factory.  * @see ResourceTransactionManager#getResourceFactory()  * @see org.springframework.core.InfrastructureProxy#getWrappedObject()  */ ;/**  * Check whether the given resource transaction managers refers to the given  * (underlying) resource factory.  * @see ResourceTransactionManager#getResourceFactory()  * @see org.springframework.core.InfrastructureProxy#getWrappedObject()  */ public static boolean sameResourceFactory(ResourceTransactionManager tm, Object resourceFactory) {     return unwrapResourceIfNecessary(tm.getResourceFactory()).equals(unwrapResourceIfNecessary(resourceFactory)). }
true;static;1;13;/**  * Unwrap the given resource handle if necessary. otherwise return  * the given handle as-is.  * @see org.springframework.core.InfrastructureProxy#getWrappedObject()  */ ;/**  * Unwrap the given resource handle if necessary. otherwise return  * the given handle as-is.  * @see org.springframework.core.InfrastructureProxy#getWrappedObject()  */ static Object unwrapResourceIfNecessary(Object resource) {     Assert.notNull(resource, "Resource must not be null").     Object resourceRef = resource.     // unwrap infrastructure proxy     if (resourceRef instanceof InfrastructureProxy) {         resourceRef = ((InfrastructureProxy) resourceRef).getWrappedObject().     }     if (aopAvailable) {         // now unwrap scoped proxy         resourceRef = ScopedProxyUnwrapper.unwrapIfNecessary(resourceRef).     }     return resourceRef. }
true;public,static;0;5;/**  * Trigger {@code flush} callbacks on all currently registered synchronizations.  * @throws RuntimeException if thrown by a {@code flush} callback  * @see TransactionSynchronization#flush()  */ ;/**  * Trigger {@code flush} callbacks on all currently registered synchronizations.  * @throws RuntimeException if thrown by a {@code flush} callback  * @see TransactionSynchronization#flush()  */ public static void triggerFlush() {     for (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) {         synchronization.flush().     } }
true;public,static;1;5;/**  * Trigger {@code beforeCommit} callbacks on all currently registered synchronizations.  * @param readOnly whether the transaction is defined as read-only transaction  * @throws RuntimeException if thrown by a {@code beforeCommit} callback  * @see TransactionSynchronization#beforeCommit(boolean)  */ ;/**  * Trigger {@code beforeCommit} callbacks on all currently registered synchronizations.  * @param readOnly whether the transaction is defined as read-only transaction  * @throws RuntimeException if thrown by a {@code beforeCommit} callback  * @see TransactionSynchronization#beforeCommit(boolean)  */ public static void triggerBeforeCommit(boolean readOnly) {     for (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) {         synchronization.beforeCommit(readOnly).     } }
true;public,static;0;10;/**  * Trigger {@code beforeCompletion} callbacks on all currently registered synchronizations.  * @see TransactionSynchronization#beforeCompletion()  */ ;/**  * Trigger {@code beforeCompletion} callbacks on all currently registered synchronizations.  * @see TransactionSynchronization#beforeCompletion()  */ public static void triggerBeforeCompletion() {     for (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) {         try {             synchronization.beforeCompletion().         } catch (Throwable tsex) {             logger.error("TransactionSynchronization.beforeCompletion threw exception", tsex).         }     } }
true;public,static;0;3;/**  * Trigger {@code afterCommit} callbacks on all currently registered synchronizations.  * @throws RuntimeException if thrown by a {@code afterCommit} callback  * @see TransactionSynchronizationManager#getSynchronizations()  * @see TransactionSynchronization#afterCommit()  */ ;/**  * Trigger {@code afterCommit} callbacks on all currently registered synchronizations.  * @throws RuntimeException if thrown by a {@code afterCommit} callback  * @see TransactionSynchronizationManager#getSynchronizations()  * @see TransactionSynchronization#afterCommit()  */ public static void triggerAfterCommit() {     invokeAfterCommit(TransactionSynchronizationManager.getSynchronizations()). }
true;public,static;1;7;/**  * Actually invoke the {@code afterCommit} methods of the  * given Spring TransactionSynchronization objects.  * @param synchronizations a List of TransactionSynchronization objects  * @see TransactionSynchronization#afterCommit()  */ ;/**  * Actually invoke the {@code afterCommit} methods of the  * given Spring TransactionSynchronization objects.  * @param synchronizations a List of TransactionSynchronization objects  * @see TransactionSynchronization#afterCommit()  */ public static void invokeAfterCommit(@Nullable List<TransactionSynchronization> synchronizations) {     if (synchronizations != null) {         for (TransactionSynchronization synchronization : synchronizations) {             synchronization.afterCommit().         }     } }
true;public,static;1;4;/**  * Trigger {@code afterCompletion} callbacks on all currently registered synchronizations.  * @param completionStatus the completion status according to the  * constants in the TransactionSynchronization interface  * @see TransactionSynchronizationManager#getSynchronizations()  * @see TransactionSynchronization#afterCompletion(int)  * @see TransactionSynchronization#STATUS_COMMITTED  * @see TransactionSynchronization#STATUS_ROLLED_BACK  * @see TransactionSynchronization#STATUS_UNKNOWN  */ ;/**  * Trigger {@code afterCompletion} callbacks on all currently registered synchronizations.  * @param completionStatus the completion status according to the  * constants in the TransactionSynchronization interface  * @see TransactionSynchronizationManager#getSynchronizations()  * @see TransactionSynchronization#afterCompletion(int)  * @see TransactionSynchronization#STATUS_COMMITTED  * @see TransactionSynchronization#STATUS_ROLLED_BACK  * @see TransactionSynchronization#STATUS_UNKNOWN  */ public static void triggerAfterCompletion(int completionStatus) {     List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations().     invokeAfterCompletion(synchronizations, completionStatus). }
true;public,static;2;14;/**  * Actually invoke the {@code afterCompletion} methods of the  * given Spring TransactionSynchronization objects.  * @param synchronizations a List of TransactionSynchronization objects  * @param completionStatus the completion status according to the  * constants in the TransactionSynchronization interface  * @see TransactionSynchronization#afterCompletion(int)  * @see TransactionSynchronization#STATUS_COMMITTED  * @see TransactionSynchronization#STATUS_ROLLED_BACK  * @see TransactionSynchronization#STATUS_UNKNOWN  */ ;/**  * Actually invoke the {@code afterCompletion} methods of the  * given Spring TransactionSynchronization objects.  * @param synchronizations a List of TransactionSynchronization objects  * @param completionStatus the completion status according to the  * constants in the TransactionSynchronization interface  * @see TransactionSynchronization#afterCompletion(int)  * @see TransactionSynchronization#STATUS_COMMITTED  * @see TransactionSynchronization#STATUS_ROLLED_BACK  * @see TransactionSynchronization#STATUS_UNKNOWN  */ public static void invokeAfterCompletion(@Nullable List<TransactionSynchronization> synchronizations, int completionStatus) {     if (synchronizations != null) {         for (TransactionSynchronization synchronization : synchronizations) {             try {                 synchronization.afterCompletion(completionStatus).             } catch (Throwable tsex) {                 logger.error("TransactionSynchronization.afterCompletion threw exception", tsex).             }         }     } }
false;public,static;1;8;;public static Object unwrapIfNecessary(Object resource) {     if (resource instanceof ScopedObject) {         return ((ScopedObject) resource).getTargetObject().     } else {         return resource.     } }
