commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the default {@link CacheManager} to use to lookup cache by name.  * Only mandatory if the {@linkplain CacheResolver cache resolver} has not been set.  */ ;/**  * Set the default {@link CacheManager} to use to lookup cache by name.  * Only mandatory if the {@linkplain CacheResolver cache resolver} has not been set.  */ public void setCacheManager(@Nullable CacheManager cacheManager) {     this.cacheManager = SingletonSupplier.ofNullable(cacheManager). }
true;public;0;4;/**  * Return the specified cache manager to use, if any.  */ ;/**  * Return the specified cache manager to use, if any.  */ @Nullable public CacheManager getCacheManager() {     return SupplierUtils.resolve(this.cacheManager). }
true;public;1;3;/**  * Set the {@link CacheResolver} to resolve regular caches. If none is set, a default  * implementation using the specified cache manager will be used.  */ ;/**  * Set the {@link CacheResolver} to resolve regular caches. If none is set, a default  * implementation using the specified cache manager will be used.  */ public void setCacheResolver(@Nullable CacheResolver cacheResolver) {     this.cacheResolver = SingletonSupplier.ofNullable(cacheResolver). }
true;public;0;4;/**  * Return the specified cache resolver to use, if any.  */ ;/**  * Return the specified cache resolver to use, if any.  */ @Nullable public CacheResolver getCacheResolver() {     return SupplierUtils.resolve(this.cacheResolver). }
true;public;1;3;/**  * Set the {@link CacheResolver} to resolve exception caches. If none is set, a default  * implementation using the specified cache manager will be used.  */ ;/**  * Set the {@link CacheResolver} to resolve exception caches. If none is set, a default  * implementation using the specified cache manager will be used.  */ public void setExceptionCacheResolver(@Nullable CacheResolver exceptionCacheResolver) {     this.exceptionCacheResolver = SingletonSupplier.ofNullable(exceptionCacheResolver). }
true;public;0;4;/**  * Return the specified exception cache resolver to use, if any.  */ ;/**  * Return the specified exception cache resolver to use, if any.  */ @Nullable public CacheResolver getExceptionCacheResolver() {     return SupplierUtils.resolve(this.exceptionCacheResolver). }
true;public;1;3;/**  * Set the default {@link KeyGenerator}. If none is set, a {@link SimpleKeyGenerator}  * honoring the JSR-107 {@link javax.cache.annotation.CacheKey} and  * {@link javax.cache.annotation.CacheValue} will be used.  */ ;/**  * Set the default {@link KeyGenerator}. If none is set, a {@link SimpleKeyGenerator}  * honoring the JSR-107 {@link javax.cache.annotation.CacheKey} and  * {@link javax.cache.annotation.CacheValue} will be used.  */ public void setKeyGenerator(KeyGenerator keyGenerator) {     this.keyGenerator = SingletonSupplier.of(keyGenerator). }
true;public;0;3;/**  * Return the specified key generator to use.  */ ;/**  * Return the specified key generator to use.  */ public KeyGenerator getKeyGenerator() {     return this.keyGenerator.obtain(). }
false;public;1;4;;@Override public void setBeanFactory(BeanFactory beanFactory) {     this.beanFactory = beanFactory. }
false;public;0;6;;@Override public void afterSingletonsInstantiated() {     // Make sure that the cache resolver is initialized. An exception cache resolver is only     // required if the exceptionCacheName attribute is set on an operation.     Assert.notNull(getDefaultCacheResolver(), "Cache resolver should have been initialized"). }
false;protected;1;17;;@Override protected <T> T getBean(Class<T> type) {     Assert.state(this.beanFactory != null, () -> "BeanFactory required for resolution of [" + type + "]").     try {         return this.beanFactory.getBean(type).     } catch (NoUniqueBeanDefinitionException ex) {         throw new IllegalStateException("No unique [" + type.getName() + "] bean found in application context - " + "mark one as primary, or declare a more specific implementation type for your cache", ex).     } catch (NoSuchBeanDefinitionException ex) {         if (logger.isDebugEnabled()) {             logger.debug("No bean of type [" + type.getName() + "] found in application context", ex).         }         return BeanUtils.instantiateClass(type).     } }
false;protected;0;17;;protected CacheManager getDefaultCacheManager() {     if (getCacheManager() == null) {         Assert.state(this.beanFactory != null, "BeanFactory required for default CacheManager resolution").         try {             this.cacheManager = SingletonSupplier.of(this.beanFactory.getBean(CacheManager.class)).         } catch (NoUniqueBeanDefinitionException ex) {             throw new IllegalStateException("No unique bean of type CacheManager found. " + "Mark one as primary or declare a specific CacheManager to use.").         } catch (NoSuchBeanDefinitionException ex) {             throw new IllegalStateException("No bean of type CacheManager found. Register a CacheManager " + "bean or remove the @EnableCaching annotation from your configuration.").         }     }     return getCacheManager(). }
false;protected;0;7;;@Override protected CacheResolver getDefaultCacheResolver() {     if (getCacheResolver() == null) {         this.cacheResolver = SingletonSupplier.of(new SimpleCacheResolver(getDefaultCacheManager())).     }     return getCacheResolver(). }
false;protected;0;7;;@Override protected CacheResolver getDefaultExceptionCacheResolver() {     if (getExceptionCacheResolver() == null) {         this.exceptionCacheResolver = SingletonSupplier.of(new LazyCacheResolver()).     }     return getExceptionCacheResolver(). }
false;protected;0;4;;@Override protected KeyGenerator getDefaultKeyGenerator() {     return this.adaptedKeyGenerator.obtain(). }
false;public;1;4;;@Override public Collection<? extends Cache> resolveCaches(CacheOperationInvocationContext<?> context) {     return this.cacheResolver.obtain().resolveCaches(context). }
