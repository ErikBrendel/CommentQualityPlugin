commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public Connection getConnection() throws SQLException {     // Return a transactional Connection, if any.     return DataSourceUtils.doGetConnection(dataSource). }
false;public;0;4;;@Override public void shutdown() { // Do nothing - a Spring-managed DataSource has its own lifecycle. }
true;public;0;3;/* Quartz 2.2 initialize method */ ;/* Quartz 2.2 initialize method */ public void initialize() { // Do nothing - a Spring-managed DataSource has its own lifecycle. }
false;public;0;5;;@Override public Connection getConnection() throws SQLException {     // Always return a non-transactional Connection.     return nonTxDataSourceToUse.getConnection(). }
false;public;0;4;;@Override public void shutdown() { // Do nothing - a Spring-managed DataSource has its own lifecycle. }
true;public;0;3;/* Quartz 2.2 initialize method */ ;/* Quartz 2.2 initialize method */ public void initialize() { // Do nothing - a Spring-managed DataSource has its own lifecycle. }
false;public;2;77;;@Override public void initialize(ClassLoadHelper loadHelper, SchedulerSignaler signaler) throws SchedulerConfigException {     // Absolutely needs thread-bound DataSource to initialize.     this.dataSource = SchedulerFactoryBean.getConfigTimeDataSource().     if (this.dataSource == null) {         throw new SchedulerConfigException("No local DataSource found for configuration - " + "'dataSource' property must be set on SchedulerFactoryBean").     }     // Configure transactional connection settings for Quartz.     setDataSource(TX_DATA_SOURCE_PREFIX + getInstanceName()).     setDontSetAutoCommitFalse(true).     // Register transactional ConnectionProvider for Quartz.     DBConnectionManager.getInstance().addConnectionProvider(TX_DATA_SOURCE_PREFIX + getInstanceName(), new ConnectionProvider() {          @Override         public Connection getConnection() throws SQLException {             // Return a transactional Connection, if any.             return DataSourceUtils.doGetConnection(dataSource).         }          @Override         public void shutdown() {         // Do nothing - a Spring-managed DataSource has its own lifecycle.         }          /* Quartz 2.2 initialize method */         public void initialize() {         // Do nothing - a Spring-managed DataSource has its own lifecycle.         }     }).     // Non-transactional DataSource is optional: fall back to default     // DataSource if not explicitly specified.     DataSource nonTxDataSource = SchedulerFactoryBean.getConfigTimeNonTransactionalDataSource().     final DataSource nonTxDataSourceToUse = (nonTxDataSource != null ? nonTxDataSource : this.dataSource).     // Configure non-transactional connection settings for Quartz.     setNonManagedTXDataSource(NON_TX_DATA_SOURCE_PREFIX + getInstanceName()).     // Register non-transactional ConnectionProvider for Quartz.     DBConnectionManager.getInstance().addConnectionProvider(NON_TX_DATA_SOURCE_PREFIX + getInstanceName(), new ConnectionProvider() {          @Override         public Connection getConnection() throws SQLException {             // Always return a non-transactional Connection.             return nonTxDataSourceToUse.getConnection().         }          @Override         public void shutdown() {         // Do nothing - a Spring-managed DataSource has its own lifecycle.         }          /* Quartz 2.2 initialize method */         public void initialize() {         // Do nothing - a Spring-managed DataSource has its own lifecycle.         }     }).     // No, if HSQL is the platform, we really don't want to use locks...     try {         String productName = JdbcUtils.extractDatabaseMetaData(this.dataSource, "getDatabaseProductName").         productName = JdbcUtils.commonDatabaseName(productName).         if (productName != null && productName.toLowerCase().contains("hsql")) {             setUseDBLocks(false).             setLockHandler(new SimpleSemaphore()).         }     } catch (MetaDataAccessException ex) {         logWarnIfNonZero(1, "Could not detect database type. Assuming locks can be taken.").     }     super.initialize(loadHelper, signaler). }
false;protected;1;5;;@Override protected void closeConnection(Connection con) {     // Will work for transactional and non-transactional connections.     DataSourceUtils.releaseConnection(con, this.dataSource). }
