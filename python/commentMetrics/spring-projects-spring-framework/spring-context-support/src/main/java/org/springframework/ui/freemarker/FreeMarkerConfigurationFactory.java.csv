commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the location of the FreeMarker config file.  * Alternatively, you can specify all setting locally.  * @see #setFreemarkerSettings  * @see #setTemplateLoaderPath  */ ;/**  * Set the location of the FreeMarker config file.  * Alternatively, you can specify all setting locally.  * @see #setFreemarkerSettings  * @see #setTemplateLoaderPath  */ public void setConfigLocation(Resource resource) {     this.configLocation = resource. }
true;public;1;3;/**  * Set properties that contain well-known FreeMarker keys which will be  * passed to FreeMarker's {@code Configuration.setSettings} method.  * @see freemarker.template.Configuration#setSettings  */ ;/**  * Set properties that contain well-known FreeMarker keys which will be  * passed to FreeMarker's {@code Configuration.setSettings} method.  * @see freemarker.template.Configuration#setSettings  */ public void setFreemarkerSettings(Properties settings) {     this.freemarkerSettings = settings. }
true;public;1;3;/**  * Set a Map that contains well-known FreeMarker objects which will be passed  * to FreeMarker's {@code Configuration.setAllSharedVariables()} method.  * @see freemarker.template.Configuration#setAllSharedVariables  */ ;/**  * Set a Map that contains well-known FreeMarker objects which will be passed  * to FreeMarker's {@code Configuration.setAllSharedVariables()} method.  * @see freemarker.template.Configuration#setAllSharedVariables  */ public void setFreemarkerVariables(Map<String, Object> variables) {     this.freemarkerVariables = variables. }
true;public;1;3;/**  * Set the default encoding for the FreeMarker configuration.  * If not specified, FreeMarker will use the platform file encoding.  * <p>Used for template rendering unless there is an explicit encoding specified  * for the rendering process (for example, on Spring's FreeMarkerView).  * @see freemarker.template.Configuration#setDefaultEncoding  * @see org.springframework.web.servlet.view.freemarker.FreeMarkerView#setEncoding  */ ;/**  * Set the default encoding for the FreeMarker configuration.  * If not specified, FreeMarker will use the platform file encoding.  * <p>Used for template rendering unless there is an explicit encoding specified  * for the rendering process (for example, on Spring's FreeMarkerView).  * @see freemarker.template.Configuration#setDefaultEncoding  * @see org.springframework.web.servlet.view.freemarker.FreeMarkerView#setEncoding  */ public void setDefaultEncoding(String defaultEncoding) {     this.defaultEncoding = defaultEncoding. }
true;public;1;3;/**  * Set a List of {@code TemplateLoader}s that will be used to search  * for templates. For example, one or more custom loaders such as database  * loaders could be configured and injected here.  * <p>The {@link TemplateLoader TemplateLoaders} specified here will be  * registered <i>before</i> the default template loaders that this factory  * registers (such as loaders for specified "templateLoaderPaths" or any  * loaders registered in {@link #postProcessTemplateLoaders}).  * @see #setTemplateLoaderPaths  * @see #postProcessTemplateLoaders  */ ;/**  * Set a List of {@code TemplateLoader}s that will be used to search  * for templates. For example, one or more custom loaders such as database  * loaders could be configured and injected here.  * <p>The {@link TemplateLoader TemplateLoaders} specified here will be  * registered <i>before</i> the default template loaders that this factory  * registers (such as loaders for specified "templateLoaderPaths" or any  * loaders registered in {@link #postProcessTemplateLoaders}).  * @see #setTemplateLoaderPaths  * @see #postProcessTemplateLoaders  */ public void setPreTemplateLoaders(TemplateLoader... preTemplateLoaders) {     this.preTemplateLoaders = Arrays.asList(preTemplateLoaders). }
true;public;1;3;/**  * Set a List of {@code TemplateLoader}s that will be used to search  * for templates. For example, one or more custom loaders such as database  * loaders can be configured.  * <p>The {@link TemplateLoader TemplateLoaders} specified here will be  * registered <i>after</i> the default template loaders that this factory  * registers (such as loaders for specified "templateLoaderPaths" or any  * loaders registered in {@link #postProcessTemplateLoaders}).  * @see #setTemplateLoaderPaths  * @see #postProcessTemplateLoaders  */ ;/**  * Set a List of {@code TemplateLoader}s that will be used to search  * for templates. For example, one or more custom loaders such as database  * loaders can be configured.  * <p>The {@link TemplateLoader TemplateLoaders} specified here will be  * registered <i>after</i> the default template loaders that this factory  * registers (such as loaders for specified "templateLoaderPaths" or any  * loaders registered in {@link #postProcessTemplateLoaders}).  * @see #setTemplateLoaderPaths  * @see #postProcessTemplateLoaders  */ public void setPostTemplateLoaders(TemplateLoader... postTemplateLoaders) {     this.postTemplateLoaders = Arrays.asList(postTemplateLoaders). }
true;public;1;3;/**  * Set the Freemarker template loader path via a Spring resource location.  * See the "templateLoaderPaths" property for details on path handling.  * @see #setTemplateLoaderPaths  */ ;/**  * Set the Freemarker template loader path via a Spring resource location.  * See the "templateLoaderPaths" property for details on path handling.  * @see #setTemplateLoaderPaths  */ public void setTemplateLoaderPath(String templateLoaderPath) {     this.templateLoaderPaths = new String[] { templateLoaderPath }. }
true;public;1;3;/**  * Set multiple Freemarker template loader paths via Spring resource locations.  * <p>When populated via a String, standard URLs like "file:" and "classpath:"  * pseudo URLs are supported, as understood by ResourceEditor. Allows for  * relative paths when running in an ApplicationContext.  * <p>Will define a path for the default FreeMarker template loader.  * If a specified resource cannot be resolved to a {@code java.io.File},  * a generic SpringTemplateLoader will be used, without modification detection.  * <p>To enforce the use of SpringTemplateLoader, i.e. to not resolve a path  * as file system resource in any case, turn off the "preferFileSystemAccess"  * flag. See the latter's javadoc for details.  * <p>If you wish to specify your own list of TemplateLoaders, do not set this  * property and instead use {@code setTemplateLoaders(List templateLoaders)}  * @see org.springframework.core.io.ResourceEditor  * @see org.springframework.context.ApplicationContext#getResource  * @see freemarker.template.Configuration#setDirectoryForTemplateLoading  * @see SpringTemplateLoader  */ ;/**  * Set multiple Freemarker template loader paths via Spring resource locations.  * <p>When populated via a String, standard URLs like "file:" and "classpath:"  * pseudo URLs are supported, as understood by ResourceEditor. Allows for  * relative paths when running in an ApplicationContext.  * <p>Will define a path for the default FreeMarker template loader.  * If a specified resource cannot be resolved to a {@code java.io.File},  * a generic SpringTemplateLoader will be used, without modification detection.  * <p>To enforce the use of SpringTemplateLoader, i.e. to not resolve a path  * as file system resource in any case, turn off the "preferFileSystemAccess"  * flag. See the latter's javadoc for details.  * <p>If you wish to specify your own list of TemplateLoaders, do not set this  * property and instead use {@code setTemplateLoaders(List templateLoaders)}  * @see org.springframework.core.io.ResourceEditor  * @see org.springframework.context.ApplicationContext#getResource  * @see freemarker.template.Configuration#setDirectoryForTemplateLoading  * @see SpringTemplateLoader  */ public void setTemplateLoaderPaths(String... templateLoaderPaths) {     this.templateLoaderPaths = templateLoaderPaths. }
true;public;1;3;/**  * Set the Spring ResourceLoader to use for loading FreeMarker template files.  * The default is DefaultResourceLoader. Will get overridden by the  * ApplicationContext if running in a context.  * @see org.springframework.core.io.DefaultResourceLoader  */ ;/**  * Set the Spring ResourceLoader to use for loading FreeMarker template files.  * The default is DefaultResourceLoader. Will get overridden by the  * ApplicationContext if running in a context.  * @see org.springframework.core.io.DefaultResourceLoader  */ public void setResourceLoader(ResourceLoader resourceLoader) {     this.resourceLoader = resourceLoader. }
true;protected;0;3;/**  * Return the Spring ResourceLoader to use for loading FreeMarker template files.  */ ;/**  * Return the Spring ResourceLoader to use for loading FreeMarker template files.  */ protected ResourceLoader getResourceLoader() {     return this.resourceLoader. }
true;public;1;3;/**  * Set whether to prefer file system access for template loading.  * File system access enables hot detection of template changes.  * <p>If this is enabled, FreeMarkerConfigurationFactory will try to resolve  * the specified "templateLoaderPath" as file system resource (which will work  * for expanded class path resources and ServletContext resources too).  * <p>Default is "true". Turn this off to always load via SpringTemplateLoader  * (i.e. as stream, without hot detection of template changes), which might  * be necessary if some of your templates reside in an expanded classes  * directory while others reside in jar files.  * @see #setTemplateLoaderPath  */ ;/**  * Set whether to prefer file system access for template loading.  * File system access enables hot detection of template changes.  * <p>If this is enabled, FreeMarkerConfigurationFactory will try to resolve  * the specified "templateLoaderPath" as file system resource (which will work  * for expanded class path resources and ServletContext resources too).  * <p>Default is "true". Turn this off to always load via SpringTemplateLoader  * (i.e. as stream, without hot detection of template changes), which might  * be necessary if some of your templates reside in an expanded classes  * directory while others reside in jar files.  * @see #setTemplateLoaderPath  */ public void setPreferFileSystemAccess(boolean preferFileSystemAccess) {     this.preferFileSystemAccess = preferFileSystemAccess. }
true;protected;0;3;/**  * Return whether to prefer file system access for template loading.  */ ;/**  * Return whether to prefer file system access for template loading.  */ protected boolean isPreferFileSystemAccess() {     return this.preferFileSystemAccess. }
true;public;0;59;/**  * Prepare the FreeMarker Configuration and return it.  * @return the FreeMarker Configuration object  * @throws IOException if the config file wasn't found  * @throws TemplateException on FreeMarker initialization failure  */ ;/**  * Prepare the FreeMarker Configuration and return it.  * @return the FreeMarker Configuration object  * @throws IOException if the config file wasn't found  * @throws TemplateException on FreeMarker initialization failure  */ public Configuration createConfiguration() throws IOException, TemplateException {     Configuration config = newConfiguration().     Properties props = new Properties().     // Load config file if specified.     if (this.configLocation != null) {         if (logger.isDebugEnabled()) {             logger.debug("Loading FreeMarker configuration from " + this.configLocation).         }         PropertiesLoaderUtils.fillProperties(props, this.configLocation).     }     // Merge local properties if specified.     if (this.freemarkerSettings != null) {         props.putAll(this.freemarkerSettings).     }     // setAllSharedVariables methods.     if (!props.isEmpty()) {         config.setSettings(props).     }     if (!CollectionUtils.isEmpty(this.freemarkerVariables)) {         config.setAllSharedVariables(new SimpleHash(this.freemarkerVariables, config.getObjectWrapper())).     }     if (this.defaultEncoding != null) {         config.setDefaultEncoding(this.defaultEncoding).     }     List<TemplateLoader> templateLoaders = new ArrayList<>(this.templateLoaders).     // Register template loaders that are supposed to kick in early.     if (this.preTemplateLoaders != null) {         templateLoaders.addAll(this.preTemplateLoaders).     }     // Register default template loaders.     if (this.templateLoaderPaths != null) {         for (String path : this.templateLoaderPaths) {             templateLoaders.add(getTemplateLoaderForPath(path)).         }     }     postProcessTemplateLoaders(templateLoaders).     // Register template loaders that are supposed to kick in late.     if (this.postTemplateLoaders != null) {         templateLoaders.addAll(this.postTemplateLoaders).     }     TemplateLoader loader = getAggregateTemplateLoader(templateLoaders).     if (loader != null) {         config.setTemplateLoader(loader).     }     postProcessConfiguration(config).     return config. }
true;protected;0;3;/**  * Return a new Configuration object. Subclasses can override this for custom  * initialization (e.g. specifying a FreeMarker compatibility level which is a  * new feature in FreeMarker 2.3.21), or for using a mock object for testing.  * <p>Called by {@code createConfiguration()}.  * @return the Configuration object  * @throws IOException if a config file wasn't found  * @throws TemplateException on FreeMarker initialization failure  * @see #createConfiguration()  */ ;/**  * Return a new Configuration object. Subclasses can override this for custom  * initialization (e.g. specifying a FreeMarker compatibility level which is a  * new feature in FreeMarker 2.3.21), or for using a mock object for testing.  * <p>Called by {@code createConfiguration()}.  * @return the Configuration object  * @throws IOException if a config file wasn't found  * @throws TemplateException on FreeMarker initialization failure  * @see #createConfiguration()  */ protected Configuration newConfiguration() throws IOException, TemplateException {     return new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS). }
true;protected;1;27;/**  * Determine a FreeMarker TemplateLoader for the given path.  * <p>Default implementation creates either a FileTemplateLoader or  * a SpringTemplateLoader.  * @param templateLoaderPath the path to load templates from  * @return an appropriate TemplateLoader  * @see freemarker.cache.FileTemplateLoader  * @see SpringTemplateLoader  */ ;/**  * Determine a FreeMarker TemplateLoader for the given path.  * <p>Default implementation creates either a FileTemplateLoader or  * a SpringTemplateLoader.  * @param templateLoaderPath the path to load templates from  * @return an appropriate TemplateLoader  * @see freemarker.cache.FileTemplateLoader  * @see SpringTemplateLoader  */ protected TemplateLoader getTemplateLoaderForPath(String templateLoaderPath) {     if (isPreferFileSystemAccess()) {         // (for hot detection of template changes, if possible).         try {             Resource path = getResourceLoader().getResource(templateLoaderPath).             // will fail if not resolvable in the file system             File file = path.getFile().             if (logger.isDebugEnabled()) {                 logger.debug("Template loader path [" + path + "] resolved to file path [" + file.getAbsolutePath() + "]").             }             return new FileTemplateLoader(file).         } catch (Exception ex) {             if (logger.isDebugEnabled()) {                 logger.debug("Cannot resolve template loader path [" + templateLoaderPath + "] to [java.io.File]: using SpringTemplateLoader as fallback", ex).             }             return new SpringTemplateLoader(getResourceLoader(), templateLoaderPath).         }     } else {         // Always load via SpringTemplateLoader (without hot detection of template changes).         logger.debug("File system access not preferred: using SpringTemplateLoader").         return new SpringTemplateLoader(getResourceLoader(), templateLoaderPath).     } }
true;protected;1;2;/**  * To be overridden by subclasses that want to register custom  * TemplateLoader instances after this factory created its default  * template loaders.  * <p>Called by {@code createConfiguration()}. Note that specified  * "postTemplateLoaders" will be registered <i>after</i> any loaders  * registered by this callback. as a consequence, they are <i>not</i>  * included in the given List.  * @param templateLoaders the current List of TemplateLoader instances,  * to be modified by a subclass  * @see #createConfiguration()  * @see #setPostTemplateLoaders  */ ;/**  * To be overridden by subclasses that want to register custom  * TemplateLoader instances after this factory created its default  * template loaders.  * <p>Called by {@code createConfiguration()}. Note that specified  * "postTemplateLoaders" will be registered <i>after</i> any loaders  * registered by this callback. as a consequence, they are <i>not</i>  * included in the given List.  * @param templateLoaders the current List of TemplateLoader instances,  * to be modified by a subclass  * @see #createConfiguration()  * @see #setPostTemplateLoaders  */ protected void postProcessTemplateLoaders(List<TemplateLoader> templateLoaders) { }
true;protected;1;13;/**  * Return a TemplateLoader based on the given TemplateLoader list.  * If more than one TemplateLoader has been registered, a FreeMarker  * MultiTemplateLoader needs to be created.  * @param templateLoaders the final List of TemplateLoader instances  * @return the aggregate TemplateLoader  */ ;/**  * Return a TemplateLoader based on the given TemplateLoader list.  * If more than one TemplateLoader has been registered, a FreeMarker  * MultiTemplateLoader needs to be created.  * @param templateLoaders the final List of TemplateLoader instances  * @return the aggregate TemplateLoader  */ @Nullable protected TemplateLoader getAggregateTemplateLoader(List<TemplateLoader> templateLoaders) {     switch(templateLoaders.size()) {         case 0:             logger.debug("No FreeMarker TemplateLoaders specified").             return null.         case 1:             return templateLoaders.get(0).         default:             TemplateLoader[] loaders = templateLoaders.toArray(new TemplateLoader[0]).             return new MultiTemplateLoader(loaders).     } }
true;protected;1;2;/**  * To be overridden by subclasses that want to perform custom  * post-processing of the Configuration object after this factory  * performed its default initialization.  * <p>Called by {@code createConfiguration()}.  * @param config the current Configuration object  * @throws IOException if a config file wasn't found  * @throws TemplateException on FreeMarker initialization failure  * @see #createConfiguration()  */ ;/**  * To be overridden by subclasses that want to perform custom  * post-processing of the Configuration object after this factory  * performed its default initialization.  * <p>Called by {@code createConfiguration()}.  * @param config the current Configuration object  * @throws IOException if a config file wasn't found  * @throws TemplateException on FreeMarker initialization failure  * @see #createConfiguration()  */ protected void postProcessConfiguration(Configuration config) throws IOException, TemplateException { }
