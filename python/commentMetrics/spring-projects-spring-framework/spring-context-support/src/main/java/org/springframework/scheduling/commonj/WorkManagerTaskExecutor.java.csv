commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify the CommonJ WorkManager to delegate to.  * <p>Alternatively, you can also specify the JNDI name of the target WorkManager.  * @see #setWorkManagerName  */ ;/**  * Specify the CommonJ WorkManager to delegate to.  * <p>Alternatively, you can also specify the JNDI name of the target WorkManager.  * @see #setWorkManagerName  */ public void setWorkManager(WorkManager workManager) {     this.workManager = workManager. }
true;public;1;3;/**  * Set the JNDI name of the CommonJ WorkManager.  * <p>This can either be a fully qualified JNDI name, or the JNDI name relative  * to the current environment naming context if "resourceRef" is set to "true".  * @see #setWorkManager  * @see #setResourceRef  */ ;/**  * Set the JNDI name of the CommonJ WorkManager.  * <p>This can either be a fully qualified JNDI name, or the JNDI name relative  * to the current environment naming context if "resourceRef" is set to "true".  * @see #setWorkManager  * @see #setResourceRef  */ public void setWorkManagerName(String workManagerName) {     this.workManagerName = workManagerName. }
true;public;1;3;/**  * Specify a CommonJ WorkListener to apply, if any.  * <p>This shared WorkListener instance will be passed on to the  * WorkManager by all {@link #execute} calls on this TaskExecutor.  */ ;/**  * Specify a CommonJ WorkListener to apply, if any.  * <p>This shared WorkListener instance will be passed on to the  * WorkManager by all {@link #execute} calls on this TaskExecutor.  */ public void setWorkListener(WorkListener workListener) {     this.workListener = workListener. }
true;public;1;3;/**  * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}  * about to be executed.  * <p>Note that such a decorator is not necessarily being applied to the  * user-supplied {@code Runnable}/{@code Callable} but rather to the actual  * execution callback (which may be a wrapper around the user-supplied task).  * <p>The primary use case is to set some execution context around the task's  * invocation, or to provide some monitoring/statistics for task execution.  * @since 4.3  */ ;/**  * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}  * about to be executed.  * <p>Note that such a decorator is not necessarily being applied to the  * user-supplied {@code Runnable}/{@code Callable} but rather to the actual  * execution callback (which may be a wrapper around the user-supplied task).  * <p>The primary use case is to set some execution context around the task's  * invocation, or to provide some monitoring/statistics for task execution.  * @since 4.3  */ public void setTaskDecorator(TaskDecorator taskDecorator) {     this.taskDecorator = taskDecorator. }
false;public;0;9;;@Override public void afterPropertiesSet() throws NamingException {     if (this.workManager == null) {         if (this.workManagerName == null) {             throw new IllegalArgumentException("Either 'workManager' or 'workManagerName' must be specified").         }         this.workManager = lookup(this.workManagerName, WorkManager.class).     } }
false;private;0;4;;private WorkManager obtainWorkManager() {     Assert.state(this.workManager != null, "No WorkManager specified").     return this.workManager. }
false;public;1;18;;// ------------------------------------------------------------------------- // Implementation of the Spring SchedulingTaskExecutor interface // ------------------------------------------------------------------------- @Override public void execute(Runnable task) {     Work work = new DelegatingWork(this.taskDecorator != null ? this.taskDecorator.decorate(task) : task).     try {         if (this.workListener != null) {             obtainWorkManager().schedule(work, this.workListener).         } else {             obtainWorkManager().schedule(work).         }     } catch (WorkRejectedException ex) {         throw new TaskRejectedException("CommonJ WorkManager did not accept task: " + task, ex).     } catch (WorkException ex) {         throw new SchedulingException("Could not schedule task on CommonJ WorkManager", ex).     } }
false;public;2;4;;@Override public void execute(Runnable task, long startTimeout) {     execute(task). }
false;public;1;6;;@Override public Future<?> submit(Runnable task) {     FutureTask<Object> future = new FutureTask<>(task, null).     execute(future).     return future. }
false;public;1;6;;@Override public <T> Future<T> submit(Callable<T> task) {     FutureTask<T> future = new FutureTask<>(task).     execute(future).     return future. }
false;public;1;6;;@Override public ListenableFuture<?> submitListenable(Runnable task) {     ListenableFutureTask<Object> future = new ListenableFutureTask<>(task, null).     execute(future).     return future. }
false;public;1;6;;@Override public <T> ListenableFuture<T> submitListenable(Callable<T> task) {     ListenableFutureTask<T> future = new ListenableFutureTask<>(task).     execute(future).     return future. }
false;public;1;4;;// ------------------------------------------------------------------------- // Implementation of the CommonJ WorkManager interface // ------------------------------------------------------------------------- @Override public WorkItem schedule(Work work) throws WorkException, IllegalArgumentException {     return obtainWorkManager().schedule(work). }
false;public;2;4;;@Override public WorkItem schedule(Work work, WorkListener workListener) throws WorkException {     return obtainWorkManager().schedule(work, workListener). }
false;public;2;5;;@Override @SuppressWarnings("rawtypes") public boolean waitForAll(Collection workItems, long timeout) throws InterruptedException {     return obtainWorkManager().waitForAll(workItems, timeout). }
false;public;2;5;;@Override @SuppressWarnings("rawtypes") public Collection waitForAny(Collection workItems, long timeout) throws InterruptedException {     return obtainWorkManager().waitForAny(workItems, timeout). }
