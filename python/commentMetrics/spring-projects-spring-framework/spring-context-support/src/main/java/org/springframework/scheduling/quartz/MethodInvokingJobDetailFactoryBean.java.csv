commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the name of the job.  * <p>Default is the bean name of this FactoryBean.  */ ;/**  * Set the name of the job.  * <p>Default is the bean name of this FactoryBean.  */ public void setName(String name) {     this.name = name. }
true;public;1;3;/**  * Set the group of the job.  * <p>Default is the default group of the Scheduler.  * @see org.quartz.Scheduler#DEFAULT_GROUP  */ ;/**  * Set the group of the job.  * <p>Default is the default group of the Scheduler.  * @see org.quartz.Scheduler#DEFAULT_GROUP  */ public void setGroup(String group) {     this.group = group. }
true;public;1;3;/**  * Specify whether or not multiple jobs should be run in a concurrent fashion.  * The behavior when one does not want concurrent jobs to be executed is  * realized through adding the {@code @PersistJobDataAfterExecution} and  * {@code @DisallowConcurrentExecution} markers.  * More information on stateful versus stateless jobs can be found  * <a href="http://www.quartz-scheduler.org/documentation/quartz-2.1.x/tutorials/tutorial-lesson-03">here</a>.  * <p>The default setting is to run jobs concurrently.  */ ;/**  * Specify whether or not multiple jobs should be run in a concurrent fashion.  * The behavior when one does not want concurrent jobs to be executed is  * realized through adding the {@code @PersistJobDataAfterExecution} and  * {@code @DisallowConcurrentExecution} markers.  * More information on stateful versus stateless jobs can be found  * <a href="http://www.quartz-scheduler.org/documentation/quartz-2.1.x/tutorials/tutorial-lesson-03">here</a>.  * <p>The default setting is to run jobs concurrently.  */ public void setConcurrent(boolean concurrent) {     this.concurrent = concurrent. }
true;public;1;3;/**  * Set the name of the target bean in the Spring BeanFactory.  * <p>This is an alternative to specifying {@link #setTargetObject "targetObject"},  * allowing for non-singleton beans to be invoked. Note that specified  * "targetObject" and {@link #setTargetClass "targetClass"} values will  * override the corresponding effect of this "targetBeanName" setting  * (i.e. statically pre-define the bean type or even the bean object).  */ ;/**  * Set the name of the target bean in the Spring BeanFactory.  * <p>This is an alternative to specifying {@link #setTargetObject "targetObject"},  * allowing for non-singleton beans to be invoked. Note that specified  * "targetObject" and {@link #setTargetClass "targetClass"} values will  * override the corresponding effect of this "targetBeanName" setting  * (i.e. statically pre-define the bean type or even the bean object).  */ public void setTargetBeanName(String targetBeanName) {     this.targetBeanName = targetBeanName. }
false;public;1;4;;@Override public void setBeanName(String beanName) {     this.beanName = beanName. }
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.beanClassLoader = classLoader. }
false;public;1;4;;@Override public void setBeanFactory(BeanFactory beanFactory) {     this.beanFactory = beanFactory. }
false;protected;1;4;;@Override protected Class<?> resolveClassName(String className) throws ClassNotFoundException {     return ClassUtils.forName(className, this.beanClassLoader). }
false;public;0;22;;@Override @SuppressWarnings("unchecked") public void afterPropertiesSet() throws ClassNotFoundException, NoSuchMethodException {     prepare().     // Use specific name if given, else fall back to bean name.     String name = (this.name != null ? this.name : this.beanName).     // Consider the concurrent flag to choose between stateful and stateless job.     Class<?> jobClass = (this.concurrent ? MethodInvokingJob.class : StatefulMethodInvokingJob.class).     // Build JobDetail instance.     JobDetailImpl jdi = new JobDetailImpl().     jdi.setName(name != null ? name : toString()).     jdi.setGroup(this.group).     jdi.setJobClass((Class) jobClass).     jdi.setDurability(true).     jdi.getJobDataMap().put("methodInvoker", this).     this.jobDetail = jdi.     postProcessJobDetail(this.jobDetail). }
true;protected;1;2;/**  * Callback for post-processing the JobDetail to be exposed by this FactoryBean.  * <p>The default implementation is empty. Can be overridden in subclasses.  * @param jobDetail the JobDetail prepared by this FactoryBean  */ ;/**  * Callback for post-processing the JobDetail to be exposed by this FactoryBean.  * <p>The default implementation is empty. Can be overridden in subclasses.  * @param jobDetail the JobDetail prepared by this FactoryBean  */ protected void postProcessJobDetail(JobDetail jobDetail) { }
true;public;0;9;/**  * Overridden to support the {@link #setTargetBeanName "targetBeanName"} feature.  */ ;/**  * Overridden to support the {@link #setTargetBeanName "targetBeanName"} feature.  */ @Override public Class<?> getTargetClass() {     Class<?> targetClass = super.getTargetClass().     if (targetClass == null && this.targetBeanName != null) {         Assert.state(this.beanFactory != null, "BeanFactory must be set when using 'targetBeanName'").         targetClass = this.beanFactory.getType(this.targetBeanName).     }     return targetClass. }
true;public;0;9;/**  * Overridden to support the {@link #setTargetBeanName "targetBeanName"} feature.  */ ;/**  * Overridden to support the {@link #setTargetBeanName "targetBeanName"} feature.  */ @Override public Object getTargetObject() {     Object targetObject = super.getTargetObject().     if (targetObject == null && this.targetBeanName != null) {         Assert.state(this.beanFactory != null, "BeanFactory must be set when using 'targetBeanName'").         targetObject = this.beanFactory.getBean(this.targetBeanName).     }     return targetObject. }
false;public;0;5;;@Override @Nullable public JobDetail getObject() {     return this.jobDetail. }
false;public;0;4;;@Override public Class<? extends JobDetail> getObjectType() {     return (this.jobDetail != null ? this.jobDetail.getClass() : JobDetail.class). }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
true;public;1;3;/**  * Set the MethodInvoker to use.  */ ;/**  * Set the MethodInvoker to use.  */ public void setMethodInvoker(MethodInvoker methodInvoker) {     this.methodInvoker = methodInvoker. }
true;protected;1;21;/**  * Invoke the method via the MethodInvoker.  */ ;/**  * Invoke the method via the MethodInvoker.  */ @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException {     Assert.state(this.methodInvoker != null, "No MethodInvoker set").     try {         context.setResult(this.methodInvoker.invoke()).     } catch (InvocationTargetException ex) {         if (ex.getTargetException() instanceof JobExecutionException) {             // -> JobExecutionException, to be logged at info level by Quartz             throw (JobExecutionException) ex.getTargetException().         } else {             // -> "unhandled exception", to be logged at error level by Quartz             throw new JobMethodInvocationFailedException(this.methodInvoker, ex.getTargetException()).         }     } catch (Exception ex) {         // -> "unhandled exception", to be logged at error level by Quartz         throw new JobMethodInvocationFailedException(this.methodInvoker, ex).     } }
