commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify the job's name.  */ ;/**  * Specify the job's name.  */ public void setName(String name) {     this.name = name. }
true;public;1;3;/**  * Specify the job's group.  */ ;/**  * Specify the job's group.  */ public void setGroup(String group) {     this.group = group. }
true;public;1;3;/**  * Specify the job's implementation class.  */ ;/**  * Specify the job's implementation class.  */ public void setJobClass(Class<? extends Job> jobClass) {     this.jobClass = jobClass. }
true;public;1;3;/**  * Set the job's JobDataMap.  * @see #setJobDataAsMap  */ ;/**  * Set the job's JobDataMap.  * @see #setJobDataAsMap  */ public void setJobDataMap(JobDataMap jobDataMap) {     this.jobDataMap = jobDataMap. }
true;public;0;3;/**  * Return the job's JobDataMap.  */ ;/**  * Return the job's JobDataMap.  */ public JobDataMap getJobDataMap() {     return this.jobDataMap. }
true;public;1;3;/**  * Register objects in the JobDataMap via a given Map.  * <p>These objects will be available to this Job only,  * in contrast to objects in the SchedulerContext.  * <p>Note: When using persistent Jobs whose JobDetail will be kept in the  * database, do not put Spring-managed beans or an ApplicationContext  * reference into the JobDataMap but rather into the SchedulerContext.  * @param jobDataAsMap a Map with String keys and any objects as values  * (for example Spring-managed beans)  * @see org.springframework.scheduling.quartz.SchedulerFactoryBean#setSchedulerContextAsMap  */ ;/**  * Register objects in the JobDataMap via a given Map.  * <p>These objects will be available to this Job only,  * in contrast to objects in the SchedulerContext.  * <p>Note: When using persistent Jobs whose JobDetail will be kept in the  * database, do not put Spring-managed beans or an ApplicationContext  * reference into the JobDataMap but rather into the SchedulerContext.  * @param jobDataAsMap a Map with String keys and any objects as values  * (for example Spring-managed beans)  * @see org.springframework.scheduling.quartz.SchedulerFactoryBean#setSchedulerContextAsMap  */ public void setJobDataAsMap(Map<String, ?> jobDataAsMap) {     getJobDataMap().putAll(jobDataAsMap). }
true;public;1;3;/**  * Specify the job's durability, i.e. whether it should remain stored  * in the job store even if no triggers point to it anymore.  */ ;/**  * Specify the job's durability, i.e. whether it should remain stored  * in the job store even if no triggers point to it anymore.  */ public void setDurability(boolean durability) {     this.durability = durability. }
true;public;1;3;/**  * Set the recovery flag for this job, i.e. whether or not the job should  * get re-executed if a 'recovery' or 'fail-over' situation is encountered.  */ ;/**  * Set the recovery flag for this job, i.e. whether or not the job should  * get re-executed if a 'recovery' or 'fail-over' situation is encountered.  */ public void setRequestsRecovery(boolean requestsRecovery) {     this.requestsRecovery = requestsRecovery. }
true;public;1;3;/**  * Set a textual description for this job.  */ ;/**  * Set a textual description for this job.  */ public void setDescription(String description) {     this.description = description. }
false;public;1;4;;@Override public void setBeanName(String beanName) {     this.beanName = beanName. }
false;public;1;4;;@Override public void setApplicationContext(ApplicationContext applicationContext) {     this.applicationContext = applicationContext. }
true;public;1;3;/**  * Set the key of an ApplicationContext reference to expose in the JobDataMap,  * for example "applicationContext". Default is none.  * Only applicable when running in a Spring ApplicationContext.  * <p>In case of a QuartzJobBean, the reference will be applied to the Job  * instance as bean property. An "applicationContext" attribute will correspond  * to a "setApplicationContext" method in that scenario.  * <p>Note that BeanFactory callback interfaces like ApplicationContextAware  * are not automatically applied to Quartz Job instances, because Quartz  * itself is responsible for the lifecycle of its Jobs.  * <p><b>Note: When using persistent job stores where JobDetail contents will  * be kept in the database, do not put an ApplicationContext reference into  * the JobDataMap but rather into the SchedulerContext.</b>  * @see org.springframework.scheduling.quartz.SchedulerFactoryBean#setApplicationContextSchedulerContextKey  * @see org.springframework.context.ApplicationContext  */ ;/**  * Set the key of an ApplicationContext reference to expose in the JobDataMap,  * for example "applicationContext". Default is none.  * Only applicable when running in a Spring ApplicationContext.  * <p>In case of a QuartzJobBean, the reference will be applied to the Job  * instance as bean property. An "applicationContext" attribute will correspond  * to a "setApplicationContext" method in that scenario.  * <p>Note that BeanFactory callback interfaces like ApplicationContextAware  * are not automatically applied to Quartz Job instances, because Quartz  * itself is responsible for the lifecycle of its Jobs.  * <p><b>Note: When using persistent job stores where JobDetail contents will  * be kept in the database, do not put an ApplicationContext reference into  * the JobDataMap but rather into the SchedulerContext.</b>  * @see org.springframework.scheduling.quartz.SchedulerFactoryBean#setApplicationContextSchedulerContextKey  * @see org.springframework.context.ApplicationContext  */ public void setApplicationContextJobDataKey(String applicationContextJobDataKey) {     this.applicationContextJobDataKey = applicationContextJobDataKey. }
false;public;0;29;;@Override public void afterPropertiesSet() {     Assert.notNull(this.jobClass, "Property 'jobClass' is required").     if (this.name == null) {         this.name = this.beanName.     }     if (this.group == null) {         this.group = Scheduler.DEFAULT_GROUP.     }     if (this.applicationContextJobDataKey != null) {         if (this.applicationContext == null) {             throw new IllegalStateException("JobDetailBean needs to be set up in an ApplicationContext " + "to be able to handle an 'applicationContextJobDataKey'").         }         getJobDataMap().put(this.applicationContextJobDataKey, this.applicationContext).     }     JobDetailImpl jdi = new JobDetailImpl().     jdi.setName(this.name != null ? this.name : toString()).     jdi.setGroup(this.group).     jdi.setJobClass(this.jobClass).     jdi.setJobDataMap(this.jobDataMap).     jdi.setDurability(this.durability).     jdi.setRequestsRecovery(this.requestsRecovery).     jdi.setDescription(this.description).     this.jobDetail = jdi. }
false;public;0;5;;@Override @Nullable public JobDetail getObject() {     return this.jobDetail. }
false;public;0;4;;@Override public Class<?> getObjectType() {     return JobDetail.class. }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
