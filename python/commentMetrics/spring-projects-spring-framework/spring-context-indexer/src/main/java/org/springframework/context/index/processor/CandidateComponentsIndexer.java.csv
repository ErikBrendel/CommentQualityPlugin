commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Set<String> getSupportedOptions() {     return Collections.emptySet(). }
false;public;0;4;;@Override public Set<String> getSupportedAnnotationTypes() {     return Collections.singleton("*"). }
false;public;0;4;;@Override public SourceVersion getSupportedSourceVersion() {     return SourceVersion.latest(). }
false;public,synchronized;1;7;;@Override public synchronized void init(ProcessingEnvironment env) {     this.stereotypesProviders = getStereotypesProviders(env).     this.typeHelper = new TypeHelper(env).     this.metadataStore = new MetadataStore(env).     this.metadataCollector = new MetadataCollector(env, this.metadataStore.readMetadata()). }
false;public;2;9;;@Override public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {     this.metadataCollector.processing(roundEnv).     roundEnv.getRootElements().forEach(this::processElement).     if (roundEnv.processingOver()) {         writeMetaData().     }     return false. }
false;public;4;6;;@Override public Iterable<? extends Completion> getCompletions(Element element, AnnotationMirror annotation, ExecutableElement member, String userText) {     return Collections.emptyList(). }
false;private;1;8;;private List<StereotypesProvider> getStereotypesProviders(ProcessingEnvironment env) {     List<StereotypesProvider> result = new ArrayList<>().     TypeHelper typeHelper = new TypeHelper(env).     result.add(new IndexedStereotypesProvider(typeHelper)).     result.add(new StandardStereotypesProvider(typeHelper)).     result.add(new PackageInfoStereotypesProvider()).     return result. }
false;private;1;4;;private void processElement(Element element) {     addMetadataFor(element).     staticTypesIn(element.getEnclosedElements()).forEach(this::processElement). }
false;private;1;7;;private void addMetadataFor(Element element) {     Set<String> stereotypes = new LinkedHashSet<>().     this.stereotypesProviders.forEach(p -> stereotypes.addAll(p.getStereotypes(element))).     if (!stereotypes.isEmpty()) {         this.metadataCollector.add(new ItemMetadata(this.typeHelper.getType(element), stereotypes)).     } }
false;private;0;11;;private void writeMetaData() {     CandidateComponentsMetadata metadata = this.metadataCollector.getMetadata().     if (!metadata.getItems().isEmpty()) {         try {             this.metadataStore.writeMetadata(metadata).         } catch (IOException ex) {             throw new IllegalStateException("Failed to write metadata", ex).         }     } }
false;private,static;1;9;;private static List<TypeElement> staticTypesIn(Iterable<? extends Element> elements) {     List<TypeElement> list = new ArrayList<>().     for (Element element : elements) {         if (TYPE_KINDS.contains(element.getKind()) && element.getModifiers().contains(Modifier.STATIC)) {             list.add(TypeElement.class.cast(element)).         }     }     return list. }
