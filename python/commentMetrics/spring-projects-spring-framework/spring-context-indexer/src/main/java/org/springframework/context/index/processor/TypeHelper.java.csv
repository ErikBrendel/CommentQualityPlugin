commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public String getType(Element element) {     return getType(element != null ? element.asType() : null). }
false;public;1;3;;public String getType(AnnotationMirror annotation) {     return getType(annotation != null ? annotation.getAnnotationType() : null). }
false;public;1;16;;public String getType(TypeMirror type) {     if (type == null) {         return null.     }     if (type instanceof DeclaredType) {         DeclaredType declaredType = (DeclaredType) type.         Element enclosingElement = declaredType.asElement().getEnclosingElement().         if (enclosingElement != null && enclosingElement instanceof TypeElement) {             return getQualifiedName(enclosingElement) + "$" + declaredType.asElement().getSimpleName().toString().         } else {             return getQualifiedName(declaredType.asElement()).         }     }     return type.toString(). }
false;private;1;6;;private String getQualifiedName(Element element) {     if (element instanceof QualifiedNameable) {         return ((QualifiedNameable) element).getQualifiedName().toString().     }     return element.toString(). }
true;public;1;7;/**  * Return the super class of the specified {@link Element} or null if this  * {@code element} represents {@link Object}.  */ ;/**  * Return the super class of the specified {@link Element} or null if this  * {@code element} represents {@link Object}.  */ public Element getSuperClass(Element element) {     List<? extends TypeMirror> superTypes = this.types.directSupertypes(element.asType()).     if (superTypes.isEmpty()) {         // reached java.lang.Object         return null.     }     return this.types.asElement(superTypes.get(0)). }
true;public;1;13;/**  * Return the interfaces that are <strong>directly</strong> implemented by the  * specified {@link Element} or an empty list if this {@code element} does not  * implement any interface.  */ ;/**  * Return the interfaces that are <strong>directly</strong> implemented by the  * specified {@link Element} or an empty list if this {@code element} does not  * implement any interface.  */ public List<Element> getDirectInterfaces(Element element) {     List<? extends TypeMirror> superTypes = this.types.directSupertypes(element.asType()).     List<Element> directInterfaces = new ArrayList<>().     if (superTypes.size() > 1) {         // index 0 is the super class         for (int i = 1. i < superTypes.size(). i++) {             Element e = this.types.asElement(superTypes.get(i)).             if (e != null) {                 directInterfaces.add(e).             }         }     }     return directInterfaces. }
false;public;1;9;;public List<? extends AnnotationMirror> getAllAnnotationMirrors(Element e) {     try {         return this.env.getElementUtils().getAllAnnotationMirrors(e).     } catch (Exception ex) {         // This may fail if one of the annotations is not available.         return Collections.emptyList().     } }
