commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void setUp() {     formattingService = new FormattingConversionService().     DefaultConversionService.addDefaultConverters(formattingService).     LocaleContextHolder.setLocale(Locale.US). }
false;public;0;4;;@After public void tearDown() {     LocaleContextHolder.setLocale(null). }
false;public;0;8;;@Test public void formatFieldForTypeWithFormatter() throws ParseException {     formattingService.addFormatterForFieldType(Number.class, new NumberStyleFormatter()).     String formatted = formattingService.convert(3, String.class).     assertEquals("3", formatted).     Integer i = formattingService.convert("3", Integer.class).     assertEquals(new Integer(3), i). }
false;public;1;4;;@Override public LocalDate convert(DateTime source) {     return source.toLocalDate(). }
false;public;0;15;;@Test public void formatFieldForTypeWithPrinterParserWithCoercion() throws ParseException {     formattingService.addConverter(new Converter<DateTime, LocalDate>() {          @Override         public LocalDate convert(DateTime source) {             return source.toLocalDate().         }     }).     formattingService.addFormatterForFieldType(LocalDate.class, new ReadablePartialPrinter(DateTimeFormat.shortDate()), new DateTimeParser(DateTimeFormat.shortDate())).     String formatted = formattingService.convert(new LocalDate(2009, 10, 31), String.class).     assertEquals("10/31/09", formatted).     LocalDate date = formattingService.convert("10/31/09", LocalDate.class).     assertEquals(new LocalDate(2009, 10, 31), date). }
false;public;0;10;;@Test @SuppressWarnings("resource") public void formatFieldForValueInjection() {     AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext().     ac.registerBeanDefinition("valueBean", new RootBeanDefinition(ValueBean.class)).     ac.registerBeanDefinition("conversionService", new RootBeanDefinition(FormattingConversionServiceFactoryBean.class)).     ac.refresh().     ValueBean valueBean = ac.getBean(ValueBean.class).     assertEquals(new LocalDate(2009, 10, 31), new LocalDate(valueBean.date)). }
false;public;0;22;;@Test @SuppressWarnings("resource") public void formatFieldForValueInjectionUsingMetaAnnotations() {     AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext().     RootBeanDefinition bd = new RootBeanDefinition(MetaValueBean.class).     bd.setScope(BeanDefinition.SCOPE_PROTOTYPE).     ac.registerBeanDefinition("valueBean", bd).     ac.registerBeanDefinition("conversionService", new RootBeanDefinition(FormattingConversionServiceFactoryBean.class)).     ac.registerBeanDefinition("ppc", new RootBeanDefinition(PropertyPlaceholderConfigurer.class)).     ac.refresh().     System.setProperty("myDate", "10-31-09").     System.setProperty("myNumber", "99.99%").     try {         MetaValueBean valueBean = ac.getBean(MetaValueBean.class).         assertEquals(new LocalDate(2009, 10, 31), new LocalDate(valueBean.date)).         assertEquals(Double.valueOf(0.9999), valueBean.number).     } finally {         System.clearProperty("myDate").         System.clearProperty("myNumber").     } }
false;public;0;5;;@Test public void formatFieldForAnnotation() throws Exception {     formattingService.addFormatterForFieldAnnotation(new JodaDateTimeFormatAnnotationFormatterFactory()).     doTestFormatFieldForAnnotation(Model.class, false). }
false;public;0;5;;@Test public void formatFieldForAnnotationWithDirectFieldAccess() throws Exception {     formattingService.addFormatterForFieldAnnotation(new JodaDateTimeFormatAnnotationFormatterFactory()).     doTestFormatFieldForAnnotation(Model.class, true). }
false;public;0;15;;@Test @SuppressWarnings("resource") public void formatFieldForAnnotationWithPlaceholders() throws Exception {     GenericApplicationContext context = new GenericApplicationContext().     PropertyPlaceholderConfigurer ppc = new PropertyPlaceholderConfigurer().     Properties props = new Properties().     props.setProperty("dateStyle", "S-").     props.setProperty("datePattern", "M-d-yy").     ppc.setProperties(props).     context.getBeanFactory().registerSingleton("ppc", ppc).     context.refresh().     context.getBeanFactory().initializeBean(formattingService, "formattingService").     formattingService.addFormatterForFieldAnnotation(new JodaDateTimeFormatAnnotationFormatterFactory()).     doTestFormatFieldForAnnotation(ModelWithPlaceholders.class, false). }
false;public;0;15;;@Test @SuppressWarnings("resource") public void formatFieldForAnnotationWithPlaceholdersAndFactoryBean() throws Exception {     GenericApplicationContext context = new GenericApplicationContext().     PropertyPlaceholderConfigurer ppc = new PropertyPlaceholderConfigurer().     Properties props = new Properties().     props.setProperty("dateStyle", "S-").     props.setProperty("datePattern", "M-d-yy").     ppc.setProperties(props).     context.registerBeanDefinition("formattingService", new RootBeanDefinition(FormattingConversionServiceFactoryBean.class)).     context.getBeanFactory().registerSingleton("ppc", ppc).     context.refresh().     formattingService = context.getBean("formattingService", FormattingConversionService.class).     doTestFormatFieldForAnnotation(ModelWithPlaceholders.class, false). }
false;public;1;4;;@Override public Long convert(Date source) {     return source.getTime(). }
false;public;1;4;;@Override public Date convert(DateTime source) {     return source.toDate(). }
false;private;2;54;;@SuppressWarnings("unchecked") private void doTestFormatFieldForAnnotation(Class<?> modelClass, boolean directFieldAccess) throws Exception {     formattingService.addConverter(new Converter<Date, Long>() {          @Override         public Long convert(Date source) {             return source.getTime().         }     }).     formattingService.addConverter(new Converter<DateTime, Date>() {          @Override         public Date convert(DateTime source) {             return source.toDate().         }     }).     String formatted = (String) formattingService.convert(new LocalDate(2009, 10, 31).toDateTimeAtCurrentTime().toDate(), new TypeDescriptor(modelClass.getField("date")), TypeDescriptor.valueOf(String.class)).     assertEquals("10/31/09", formatted).     LocalDate date = new LocalDate(formattingService.convert("10/31/09", TypeDescriptor.valueOf(String.class), new TypeDescriptor(modelClass.getField("date")))).     assertEquals(new LocalDate(2009, 10, 31), date).     List<Date> dates = new ArrayList<>().     dates.add(new LocalDate(2009, 10, 31).toDateTimeAtCurrentTime().toDate()).     dates.add(new LocalDate(2009, 11, 1).toDateTimeAtCurrentTime().toDate()).     dates.add(new LocalDate(2009, 11, 2).toDateTimeAtCurrentTime().toDate()).     formatted = (String) formattingService.convert(dates, new TypeDescriptor(modelClass.getField("dates")), TypeDescriptor.valueOf(String.class)).     assertEquals("10-31-09,11-1-09,11-2-09", formatted).     dates = (List<Date>) formattingService.convert("10-31-09,11-1-09,11-2-09", TypeDescriptor.valueOf(String.class), new TypeDescriptor(modelClass.getField("dates"))).     assertEquals(new LocalDate(2009, 10, 31), new LocalDate(dates.get(0))).     assertEquals(new LocalDate(2009, 11, 1), new LocalDate(dates.get(1))).     assertEquals(new LocalDate(2009, 11, 2), new LocalDate(dates.get(2))).     Object model = modelClass.newInstance().     ConfigurablePropertyAccessor accessor = directFieldAccess ? PropertyAccessorFactory.forDirectFieldAccess(model) : PropertyAccessorFactory.forBeanPropertyAccess(model).     accessor.setConversionService(formattingService).     accessor.setPropertyValue("dates", "10-31-09,11-1-09,11-2-09").     dates = (List<Date>) accessor.getPropertyValue("dates").     assertEquals(new LocalDate(2009, 10, 31), new LocalDate(dates.get(0))).     assertEquals(new LocalDate(2009, 11, 1), new LocalDate(dates.get(1))).     assertEquals(new LocalDate(2009, 11, 2), new LocalDate(dates.get(2))).     if (!directFieldAccess) {         accessor.setPropertyValue("dates[0]", "10-30-09").         accessor.setPropertyValue("dates[1]", "10-1-09").         accessor.setPropertyValue("dates[2]", "10-2-09").         dates = (List<Date>) accessor.getPropertyValue("dates").         assertEquals(new LocalDate(2009, 10, 30), new LocalDate(dates.get(0))).         assertEquals(new LocalDate(2009, 10, 1), new LocalDate(dates.get(1))).         assertEquals(new LocalDate(2009, 10, 2), new LocalDate(dates.get(2))).     } }
false;public;0;5;;@Test public void printNull() throws ParseException {     formattingService.addFormatterForFieldType(Number.class, new NumberStyleFormatter()).     assertEquals("", formattingService.convert(null, TypeDescriptor.valueOf(Integer.class), TypeDescriptor.valueOf(String.class))). }
false;public;0;6;;@Test public void parseNull() throws ParseException {     formattingService.addFormatterForFieldType(Number.class, new NumberStyleFormatter()).     assertNull(formattingService.convert(null, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class))). }
false;public;0;5;;@Test public void parseEmptyString() throws ParseException {     formattingService.addFormatterForFieldType(Number.class, new NumberStyleFormatter()).     assertNull(formattingService.convert("", TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class))). }
false;public;0;5;;@Test public void parseBlankString() throws ParseException {     formattingService.addFormatterForFieldType(Number.class, new NumberStyleFormatter()).     assertNull(formattingService.convert("     ", TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class))). }
false;public;0;5;;@Test(expected = ConversionFailedException.class) public void parseParserReturnsNull() throws ParseException {     formattingService.addFormatterForFieldType(Integer.class, new NullReturningFormatter()).     assertNull(formattingService.convert("1", TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class))). }
false;public;0;5;;@Test(expected = ConversionFailedException.class) public void parseNullPrimitiveProperty() throws ParseException {     formattingService.addFormatterForFieldType(Integer.class, new NumberStyleFormatter()).     assertNull(formattingService.convert(null, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(int.class))). }
false;public;0;5;;@Test public void printNullDefault() throws ParseException {     assertEquals(null, formattingService.convert(null, TypeDescriptor.valueOf(Integer.class), TypeDescriptor.valueOf(String.class))). }
false;public;0;5;;@Test public void parseNullDefault() throws ParseException {     assertNull(formattingService.convert(null, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class))). }
false;public;0;4;;@Test public void parseEmptyStringDefault() throws ParseException {     assertNull(formattingService.convert("", TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class))). }
false;public;2;5;;@Override public Printer<?> getPrinter(org.springframework.format.annotation.DateTimeFormat annotation, Class<?> fieldType) {     assertEquals(MyDate.class, fieldType).     return super.getPrinter(annotation, fieldType). }
false;public;1;4;;@Override public Long convert(MyDate source) {     return source.getTime(). }
false;public;1;4;;@Override public Date convert(MyDate source) {     return source. }
false;public;0;25;;@Test public void formatFieldForAnnotationWithSubclassAsFieldType() throws Exception {     formattingService.addFormatterForFieldAnnotation(new JodaDateTimeFormatAnnotationFormatterFactory() {          @Override         public Printer<?> getPrinter(org.springframework.format.annotation.DateTimeFormat annotation, Class<?> fieldType) {             assertEquals(MyDate.class, fieldType).             return super.getPrinter(annotation, fieldType).         }     }).     formattingService.addConverter(new Converter<MyDate, Long>() {          @Override         public Long convert(MyDate source) {             return source.getTime().         }     }).     formattingService.addConverter(new Converter<MyDate, Date>() {          @Override         public Date convert(MyDate source) {             return source.         }     }).     formattingService.convert(new MyDate(), new TypeDescriptor(ModelWithSubclassField.class.getField("date")), TypeDescriptor.valueOf(String.class)). }
false;public;0;4;;@Test public void registerDefaultValueViaFormatter() {     registerDefaultValue(Date.class, new Date()). }
false;public;2;4;;@Override public T parse(String text, Locale locale) throws ParseException {     return defaultValue. }
false;public;2;4;;@Override public String print(T t, Locale locale) {     return defaultValue.toString(). }
false;public;0;4;;@Override public String toString() {     return defaultValue.toString(). }
false;private;2;16;;private <T> void registerDefaultValue(Class<T> clazz, final T defaultValue) {     formattingService.addFormatterForFieldType(clazz, new Formatter<T>() {          @Override         public T parse(String text, Locale locale) throws ParseException {             return defaultValue.         }          @Override         public String print(T t, Locale locale) {             return defaultValue.toString().         }          @Override         public String toString() {             return defaultValue.toString().         }     }). }
false;public;0;5;;@Test public void introspectedFormatter() throws ParseException {     formattingService.addFormatter(new NumberStyleFormatter()).     assertNull(formattingService.convert(null, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class))). }
false;public;0;6;;@Test public void proxiedFormatter() throws ParseException {     Formatter<?> formatter = new NumberStyleFormatter().     formattingService.addFormatter((Formatter<?>) new ProxyFactory(formatter).getProxy()).     assertNull(formattingService.convert(null, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class))). }
false;public;0;5;;@Test public void introspectedConverter() {     formattingService.addConverter(new IntegerConverter()).     assertEquals(Integer.valueOf(1), formattingService.convert("1", Integer.class)). }
false;public;0;6;;@Test public void proxiedConverter() {     Converter<?, ?> converter = new IntegerConverter().     formattingService.addConverter((Converter<?, ?>) new ProxyFactory(converter).getProxy()).     assertEquals(Integer.valueOf(1), formattingService.convert("1", Integer.class)). }
false;public;0;5;;@Test public void introspectedConverterFactory() {     formattingService.addConverterFactory(new IntegerConverterFactory()).     assertEquals(Integer.valueOf(1), formattingService.convert("1", Integer.class)). }
false;public;0;6;;@Test public void proxiedConverterFactory() {     ConverterFactory<?, ?> converterFactory = new IntegerConverterFactory().     formattingService.addConverterFactory((ConverterFactory<?, ?>) new ProxyFactory(converterFactory).getProxy()).     assertEquals(Integer.valueOf(1), formattingService.convert("1", Integer.class)). }
false;public;0;3;;public List<Date> getDates() {     return dates. }
false;public;1;3;;public void setDates(List<Date> dates) {     this.dates = dates. }
false;public;0;3;;public List<Date> getDates() {     return dates. }
false;public;1;3;;public void setDates(List<Date> dates) {     this.dates = dates. }
false;public;2;4;;@Override public String print(Integer object, Locale locale) {     return null. }
false;public;2;4;;@Override public Integer parse(String text, Locale locale) throws ParseException {     return null. }
false;public;1;4;;@Override public Integer convert(String source) {     return Integer.parseInt(source). }
false;public;1;10;;@Override @SuppressWarnings("unchecked") public <T extends Number> Converter<String, T> getConverter(Class<T> targetType) {     if (Integer.class == targetType) {         return (Converter<String, T>) new IntegerConverter().     } else {         throw new IllegalStateException().     } }
