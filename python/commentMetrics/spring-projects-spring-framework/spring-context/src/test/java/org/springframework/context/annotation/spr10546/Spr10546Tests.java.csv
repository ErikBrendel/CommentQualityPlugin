commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@After public void closeContext() {     if (context != null) {         context.close().     } }
false;public;0;4;;// These fail prior to fixing SPR-10546 @Test public void enclosingConfigFirstParentDefinesBean() {     assertLoadsMyBean(AEnclosingConfig.class, AEnclosingConfig.ChildConfig.class). }
true;public;0;8;/**  * Prior to fixing SPR-10546 this might have succeeded depending on the ordering the  * classes were picked up. If they are picked up in the same order as  * {@link #enclosingConfigFirstParentDefinesBean()} then it would fail. This test is  * mostly for illustration purposes, but doesn't hurt to continue using it.  *  * <p>We purposely use the {@link AEnclosingConfig} to make it alphabetically prior to the  * {@link AEnclosingConfig.ChildConfig} which encourages this to occur with the  * classpath scanning implementation being used by the author of this test.  */ ;/**  * Prior to fixing SPR-10546 this might have succeeded depending on the ordering the  * classes were picked up. If they are picked up in the same order as  * {@link #enclosingConfigFirstParentDefinesBean()} then it would fail. This test is  * mostly for illustration purposes, but doesn't hurt to continue using it.  *  * <p>We purposely use the {@link AEnclosingConfig} to make it alphabetically prior to the  * {@link AEnclosingConfig.ChildConfig} which encourages this to occur with the  * classpath scanning implementation being used by the author of this test.  */ @Test public void enclosingConfigFirstParentDefinesBeanWithScanning() {     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     context = ctx.     ctx.scan(AEnclosingConfig.class.getPackage().getName()).     ctx.refresh().     assertThat(context.getBean("myBean", String.class), equalTo("myBean")). }
false;public;0;4;;@Test public void enclosingConfigFirstParentDefinesBeanWithImportResource() {     assertLoadsMyBean(AEnclosingWithImportResourceConfig.class, AEnclosingWithImportResourceConfig.ChildConfig.class). }
false;public;0;4;;@Test public void enclosingConfigFirstParentDefinesBeanWithComponentScan() {     assertLoadsMyBean(AEnclosingWithComponentScanConfig.class, AEnclosingWithComponentScanConfig.ChildConfig.class). }
false;public;0;4;;@Test public void enclosingConfigFirstParentWithParentDefinesBean() {     assertLoadsMyBean(AEnclosingWithGrandparentConfig.class, AEnclosingWithGrandparentConfig.ChildConfig.class). }
false;public;0;4;;@Test public void importChildConfigThenChildConfig() {     assertLoadsMyBean(ImportChildConfig.class, ChildConfig.class). }
false;public;0;4;;// These worked prior, but validating they continue to work @Test public void enclosingConfigFirstParentDefinesBeanWithImport() {     assertLoadsMyBean(AEnclosingWithImportConfig.class, AEnclosingWithImportConfig.ChildConfig.class). }
false;public;0;4;;@Test public void childConfigFirst() {     assertLoadsMyBean(AEnclosingConfig.ChildConfig.class, AEnclosingConfig.class). }
false;public;0;4;;@Test public void enclosingConfigOnly() {     assertLoadsMyBean(AEnclosingConfig.class). }
false;public;0;4;;@Test public void childConfigOnly() {     assertLoadsMyBean(AEnclosingConfig.ChildConfig.class). }
false;private;1;4;;private void assertLoadsMyBean(Class<?>... annotatedClasses) {     context = new AnnotationConfigApplicationContext(annotatedClasses).     assertThat(context.getBean("myBean", String.class), equalTo("myBean")). }
