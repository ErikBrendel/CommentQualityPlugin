# id;timestamp;commentText;codeText;commentWords;codeWords
ConfigurationClassWithPlaceholderConfigurerBeanTests -> @Ignore @Test 	public void valueFieldsAreNotProcessedWhenPlaceholderConfigurerIsIntegrated();1328020251;Intentionally ignored test proving that a property placeholder bean_cannot be declared in the same configuration class that has a @Value_field in need of placeholder replacement.  It's an obvious chicken-and-egg issue._The solution is to do as {@link #valueFieldsAreProcessedWhenPlaceholderConfigurerIsSegregated()}_does and segragate the two bean definitions across configuration classes.;@Ignore @Test_	public void valueFieldsAreNotProcessedWhenPlaceholderConfigurerIsIntegrated() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext()__		ctx.register(ConfigWithValueFieldAndPlaceholderConfigurer.class)__		System.setProperty("test.name", "foo")__		ctx.refresh()__		System.clearProperty("test.name")___		TestBean testBean = ctx.getBean(TestBean.class)__		assertThat(testBean.getName(), nullValue())__	};intentionally,ignored,test,proving,that,a,property,placeholder,bean,cannot,be,declared,in,the,same,configuration,class,that,has,a,value,field,in,need,of,placeholder,replacement,it,s,an,obvious,chicken,and,egg,issue,the,solution,is,to,do,as,link,value,fields,are,processed,when,placeholder,configurer,is,segregated,does,and,segragate,the,two,bean,definitions,across,configuration,classes;ignore,test,public,void,value,fields,are,not,processed,when,placeholder,configurer,is,integrated,annotation,config,application,context,ctx,new,annotation,config,application,context,ctx,register,config,with,value,field,and,placeholder,configurer,class,system,set,property,test,name,foo,ctx,refresh,system,clear,property,test,name,test,bean,test,bean,ctx,get,bean,test,bean,class,assert,that,test,bean,get,name,null,value
ConfigurationClassWithPlaceholderConfigurerBeanTests -> @Ignore @Test 	public void valueFieldsAreNotProcessedWhenPlaceholderConfigurerIsIntegrated();1362408075;Intentionally ignored test proving that a property placeholder bean_cannot be declared in the same configuration class that has a @Value_field in need of placeholder replacement.  It's an obvious chicken-and-egg issue._The solution is to do as {@link #valueFieldsAreProcessedWhenPlaceholderConfigurerIsSegregated()}_does and segragate the two bean definitions across configuration classes.;@Ignore @Test_	public void valueFieldsAreNotProcessedWhenPlaceholderConfigurerIsIntegrated() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext()__		ctx.register(ConfigWithValueFieldAndPlaceholderConfigurer.class)__		System.setProperty("test.name", "foo")__		ctx.refresh()__		System.clearProperty("test.name")___		TestBean testBean = ctx.getBean(TestBean.class)__		assertThat(testBean.getName(), nullValue())__	};intentionally,ignored,test,proving,that,a,property,placeholder,bean,cannot,be,declared,in,the,same,configuration,class,that,has,a,value,field,in,need,of,placeholder,replacement,it,s,an,obvious,chicken,and,egg,issue,the,solution,is,to,do,as,link,value,fields,are,processed,when,placeholder,configurer,is,segregated,does,and,segragate,the,two,bean,definitions,across,configuration,classes;ignore,test,public,void,value,fields,are,not,processed,when,placeholder,configurer,is,integrated,annotation,config,application,context,ctx,new,annotation,config,application,context,ctx,register,config,with,value,field,and,placeholder,configurer,class,system,set,property,test,name,foo,ctx,refresh,system,clear,property,test,name,test,bean,test,bean,ctx,get,bean,test,bean,class,assert,that,test,bean,get,name,null,value
ConfigurationClassWithPlaceholderConfigurerBeanTests -> @Ignore @Test 	public void valueFieldsAreNotProcessedWhenPlaceholderConfigurerIsIntegrated();1413848647;Intentionally ignored test proving that a property placeholder bean_cannot be declared in the same configuration class that has a @Value_field in need of placeholder replacement.  It's an obvious chicken-and-egg issue._The solution is to do as {@link #valueFieldsAreProcessedWhenPlaceholderConfigurerIsSegregated()}_does and segragate the two bean definitions across configuration classes.;@Ignore @Test_	public void valueFieldsAreNotProcessedWhenPlaceholderConfigurerIsIntegrated() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext()__		ctx.register(ConfigWithValueFieldAndPlaceholderConfigurer.class)__		System.setProperty("test.name", "foo")__		ctx.refresh()__		System.clearProperty("test.name")___		TestBean testBean = ctx.getBean(TestBean.class)__		assertThat(testBean.getName(), nullValue())__	};intentionally,ignored,test,proving,that,a,property,placeholder,bean,cannot,be,declared,in,the,same,configuration,class,that,has,a,value,field,in,need,of,placeholder,replacement,it,s,an,obvious,chicken,and,egg,issue,the,solution,is,to,do,as,link,value,fields,are,processed,when,placeholder,configurer,is,segregated,does,and,segragate,the,two,bean,definitions,across,configuration,classes;ignore,test,public,void,value,fields,are,not,processed,when,placeholder,configurer,is,integrated,annotation,config,application,context,ctx,new,annotation,config,application,context,ctx,register,config,with,value,field,and,placeholder,configurer,class,system,set,property,test,name,foo,ctx,refresh,system,clear,property,test,name,test,bean,test,bean,ctx,get,bean,test,bean,class,assert,that,test,bean,get,name,null,value
ConfigurationClassWithPlaceholderConfigurerBeanTests -> @Ignore @Test 	public void valueFieldsAreNotProcessedWhenPlaceholderConfigurerIsIntegrated();1457704801;Intentionally ignored test proving that a property placeholder bean_cannot be declared in the same configuration class that has a @Value_field in need of placeholder replacement. It's an obvious chicken-and-egg issue._The solution is to do as {@link #valueFieldsAreProcessedWhenPlaceholderConfigurerIsSegregated()}_does and segregate the two bean definitions across configuration classes.;@Ignore @Test_	public void valueFieldsAreNotProcessedWhenPlaceholderConfigurerIsIntegrated() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext()__		ctx.register(ConfigWithValueFieldAndPlaceholderConfigurer.class)__		System.setProperty("test.name", "foo")__		ctx.refresh()__		System.clearProperty("test.name")___		TestBean testBean = ctx.getBean(TestBean.class)__		assertThat(testBean.getName(), nullValue())__	};intentionally,ignored,test,proving,that,a,property,placeholder,bean,cannot,be,declared,in,the,same,configuration,class,that,has,a,value,field,in,need,of,placeholder,replacement,it,s,an,obvious,chicken,and,egg,issue,the,solution,is,to,do,as,link,value,fields,are,processed,when,placeholder,configurer,is,segregated,does,and,segregate,the,two,bean,definitions,across,configuration,classes;ignore,test,public,void,value,fields,are,not,processed,when,placeholder,configurer,is,integrated,annotation,config,application,context,ctx,new,annotation,config,application,context,ctx,register,config,with,value,field,and,placeholder,configurer,class,system,set,property,test,name,foo,ctx,refresh,system,clear,property,test,name,test,bean,test,bean,ctx,get,bean,test,bean,class,assert,that,test,bean,get,name,null,value
