commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void initExecutor() {     executor = buildExecutor(). }
false;protected,abstract;0;1;;protected abstract AsyncListenableTaskExecutor buildExecutor().
false;public;0;6;;@After public void shutdownExecutor() throws Exception {     if (executor instanceof DisposableBean) {         ((DisposableBean) executor).destroy().     } }
false;public;0;7;;@Test public void executeRunnable() {     TestTask task = new TestTask(1).     executor.execute(task).     await(task).     assertThreadNamePrefix(task). }
false;public;0;6;;@Test public void executeFailingRunnable() {     TestTask task = new TestTask(0).     executor.execute(task). // nothing to assert }
false;public;0;8;;@Test public void submitRunnable() throws Exception {     TestTask task = new TestTask(1).     Future<?> future = executor.submit(task).     Object result = future.get(1000, TimeUnit.MILLISECONDS).     assertNull(result).     assertThreadNamePrefix(task). }
false;public;0;12;;@Test(expected = ExecutionException.class) public void submitFailingRunnable() throws Exception {     TestTask task = new TestTask(0).     Future<?> future = executor.submit(task).     try {         future.get(1000, TimeUnit.MILLISECONDS).     } catch (ExecutionException ex) {         assertTrue(future.isDone()).         throw ex.     } }
false;public;0;10;;@Test(expected = CancellationException.class) public void submitRunnableWithGetAfterShutdown() throws Exception {     TestTask task1 = new TestTask(-1).     Future<?> future1 = executor.submit(task1).     TestTask task2 = new TestTask(-1).     Future<?> future2 = executor.submit(task2).     shutdownExecutor().     future1.get().     future2.get(). }
false;public;0;14;;@Test public void submitListenableRunnable() throws Exception {     TestTask task = new TestTask(1).     // Act     ListenableFuture<?> future = executor.submitListenable(task).     future.addCallback(result -> outcome = result, ex -> outcome = ex).     // Assert     Awaitility.await().atMost(1, TimeUnit.SECONDS).pollInterval(10, TimeUnit.MILLISECONDS).until(future::isDone).     assertNull(outcome).     assertThreadNamePrefix(task). }
false;public;0;13;;@Test public void submitFailingListenableRunnable() throws Exception {     TestTask task = new TestTask(0).     ListenableFuture<?> future = executor.submitListenable(task).     future.addCallback(result -> outcome = result, ex -> outcome = ex).     Awaitility.await().dontCatchUncaughtExceptions().atMost(1, TimeUnit.SECONDS).pollInterval(10, TimeUnit.MILLISECONDS).until(() -> future.isDone() && outcome != null).     assertSame(RuntimeException.class, outcome.getClass()). }
false;public;0;10;;@Test(expected = CancellationException.class) public void submitListenableRunnableWithGetAfterShutdown() throws Exception {     TestTask task1 = new TestTask(-1).     ListenableFuture<?> future1 = executor.submitListenable(task1).     TestTask task2 = new TestTask(-1).     ListenableFuture<?> future2 = executor.submitListenable(task2).     shutdownExecutor().     future1.get().     future2.get(). }
false;public;0;7;;@Test public void submitCallable() throws Exception {     TestCallable task = new TestCallable(1).     Future<String> future = executor.submit(task).     String result = future.get(1000, TimeUnit.MILLISECONDS).     assertEquals(THREAD_NAME_PREFIX, result.substring(0, THREAD_NAME_PREFIX.length())). }
false;public;0;7;;@Test(expected = ExecutionException.class) public void submitFailingCallable() throws Exception {     TestCallable task = new TestCallable(0).     Future<String> future = executor.submit(task).     future.get(1000, TimeUnit.MILLISECONDS).     assertTrue(future.isDone()). }
false;public;0;10;;@Test(expected = CancellationException.class) public void submitCallableWithGetAfterShutdown() throws Exception {     TestCallable task1 = new TestCallable(-1).     Future<?> future1 = executor.submit(task1).     TestCallable task2 = new TestCallable(-1).     Future<?> future2 = executor.submit(task2).     shutdownExecutor().     future1.get(1000, TimeUnit.MILLISECONDS).     future2.get(1000, TimeUnit.MILLISECONDS). }
false;public;0;13;;@Test public void submitListenableCallable() throws Exception {     TestCallable task = new TestCallable(1).     // Act     ListenableFuture<String> future = executor.submitListenable(task).     future.addCallback(result -> outcome = result, ex -> outcome = ex).     // Assert     Awaitility.await().atMost(1, TimeUnit.SECONDS).pollInterval(10, TimeUnit.MILLISECONDS).until(() -> future.isDone() && outcome != null).     assertEquals(THREAD_NAME_PREFIX, outcome.toString().substring(0, THREAD_NAME_PREFIX.length())). }
false;public;0;14;;@Test public void submitFailingListenableCallable() throws Exception {     TestCallable task = new TestCallable(0).     // Act     ListenableFuture<String> future = executor.submitListenable(task).     future.addCallback(result -> outcome = result, ex -> outcome = ex).     // Assert     Awaitility.await().dontCatchUncaughtExceptions().atMost(1, TimeUnit.SECONDS).pollInterval(10, TimeUnit.MILLISECONDS).until(() -> future.isDone() && outcome != null).     assertSame(RuntimeException.class, outcome.getClass()). }
false;public;0;10;;@Test(expected = CancellationException.class) public void submitListenableCallableWithGetAfterShutdown() throws Exception {     TestCallable task1 = new TestCallable(-1).     ListenableFuture<?> future1 = executor.submitListenable(task1).     TestCallable task2 = new TestCallable(-1).     ListenableFuture<?> future2 = executor.submitListenable(task2).     shutdownExecutor().     future1.get(1000, TimeUnit.MILLISECONDS).     future2.get(1000, TimeUnit.MILLISECONDS). }
false;private;1;3;;private void assertThreadNamePrefix(TestTask task) {     assertEquals(THREAD_NAME_PREFIX, task.lastThread.getName().substring(0, THREAD_NAME_PREFIX.length())). }
false;private;1;3;;private void await(TestTask task) {     await(task.latch). }
false;private;1;9;;private void await(CountDownLatch latch) {     try {         latch.await(1000, TimeUnit.MILLISECONDS).     } catch (InterruptedException ex) {         throw new IllegalStateException(ex).     }     assertEquals("latch did not count down,", 0, latch.getCount()). }
false;public;0;15;;@Override public void run() {     lastThread = Thread.currentThread().     try {         Thread.sleep(10).     } catch (InterruptedException ex) {     }     if (expectedRunCount >= 0) {         if (actualRunCount.incrementAndGet() > expectedRunCount) {             throw new RuntimeException("intentional test failure").         }         latch.countDown().     } }
false;public;0;14;;@Override public String call() throws Exception {     try {         Thread.sleep(10).     } catch (InterruptedException ex) {     }     if (expectedRunCount >= 0) {         if (actualRunCount.incrementAndGet() > expectedRunCount) {             throw new RuntimeException("intentional test failure").         }     }     return Thread.currentThread().getName(). }
