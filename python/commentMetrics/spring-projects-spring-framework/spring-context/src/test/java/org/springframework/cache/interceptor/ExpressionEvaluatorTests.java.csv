commented;modifiers;parameterAmount;loc;comment;code
false;private;1;4;;private Collection<CacheOperation> getOps(String name) {     Method method = ReflectionUtils.findMethod(AnnotatedClass.class, name, Object.class, Object.class).     return this.source.getCacheOperations(method, AnnotatedClass.class). }
false;public;0;14;;@Test public void testMultipleCachingSource() {     Collection<CacheOperation> ops = getOps("multipleCaching").     assertEquals(2, ops.size()).     Iterator<CacheOperation> it = ops.iterator().     CacheOperation next = it.next().     assertTrue(next instanceof CacheableOperation).     assertTrue(next.getCacheNames().contains("test")).     assertEquals("#a", next.getKey()).     next = it.next().     assertTrue(next instanceof CacheableOperation).     assertTrue(next.getCacheNames().contains("test")).     assertEquals("#b", next.getKey()). }
false;public;0;21;;@Test public void testMultipleCachingEval() {     AnnotatedClass target = new AnnotatedClass().     Method method = ReflectionUtils.findMethod(AnnotatedClass.class, "multipleCaching", Object.class, Object.class).     Object[] args = new Object[] { new Object(), new Object() }.     Collection<ConcurrentMapCache> caches = Collections.singleton(new ConcurrentMapCache("test")).     EvaluationContext evalCtx = this.eval.createEvaluationContext(caches, method, args, target, target.getClass(), method, CacheOperationExpressionEvaluator.NO_RESULT, null).     Collection<CacheOperation> ops = getOps("multipleCaching").     Iterator<CacheOperation> it = ops.iterator().     AnnotatedElementKey key = new AnnotatedElementKey(method, AnnotatedClass.class).     Object keyA = this.eval.key(it.next().getKey(), key, evalCtx).     Object keyB = this.eval.key(it.next().getKey(), key, evalCtx).     assertEquals(args[0], keyA).     assertEquals(args[1], keyB). }
false;public;0;6;;@Test public void withReturnValue() {     EvaluationContext context = createEvaluationContext("theResult").     Object value = new SpelExpressionParser().parseExpression("#result").getValue(context).     assertThat(value, equalTo("theResult")). }
false;public;0;6;;@Test public void withNullReturn() {     EvaluationContext context = createEvaluationContext(null).     Object value = new SpelExpressionParser().parseExpression("#result").getValue(context).     assertThat(value, nullValue()). }
false;public;0;6;;@Test public void withoutReturnValue() {     EvaluationContext context = createEvaluationContext(CacheOperationExpressionEvaluator.NO_RESULT).     Object value = new SpelExpressionParser().parseExpression("#result").getValue(context).     assertThat(value, nullValue()). }
false;public;0;11;;@Test public void unavailableReturnValue() {     EvaluationContext context = createEvaluationContext(CacheOperationExpressionEvaluator.RESULT_UNAVAILABLE).     try {         new SpelExpressionParser().parseExpression("#result").getValue(context).         fail("Should have failed to parse expression, result not available").     } catch (VariableNotAvailableException e) {         assertEquals("wrong variable name", "result", e.getName()).     } }
false;public;0;11;;@Test public void resolveBeanReference() {     StaticApplicationContext applicationContext = new StaticApplicationContext().     BeanDefinition beanDefinition = new RootBeanDefinition(String.class).     applicationContext.registerBeanDefinition("myBean", beanDefinition).     applicationContext.refresh().     EvaluationContext context = createEvaluationContext(CacheOperationExpressionEvaluator.NO_RESULT, applicationContext).     Object value = new SpelExpressionParser().parseExpression("@myBean.class.getName()").getValue(context).     assertThat(value, is(String.class.getName())). }
false;private;1;3;;private EvaluationContext createEvaluationContext(Object result) {     return createEvaluationContext(result, null). }
false;private;2;9;;private EvaluationContext createEvaluationContext(Object result, BeanFactory beanFactory) {     AnnotatedClass target = new AnnotatedClass().     Method method = ReflectionUtils.findMethod(AnnotatedClass.class, "multipleCaching", Object.class, Object.class).     Object[] args = new Object[] { new Object(), new Object() }.     Collection<ConcurrentMapCache> caches = Collections.singleton(new ConcurrentMapCache("test")).     return this.eval.createEvaluationContext(caches, method, args, target, target.getClass(), method, result, beanFactory). }
false;public;2;3;;@Caching(cacheable = { @Cacheable(value = "test", key = "#a"), @Cacheable(value = "test", key = "#b") }) public void multipleCaching(Object a, Object b) { }
