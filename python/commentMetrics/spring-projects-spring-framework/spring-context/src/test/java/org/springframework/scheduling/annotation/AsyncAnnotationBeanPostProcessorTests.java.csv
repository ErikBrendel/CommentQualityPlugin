commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Test public void proxyCreated() {     ConfigurableApplicationContext context = initContext(new RootBeanDefinition(AsyncAnnotationBeanPostProcessor.class)).     Object target = context.getBean("target").     assertTrue(AopUtils.isAopProxy(target)).     context.close(). }
false;public;0;13;;@Test public void invokedAsynchronously() {     ConfigurableApplicationContext context = initContext(new RootBeanDefinition(AsyncAnnotationBeanPostProcessor.class)).     ITestBean testBean = context.getBean("target", ITestBean.class).     testBean.test().     Thread mainThread = Thread.currentThread().     testBean.await(3000).     Thread asyncThread = testBean.getThread().     assertNotSame(mainThread, asyncThread).     context.close(). }
false;public;0;18;;@Test public void invokedAsynchronouslyOnProxyTarget() {     StaticApplicationContext context = new StaticApplicationContext().     context.registerBeanDefinition("postProcessor", new RootBeanDefinition(AsyncAnnotationBeanPostProcessor.class)).     TestBean tb = new TestBean().     ProxyFactory pf = new ProxyFactory(ITestBean.class, (MethodInterceptor) invocation -> invocation.getMethod().invoke(tb, invocation.getArguments())).     context.registerBean("target", ITestBean.class, () -> (ITestBean) pf.getProxy()).     context.refresh().     ITestBean testBean = context.getBean("target", ITestBean.class).     testBean.test().     Thread mainThread = Thread.currentThread().     testBean.await(3000).     Thread asyncThread = testBean.getThread().     assertNotSame(mainThread, asyncThread).     context.close(). }
false;public;0;16;;@Test public void threadNamePrefix() {     BeanDefinition processorDefinition = new RootBeanDefinition(AsyncAnnotationBeanPostProcessor.class).     ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor().     executor.setThreadNamePrefix("testExecutor").     executor.afterPropertiesSet().     processorDefinition.getPropertyValues().add("executor", executor).     ConfigurableApplicationContext context = initContext(processorDefinition).     ITestBean testBean = context.getBean("target", ITestBean.class).     testBean.test().     testBean.await(3000).     Thread asyncThread = testBean.getThread().     assertTrue(asyncThread.getName().startsWith("testExecutor")).     context.close(). }
false;public;0;24;;@Test public void taskExecutorByBeanType() {     StaticApplicationContext context = new StaticApplicationContext().     BeanDefinition processorDefinition = new RootBeanDefinition(AsyncAnnotationBeanPostProcessor.class).     context.registerBeanDefinition("postProcessor", processorDefinition).     BeanDefinition executorDefinition = new RootBeanDefinition(ThreadPoolTaskExecutor.class).     executorDefinition.getPropertyValues().add("threadNamePrefix", "testExecutor").     context.registerBeanDefinition("myExecutor", executorDefinition).     BeanDefinition targetDefinition = new RootBeanDefinition(AsyncAnnotationBeanPostProcessorTests.TestBean.class).     context.registerBeanDefinition("target", targetDefinition).     context.refresh().     ITestBean testBean = context.getBean("target", ITestBean.class).     testBean.test().     testBean.await(3000).     Thread asyncThread = testBean.getThread().     assertTrue(asyncThread.getName().startsWith("testExecutor")).     context.close(). }
false;public;0;28;;@Test public void taskExecutorByBeanName() {     StaticApplicationContext context = new StaticApplicationContext().     BeanDefinition processorDefinition = new RootBeanDefinition(AsyncAnnotationBeanPostProcessor.class).     context.registerBeanDefinition("postProcessor", processorDefinition).     BeanDefinition executorDefinition = new RootBeanDefinition(ThreadPoolTaskExecutor.class).     executorDefinition.getPropertyValues().add("threadNamePrefix", "testExecutor").     context.registerBeanDefinition("myExecutor", executorDefinition).     BeanDefinition executorDefinition2 = new RootBeanDefinition(ThreadPoolTaskExecutor.class).     executorDefinition2.getPropertyValues().add("threadNamePrefix", "testExecutor2").     context.registerBeanDefinition("taskExecutor", executorDefinition2).     BeanDefinition targetDefinition = new RootBeanDefinition(AsyncAnnotationBeanPostProcessorTests.TestBean.class).     context.registerBeanDefinition("target", targetDefinition).     context.refresh().     ITestBean testBean = context.getBean("target", ITestBean.class).     testBean.test().     testBean.await(3000).     Thread asyncThread = testBean.getThread().     assertTrue(asyncThread.getName().startsWith("testExecutor2")).     context.close(). }
false;public;0;21;;@Test public void configuredThroughNamespace() {     GenericXmlApplicationContext context = new GenericXmlApplicationContext().     context.load(new ClassPathResource("taskNamespaceTests.xml", getClass())).     context.refresh().     ITestBean testBean = context.getBean("target", ITestBean.class).     testBean.test().     testBean.await(3000).     Thread asyncThread = testBean.getThread().     assertTrue(asyncThread.getName().startsWith("testExecutor")).     TestableAsyncUncaughtExceptionHandler exceptionHandler = context.getBean("exceptionHandler", TestableAsyncUncaughtExceptionHandler.class).     assertFalse("handler should not have been called yet", exceptionHandler.isCalled()).     testBean.failWithVoid().     exceptionHandler.await(3000).     Method m = ReflectionUtils.findMethod(TestBean.class, "failWithVoid").     exceptionHandler.assertCalledWith(m, UnsupportedOperationException.class).     context.close(). }
false;public;0;12;;@Test public void handleExceptionWithFuture() {     ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(ConfigWithExceptionHandler.class).     ITestBean testBean = context.getBean("target", ITestBean.class).     TestableAsyncUncaughtExceptionHandler exceptionHandler = context.getBean("exceptionHandler", TestableAsyncUncaughtExceptionHandler.class).     assertFalse("handler should not have been called yet", exceptionHandler.isCalled()).     Future<Object> result = testBean.failWithFuture().     assertFutureWithException(result, exceptionHandler). }
false;public;0;12;;@Test public void handleExceptionWithListenableFuture() {     ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(ConfigWithExceptionHandler.class).     ITestBean testBean = context.getBean("target", ITestBean.class).     TestableAsyncUncaughtExceptionHandler exceptionHandler = context.getBean("exceptionHandler", TestableAsyncUncaughtExceptionHandler.class).     assertFalse("handler should not have been called yet", exceptionHandler.isCalled()).     Future<Object> result = testBean.failWithListenableFuture().     assertFutureWithException(result, exceptionHandler). }
false;private;2;15;;private void assertFutureWithException(Future<Object> result, TestableAsyncUncaughtExceptionHandler exceptionHandler) {     try {         result.get().     } catch (InterruptedException ex) {         fail("Should not have failed with InterruptedException: " + ex).     } catch (ExecutionException ex) {         // expected         assertEquals("Wrong exception cause", UnsupportedOperationException.class, ex.getCause().getClass()).     }     assertFalse("handler should never be called with Future return type", exceptionHandler.isCalled()). }
false;public;0;16;;@Test public void handleExceptionWithCustomExceptionHandler() {     Method m = ReflectionUtils.findMethod(TestBean.class, "failWithVoid").     TestableAsyncUncaughtExceptionHandler exceptionHandler = new TestableAsyncUncaughtExceptionHandler().     BeanDefinition processorDefinition = new RootBeanDefinition(AsyncAnnotationBeanPostProcessor.class).     processorDefinition.getPropertyValues().add("exceptionHandler", exceptionHandler).     ConfigurableApplicationContext context = initContext(processorDefinition).     ITestBean testBean = context.getBean("target", ITestBean.class).     assertFalse("Handler should not have been called", exceptionHandler.isCalled()).     testBean.failWithVoid().     exceptionHandler.await(3000).     exceptionHandler.assertCalledWith(m, UnsupportedOperationException.class). }
false;public;0;21;;@Test public void exceptionHandlerThrowsUnexpectedException() {     Method m = ReflectionUtils.findMethod(TestBean.class, "failWithVoid").     TestableAsyncUncaughtExceptionHandler exceptionHandler = new TestableAsyncUncaughtExceptionHandler(true).     BeanDefinition processorDefinition = new RootBeanDefinition(AsyncAnnotationBeanPostProcessor.class).     processorDefinition.getPropertyValues().add("exceptionHandler", exceptionHandler).     processorDefinition.getPropertyValues().add("executor", new DirectExecutor()).     ConfigurableApplicationContext context = initContext(processorDefinition).     ITestBean testBean = context.getBean("target", ITestBean.class).     assertFalse("Handler should not have been called", exceptionHandler.isCalled()).     try {         testBean.failWithVoid().         exceptionHandler.assertCalledWith(m, UnsupportedOperationException.class).     } catch (Exception e) {         fail("No unexpected exception should have been received").     } }
false;private;1;8;;private ConfigurableApplicationContext initContext(BeanDefinition asyncAnnotationBeanPostProcessorDefinition) {     StaticApplicationContext context = new StaticApplicationContext().     BeanDefinition targetDefinition = new RootBeanDefinition(TestBean.class).     context.registerBeanDefinition("postProcessor", asyncAnnotationBeanPostProcessorDefinition).     context.registerBeanDefinition("target", targetDefinition).     context.refresh().     return context. }
false;;0;1;;Thread getThread().
false;;0;2;;@Async void test().
false;;0;1;;Future<Object> failWithFuture().
false;;0;1;;ListenableFuture<Object> failWithListenableFuture().
false;;0;1;;void failWithVoid().
false;;1;1;;void await(long timeout).
false;public;0;4;;@Override public Thread getThread() {     return this.thread. }
false;public;0;6;;@Override @Async public void test() {     this.thread = Thread.currentThread().     this.latch.countDown(). }
false;public;0;5;;@Async @Override public Future<Object> failWithFuture() {     throw new UnsupportedOperationException("failWithFuture"). }
false;public;0;5;;@Async @Override public ListenableFuture<Object> failWithListenableFuture() {     throw new UnsupportedOperationException("failWithListenableFuture"). }
false;public;0;5;;@Async @Override public void failWithVoid() {     throw new UnsupportedOperationException("failWithVoid"). }
false;public;1;9;;@Override public void await(long timeout) {     try {         this.latch.await(timeout, TimeUnit.MILLISECONDS).     } catch (Exception e) {         Thread.currentThread().interrupt().     } }
false;public;1;4;;@Override public void execute(Runnable r) {     r.run(). }
false;public;0;4;;@Bean public ITestBean target() {     return new TestBean(). }
false;public;0;4;;@Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {     return exceptionHandler(). }
false;public;0;4;;@Bean public TestableAsyncUncaughtExceptionHandler exceptionHandler() {     return new TestableAsyncUncaughtExceptionHandler(). }
