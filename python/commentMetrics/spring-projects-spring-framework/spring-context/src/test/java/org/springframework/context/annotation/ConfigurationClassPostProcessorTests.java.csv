# id;timestamp;commentText;codeText;commentWords;codeWords
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1328020251;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1362408075;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1377720874;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1381788683;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1382868136;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1383166924;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1383229570;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1384168190;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1386541456;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1387226855;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1390263990;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly();1394826024;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void testPostProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,test,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1394832851;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1394838293;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1394893697;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1395163215;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1395164006;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1395269053;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1398721027;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1406196805;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1407503729;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1413920443;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1414616581;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1416668785;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1417457126;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1426267101;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1426780215;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1429133871;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1434204449;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1437139427;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1440532331;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1455886852;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1464381249;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1467730834;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1468583965;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1480546052;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1481321350;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1482012648;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1482521352;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1482747787;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1483047480;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1485810955;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1487773939;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1488891103;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1491319023;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1500332089;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1501581926;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1515363776;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1523962712;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1530625997;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1532385723;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1532430234;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1536855799;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1543177639;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected();1549958959;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void enhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__		assertTrue(Arrays.asList(beanFactory.getDependentBeans("foo")).contains("bar"))__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo,assert,true,arrays,as,list,bean,factory,get,dependent,beans,foo,contains,bar
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1394832851;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1394838293;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1394893697;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1395163215;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1395164006;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1395269053;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1398721027;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1406196805;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1407503729;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1413920443;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1414616581;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1416668785;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1417457126;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1426267101;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1426780215;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1429133871;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1434204449;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1437139427;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1440532331;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1455886852;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1464381249;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1467730834;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1468583965;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1480546052;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1481321350;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1482012648;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1482521352;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1482747787;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1483047480;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1485810955;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1487773939;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1488891103;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1491319023;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1500332089;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1501581926;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1515363776;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1523962712;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1530625997;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1532385723;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1532430234;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1536855799;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1543177639;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void postProcessorIntrospectsInheritedDefinitionsCorrectly();1549958959;Tests whether a bean definition without a specified bean class is handled_correctly.;@Test_	public void postProcessorIntrospectsInheritedDefinitionsCorrectly() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		beanFactory.registerBeanDefinition("parent", new RootBeanDefinition(TestBean.class))__		beanFactory.registerBeanDefinition("child", new ChildBeanDefinition("parent"))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};tests,whether,a,bean,definition,without,a,specified,bean,class,is,handled,correctly;test,public,void,post,processor,introspects,inherited,definitions,correctly,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,bean,factory,register,bean,definition,parent,new,root,bean,definition,test,bean,class,bean,factory,register,bean,definition,child,new,child,bean,definition,parent,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1328020251;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1362408075;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1377720874;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1381788683;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1382868136;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1383166924;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1383229570;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1384168190;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1386541456;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1387226855;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1390263990;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected();1394826024;Enhanced {@link Configuration} classes are only necessary for respecting_certain bean semantics, like singleton-scoping, scoped proxies, etc._<p>Technically, {@link ConfigurationClassPostProcessor} could fail to enhance the_registered Configuration classes and many use cases would still work._Certain cases, however, like inter-bean singleton references would not._We test for such a case below, and in doing so prove that enhancement is_working.;@Test_	public void testEnhancementIsPresentBecauseSingletonSemanticsAreRespected() {_		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(SingletonBeanConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		Foo foo = beanFactory.getBean("foo", Foo.class)__		Bar bar = beanFactory.getBean("bar", Bar.class)__		assertSame(foo, bar.foo)__	};enhanced,link,configuration,classes,are,only,necessary,for,respecting,certain,bean,semantics,like,singleton,scoping,scoped,proxies,etc,p,technically,link,configuration,class,post,processor,could,fail,to,enhance,the,registered,configuration,classes,and,many,use,cases,would,still,work,certain,cases,however,like,inter,bean,singleton,references,would,not,we,test,for,such,a,case,below,and,in,doing,so,prove,that,enhancement,is,working;test,public,void,test,enhancement,is,present,because,singleton,semantics,are,respected,bean,factory,register,bean,definition,config,new,root,bean,definition,singleton,bean,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,foo,foo,bean,factory,get,bean,foo,foo,class,bar,bar,bean,factory,get,bean,bar,bar,class,assert,same,foo,bar,foo
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1328020251;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1362408075;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1377720874;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1381788683;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1382868136;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1383166924;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1383229570;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1384168190;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1386541456;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1387226855;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1390263990;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void testAlreadyLoadedConfigurationClasses();1394826024;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void testAlreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,test,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1394832851;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1394838293;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1394893697;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig",_				new RootBeanDefinition(UnloadedConfig.class.getName(), null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1395163215;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName(),_			null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1395164006;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName(),_			null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1395269053;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName(),_			null, null))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,null,null,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1398721027;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1406196805;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1407503729;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1413920443;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1414616581;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1416668785;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1417457126;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1426267101;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1426780215;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1429133871;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1434204449;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1437139427;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1440532331;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1455886852;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1464381249;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1467730834;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1468583965;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1480546052;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1481321350;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1482012648;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1482521352;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1482747787;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1483047480;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1485810955;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1487773939;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1488891103;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1491319023;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1500332089;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1501581926;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1515363776;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1523962712;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1530625997;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1532385723;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1532430234;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1536855799;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1543177639;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
ConfigurationClassPostProcessorTests -> @Test 	public void alreadyLoadedConfigurationClasses();1549958959;Tests the fix for SPR-5655, a special workaround that prefers reflection_over ASM if a bean class is already loaded.;@Test_	public void alreadyLoadedConfigurationClasses() {_		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()))__		beanFactory.registerBeanDefinition("loadedConfig", new RootBeanDefinition(LoadedConfig.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("foo")__		beanFactory.getBean("bar")__	};tests,the,fix,for,spr,5655,a,special,workaround,that,prefers,reflection,over,asm,if,a,bean,class,is,already,loaded;test,public,void,already,loaded,configuration,classes,bean,factory,register,bean,definition,unloaded,config,new,root,bean,definition,unloaded,config,class,get,name,bean,factory,register,bean,definition,loaded,config,new,root,bean,definition,loaded,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,foo,bean,factory,get,bean,bar
