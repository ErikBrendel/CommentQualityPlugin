commented;modifiers;parameterAmount;loc;comment;code
false;;0;1;;@Async("qMethod") void m() { }
false;;0;1;;void m() { }
false;;0;1;;@Async("qMethod") void m() { }
false;;0;1;;@Async void m() { }
false;;0;1;;void m() { }
false;public;0;25;;@Test @SuppressWarnings("unused") public void testGetExecutorQualifier() throws SecurityException, NoSuchMethodException {     AnnotationAsyncExecutionInterceptor i = new AnnotationAsyncExecutionInterceptor(null).     {         // method level         class C {              @Async("qMethod")             void m() {             }         }         assertThat(i.getExecutorQualifier(C.class.getDeclaredMethod("m")), is("qMethod")).     }     {         // class level         @Async("qClass")         class C {              void m() {             }         }         assertThat(i.getExecutorQualifier(C.class.getDeclaredMethod("m")), is("qClass")).     }     {         // method and class level -> method value overrides         @Async("qClass")         class C {              @Async("qMethod")             void m() {             }         }         assertThat(i.getExecutorQualifier(C.class.getDeclaredMethod("m")), is("qMethod")).     }     {         // method and class level -> method value, even if empty, overrides         @Async("qClass")         class C {              @Async             void m() {             }         }         assertThat(i.getExecutorQualifier(C.class.getDeclaredMethod("m")), is("")).     }     {         // meta annotation with qualifier         @MyAsync         class C {              void m() {             }         }         assertThat(i.getExecutorQualifier(C.class.getDeclaredMethod("m")), is("qMeta")).     } }
