commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void setupSpringValidatorAdapter() {     messageSource.addMessage("Size", Locale.ENGLISH, "Size of {0} is must be between {2} and {1}").     messageSource.addMessage("Same", Locale.ENGLISH, "{2} must be same value as {1}").     messageSource.addMessage("password", Locale.ENGLISH, "Password").     messageSource.addMessage("confirmPassword", Locale.ENGLISH, "Password(Confirm)"). }
false;public;0;5;;@Test public void testUnwrap() {     Validator nativeValidator = validatorAdapter.unwrap(Validator.class).     assertSame(this.nativeValidator, nativeValidator). }
false;public;0;17;;// SPR-13406 @Test public void testNoStringArgumentValue() {     TestBean testBean = new TestBean().     testBean.setPassword("pass").     testBean.setConfirmPassword("pass").     BeanPropertyBindingResult errors = new BeanPropertyBindingResult(testBean, "testBean").     validatorAdapter.validate(testBean, errors).     assertThat(errors.getFieldErrorCount("password"), is(1)).     assertThat(errors.getFieldValue("password"), is("pass")).     FieldError error = errors.getFieldError("password").     assertNotNull(error).     assertThat(messageSource.getMessage(error, Locale.ENGLISH), is("Size of Password is must be between 8 and 128")).     assertTrue(error.contains(ConstraintViolation.class)).     assertThat(error.unwrap(ConstraintViolation.class).getPropertyPath().toString(), is("password")). }
false;public;0;17;;// SPR-13406 @Test public void testApplyMessageSourceResolvableToStringArgumentValueWithResolvedLogicalFieldName() {     TestBean testBean = new TestBean().     testBean.setPassword("password").     testBean.setConfirmPassword("PASSWORD").     BeanPropertyBindingResult errors = new BeanPropertyBindingResult(testBean, "testBean").     validatorAdapter.validate(testBean, errors).     assertThat(errors.getFieldErrorCount("password"), is(1)).     assertThat(errors.getFieldValue("password"), is("password")).     FieldError error = errors.getFieldError("password").     assertNotNull(error).     assertThat(messageSource.getMessage(error, Locale.ENGLISH), is("Password must be same value as Password(Confirm)")).     assertTrue(error.contains(ConstraintViolation.class)).     assertThat(error.unwrap(ConstraintViolation.class).getPropertyPath().toString(), is("password")). }
false;public;0;23;;// SPR-13406 @Test public void testApplyMessageSourceResolvableToStringArgumentValueWithUnresolvedLogicalFieldName() {     TestBean testBean = new TestBean().     testBean.setEmail("test@example.com").     testBean.setConfirmEmail("TEST@EXAMPLE.IO").     BeanPropertyBindingResult errors = new BeanPropertyBindingResult(testBean, "testBean").     validatorAdapter.validate(testBean, errors).     assertThat(errors.getFieldErrorCount("email"), is(1)).     assertThat(errors.getFieldValue("email"), is("test@example.com")).     assertThat(errors.getFieldErrorCount("confirmEmail"), is(1)).     FieldError error1 = errors.getFieldError("email").     FieldError error2 = errors.getFieldError("confirmEmail").     assertNotNull(error1).     assertNotNull(error2).     assertThat(messageSource.getMessage(error1, Locale.ENGLISH), is("email must be same value as confirmEmail")).     assertThat(messageSource.getMessage(error2, Locale.ENGLISH), is("Email required")).     assertTrue(error1.contains(ConstraintViolation.class)).     assertThat(error1.unwrap(ConstraintViolation.class).getPropertyPath().toString(), is("email")).     assertTrue(error2.contains(ConstraintViolation.class)).     assertThat(error2.unwrap(ConstraintViolation.class).getPropertyPath().toString(), is("confirmEmail")). }
false;public;0;25;;// SPR-15123 @Test public void testApplyMessageSourceResolvableToStringArgumentValueWithAlwaysUseMessageFormat() {     messageSource.setAlwaysUseMessageFormat(true).     TestBean testBean = new TestBean().     testBean.setEmail("test@example.com").     testBean.setConfirmEmail("TEST@EXAMPLE.IO").     BeanPropertyBindingResult errors = new BeanPropertyBindingResult(testBean, "testBean").     validatorAdapter.validate(testBean, errors).     assertThat(errors.getFieldErrorCount("email"), is(1)).     assertThat(errors.getFieldValue("email"), is("test@example.com")).     assertThat(errors.getFieldErrorCount("confirmEmail"), is(1)).     FieldError error1 = errors.getFieldError("email").     FieldError error2 = errors.getFieldError("confirmEmail").     assertNotNull(error1).     assertNotNull(error2).     assertThat(messageSource.getMessage(error1, Locale.ENGLISH), is("email must be same value as confirmEmail")).     assertThat(messageSource.getMessage(error2, Locale.ENGLISH), is("Email required")).     assertTrue(error1.contains(ConstraintViolation.class)).     assertThat(error1.unwrap(ConstraintViolation.class).getPropertyPath().toString(), is("email")).     assertTrue(error2.contains(ConstraintViolation.class)).     assertThat(error2.unwrap(ConstraintViolation.class).getPropertyPath().toString(), is("confirmEmail")). }
false;public;0;11;;// SPR-16177 @Test public void testWithList() {     Parent parent = new Parent().     parent.setName("Parent whit list").     parent.getChildList().addAll(createChildren(parent)).     BeanPropertyBindingResult errors = new BeanPropertyBindingResult(parent, "parent").     validatorAdapter.validate(parent, errors).     assertTrue(errors.getErrorCount() > 0). }
false;public;0;11;;// SPR-16177 @Test public void testWithSet() {     Parent parent = new Parent().     parent.setName("Parent with set").     parent.getChildSet().addAll(createChildren(parent)).     BeanPropertyBindingResult errors = new BeanPropertyBindingResult(parent, "parent").     validatorAdapter.validate(parent, errors).     assertTrue(errors.getErrorCount() > 0). }
false;private;1;13;;private List<Child> createChildren(Parent parent) {     Child child1 = new Child().     child1.setName("Child1").     child1.setAge(null).     child1.setParent(parent).     Child child2 = new Child().     child2.setName(null).     child2.setAge(17).     child2.setParent(parent).     return Arrays.asList(child1, child2). }
false;public;0;3;;public String getPassword() {     return password. }
false;public;1;3;;public void setPassword(String password) {     this.password = password. }
false;public;0;3;;public String getConfirmPassword() {     return confirmPassword. }
false;public;1;3;;public void setConfirmPassword(String confirmPassword) {     this.confirmPassword = confirmPassword. }
false;public;0;3;;public String getEmail() {     return email. }
false;public;1;3;;public void setEmail(String email) {     this.email = email. }
false;public;0;3;;public String getConfirmEmail() {     return confirmEmail. }
false;public;1;3;;public void setConfirmEmail(String confirmEmail) {     this.confirmEmail = confirmEmail. }
false;public;1;5;;public void initialize(Same constraintAnnotation) {     field = constraintAnnotation.field().     comparingField = constraintAnnotation.comparingField().     message = constraintAnnotation.message(). }
false;public;2;16;;public boolean isValid(Object value, ConstraintValidatorContext context) {     BeanWrapper beanWrapper = new BeanWrapperImpl(value).     Object fieldValue = beanWrapper.getPropertyValue(field).     Object comparingFieldValue = beanWrapper.getPropertyValue(comparingField).     boolean matched = ObjectUtils.nullSafeEquals(fieldValue, comparingFieldValue).     if (matched) {         return true.     } else {         context.disableDefaultConstraintViolation().         context.buildConstraintViolationWithTemplate(message).addPropertyNode(field).addConstraintViolation().         return false.     } }
false;public;0;3;;public Integer getId() {     return id. }
false;public;1;3;;public void setId(Integer id) {     this.id = id. }
false;public;0;3;;public String getName() {     return name. }
false;public;1;3;;public void setName(String name) {     this.name = name. }
false;public;0;3;;public Set<Child> getChildSet() {     return childSet. }
false;public;1;3;;public void setChildSet(Set<Child> childSet) {     this.childSet = childSet. }
false;public;0;3;;public List<Child> getChildList() {     return childList. }
false;public;1;3;;public void setChildList(List<Child> childList) {     this.childList = childList. }
false;public;0;3;;public Integer getId() {     return id. }
false;public;1;3;;public void setId(Integer id) {     this.id = id. }
false;public;0;3;;public String getName() {     return name. }
false;public;1;3;;public void setName(String name) {     this.name = name. }
false;public;0;3;;public Integer getAge() {     return age. }
false;public;1;3;;public void setAge(Integer age) {     this.age = age. }
false;public;0;3;;public Parent getParent() {     return parent. }
false;public;1;3;;public void setParent(Parent parent) {     this.parent = parent. }
false;public;1;3;;@Override public void initialize(AnythingValid constraintAnnotation) { }
false;public;2;19;;@Override public boolean isValid(Object value, ConstraintValidatorContext context) {     List<Field> fieldsErros = new ArrayList<>().     Arrays.asList(value.getClass().getDeclaredFields()).forEach(f -> {         f.setAccessible(true).         try {             if (!f.getName().equals(ID) && f.get(value) == null) {                 fieldsErros.add(f).                 context.buildConstraintViolationWithTemplate(context.getDefaultConstraintMessageTemplate()).addPropertyNode(f.getName()).addConstraintViolation().             }         } catch (IllegalAccessException ex) {             throw new IllegalStateException(ex).         }     }).     return fieldsErros.isEmpty(). }
