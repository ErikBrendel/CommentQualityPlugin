commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;6;;@Override protected AsyncListenableTaskExecutor buildExecutor() {     scheduler.setThreadNamePrefix(THREAD_NAME_PREFIX).     scheduler.afterPropertiesSet().     return scheduler. }
false;public;0;9;;@Test public void executeFailingRunnableWithErrorHandler() {     TestTask task = new TestTask(0).     TestErrorHandler errorHandler = new TestErrorHandler(1).     scheduler.setErrorHandler(errorHandler).     scheduler.execute(task).     await(errorHandler).     assertNotNull(errorHandler.lastError). }
false;public;0;11;;@Test public void submitFailingRunnableWithErrorHandler() throws Exception {     TestTask task = new TestTask(0).     TestErrorHandler errorHandler = new TestErrorHandler(1).     scheduler.setErrorHandler(errorHandler).     Future<?> future = scheduler.submit(task).     Object result = future.get(1000, TimeUnit.MILLISECONDS).     assertTrue(future.isDone()).     assertNull(result).     assertNotNull(errorHandler.lastError). }
false;public;0;11;;@Test public void submitFailingCallableWithErrorHandler() throws Exception {     TestCallable task = new TestCallable(0).     TestErrorHandler errorHandler = new TestErrorHandler(1).     scheduler.setErrorHandler(errorHandler).     Future<String> future = scheduler.submit(task).     Object result = future.get(1000, TimeUnit.MILLISECONDS).     assertTrue(future.isDone()).     assertNull(result).     assertNotNull(errorHandler.lastError). }
false;public;0;9;;@Test public void scheduleOneTimeTask() throws Exception {     TestTask task = new TestTask(1).     Future<?> future = scheduler.schedule(task, new Date()).     Object result = future.get(1000, TimeUnit.MILLISECONDS).     assertNull(result).     assertTrue(future.isDone()).     assertThreadNamePrefix(task). }
false;public;0;12;;@Test(expected = ExecutionException.class) public void scheduleOneTimeFailingTaskWithoutErrorHandler() throws Exception {     TestTask task = new TestTask(0).     Future<?> future = scheduler.schedule(task, new Date()).     try {         future.get(1000, TimeUnit.MILLISECONDS).     } catch (ExecutionException ex) {         assertTrue(future.isDone()).         throw ex.     } }
false;public;0;11;;@Test public void scheduleOneTimeFailingTaskWithErrorHandler() throws Exception {     TestTask task = new TestTask(0).     TestErrorHandler errorHandler = new TestErrorHandler(1).     scheduler.setErrorHandler(errorHandler).     Future<?> future = scheduler.schedule(task, new Date()).     Object result = future.get(1000, TimeUnit.MILLISECONDS).     assertTrue(future.isDone()).     assertNull(result).     assertNotNull(errorHandler.lastError). }
false;public;0;9;;@Test public void scheduleTriggerTask() throws Exception {     TestTask task = new TestTask(3).     Future<?> future = scheduler.schedule(task, new TestTrigger(3)).     Object result = future.get(1000, TimeUnit.MILLISECONDS).     assertNull(result).     await(task).     assertThreadNamePrefix(task). }
false;public;0;6;;@Test public void scheduleMultipleTriggerTasks() throws Exception {     for (int i = 0. i < 1000. i++) {         scheduleTriggerTask().     } }
false;private;1;3;;private void assertThreadNamePrefix(TestTask task) {     assertEquals(THREAD_NAME_PREFIX, task.lastThread.getName().substring(0, THREAD_NAME_PREFIX.length())). }
false;private;1;3;;private void await(TestTask task) {     await(task.latch). }
false;private;1;3;;private void await(TestErrorHandler errorHandler) {     await(errorHandler.latch). }
false;private;1;9;;private void await(CountDownLatch latch) {     try {         latch.await(1000, TimeUnit.MILLISECONDS).     } catch (InterruptedException ex) {         throw new IllegalStateException(ex).     }     assertEquals("latch did not count down,", 0, latch.getCount()). }
false;public;0;8;;@Override public void run() {     lastThread = Thread.currentThread().     if (actualRunCount.incrementAndGet() > expectedRunCount) {         throw new RuntimeException("intentional test failure").     }     latch.countDown(). }
false;public;0;7;;@Override public String call() throws Exception {     if (actualRunCount.incrementAndGet() > expectedRunCount) {         throw new RuntimeException("intentional test failure").     }     return Thread.currentThread().getName(). }
false;public;1;5;;@Override public void handleError(Throwable t) {     this.lastError = t.     this.latch.countDown(). }
false;public;1;7;;@Override public Date nextExecutionTime(TriggerContext triggerContext) {     if (this.actualRunCount.incrementAndGet() > this.maxRunCount) {         return null.     }     return new Date(). }
