# id;timestamp;commentText;codeText;commentWords;codeWords
BeanMethodPolymorphismTests -> @Test 	public void beanMethodsDetectedOnSuperClass();1328020251;Tests that polymorphic Configuration classes need not explicitly redeclare the_{@link Configuration} annotation. This respects the {@link Inherited} nature_of the Configuration annotation, even though it's being detected via ASM.;@Test_	public void beanMethodsDetectedOnSuperClass() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(Config.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("testBean", TestBean.class)__	};tests,that,polymorphic,configuration,classes,need,not,explicitly,redeclare,the,link,configuration,annotation,this,respects,the,link,inherited,nature,of,the,configuration,annotation,even,though,it,s,being,detected,via,asm;test,public,void,bean,methods,detected,on,super,class,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,test,bean,test,bean,class
BeanMethodPolymorphismTests -> @Test 	public void beanMethodsDetectedOnSuperClass();1362408075;Tests that polymorphic Configuration classes need not explicitly redeclare the_{@link Configuration} annotation. This respects the {@link Inherited} nature_of the Configuration annotation, even though it's being detected via ASM.;@Test_	public void beanMethodsDetectedOnSuperClass() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(Config.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("testBean", TestBean.class)__	};tests,that,polymorphic,configuration,classes,need,not,explicitly,redeclare,the,link,configuration,annotation,this,respects,the,link,inherited,nature,of,the,configuration,annotation,even,though,it,s,being,detected,via,asm;test,public,void,bean,methods,detected,on,super,class,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,test,bean,test,bean,class
BeanMethodPolymorphismTests -> @Test 	public void beanMethodsDetectedOnSuperClass();1383004280;Tests that polymorphic Configuration classes need not explicitly redeclare the_{@link Configuration} annotation. This respects the {@link Inherited} nature_of the Configuration annotation, even though it's being detected via ASM.;@Test_	public void beanMethodsDetectedOnSuperClass() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(Config.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("testBean", TestBean.class)__	};tests,that,polymorphic,configuration,classes,need,not,explicitly,redeclare,the,link,configuration,annotation,this,respects,the,link,inherited,nature,of,the,configuration,annotation,even,though,it,s,being,detected,via,asm;test,public,void,bean,methods,detected,on,super,class,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,test,bean,test,bean,class
BeanMethodPolymorphismTests -> @Test 	public void beanMethodsDetectedOnSuperClass();1383520795;Tests that polymorphic Configuration classes need not explicitly redeclare the_{@link Configuration} annotation. This respects the {@link Inherited} nature_of the Configuration annotation, even though it's being detected via ASM.;@Test_	public void beanMethodsDetectedOnSuperClass() {_		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()__		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(Config.class))__		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor()__		pp.postProcessBeanFactory(beanFactory)__		beanFactory.getBean("testBean", TestBean.class)__	};tests,that,polymorphic,configuration,classes,need,not,explicitly,redeclare,the,link,configuration,annotation,this,respects,the,link,inherited,nature,of,the,configuration,annotation,even,though,it,s,being,detected,via,asm;test,public,void,bean,methods,detected,on,super,class,default,listable,bean,factory,bean,factory,new,default,listable,bean,factory,bean,factory,register,bean,definition,config,new,root,bean,definition,config,class,configuration,class,post,processor,pp,new,configuration,class,post,processor,pp,post,process,bean,factory,bean,factory,bean,factory,get,bean,test,bean,test,bean,class
BeanMethodPolymorphismTests -> @Test 	public void beanMethodShadowing();1328020251;When inheritance is not involved, it is still possible to override a bean method from_the container's point of view. This is not strictly 'overloading' of a method per se,_so it's referred to here as 'shadowing' to distinguish the difference.;@Test_	public void beanMethodShadowing() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ShadowConfig.class)__		assertThat(ctx.getBean(String.class), equalTo("shadow"))__	};when,inheritance,is,not,involved,it,is,still,possible,to,override,a,bean,method,from,the,container,s,point,of,view,this,is,not,strictly,overloading,of,a,method,per,se,so,it,s,referred,to,here,as,shadowing,to,distinguish,the,difference;test,public,void,bean,method,shadowing,annotation,config,application,context,ctx,new,annotation,config,application,context,shadow,config,class,assert,that,ctx,get,bean,string,class,equal,to,shadow
BeanMethodPolymorphismTests -> @Test 	public void beanMethodShadowing();1362408075;When inheritance is not involved, it is still possible to override a bean method from_the container's point of view. This is not strictly 'overloading' of a method per se,_so it's referred to here as 'shadowing' to distinguish the difference.;@Test_	public void beanMethodShadowing() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ShadowConfig.class)__		assertThat(ctx.getBean(String.class), equalTo("shadow"))__	};when,inheritance,is,not,involved,it,is,still,possible,to,override,a,bean,method,from,the,container,s,point,of,view,this,is,not,strictly,overloading,of,a,method,per,se,so,it,s,referred,to,here,as,shadowing,to,distinguish,the,difference;test,public,void,bean,method,shadowing,annotation,config,application,context,ctx,new,annotation,config,application,context,shadow,config,class,assert,that,ctx,get,bean,string,class,equal,to,shadow
BeanMethodPolymorphismTests -> @Test 	public void beanMethodShadowing();1383004280;When inheritance is not involved, it is still possible to override a bean method from_the container's point of view. This is not strictly 'overloading' of a method per se,_so it's referred to here as 'shadowing' to distinguish the difference.;@Test_	public void beanMethodShadowing() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ShadowConfig.class)__		assertThat(ctx.getBean(String.class), equalTo("shadow"))__	};when,inheritance,is,not,involved,it,is,still,possible,to,override,a,bean,method,from,the,container,s,point,of,view,this,is,not,strictly,overloading,of,a,method,per,se,so,it,s,referred,to,here,as,shadowing,to,distinguish,the,difference;test,public,void,bean,method,shadowing,annotation,config,application,context,ctx,new,annotation,config,application,context,shadow,config,class,assert,that,ctx,get,bean,string,class,equal,to,shadow
BeanMethodPolymorphismTests -> @Test 	public void beanMethodShadowing();1383520795;When inheritance is not involved, it is still possible to override a bean method from_the container's point of view. This is not strictly 'overloading' of a method per se,_so it's referred to here as 'shadowing' to distinguish the difference.;@Test_	public void beanMethodShadowing() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ShadowConfig.class)__		assertThat(ctx.getBean(String.class), equalTo("shadow"))__	};when,inheritance,is,not,involved,it,is,still,possible,to,override,a,bean,method,from,the,container,s,point,of,view,this,is,not,strictly,overloading,of,a,method,per,se,so,it,s,referred,to,here,as,shadowing,to,distinguish,the,difference;test,public,void,bean,method,shadowing,annotation,config,application,context,ctx,new,annotation,config,application,context,shadow,config,class,assert,that,ctx,get,bean,string,class,equal,to,shadow
BeanMethodPolymorphismTests -> @Test 	public void beanMethodShadowing();1383604440;When inheritance is not involved, it is still possible to override a bean method from_the container's point of view. This is not strictly 'overloading' of a method per se,_so it's referred to here as 'shadowing' to distinguish the difference.;@Test_	public void beanMethodShadowing() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ShadowConfig.class)__		assertThat(ctx.getBean(String.class), equalTo("shadow"))__	};when,inheritance,is,not,involved,it,is,still,possible,to,override,a,bean,method,from,the,container,s,point,of,view,this,is,not,strictly,overloading,of,a,method,per,se,so,it,s,referred,to,here,as,shadowing,to,distinguish,the,difference;test,public,void,bean,method,shadowing,annotation,config,application,context,ctx,new,annotation,config,application,context,shadow,config,class,assert,that,ctx,get,bean,string,class,equal,to,shadow
BeanMethodPolymorphismTests -> @Test 	public void beanMethodShadowing();1383610191;When inheritance is not involved, it is still possible to override a bean method from_the container's point of view. This is not strictly 'overloading' of a method per se,_so it's referred to here as 'shadowing' to distinguish the difference.;@Test_	public void beanMethodShadowing() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ShadowConfig.class)__		assertThat(ctx.getBean(String.class), equalTo("shadow"))__	};when,inheritance,is,not,involved,it,is,still,possible,to,override,a,bean,method,from,the,container,s,point,of,view,this,is,not,strictly,overloading,of,a,method,per,se,so,it,s,referred,to,here,as,shadowing,to,distinguish,the,difference;test,public,void,bean,method,shadowing,annotation,config,application,context,ctx,new,annotation,config,application,context,shadow,config,class,assert,that,ctx,get,bean,string,class,equal,to,shadow
BeanMethodPolymorphismTests -> @Test 	public void beanMethodShadowing();1384168190;When inheritance is not involved, it is still possible to override a bean method from_the container's point of view. This is not strictly 'overloading' of a method per se,_so it's referred to here as 'shadowing' to distinguish the difference.;@Test_	public void beanMethodShadowing() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ShadowConfig.class)__		assertThat(ctx.getBean(String.class), equalTo("shadow"))__	};when,inheritance,is,not,involved,it,is,still,possible,to,override,a,bean,method,from,the,container,s,point,of,view,this,is,not,strictly,overloading,of,a,method,per,se,so,it,s,referred,to,here,as,shadowing,to,distinguish,the,difference;test,public,void,bean,method,shadowing,annotation,config,application,context,ctx,new,annotation,config,application,context,shadow,config,class,assert,that,ctx,get,bean,string,class,equal,to,shadow
BeanMethodPolymorphismTests -> @Test 	public void beanMethodShadowing();1385991737;When inheritance is not involved, it is still possible to override a bean method from_the container's point of view. This is not strictly 'overloading' of a method per se,_so it's referred to here as 'shadowing' to distinguish the difference.;@Test_	public void beanMethodShadowing() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ShadowConfig.class)__		assertThat(ctx.getBean(String.class), equalTo("shadow"))__	};when,inheritance,is,not,involved,it,is,still,possible,to,override,a,bean,method,from,the,container,s,point,of,view,this,is,not,strictly,overloading,of,a,method,per,se,so,it,s,referred,to,here,as,shadowing,to,distinguish,the,difference;test,public,void,bean,method,shadowing,annotation,config,application,context,ctx,new,annotation,config,application,context,shadow,config,class,assert,that,ctx,get,bean,string,class,equal,to,shadow
BeanMethodPolymorphismTests -> @Test 	public void beanMethodShadowing();1393419926;When inheritance is not involved, it is still possible to override a bean method from_the container's point of view. This is not strictly 'overloading' of a method per se,_so it's referred to here as 'shadowing' to distinguish the difference.;@Test_	public void beanMethodShadowing() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ShadowConfig.class)__		assertThat(ctx.getBean(String.class), equalTo("shadow"))__	};when,inheritance,is,not,involved,it,is,still,possible,to,override,a,bean,method,from,the,container,s,point,of,view,this,is,not,strictly,overloading,of,a,method,per,se,so,it,s,referred,to,here,as,shadowing,to,distinguish,the,difference;test,public,void,bean,method,shadowing,annotation,config,application,context,ctx,new,annotation,config,application,context,shadow,config,class,assert,that,ctx,get,bean,string,class,equal,to,shadow
BeanMethodPolymorphismTests -> @Test 	public void beanMethodShadowing();1398637984;When inheritance is not involved, it is still possible to override a bean method from_the container's point of view. This is not strictly 'overloading' of a method per se,_so it's referred to here as 'shadowing' to distinguish the difference.;@Test_	public void beanMethodShadowing() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ShadowConfig.class)__		assertThat(ctx.getBean(String.class), equalTo("shadow"))__	};when,inheritance,is,not,involved,it,is,still,possible,to,override,a,bean,method,from,the,container,s,point,of,view,this,is,not,strictly,overloading,of,a,method,per,se,so,it,s,referred,to,here,as,shadowing,to,distinguish,the,difference;test,public,void,bean,method,shadowing,annotation,config,application,context,ctx,new,annotation,config,application,context,shadow,config,class,assert,that,ctx,get,bean,string,class,equal,to,shadow
BeanMethodPolymorphismTests -> @Test 	public void beanMethodShadowing();1408056914;When inheritance is not involved, it is still possible to override a bean method from_the container's point of view. This is not strictly 'overloading' of a method per se,_so it's referred to here as 'shadowing' to distinguish the difference.;@Test_	public void beanMethodShadowing() {_		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ShadowConfig.class)__		assertThat(ctx.getBean(String.class), equalTo("shadow"))__	};when,inheritance,is,not,involved,it,is,still,possible,to,override,a,bean,method,from,the,container,s,point,of,view,this,is,not,strictly,overloading,of,a,method,per,se,so,it,s,referred,to,here,as,shadowing,to,distinguish,the,difference;test,public,void,bean,method,shadowing,annotation,config,application,context,ctx,new,annotation,config,application,context,shadow,config,class,assert,that,ctx,get,bean,string,class,equal,to,shadow
