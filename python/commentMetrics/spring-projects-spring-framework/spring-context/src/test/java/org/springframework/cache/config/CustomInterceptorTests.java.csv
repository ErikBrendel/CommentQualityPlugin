commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void setup() {     this.ctx = new AnnotationConfigApplicationContext(EnableCachingConfig.class).     this.cs = ctx.getBean("service", CacheableService.class). }
false;public;0;4;;@After public void tearDown() {     this.ctx.close(). }
false;public;0;7;;@Test public void onlyOneInterceptorIsAvailable() {     Map<String, CacheInterceptor> interceptors = this.ctx.getBeansOfType(CacheInterceptor.class).     assertEquals("Only one interceptor should be defined", 1, interceptors.size()).     CacheInterceptor interceptor = interceptors.values().iterator().next().     assertEquals("Custom interceptor not defined", TestCacheInterceptor.class, interceptor.getClass()). }
false;public;0;5;;@Test public void customInterceptorAppliesWithRuntimeException() {     Object o = this.cs.throwUnchecked(0L).     // See TestCacheInterceptor     assertEquals(55L, o). }
false;public;0;14;;@Test public void customInterceptorAppliesWithCheckedException() {     try {         this.cs.throwChecked(0L).         fail("Should have failed").     } catch (RuntimeException e) {         assertNotNull("missing original exception", e.getCause()).         assertEquals(IOException.class, e.getCause().getClass()).     } catch (Exception e) {         fail("Wrong exception type " + e).     } }
false;public;0;4;;@Bean public CacheManager cacheManager() {     return CacheTestUtils.createSimpleCacheManager("testCache", "primary", "secondary"). }
false;public;0;4;;@Bean public CacheableService<?> service() {     return new DefaultCacheableService(). }
false;public;1;7;;@Bean public CacheInterceptor cacheInterceptor(CacheOperationSource cacheOperationSource) {     CacheInterceptor cacheInterceptor = new TestCacheInterceptor().     cacheInterceptor.setCacheManager(cacheManager()).     cacheInterceptor.setCacheOperationSources(cacheOperationSource).     return cacheInterceptor. }
false;protected;1;16;;@Override protected Object invokeOperation(CacheOperationInvoker invoker) {     try {         return super.invokeOperation(invoker).     } catch (CacheOperationInvoker.ThrowableWrapper e) {         Throwable original = e.getOriginal().         if (original.getClass() == UnsupportedOperationException.class) {             return 55L.         } else {             throw new CacheOperationInvoker.ThrowableWrapper(new RuntimeException("wrapping original", original)).         }     } }
