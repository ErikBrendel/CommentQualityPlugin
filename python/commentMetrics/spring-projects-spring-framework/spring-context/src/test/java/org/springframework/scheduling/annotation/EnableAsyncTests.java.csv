commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Test public void proxyingOccurs() {     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(AsyncConfig.class).     ctx.refresh().     AsyncBean asyncBean = ctx.getBean(AsyncBean.class).     assertThat(AopUtils.isAopProxy(asyncBean), is(true)).     asyncBean.work().     ctx.close(). }
false;public;0;12;;@Test public void proxyingOccursWithMockitoStub() {     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(AsyncConfigWithMockito.class, AsyncBeanUser.class).     ctx.refresh().     AsyncBeanUser asyncBeanUser = ctx.getBean(AsyncBeanUser.class).     AsyncBean asyncBean = asyncBeanUser.getAsyncBean().     assertThat(AopUtils.isAopProxy(asyncBean), is(true)).     asyncBean.work().     ctx.close(). }
false;public;0;14;;@Test public void properExceptionForExistingProxyDependencyMismatch() {     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(AsyncConfig.class, AsyncBeanWithInterface.class, AsyncBeanUser.class).     try {         ctx.refresh().         fail("Should have thrown UnsatisfiedDependencyException").     } catch (UnsatisfiedDependencyException ex) {         assertTrue(ex.getCause() instanceof BeanNotOfRequiredTypeException).     }     ctx.close(). }
false;public;0;15;;@Test public void properExceptionForResolvedProxyDependencyMismatch() {     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(AsyncConfig.class, AsyncBeanUser.class, AsyncBeanWithInterface.class).     try {         ctx.refresh().         fail("Should have thrown UnsatisfiedDependencyException").     } catch (UnsatisfiedDependencyException ex) {         assertTrue(ex.getCause() instanceof BeanNotOfRequiredTypeException).     }     ctx.close(). }
false;public;0;18;;@Test public void withAsyncBeanWithExecutorQualifiedByName() throws ExecutionException, InterruptedException {     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(AsyncWithExecutorQualifiedByNameConfig.class).     ctx.refresh().     AsyncBeanWithExecutorQualifiedByName asyncBean = ctx.getBean(AsyncBeanWithExecutorQualifiedByName.class).     Future<Thread> workerThread0 = asyncBean.work0().     assertThat(workerThread0.get().getName(), not(anyOf(startsWith("e1-"), startsWith("otherExecutor-")))).     Future<Thread> workerThread = asyncBean.work().     assertThat(workerThread.get().getName(), startsWith("e1-")).     Future<Thread> workerThread2 = asyncBean.work2().     assertThat(workerThread2.get().getName(), startsWith("otherExecutor-")).     Future<Thread> workerThread3 = asyncBean.work3().     assertThat(workerThread3.get().getName(), startsWith("otherExecutor-")).     ctx.close(). }
false;public;0;11;;@Test public void asyncProcessorIsOrderedLowestPrecedenceByDefault() {     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(AsyncConfig.class).     ctx.refresh().     AsyncAnnotationBeanPostProcessor bpp = ctx.getBean(AsyncAnnotationBeanPostProcessor.class).     assertThat(bpp.getOrder(), is(Ordered.LOWEST_PRECEDENCE)).     ctx.close(). }
false;public;0;11;;@Test public void orderAttributeIsPropagated() {     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(OrderedAsyncConfig.class).     ctx.refresh().     AsyncAnnotationBeanPostProcessor bpp = ctx.getBean(AsyncAnnotationBeanPostProcessor.class).     assertThat(bpp.getOrder(), is(Ordered.HIGHEST_PRECEDENCE)).     ctx.close(). }
false;public;0;19;;@Test public void customAsyncAnnotationIsPropagated() {     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(CustomAsyncAnnotationConfig.class, CustomAsyncBean.class).     ctx.refresh().     Object bean = ctx.getBean(CustomAsyncBean.class).     assertTrue(AopUtils.isAopProxy(bean)).     boolean isAsyncAdvised = false.     for (Advisor advisor : ((Advised) bean).getAdvisors()) {         if (advisor instanceof AsyncAnnotationAdvisor) {             isAsyncAdvised = true.             break.         }     }     assertTrue("bean was not async advised as expected", isAsyncAdvised).     ctx.close(). }
true;public;0;7;/**  * Fails with classpath errors on trying to classload AnnotationAsyncExecutionAspect  */ ;/**  * Fails with classpath errors on trying to classload AnnotationAsyncExecutionAspect  */ @Test(expected = BeanDefinitionStoreException.class) public void aspectModeAspectJAttemptsToRegisterAsyncAspect() {     @SuppressWarnings("resource")     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(AspectJAsyncAnnotationConfig.class).     ctx.refresh(). }
false;public;0;17;;@Test public void customExecutorBean() throws InterruptedException {     // Arrange     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(CustomExecutorBean.class).     ctx.refresh().     AsyncBean asyncBean = ctx.getBean(AsyncBean.class).     // Act     asyncBean.work().     // Assert     Awaitility.await().atMost(500, TimeUnit.MILLISECONDS).pollInterval(10, TimeUnit.MILLISECONDS).until(() -> asyncBean.getThreadOfExecution() != null).     assertThat(asyncBean.getThreadOfExecution().getName(), startsWith("Custom-")).     ctx.close(). }
false;public;0;17;;@Test public void customExecutorConfig() {     // Arrange     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(CustomExecutorConfig.class).     ctx.refresh().     AsyncBean asyncBean = ctx.getBean(AsyncBean.class).     // Act     asyncBean.work().     // Assert     Awaitility.await().atMost(500, TimeUnit.MILLISECONDS).pollInterval(10, TimeUnit.MILLISECONDS).until(() -> asyncBean.getThreadOfExecution() != null).     assertThat(asyncBean.getThreadOfExecution().getName(), startsWith("Custom-")).     ctx.close(). }
false;public;0;20;;@Test public void customExecutorConfigWithThrowsException() {     // Arrange     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(CustomExecutorConfig.class).     ctx.refresh().     AsyncBean asyncBean = ctx.getBean(AsyncBean.class).     Method method = ReflectionUtils.findMethod(AsyncBean.class, "fail").     TestableAsyncUncaughtExceptionHandler exceptionHandler = (TestableAsyncUncaughtExceptionHandler) ctx.getBean("exceptionHandler").     assertFalse("handler should not have been called yet", exceptionHandler.isCalled()).     // Act     asyncBean.fail().     // Assert     Awaitility.await().atMost(500, TimeUnit.MILLISECONDS).pollInterval(10, TimeUnit.MILLISECONDS).untilAsserted(() -> exceptionHandler.assertCalledWith(method, UnsupportedOperationException.class)).     ctx.close(). }
false;public;0;17;;@Test public void customExecutorBeanConfig() throws InterruptedException {     // Arrange     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(CustomExecutorBeanConfig.class, ExecutorPostProcessor.class).     ctx.refresh().     AsyncBean asyncBean = ctx.getBean(AsyncBean.class).     // Act     asyncBean.work().     // Assert     Awaitility.await().atMost(500, TimeUnit.MILLISECONDS).pollInterval(10, TimeUnit.MILLISECONDS).until(() -> asyncBean.getThreadOfExecution() != null).     assertThat(asyncBean.getThreadOfExecution().getName(), startsWith("Post-")).     ctx.close(). }
false;public;0;20;;@Test public void customExecutorBeanConfigWithThrowsException() {     // Arrange     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext().     ctx.register(CustomExecutorBeanConfig.class, ExecutorPostProcessor.class).     ctx.refresh().     AsyncBean asyncBean = ctx.getBean(AsyncBean.class).     TestableAsyncUncaughtExceptionHandler exceptionHandler = (TestableAsyncUncaughtExceptionHandler) ctx.getBean("exceptionHandler").     assertFalse("handler should not have been called yet", exceptionHandler.isCalled()).     Method method = ReflectionUtils.findMethod(AsyncBean.class, "fail").     // Act     asyncBean.fail().     // Assert     Awaitility.await().atMost(500, TimeUnit.MILLISECONDS).pollInterval(10, TimeUnit.MILLISECONDS).untilAsserted(() -> exceptionHandler.assertCalledWith(method, UnsupportedOperationException.class)).     ctx.close(). }
false;public;0;15;;// SPR-14949 @Test public void findOnInterfaceWithInterfaceProxy() throws InterruptedException {     // Arrange     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(Spr14949ConfigA.class).     AsyncInterface asyncBean = ctx.getBean(AsyncInterface.class).     // Act     asyncBean.work().     // Assert     Awaitility.await().atMost(500, TimeUnit.MILLISECONDS).pollInterval(10, TimeUnit.MILLISECONDS).until(() -> asyncBean.getThreadOfExecution() != null).     assertThat(asyncBean.getThreadOfExecution().getName(), startsWith("Custom-")).     ctx.close(). }
false;public;0;15;;// SPR-14949 @Test public void findOnInterfaceWithCglibProxy() throws InterruptedException {     // Arrange     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(Spr14949ConfigB.class).     AsyncInterface asyncBean = ctx.getBean(AsyncInterface.class).     // Act     asyncBean.work().     // Assert     Awaitility.await().atMost(500, TimeUnit.MILLISECONDS).pollInterval(10, TimeUnit.MILLISECONDS).until(() -> asyncBean.getThreadOfExecution() != null).     assertThat(asyncBean.getThreadOfExecution().getName(), startsWith("Custom-")).     ctx.close(). }
false;public;0;4;;@Async public Future<Thread> work0() {     return new AsyncResult<>(Thread.currentThread()). }
false;public;0;4;;@Async("e1") public Future<Thread> work() {     return new AsyncResult<>(Thread.currentThread()). }
false;public;0;4;;@Async("otherExecutor") public Future<Thread> work2() {     return new AsyncResult<>(Thread.currentThread()). }
false;public;0;4;;@Async("e2") public Future<Thread> work3() {     return new AsyncResult<>(Thread.currentThread()). }
false;public;0;4;;@Async public void work() {     this.threadOfExecution = Thread.currentThread(). }
false;public;0;4;;@Async public void fail() {     throw new UnsupportedOperationException(). }
false;public;0;3;;public Thread getThreadOfExecution() {     return threadOfExecution. }
false;public;0;3;;@Override public void run() { }
false;public;0;3;;public AsyncBean getAsyncBean() {     return asyncBean. }
false;public;0;3;;@CustomAsync public void work() { }
false;public;0;4;;@Bean public AsyncBean asyncBean() {     return new AsyncBean(). }
false;public;0;4;;@Bean public AsyncBean asyncBean() {     return new AsyncBean(). }
false;public;0;4;;@Bean public AsyncBean asyncBean() {     return new AsyncBean(). }
false;public;0;5;;@Bean @Lazy public AsyncBean asyncBean() {     return Mockito.mock(AsyncBean.class). }
false;public;0;4;;@Bean public AsyncBeanWithExecutorQualifiedByName asyncBean() {     return new AsyncBeanWithExecutorQualifiedByName(). }
false;public;0;4;;@Bean public Executor e1() {     return new ThreadPoolTaskExecutor(). }
false;public;0;5;;@Bean @Qualifier("e2") public Executor otherExecutor() {     return new ThreadPoolTaskExecutor(). }
false;public;0;4;;@Bean public AsyncBean asyncBean() {     return new AsyncBean(). }
false;public;0;4;;@Bean public Executor taskExecutor() {     return Executors.newSingleThreadExecutor(new CustomizableThreadFactory("Custom-")). }
false;public;0;4;;@Bean public AsyncBean asyncBean() {     return new AsyncBean(). }
false;public;0;7;;@Override public Executor getAsyncExecutor() {     ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor().     executor.setThreadNamePrefix("Custom-").     executor.initialize().     return executor. }
false;public;0;4;;@Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {     return exceptionHandler(). }
false;public;0;4;;@Bean public AsyncUncaughtExceptionHandler exceptionHandler() {     return new TestableAsyncUncaughtExceptionHandler(). }
false;public;0;4;;@Bean public AsyncBean asyncBean() {     return new AsyncBean(). }
false;public;0;4;;@Override public Executor getAsyncExecutor() {     return executor(). }
false;public;0;7;;@Bean public ThreadPoolTaskExecutor executor() {     ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor().     executor.setThreadNamePrefix("Custom-").     executor.initialize().     return executor. }
false;public;0;4;;@Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {     return exceptionHandler(). }
false;public;0;4;;@Bean public AsyncUncaughtExceptionHandler exceptionHandler() {     return new TestableAsyncUncaughtExceptionHandler(). }
false;public;2;8;;@Nullable @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {     if (bean instanceof ThreadPoolTaskExecutor) {         ((ThreadPoolTaskExecutor) bean).setThreadNamePrefix("Post-").     }     return bean. }
false;;0;2;;@Async void work().
false;;0;1;;Thread getThreadOfExecution().
false;public;0;4;;@Override public void work() {     this.threadOfExecution = Thread.currentThread(). }
false;public;0;4;;@Override public Thread getThreadOfExecution() {     return threadOfExecution. }
false;public;0;4;;@Bean public AsyncInterface asyncBean() {     return new AsyncService(). }
false;public;0;7;;@Override public Executor getAsyncExecutor() {     ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor().     executor.setThreadNamePrefix("Custom-").     executor.initialize().     return executor. }
false;public;0;4;;@Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {     return null. }
false;public;0;4;;@Bean public AsyncInterface asyncBean() {     return new AsyncService(). }
false;public;0;7;;@Override public Executor getAsyncExecutor() {     ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor().     executor.setThreadNamePrefix("Custom-").     executor.initialize().     return executor. }
false;public;0;4;;@Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {     return null. }
