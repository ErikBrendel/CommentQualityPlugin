commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void setup() {     this.context = new AnnotationConfigApplicationContext(Config.class).     this.cache = this.context.getBean(CacheManager.class).getCache("test").     this.service = this.context.getBean(SimpleService.class). }
false;public;0;6;;@After public void close() {     if (this.context != null) {         this.context.close().     } }
false;public;0;16;;@Test public void mutualGetPutExclusion() {     String key = "1".     Long first = this.service.getOrPut(key, true).     Long second = this.service.getOrPut(key, true).     assertSame(first, second).     // This forces the method to be executed again     Long expected = first + 1.     Long third = this.service.getOrPut(key, false).     assertEquals(expected, third).     Long fourth = this.service.getOrPut(key, true).     assertSame(third, fourth). }
false;public;0;20;;@Test public void getAndPut() {     this.cache.clear().     long key = 1.     Long value = this.service.getAndPut(key).     assertEquals("Wrong value for @Cacheable key", value, this.cache.get(key).get()).     // See @CachePut     assertEquals("Wrong value for @CachePut key", value, this.cache.get(value + 100).get()).     // CachePut forced a method call     Long anotherValue = this.service.getAndPut(key).     assertNotSame(value, anotherValue).     // NOTE: while you might expect the main key to have been updated, it hasn't. @Cacheable operations     // are only processed in case of a cache miss. This is why combining @Cacheable with @CachePut     // is a very bad idea. We could refine the condition now that we can figure out if we are going     // to invoke the method anyway but that brings a whole new set of potential regressions.     // assertEquals("Wrong value for @Cacheable key", anotherValue, cache.get(key).get()).     assertEquals("Wrong value for @CachePut key", anotherValue, this.cache.get(anotherValue + 100).get()). }
false;public;0;5;;@Bean @Override public CacheManager cacheManager() {     return new ConcurrentMapCacheManager(). }
false;public;0;4;;@Bean public SimpleService simpleService() {     return new SimpleService(). }
true;public;2;5;/**  * Represent a mutual exclusion use case. The boolean flag exclude one of the two operation.  */ ;/**  * Represent a mutual exclusion use case. The boolean flag exclude one of the two operation.  */ @Cacheable(condition = "#p1", key = "#p0") @CachePut(condition = "!#p1", key = "#p0") public Long getOrPut(Object id, boolean flag) {     return this.counter.getAndIncrement(). }
true;public;1;5;/**  * Represent an invalid use case. If the result of the operation is non null, then we put  * the value with a different key. This forces the method to be executed every time.  */ ;/**  * Represent an invalid use case. If the result of the operation is non null, then we put  * the value with a different key. This forces the method to be executed every time.  */ @Cacheable @CachePut(key = "#result + 100", condition = "#result != null") public Long getAndPut(long id) {     return this.counter.getAndIncrement(). }
