commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Test public void supportsEventTypeWithSmartApplicationListener() {     SmartApplicationListener smartListener = mock(SmartApplicationListener.class).     GenericApplicationListenerAdapter listener = new GenericApplicationListenerAdapter(smartListener).     ResolvableType type = ResolvableType.forClass(ApplicationEvent.class).     listener.supportsEventType(type).     verify(smartListener, times(1)).supportsEventType(ApplicationEvent.class). }
false;public;0;7;;@Test public void supportsSourceTypeWithSmartApplicationListener() {     SmartApplicationListener smartListener = mock(SmartApplicationListener.class).     GenericApplicationListenerAdapter listener = new GenericApplicationListenerAdapter(smartListener).     listener.supportsSourceType(Object.class).     verify(smartListener, times(1)).supportsSourceType(Object.class). }
false;public;0;4;;@Test public void genericListenerStrictType() {     supportsEventType(true, StringEventListener.class, getGenericApplicationEventType("stringEvent")). }
false;public;0;6;;// Demonstrates we can't inject that event because the generic type is lost @Test public void genericListenerStrictTypeTypeErasure() {     GenericTestEvent<String> stringEvent = createGenericTestEvent("test").     ResolvableType eventType = ResolvableType.forType(stringEvent.getClass()).     supportsEventType(false, StringEventListener.class, eventType). }
false;public;0;6;;// But it works if we specify the type properly @Test public void genericListenerStrictTypeAndResolvableType() {     ResolvableType eventType = ResolvableType.forClassWithGenerics(GenericTestEvent.class, String.class).     supportsEventType(true, StringEventListener.class, eventType). }
false;public;0;5;;// or if the event provides its precise type @Test public void genericListenerStrictTypeAndResolvableTypeProvider() {     ResolvableType eventType = new SmartGenericTestEvent<>(this, "foo").getResolvableType().     supportsEventType(true, StringEventListener.class, eventType). }
false;public;0;6;;// Demonstrates it works if we actually use the subtype @Test public void genericListenerStrictTypeEventSubType() {     StringEvent stringEvent = new StringEvent(this, "test").     ResolvableType eventType = ResolvableType.forType(stringEvent.getClass()).     supportsEventType(true, StringEventListener.class, eventType). }
false;public;0;4;;@Test public void genericListenerStrictTypeNotMatching() {     supportsEventType(false, StringEventListener.class, getGenericApplicationEventType("longEvent")). }
false;public;0;6;;@Test public void genericListenerStrictTypeEventSubTypeNotMatching() {     LongEvent stringEvent = new LongEvent(this, 123L).     ResolvableType eventType = ResolvableType.forType(stringEvent.getClass()).     supportsEventType(false, StringEventListener.class, eventType). }
false;public;0;6;;@Test public void genericListenerStrictTypeNotMatchTypeErasure() {     GenericTestEvent<Long> longEvent = createGenericTestEvent(123L).     ResolvableType eventType = ResolvableType.forType(longEvent.getClass()).     supportsEventType(false, StringEventListener.class, eventType). }
false;public;0;4;;@Test public void genericListenerStrictTypeSubClass() {     supportsEventType(false, ObjectEventListener.class, getGenericApplicationEventType("longEvent")). }
false;public;0;5;;@Test public void genericListenerUpperBoundType() {     supportsEventType(true, UpperBoundEventListener.class, getGenericApplicationEventType("illegalStateExceptionEvent")). }
false;public;0;5;;@Test public void genericListenerUpperBoundTypeNotMatching() {     supportsEventType(false, UpperBoundEventListener.class, getGenericApplicationEventType("ioExceptionEvent")). }
false;public;0;5;;@Test public void genericListenerWildcardType() {     supportsEventType(true, GenericEventListener.class, getGenericApplicationEventType("stringEvent")). }
false;public;0;6;;// Demonstrates we cant inject that event because the listener has a wildcard @Test public void genericListenerWildcardTypeTypeErasure() {     GenericTestEvent<String> stringEvent = createGenericTestEvent("test").     ResolvableType eventType = ResolvableType.forType(stringEvent.getClass()).     supportsEventType(true, GenericEventListener.class, eventType). }
false;public;0;5;;@Test public void genericListenerRawType() {     supportsEventType(true, RawApplicationListener.class, getGenericApplicationEventType("stringEvent")). }
false;public;0;6;;// Demonstrates we cant inject that event because the listener has a raw type @Test public void genericListenerRawTypeTypeErasure() {     GenericTestEvent<String> stringEvent = createGenericTestEvent("test").     ResolvableType eventType = ResolvableType.forType(stringEvent.getClass()).     supportsEventType(true, RawApplicationListener.class, eventType). }
false;private;3;8;;private void supportsEventType(boolean match, Class<? extends ApplicationListener> listenerType, ResolvableType eventType) {     ApplicationListener<?> listener = mock(listenerType).     GenericApplicationListenerAdapter adapter = new GenericApplicationListenerAdapter(listener).     assertEquals("Wrong match for event '" + eventType + "' on " + listenerType.getClass().getName(), match, adapter.supportsEventType(eventType)). }
