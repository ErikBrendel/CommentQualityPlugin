commented;modifiers;parameterAmount;loc;comment;code
false;public;2;12;;@Override public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {     if (definition instanceof AnnotatedBeanDefinition) {         String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition).         if (StringUtils.hasText(beanName)) {             // Explicit bean name found.             return beanName.         }     }     // Fallback: generate a unique default bean name.     return buildDefaultBeanName(definition, registry). }
true;protected;1;23;/**  * Derive a bean name from one of the annotations on the class.  * @param annotatedDef the annotation-aware bean definition  * @return the bean name, or {@code null} if none is found  */ ;/**  * Derive a bean name from one of the annotations on the class.  * @param annotatedDef the annotation-aware bean definition  * @return the bean name, or {@code null} if none is found  */ @Nullable protected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) {     AnnotationMetadata amd = annotatedDef.getMetadata().     Set<String> types = amd.getAnnotationTypes().     String beanName = null.     for (String type : types) {         AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type).         if (attributes != null && isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) {             Object value = attributes.get("value").             if (value instanceof String) {                 String strVal = (String) value.                 if (StringUtils.hasLength(strVal)) {                     if (beanName != null && !strVal.equals(beanName)) {                         throw new IllegalStateException("Stereotype annotations suggest inconsistent " + "component names: '" + beanName + "' versus '" + strVal + "'").                     }                     beanName = strVal.                 }             }         }     }     return beanName. }
true;protected;3;10;/**  * Check whether the given annotation is a stereotype that is allowed  * to suggest a component name through its annotation {@code value()}.  * @param annotationType the name of the annotation class to check  * @param metaAnnotationTypes the names of meta-annotations on the given annotation  * @param attributes the map of attributes for the given annotation  * @return whether the annotation qualifies as a stereotype with component name  */ ;/**  * Check whether the given annotation is a stereotype that is allowed  * to suggest a component name through its annotation {@code value()}.  * @param annotationType the name of the annotation class to check  * @param metaAnnotationTypes the names of meta-annotations on the given annotation  * @param attributes the map of attributes for the given annotation  * @return whether the annotation qualifies as a stereotype with component name  */ protected boolean isStereotypeWithNameValue(String annotationType, Set<String> metaAnnotationTypes, @Nullable Map<String, Object> attributes) {     boolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) || metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME) || annotationType.equals("javax.annotation.ManagedBean") || annotationType.equals("javax.inject.Named").     return (isStereotype && attributes != null && attributes.containsKey("value")). }
true;protected;2;3;/**  * Derive a default bean name from the given bean definition.  * <p>The default implementation delegates to {@link #buildDefaultBeanName(BeanDefinition)}.  * @param definition the bean definition to build a bean name for  * @param registry the registry that the given bean definition is being registered with  * @return the default bean name (never {@code null})  */ ;/**  * Derive a default bean name from the given bean definition.  * <p>The default implementation delegates to {@link #buildDefaultBeanName(BeanDefinition)}.  * @param definition the bean definition to build a bean name for  * @param registry the registry that the given bean definition is being registered with  * @return the default bean name (never {@code null})  */ protected String buildDefaultBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {     return buildDefaultBeanName(definition). }
true;protected;1;6;/**  * Derive a default bean name from the given bean definition.  * <p>The default implementation simply builds a decapitalized version  * of the short class name: e.g. "mypackage.MyJdbcDao" -> "myJdbcDao".  * <p>Note that inner classes will thus have names of the form  * "outerClassName.InnerClassName", which because of the period in the  * name may be an issue if you are autowiring by name.  * @param definition the bean definition to build a bean name for  * @return the default bean name (never {@code null})  */ ;/**  * Derive a default bean name from the given bean definition.  * <p>The default implementation simply builds a decapitalized version  * of the short class name: e.g. "mypackage.MyJdbcDao" -> "myJdbcDao".  * <p>Note that inner classes will thus have names of the form  * "outerClassName.InnerClassName", which because of the period in the  * name may be an issue if you are autowiring by name.  * @param definition the bean definition to build a bean name for  * @return the default bean name (never {@code null})  */ protected String buildDefaultBeanName(BeanDefinition definition) {     String beanClassName = definition.getBeanClassName().     Assert.state(beanClassName != null, "No bean class name set").     String shortClassName = ClassUtils.getShortName(beanClassName).     return Introspector.decapitalize(shortClassName). }
