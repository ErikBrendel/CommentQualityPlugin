commented;modifiers;parameterAmount;loc;comment;code
false;static;1;19;;static void registerApplicationContext(ConfigurableApplicationContext applicationContext) {     String mbeanDomain = applicationContext.getEnvironment().getProperty(MBEAN_DOMAIN_PROPERTY_NAME).     if (mbeanDomain != null) {         synchronized (applicationContexts) {             if (applicationContexts.isEmpty()) {                 try {                     MBeanServer server = ManagementFactory.getPlatformMBeanServer().                     applicationName = applicationContext.getApplicationName().                     server.registerMBean(new LiveBeansView(), new ObjectName(mbeanDomain, MBEAN_APPLICATION_KEY, applicationName)).                 } catch (Throwable ex) {                     throw new ApplicationContextException("Failed to register LiveBeansView MBean", ex).                 }             }             applicationContexts.add(applicationContext).         }     } }
false;static;1;19;;static void unregisterApplicationContext(ConfigurableApplicationContext applicationContext) {     synchronized (applicationContexts) {         if (applicationContexts.remove(applicationContext) && applicationContexts.isEmpty()) {             try {                 MBeanServer server = ManagementFactory.getPlatformMBeanServer().                 String mbeanDomain = applicationContext.getEnvironment().getProperty(MBEAN_DOMAIN_PROPERTY_NAME).                 if (mbeanDomain != null) {                     server.unregisterMBean(new ObjectName(mbeanDomain, MBEAN_APPLICATION_KEY, applicationName)).                 }             } catch (Throwable ex) {                 throw new ApplicationContextException("Failed to unregister LiveBeansView MBean", ex).             } finally {                 applicationName = null.             }         }     } }
false;public;1;6;;@Override public void setApplicationContext(ApplicationContext applicationContext) {     Assert.isTrue(applicationContext instanceof ConfigurableApplicationContext, "ApplicationContext does not implement ConfigurableApplicationContext").     this.applicationContext = (ConfigurableApplicationContext) applicationContext. }
true;public;0;11;/**  * Generate a JSON snapshot of current beans and their dependencies,  * finding all active ApplicationContexts through {@link #findApplicationContexts()},  * then delegating to {@link #generateJson(java.util.Set)}.  */ ;/**  * Generate a JSON snapshot of current beans and their dependencies,  * finding all active ApplicationContexts through {@link #findApplicationContexts()},  * then delegating to {@link #generateJson(java.util.Set)}.  */ @Override public String getSnapshotAsJson() {     Set<ConfigurableApplicationContext> contexts.     if (this.applicationContext != null) {         contexts = Collections.singleton(this.applicationContext).     } else {         contexts = findApplicationContexts().     }     return generateJson(contexts). }
true;protected;0;5;/**  * Find all applicable ApplicationContexts for the current application.  * <p>Called if no specific ApplicationContext has been set for this LiveBeansView.  * @return the set of ApplicationContexts  */ ;/**  * Find all applicable ApplicationContexts for the current application.  * <p>Called if no specific ApplicationContext has been set for this LiveBeansView.  * @return the set of ApplicationContexts  */ protected Set<ConfigurableApplicationContext> findApplicationContexts() {     synchronized (applicationContexts) {         return new LinkedHashSet<>(applicationContexts).     } }
true;protected;1;53;/**  * Actually generate a JSON snapshot of the beans in the given ApplicationContexts.  * <p>This implementation doesn't use any JSON parsing libraries in order to avoid  * third-party library dependencies. It produces an array of context description  * objects, each containing a context and parent attribute as well as a beans  * attribute with nested bean description objects. Each bean object contains a  * bean, scope, type and resource attribute, as well as a dependencies attribute  * with a nested array of bean names that the present bean depends on.  * @param contexts the set of ApplicationContexts  * @return the JSON document  */ ;/**  * Actually generate a JSON snapshot of the beans in the given ApplicationContexts.  * <p>This implementation doesn't use any JSON parsing libraries in order to avoid  * third-party library dependencies. It produces an array of context description  * objects, each containing a context and parent attribute as well as a beans  * attribute with nested bean description objects. Each bean object contains a  * bean, scope, type and resource attribute, as well as a dependencies attribute  * with a nested array of bean names that the present bean depends on.  * @param contexts the set of ApplicationContexts  * @return the JSON document  */ protected String generateJson(Set<ConfigurableApplicationContext> contexts) {     StringBuilder result = new StringBuilder("[\n").     for (Iterator<ConfigurableApplicationContext> it = contexts.iterator(). it.hasNext(). ) {         ConfigurableApplicationContext context = it.next().         result.append("{\n\"context\": \"").append(context.getId()).append("\",\n").         if (context.getParent() != null) {             result.append("\"parent\": \"").append(context.getParent().getId()).append("\",\n").         } else {             result.append("\"parent\": null,\n").         }         result.append("\"beans\": [\n").         ConfigurableListableBeanFactory bf = context.getBeanFactory().         String[] beanNames = bf.getBeanDefinitionNames().         boolean elementAppended = false.         for (String beanName : beanNames) {             BeanDefinition bd = bf.getBeanDefinition(beanName).             if (isBeanEligible(beanName, bd, bf)) {                 if (elementAppended) {                     result.append(",\n").                 }                 result.append("{\n\"bean\": \"").append(beanName).append("\",\n").                 result.append("\"aliases\": ").                 appendArray(result, bf.getAliases(beanName)).                 result.append(",\n").                 String scope = bd.getScope().                 if (!StringUtils.hasText(scope)) {                     scope = BeanDefinition.SCOPE_SINGLETON.                 }                 result.append("\"scope\": \"").append(scope).append("\",\n").                 Class<?> beanType = bf.getType(beanName).                 if (beanType != null) {                     result.append("\"type\": \"").append(beanType.getName()).append("\",\n").                 } else {                     result.append("\"type\": null,\n").                 }                 result.append("\"resource\": \"").append(getEscapedResourceDescription(bd)).append("\",\n").                 result.append("\"dependencies\": ").                 appendArray(result, bf.getDependenciesForBean(beanName)).                 result.append("\n}").                 elementAppended = true.             }         }         result.append("]\n").         result.append("}").         if (it.hasNext()) {             result.append(",\n").         }     }     result.append("]").     return result.toString(). }
true;protected;3;4;/**  * Determine whether the specified bean is eligible for inclusion in the  * LiveBeansView JSON snapshot.  * @param beanName the name of the bean  * @param bd the corresponding bean definition  * @param bf the containing bean factory  * @return {@code true} if the bean is to be included. {@code false} otherwise  */ ;/**  * Determine whether the specified bean is eligible for inclusion in the  * LiveBeansView JSON snapshot.  * @param beanName the name of the bean  * @param bd the corresponding bean definition  * @param bf the containing bean factory  * @return {@code true} if the bean is to be included. {@code false} otherwise  */ protected boolean isBeanEligible(String beanName, BeanDefinition bd, ConfigurableBeanFactory bf) {     return (bd.getRole() != BeanDefinition.ROLE_INFRASTRUCTURE && (!bd.isLazyInit() || bf.containsSingleton(beanName))). }
true;protected;1;21;/**  * Determine a resource description for the given bean definition and  * apply basic JSON escaping (backslashes, double quotes) to it.  * @param bd the bean definition to build the resource description for  * @return the JSON-escaped resource description  */ ;/**  * Determine a resource description for the given bean definition and  * apply basic JSON escaping (backslashes, double quotes) to it.  * @param bd the bean definition to build the resource description for  * @return the JSON-escaped resource description  */ @Nullable protected String getEscapedResourceDescription(BeanDefinition bd) {     String resourceDescription = bd.getResourceDescription().     if (resourceDescription == null) {         return null.     }     StringBuilder result = new StringBuilder(resourceDescription.length() + 16).     for (int i = 0. i < resourceDescription.length(). i++) {         char character = resourceDescription.charAt(i).         if (character == '\\') {             result.append('/').         } else if (character == '"') {             result.append("\\").append('"').         } else {             result.append(character).         }     }     return result.toString(). }
false;private;2;11;;private void appendArray(StringBuilder result, String[] arr) {     result.append('[').     if (arr.length > 0) {         result.append('\"').     }     result.append(StringUtils.arrayToDelimitedString(arr, "\", \"")).     if (arr.length > 0) {         result.append('\"').     }     result.append(']'). }
