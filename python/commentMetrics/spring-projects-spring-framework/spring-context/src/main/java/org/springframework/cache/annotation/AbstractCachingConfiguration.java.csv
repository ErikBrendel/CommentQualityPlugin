# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractCachingConfiguration -> protected void useCachingConfigurer(CachingConfigurer config);1427292728;Extract the configuration from the nominated {@link CachingConfigurer}.;protected void useCachingConfigurer(CachingConfigurer config) {_		this.cacheManager = config.cacheManager()__		this.cacheResolver = config.cacheResolver()__		this.keyGenerator = config.keyGenerator()__		this.errorHandler = config.errorHandler()__	};extract,the,configuration,from,the,nominated,link,caching,configurer;protected,void,use,caching,configurer,caching,configurer,config,this,cache,manager,config,cache,manager,this,cache,resolver,config,cache,resolver,this,key,generator,config,key,generator,this,error,handler,config,error,handler
AbstractCachingConfiguration -> protected void useCachingConfigurer(CachingConfigurer config);1496837955;Extract the configuration from the nominated {@link CachingConfigurer}.;protected void useCachingConfigurer(CachingConfigurer config) {_		this.cacheManager = config.cacheManager()__		this.cacheResolver = config.cacheResolver()__		this.keyGenerator = config.keyGenerator()__		this.errorHandler = config.errorHandler()__	};extract,the,configuration,from,the,nominated,link,caching,configurer;protected,void,use,caching,configurer,caching,configurer,config,this,cache,manager,config,cache,manager,this,cache,resolver,config,cache,resolver,this,key,generator,config,key,generator,this,error,handler,config,error,handler
AbstractCachingConfiguration -> protected void useCachingConfigurer(CachingConfigurer config);1498780456;Extract the configuration from the nominated {@link CachingConfigurer}.;protected void useCachingConfigurer(CachingConfigurer config) {_		this.cacheManager = config.cacheManager()__		this.cacheResolver = config.cacheResolver()__		this.keyGenerator = config.keyGenerator()__		this.errorHandler = config.errorHandler()__	};extract,the,configuration,from,the,nominated,link,caching,configurer;protected,void,use,caching,configurer,caching,configurer,config,this,cache,manager,config,cache,manager,this,cache,resolver,config,cache,resolver,this,key,generator,config,key,generator,this,error,handler,config,error,handler
AbstractCachingConfiguration -> protected void useCachingConfigurer(CachingConfigurer config);1531589372;Extract the configuration from the nominated {@link CachingConfigurer}.;protected void useCachingConfigurer(CachingConfigurer config) {_		this.cacheManager = config::cacheManager__		this.cacheResolver = config::cacheResolver__		this.keyGenerator = config::keyGenerator__		this.errorHandler = config::errorHandler__	};extract,the,configuration,from,the,nominated,link,caching,configurer;protected,void,use,caching,configurer,caching,configurer,config,this,cache,manager,config,cache,manager,this,cache,resolver,config,cache,resolver,this,key,generator,config,key,generator,this,error,handler,config,error,handler
AbstractCachingConfiguration -> @PostConstruct 	protected void reconcileCacheManager();1328020251;Determine which {@code CacheManager} bean to use. Prefer the result of_{@link CachingConfigurer#cacheManager()} over any by-type matching. If none, fall_back to by-type matching on {@code CacheManager}._@throws IllegalArgumentException if no CacheManager can be found_ if more than one_CachingConfigurer implementation exists_ if multiple CacheManager beans and no_CachingConfigurer exists to disambiguate.;@PostConstruct_	protected void reconcileCacheManager() {_		if (!CollectionUtils.isEmpty(cachingConfigurers)) {_			int nConfigurers = cachingConfigurers.size()__			if (nConfigurers > 1) {_				throw new IllegalStateException(nConfigurers + " implementations of " +_						"CachingConfigurer were found when only 1 was expected. " +_						"Refactor the configuration such that CachingConfigurer is " +_						"implemented only once or not at all.")__			}_			CachingConfigurer cachingConfigurer = cachingConfigurers.iterator().next()__			this.cacheManager = cachingConfigurer.cacheManager()__			this.keyGenerator = cachingConfigurer.keyGenerator()__		}_		else if (!CollectionUtils.isEmpty(cacheManagerBeans)) {_			int nManagers = cacheManagerBeans.size()__			if (nManagers > 1) {_				throw new IllegalStateException(nManagers + " beans of type CacheManager " +_						"were found when only 1 was expected. Remove all but one of the " +_						"CacheManager bean definitions, or implement CachingConfigurer " +_						"to make explicit which CacheManager should be used for " +_						"annotation-driven cache management.")__			}_			CacheManager cacheManager = cacheManagerBeans.iterator().next()__			this.cacheManager = cacheManager__			_		}_		else {_			throw new IllegalStateException("No bean of type CacheManager could be found. " +_					"Register a CacheManager bean or remove the @EnableCaching annotation " +_					"from your configuration.")__		}_	};determine,which,code,cache,manager,bean,to,use,prefer,the,result,of,link,caching,configurer,cache,manager,over,any,by,type,matching,if,none,fall,back,to,by,type,matching,on,code,cache,manager,throws,illegal,argument,exception,if,no,cache,manager,can,be,found,if,more,than,one,caching,configurer,implementation,exists,if,multiple,cache,manager,beans,and,no,caching,configurer,exists,to,disambiguate;post,construct,protected,void,reconcile,cache,manager,if,collection,utils,is,empty,caching,configurers,int,n,configurers,caching,configurers,size,if,n,configurers,1,throw,new,illegal,state,exception,n,configurers,implementations,of,caching,configurer,were,found,when,only,1,was,expected,refactor,the,configuration,such,that,caching,configurer,is,implemented,only,once,or,not,at,all,caching,configurer,caching,configurer,caching,configurers,iterator,next,this,cache,manager,caching,configurer,cache,manager,this,key,generator,caching,configurer,key,generator,else,if,collection,utils,is,empty,cache,manager,beans,int,n,managers,cache,manager,beans,size,if,n,managers,1,throw,new,illegal,state,exception,n,managers,beans,of,type,cache,manager,were,found,when,only,1,was,expected,remove,all,but,one,of,the,cache,manager,bean,definitions,or,implement,caching,configurer,to,make,explicit,which,cache,manager,should,be,used,for,annotation,driven,cache,management,cache,manager,cache,manager,cache,manager,beans,iterator,next,this,cache,manager,cache,manager,else,throw,new,illegal,state,exception,no,bean,of,type,cache,manager,could,be,found,register,a,cache,manager,bean,or,remove,the,enable,caching,annotation,from,your,configuration
AbstractCachingConfiguration -> @PostConstruct 	protected void reconcileCacheManager();1329142650;Determine which {@code CacheManager} bean to use. Prefer the result of_{@link CachingConfigurer#cacheManager()} over any by-type matching. If none, fall_back to by-type matching on {@code CacheManager}._@throws IllegalArgumentException if no CacheManager can be found_ if more than one_CachingConfigurer implementation exists_ if multiple CacheManager beans and no_CachingConfigurer exists to disambiguate.;@PostConstruct_	protected void reconcileCacheManager() {_		if (!CollectionUtils.isEmpty(cachingConfigurers)) {_			int nConfigurers = cachingConfigurers.size()__			if (nConfigurers > 1) {_				throw new IllegalStateException(nConfigurers + " implementations of " +_						"CachingConfigurer were found when only 1 was expected. " +_						"Refactor the configuration such that CachingConfigurer is " +_						"implemented only once or not at all.")__			}_			CachingConfigurer cachingConfigurer = cachingConfigurers.iterator().next()__			this.cacheManager = cachingConfigurer.cacheManager()__			this.keyGenerator = cachingConfigurer.keyGenerator()__		}_		else if (!CollectionUtils.isEmpty(cacheManagerBeans)) {_			int nManagers = cacheManagerBeans.size()__			if (nManagers > 1) {_				throw new IllegalStateException(nManagers + " beans of type CacheManager " +_						"were found when only 1 was expected. Remove all but one of the " +_						"CacheManager bean definitions, or implement CachingConfigurer " +_						"to make explicit which CacheManager should be used for " +_						"annotation-driven cache management.")__			}_			CacheManager cacheManager = cacheManagerBeans.iterator().next()__			this.cacheManager = cacheManager__			_		}_		else {_			throw new IllegalStateException("No bean of type CacheManager could be found. " +_					"Register a CacheManager bean or remove the @EnableCaching annotation " +_					"from your configuration.")__		}_	};determine,which,code,cache,manager,bean,to,use,prefer,the,result,of,link,caching,configurer,cache,manager,over,any,by,type,matching,if,none,fall,back,to,by,type,matching,on,code,cache,manager,throws,illegal,argument,exception,if,no,cache,manager,can,be,found,if,more,than,one,caching,configurer,implementation,exists,if,multiple,cache,manager,beans,and,no,caching,configurer,exists,to,disambiguate;post,construct,protected,void,reconcile,cache,manager,if,collection,utils,is,empty,caching,configurers,int,n,configurers,caching,configurers,size,if,n,configurers,1,throw,new,illegal,state,exception,n,configurers,implementations,of,caching,configurer,were,found,when,only,1,was,expected,refactor,the,configuration,such,that,caching,configurer,is,implemented,only,once,or,not,at,all,caching,configurer,caching,configurer,caching,configurers,iterator,next,this,cache,manager,caching,configurer,cache,manager,this,key,generator,caching,configurer,key,generator,else,if,collection,utils,is,empty,cache,manager,beans,int,n,managers,cache,manager,beans,size,if,n,managers,1,throw,new,illegal,state,exception,n,managers,beans,of,type,cache,manager,were,found,when,only,1,was,expected,remove,all,but,one,of,the,cache,manager,bean,definitions,or,implement,caching,configurer,to,make,explicit,which,cache,manager,should,be,used,for,annotation,driven,cache,management,cache,manager,cache,manager,cache,manager,beans,iterator,next,this,cache,manager,cache,manager,else,throw,new,illegal,state,exception,no,bean,of,type,cache,manager,could,be,found,register,a,cache,manager,bean,or,remove,the,enable,caching,annotation,from,your,configuration
AbstractCachingConfiguration -> @PostConstruct 	protected void reconcileCacheManager();1356735495;Determine which {@code CacheManager} bean to use. Prefer the result of_{@link CachingConfigurer#cacheManager()} over any by-type matching. If none, fall_back to by-type matching on {@code CacheManager}._@throws IllegalArgumentException if no CacheManager can be found_ if more than one_CachingConfigurer implementation exists_ if multiple CacheManager beans and no_CachingConfigurer exists to disambiguate.;@PostConstruct_	protected void reconcileCacheManager() {_		if (!CollectionUtils.isEmpty(cachingConfigurers)) {_			int nConfigurers = cachingConfigurers.size()__			if (nConfigurers > 1) {_				throw new IllegalStateException(nConfigurers + " implementations of " +_						"CachingConfigurer were found when only 1 was expected. " +_						"Refactor the configuration such that CachingConfigurer is " +_						"implemented only once or not at all.")__			}_			CachingConfigurer cachingConfigurer = cachingConfigurers.iterator().next()__			this.cacheManager = cachingConfigurer.cacheManager()__			this.keyGenerator = cachingConfigurer.keyGenerator()__		}_		else if (!CollectionUtils.isEmpty(cacheManagerBeans)) {_			int nManagers = cacheManagerBeans.size()__			if (nManagers > 1) {_				throw new IllegalStateException(nManagers + " beans of type CacheManager " +_						"were found when only 1 was expected. Remove all but one of the " +_						"CacheManager bean definitions, or implement CachingConfigurer " +_						"to make explicit which CacheManager should be used for " +_						"annotation-driven cache management.")__			}_			CacheManager cacheManager = cacheManagerBeans.iterator().next()__			this.cacheManager = cacheManager__			_		}_		else {_			throw new IllegalStateException("No bean of type CacheManager could be found. " +_					"Register a CacheManager bean or remove the @EnableCaching annotation " +_					"from your configuration.")__		}_	};determine,which,code,cache,manager,bean,to,use,prefer,the,result,of,link,caching,configurer,cache,manager,over,any,by,type,matching,if,none,fall,back,to,by,type,matching,on,code,cache,manager,throws,illegal,argument,exception,if,no,cache,manager,can,be,found,if,more,than,one,caching,configurer,implementation,exists,if,multiple,cache,manager,beans,and,no,caching,configurer,exists,to,disambiguate;post,construct,protected,void,reconcile,cache,manager,if,collection,utils,is,empty,caching,configurers,int,n,configurers,caching,configurers,size,if,n,configurers,1,throw,new,illegal,state,exception,n,configurers,implementations,of,caching,configurer,were,found,when,only,1,was,expected,refactor,the,configuration,such,that,caching,configurer,is,implemented,only,once,or,not,at,all,caching,configurer,caching,configurer,caching,configurers,iterator,next,this,cache,manager,caching,configurer,cache,manager,this,key,generator,caching,configurer,key,generator,else,if,collection,utils,is,empty,cache,manager,beans,int,n,managers,cache,manager,beans,size,if,n,managers,1,throw,new,illegal,state,exception,n,managers,beans,of,type,cache,manager,were,found,when,only,1,was,expected,remove,all,but,one,of,the,cache,manager,bean,definitions,or,implement,caching,configurer,to,make,explicit,which,cache,manager,should,be,used,for,annotation,driven,cache,management,cache,manager,cache,manager,cache,manager,beans,iterator,next,this,cache,manager,cache,manager,else,throw,new,illegal,state,exception,no,bean,of,type,cache,manager,could,be,found,register,a,cache,manager,bean,or,remove,the,enable,caching,annotation,from,your,configuration
AbstractCachingConfiguration -> @PostConstruct 	protected void reconcileCacheManager();1357119239;Determine which {@code CacheManager} bean to use. Prefer the result of_{@link CachingConfigurer#cacheManager()} over any by-type matching. If none, fall_back to by-type matching on {@code CacheManager}._@throws IllegalArgumentException if no CacheManager can be found_ if more than one_CachingConfigurer implementation exists_ if multiple CacheManager beans and no_CachingConfigurer exists to disambiguate.;@PostConstruct_	protected void reconcileCacheManager() {_		if (!CollectionUtils.isEmpty(cachingConfigurers)) {_			int nConfigurers = cachingConfigurers.size()__			if (nConfigurers > 1) {_				throw new IllegalStateException(nConfigurers + " implementations of " +_						"CachingConfigurer were found when only 1 was expected. " +_						"Refactor the configuration such that CachingConfigurer is " +_						"implemented only once or not at all.")__			}_			CachingConfigurer cachingConfigurer = cachingConfigurers.iterator().next()__			this.cacheManager = cachingConfigurer.cacheManager()__			this.keyGenerator = cachingConfigurer.keyGenerator()__		}_		else if (!CollectionUtils.isEmpty(cacheManagerBeans)) {_			int nManagers = cacheManagerBeans.size()__			if (nManagers > 1) {_				throw new IllegalStateException(nManagers + " beans of type CacheManager " +_						"were found when only 1 was expected. Remove all but one of the " +_						"CacheManager bean definitions, or implement CachingConfigurer " +_						"to make explicit which CacheManager should be used for " +_						"annotation-driven cache management.")__			}_			CacheManager cacheManager = cacheManagerBeans.iterator().next()__			this.cacheManager = cacheManager__			_		}_		else {_			throw new IllegalStateException("No bean of type CacheManager could be found. " +_					"Register a CacheManager bean or remove the @EnableCaching annotation " +_					"from your configuration.")__		}_	};determine,which,code,cache,manager,bean,to,use,prefer,the,result,of,link,caching,configurer,cache,manager,over,any,by,type,matching,if,none,fall,back,to,by,type,matching,on,code,cache,manager,throws,illegal,argument,exception,if,no,cache,manager,can,be,found,if,more,than,one,caching,configurer,implementation,exists,if,multiple,cache,manager,beans,and,no,caching,configurer,exists,to,disambiguate;post,construct,protected,void,reconcile,cache,manager,if,collection,utils,is,empty,caching,configurers,int,n,configurers,caching,configurers,size,if,n,configurers,1,throw,new,illegal,state,exception,n,configurers,implementations,of,caching,configurer,were,found,when,only,1,was,expected,refactor,the,configuration,such,that,caching,configurer,is,implemented,only,once,or,not,at,all,caching,configurer,caching,configurer,caching,configurers,iterator,next,this,cache,manager,caching,configurer,cache,manager,this,key,generator,caching,configurer,key,generator,else,if,collection,utils,is,empty,cache,manager,beans,int,n,managers,cache,manager,beans,size,if,n,managers,1,throw,new,illegal,state,exception,n,managers,beans,of,type,cache,manager,were,found,when,only,1,was,expected,remove,all,but,one,of,the,cache,manager,bean,definitions,or,implement,caching,configurer,to,make,explicit,which,cache,manager,should,be,used,for,annotation,driven,cache,management,cache,manager,cache,manager,cache,manager,beans,iterator,next,this,cache,manager,cache,manager,else,throw,new,illegal,state,exception,no,bean,of,type,cache,manager,could,be,found,register,a,cache,manager,bean,or,remove,the,enable,caching,annotation,from,your,configuration
AbstractCachingConfiguration -> @PostConstruct 	protected void reconcileCacheManager();1368482696;Determine which {@code CacheManager} bean to use. Prefer the result of_{@link CachingConfigurer#cacheManager()} over any by-type matching. If none, fall_back to by-type matching on {@code CacheManager}._@throws IllegalArgumentException if no CacheManager can be found_ if more than one_CachingConfigurer implementation exists_ if multiple CacheManager beans and no_CachingConfigurer exists to disambiguate.;@PostConstruct_	protected void reconcileCacheManager() {_		if (!CollectionUtils.isEmpty(cachingConfigurers)) {_			int nConfigurers = cachingConfigurers.size()__			if (nConfigurers > 1) {_				throw new IllegalStateException(nConfigurers + " implementations of " +_						"CachingConfigurer were found when only 1 was expected. " +_						"Refactor the configuration such that CachingConfigurer is " +_						"implemented only once or not at all.")__			}_			CachingConfigurer cachingConfigurer = cachingConfigurers.iterator().next()__			this.cacheManager = cachingConfigurer.cacheManager()__			this.keyGenerator = cachingConfigurer.keyGenerator()__		}_		else if (!CollectionUtils.isEmpty(cacheManagerBeans)) {_			int nManagers = cacheManagerBeans.size()__			if (nManagers > 1) {_				throw new IllegalStateException(nManagers + " beans of type CacheManager " +_						"were found when only 1 was expected. Remove all but one of the " +_						"CacheManager bean definitions, or implement CachingConfigurer " +_						"to make explicit which CacheManager should be used for " +_						"annotation-driven cache management.")__			}_			CacheManager cacheManager = cacheManagerBeans.iterator().next()__			this.cacheManager = cacheManager__			_		}_		else {_			throw new IllegalStateException("No bean of type CacheManager could be found. " +_					"Register a CacheManager bean or remove the @EnableCaching annotation " +_					"from your configuration.")__		}_	};determine,which,code,cache,manager,bean,to,use,prefer,the,result,of,link,caching,configurer,cache,manager,over,any,by,type,matching,if,none,fall,back,to,by,type,matching,on,code,cache,manager,throws,illegal,argument,exception,if,no,cache,manager,can,be,found,if,more,than,one,caching,configurer,implementation,exists,if,multiple,cache,manager,beans,and,no,caching,configurer,exists,to,disambiguate;post,construct,protected,void,reconcile,cache,manager,if,collection,utils,is,empty,caching,configurers,int,n,configurers,caching,configurers,size,if,n,configurers,1,throw,new,illegal,state,exception,n,configurers,implementations,of,caching,configurer,were,found,when,only,1,was,expected,refactor,the,configuration,such,that,caching,configurer,is,implemented,only,once,or,not,at,all,caching,configurer,caching,configurer,caching,configurers,iterator,next,this,cache,manager,caching,configurer,cache,manager,this,key,generator,caching,configurer,key,generator,else,if,collection,utils,is,empty,cache,manager,beans,int,n,managers,cache,manager,beans,size,if,n,managers,1,throw,new,illegal,state,exception,n,managers,beans,of,type,cache,manager,were,found,when,only,1,was,expected,remove,all,but,one,of,the,cache,manager,bean,definitions,or,implement,caching,configurer,to,make,explicit,which,cache,manager,should,be,used,for,annotation,driven,cache,management,cache,manager,cache,manager,cache,manager,beans,iterator,next,this,cache,manager,cache,manager,else,throw,new,illegal,state,exception,no,bean,of,type,cache,manager,could,be,found,register,a,cache,manager,bean,or,remove,the,enable,caching,annotation,from,your,configuration
AbstractCachingConfiguration -> @PostConstruct 	protected void reconcileCacheManager();1372363092;Determine which {@code CacheManager} bean to use. Prefer the result of_{@link CachingConfigurer#cacheManager()} over any by-type matching. If none, fall_back to by-type matching on {@code CacheManager}._@throws IllegalArgumentException if no CacheManager can be found_ if more than one_CachingConfigurer implementation exists_ if multiple CacheManager beans and no_CachingConfigurer exists to disambiguate.;@PostConstruct_	protected void reconcileCacheManager() {_		if (!CollectionUtils.isEmpty(cachingConfigurers)) {_			int nConfigurers = cachingConfigurers.size()__			if (nConfigurers > 1) {_				throw new IllegalStateException(nConfigurers + " implementations of " +_						"CachingConfigurer were found when only 1 was expected. " +_						"Refactor the configuration such that CachingConfigurer is " +_						"implemented only once or not at all.")__			}_			CachingConfigurer cachingConfigurer = cachingConfigurers.iterator().next()__			this.cacheManager = cachingConfigurer.cacheManager()__			this.keyGenerator = cachingConfigurer.keyGenerator()__		}_		else if (!CollectionUtils.isEmpty(cacheManagerBeans)) {_			int nManagers = cacheManagerBeans.size()__			if (nManagers > 1) {_				throw new IllegalStateException(nManagers + " beans of type CacheManager " +_						"were found when only 1 was expected. Remove all but one of the " +_						"CacheManager bean definitions, or implement CachingConfigurer " +_						"to make explicit which CacheManager should be used for " +_						"annotation-driven cache management.")__			}_			CacheManager cacheManager = cacheManagerBeans.iterator().next()__			this.cacheManager = cacheManager__			_		}_		else {_			throw new IllegalStateException("No bean of type CacheManager could be found. " +_					"Register a CacheManager bean or remove the @EnableCaching annotation " +_					"from your configuration.")__		}_	};determine,which,code,cache,manager,bean,to,use,prefer,the,result,of,link,caching,configurer,cache,manager,over,any,by,type,matching,if,none,fall,back,to,by,type,matching,on,code,cache,manager,throws,illegal,argument,exception,if,no,cache,manager,can,be,found,if,more,than,one,caching,configurer,implementation,exists,if,multiple,cache,manager,beans,and,no,caching,configurer,exists,to,disambiguate;post,construct,protected,void,reconcile,cache,manager,if,collection,utils,is,empty,caching,configurers,int,n,configurers,caching,configurers,size,if,n,configurers,1,throw,new,illegal,state,exception,n,configurers,implementations,of,caching,configurer,were,found,when,only,1,was,expected,refactor,the,configuration,such,that,caching,configurer,is,implemented,only,once,or,not,at,all,caching,configurer,caching,configurer,caching,configurers,iterator,next,this,cache,manager,caching,configurer,cache,manager,this,key,generator,caching,configurer,key,generator,else,if,collection,utils,is,empty,cache,manager,beans,int,n,managers,cache,manager,beans,size,if,n,managers,1,throw,new,illegal,state,exception,n,managers,beans,of,type,cache,manager,were,found,when,only,1,was,expected,remove,all,but,one,of,the,cache,manager,bean,definitions,or,implement,caching,configurer,to,make,explicit,which,cache,manager,should,be,used,for,annotation,driven,cache,management,cache,manager,cache,manager,cache,manager,beans,iterator,next,this,cache,manager,cache,manager,else,throw,new,illegal,state,exception,no,bean,of,type,cache,manager,could,be,found,register,a,cache,manager,bean,or,remove,the,enable,caching,annotation,from,your,configuration
AbstractCachingConfiguration -> @PostConstruct 	protected void reconcileCacheManager();1396865240;Determine which {@code CacheManager} bean to use. Prefer the result of_{@link CachingConfigurer#cacheManager()} over any by-type matching. If none, fall_back to by-type matching on {@code CacheManager}._@throws IllegalArgumentException if no CacheManager can be found_ if more than one_CachingConfigurer implementation exists_ if multiple CacheManager beans and no_CachingConfigurer exists to disambiguate.;@PostConstruct_	protected void reconcileCacheManager() {_		if (!CollectionUtils.isEmpty(cachingConfigurers)) {_			int nConfigurers = cachingConfigurers.size()__			if (nConfigurers > 1) {_				throw new IllegalStateException(nConfigurers + " implementations of " +_						"CachingConfigurer were found when only 1 was expected. " +_						"Refactor the configuration such that CachingConfigurer is " +_						"implemented only once or not at all.")__			}_			C cachingConfigurer = cachingConfigurers.iterator().next()__			useCachingConfigurer(cachingConfigurer)__		}_		else if (!CollectionUtils.isEmpty(cacheManagerBeans)) {_			int nManagers = cacheManagerBeans.size()__			if (nManagers > 1) {_				throw new IllegalStateException(nManagers + " beans of type CacheManager " +_						"were found when only 1 was expected. Remove all but one of the " +_						"CacheManager bean definitions, or implement CachingConfigurer " +_						"to make explicit which CacheManager should be used for " +_						"annotation-driven cache management.")__			}_			this.cacheManager = cacheManagerBeans.iterator().next()__			_		}_		else {_			throw new IllegalStateException("No bean of type CacheManager could be found. " +_					"Register a CacheManager bean or remove the @EnableCaching annotation " +_					"from your configuration.")__		}_	};determine,which,code,cache,manager,bean,to,use,prefer,the,result,of,link,caching,configurer,cache,manager,over,any,by,type,matching,if,none,fall,back,to,by,type,matching,on,code,cache,manager,throws,illegal,argument,exception,if,no,cache,manager,can,be,found,if,more,than,one,caching,configurer,implementation,exists,if,multiple,cache,manager,beans,and,no,caching,configurer,exists,to,disambiguate;post,construct,protected,void,reconcile,cache,manager,if,collection,utils,is,empty,caching,configurers,int,n,configurers,caching,configurers,size,if,n,configurers,1,throw,new,illegal,state,exception,n,configurers,implementations,of,caching,configurer,were,found,when,only,1,was,expected,refactor,the,configuration,such,that,caching,configurer,is,implemented,only,once,or,not,at,all,c,caching,configurer,caching,configurers,iterator,next,use,caching,configurer,caching,configurer,else,if,collection,utils,is,empty,cache,manager,beans,int,n,managers,cache,manager,beans,size,if,n,managers,1,throw,new,illegal,state,exception,n,managers,beans,of,type,cache,manager,were,found,when,only,1,was,expected,remove,all,but,one,of,the,cache,manager,bean,definitions,or,implement,caching,configurer,to,make,explicit,which,cache,manager,should,be,used,for,annotation,driven,cache,management,this,cache,manager,cache,manager,beans,iterator,next,else,throw,new,illegal,state,exception,no,bean,of,type,cache,manager,could,be,found,register,a,cache,manager,bean,or,remove,the,enable,caching,annotation,from,your,configuration
AbstractCachingConfiguration -> @PostConstruct 	protected void reconcileCacheManager();1396878069;Determine which {@code CacheManager} bean to use. Prefer the result of_{@link CachingConfigurer#cacheManager()} over any by-type matching. If none, fall_back to by-type matching on {@code CacheManager}._@throws IllegalArgumentException if no CacheManager can be found_ if more than one_CachingConfigurer implementation exists_ if multiple CacheManager beans and no_CachingConfigurer exists to disambiguate.;@PostConstruct_	protected void reconcileCacheManager() {_		if (!CollectionUtils.isEmpty(cachingConfigurers)) {_			int nConfigurers = cachingConfigurers.size()__			if (nConfigurers > 1) {_				throw new IllegalStateException(nConfigurers + " implementations of " +_						"CachingConfigurer were found when only 1 was expected. " +_						"Refactor the configuration such that CachingConfigurer is " +_						"implemented only once or not at all.")__			}_			C cachingConfigurer = cachingConfigurers.iterator().next()__			useCachingConfigurer(cachingConfigurer)__		}_		if (this.cacheManager == null && !CollectionUtils.isEmpty(cacheManagerBeans)) {_			int nManagers = cacheManagerBeans.size()__			if (nManagers > 1) {_				throw new IllegalStateException(nManagers + " beans of type CacheManager " +_						"were found when only 1 was expected. Remove all but one of the " +_						"CacheManager bean definitions, or implement CachingConfigurer " +_						"to make explicit which CacheManager should be used for " +_						"annotation-driven cache management.")__			}_			this.cacheManager = cacheManagerBeans.iterator().next()__			_		}_		if (this.cacheManager == null) {_			throw new IllegalStateException("No bean of type CacheManager could be found. " +_					"Register a CacheManager bean or remove the @EnableCaching annotation " +_					"from your configuration.")__		}_	};determine,which,code,cache,manager,bean,to,use,prefer,the,result,of,link,caching,configurer,cache,manager,over,any,by,type,matching,if,none,fall,back,to,by,type,matching,on,code,cache,manager,throws,illegal,argument,exception,if,no,cache,manager,can,be,found,if,more,than,one,caching,configurer,implementation,exists,if,multiple,cache,manager,beans,and,no,caching,configurer,exists,to,disambiguate;post,construct,protected,void,reconcile,cache,manager,if,collection,utils,is,empty,caching,configurers,int,n,configurers,caching,configurers,size,if,n,configurers,1,throw,new,illegal,state,exception,n,configurers,implementations,of,caching,configurer,were,found,when,only,1,was,expected,refactor,the,configuration,such,that,caching,configurer,is,implemented,only,once,or,not,at,all,c,caching,configurer,caching,configurers,iterator,next,use,caching,configurer,caching,configurer,if,this,cache,manager,null,collection,utils,is,empty,cache,manager,beans,int,n,managers,cache,manager,beans,size,if,n,managers,1,throw,new,illegal,state,exception,n,managers,beans,of,type,cache,manager,were,found,when,only,1,was,expected,remove,all,but,one,of,the,cache,manager,bean,definitions,or,implement,caching,configurer,to,make,explicit,which,cache,manager,should,be,used,for,annotation,driven,cache,management,this,cache,manager,cache,manager,beans,iterator,next,if,this,cache,manager,null,throw,new,illegal,state,exception,no,bean,of,type,cache,manager,could,be,found,register,a,cache,manager,bean,or,remove,the,enable,caching,annotation,from,your,configuration
AbstractCachingConfiguration -> @PostConstruct 	protected void reconcileCacheManager();1400596774;Determine which {@code CacheManager} bean to use. Prefer the result of_{@link CachingConfigurer#cacheManager()} over any by-type matching. If none, fall_back to by-type matching on {@code CacheManager}._@throws IllegalArgumentException if no CacheManager can be found_ if more than one_CachingConfigurer implementation exists_ if multiple CacheManager beans and no_CachingConfigurer exists to disambiguate.;@PostConstruct_	protected void reconcileCacheManager() {_		if (!CollectionUtils.isEmpty(cachingConfigurers)) {_			int nConfigurers = cachingConfigurers.size()__			if (nConfigurers > 1) {_				throw new IllegalStateException(nConfigurers + " implementations of " +_						"CachingConfigurer were found when only 1 was expected. " +_						"Refactor the configuration such that CachingConfigurer is " +_						"implemented only once or not at all.")__			}_			C cachingConfigurer = cachingConfigurers.iterator().next()__			useCachingConfigurer(cachingConfigurer)__		}_		if (this.cacheManager == null && !CollectionUtils.isEmpty(cacheManagerBeans)) {_			int nManagers = cacheManagerBeans.size()__			if (nManagers > 1) {_				throw new IllegalStateException(nManagers + " beans of type CacheManager " +_						"were found when only 1 was expected. Remove all but one of the " +_						"CacheManager bean definitions, or implement CachingConfigurer " +_						"to make explicit which CacheManager should be used for " +_						"annotation-driven cache management.")__			}_			this.cacheManager = cacheManagerBeans.iterator().next()__			_		}_		if (this.cacheManager == null) {_			throw new IllegalStateException("No bean of type CacheManager could be found. " +_					"Register a CacheManager bean or remove the @EnableCaching annotation " +_					"from your configuration.")__		}_	};determine,which,code,cache,manager,bean,to,use,prefer,the,result,of,link,caching,configurer,cache,manager,over,any,by,type,matching,if,none,fall,back,to,by,type,matching,on,code,cache,manager,throws,illegal,argument,exception,if,no,cache,manager,can,be,found,if,more,than,one,caching,configurer,implementation,exists,if,multiple,cache,manager,beans,and,no,caching,configurer,exists,to,disambiguate;post,construct,protected,void,reconcile,cache,manager,if,collection,utils,is,empty,caching,configurers,int,n,configurers,caching,configurers,size,if,n,configurers,1,throw,new,illegal,state,exception,n,configurers,implementations,of,caching,configurer,were,found,when,only,1,was,expected,refactor,the,configuration,such,that,caching,configurer,is,implemented,only,once,or,not,at,all,c,caching,configurer,caching,configurers,iterator,next,use,caching,configurer,caching,configurer,if,this,cache,manager,null,collection,utils,is,empty,cache,manager,beans,int,n,managers,cache,manager,beans,size,if,n,managers,1,throw,new,illegal,state,exception,n,managers,beans,of,type,cache,manager,were,found,when,only,1,was,expected,remove,all,but,one,of,the,cache,manager,bean,definitions,or,implement,caching,configurer,to,make,explicit,which,cache,manager,should,be,used,for,annotation,driven,cache,management,this,cache,manager,cache,manager,beans,iterator,next,if,this,cache,manager,null,throw,new,illegal,state,exception,no,bean,of,type,cache,manager,could,be,found,register,a,cache,manager,bean,or,remove,the,enable,caching,annotation,from,your,configuration
AbstractCachingConfiguration -> @PostConstruct 	protected void reconcileCacheManager();1413848647;Determine which {@code CacheManager} bean to use. Prefer the result of_{@link CachingConfigurer#cacheManager()} over any by-type matching. If none, fall_back to by-type matching on {@code CacheManager}._@throws IllegalArgumentException if no CacheManager can be found_ if more than one_CachingConfigurer implementation exists_ if multiple CacheManager beans and no_CachingConfigurer exists to disambiguate.;@PostConstruct_	protected void reconcileCacheManager() {_		if (!CollectionUtils.isEmpty(cachingConfigurers)) {_			int nConfigurers = cachingConfigurers.size()__			if (nConfigurers > 1) {_				throw new IllegalStateException(nConfigurers + " implementations of " +_						"CachingConfigurer were found when only 1 was expected. " +_						"Refactor the configuration such that CachingConfigurer is " +_						"implemented only once or not at all.")__			}_			C cachingConfigurer = cachingConfigurers.iterator().next()__			useCachingConfigurer(cachingConfigurer)__		}_		if (this.cacheManager == null && !CollectionUtils.isEmpty(cacheManagerBeans)) {_			int nManagers = cacheManagerBeans.size()__			if (nManagers > 1) {_				throw new IllegalStateException(nManagers + " beans of type CacheManager " +_						"were found when only 1 was expected. Remove all but one of the " +_						"CacheManager bean definitions, or implement CachingConfigurer " +_						"to make explicit which CacheManager should be used for " +_						"annotation-driven cache management.")__			}_			this.cacheManager = cacheManagerBeans.iterator().next()__			_		}_		if (this.cacheManager == null) {_			throw new IllegalStateException("No bean of type CacheManager could be found. " +_					"Register a CacheManager bean or remove the @EnableCaching annotation " +_					"from your configuration.")__		}_	};determine,which,code,cache,manager,bean,to,use,prefer,the,result,of,link,caching,configurer,cache,manager,over,any,by,type,matching,if,none,fall,back,to,by,type,matching,on,code,cache,manager,throws,illegal,argument,exception,if,no,cache,manager,can,be,found,if,more,than,one,caching,configurer,implementation,exists,if,multiple,cache,manager,beans,and,no,caching,configurer,exists,to,disambiguate;post,construct,protected,void,reconcile,cache,manager,if,collection,utils,is,empty,caching,configurers,int,n,configurers,caching,configurers,size,if,n,configurers,1,throw,new,illegal,state,exception,n,configurers,implementations,of,caching,configurer,were,found,when,only,1,was,expected,refactor,the,configuration,such,that,caching,configurer,is,implemented,only,once,or,not,at,all,c,caching,configurer,caching,configurers,iterator,next,use,caching,configurer,caching,configurer,if,this,cache,manager,null,collection,utils,is,empty,cache,manager,beans,int,n,managers,cache,manager,beans,size,if,n,managers,1,throw,new,illegal,state,exception,n,managers,beans,of,type,cache,manager,were,found,when,only,1,was,expected,remove,all,but,one,of,the,cache,manager,bean,definitions,or,implement,caching,configurer,to,make,explicit,which,cache,manager,should,be,used,for,annotation,driven,cache,management,this,cache,manager,cache,manager,beans,iterator,next,if,this,cache,manager,null,throw,new,illegal,state,exception,no,bean,of,type,cache,manager,could,be,found,register,a,cache,manager,bean,or,remove,the,enable,caching,annotation,from,your,configuration
AbstractCachingConfiguration -> protected void useCachingConfigurer(C config);1396865240;Extract the configuration from the nominated {@link CachingConfigurer}.;protected void useCachingConfigurer(C config) {_		this.cacheManager = config.cacheManager()__		this.keyGenerator = config.keyGenerator()__	};extract,the,configuration,from,the,nominated,link,caching,configurer;protected,void,use,caching,configurer,c,config,this,cache,manager,config,cache,manager,this,key,generator,config,key,generator
AbstractCachingConfiguration -> protected void useCachingConfigurer(C config);1396878069;Extract the configuration from the nominated {@link CachingConfigurer}.;protected void useCachingConfigurer(C config) {_		this.cacheManager = config.cacheManager()__		this.cacheResolver = config.cacheResolver()__		this.keyGenerator = config.keyGenerator()__	};extract,the,configuration,from,the,nominated,link,caching,configurer;protected,void,use,caching,configurer,c,config,this,cache,manager,config,cache,manager,this,cache,resolver,config,cache,resolver,this,key,generator,config,key,generator
AbstractCachingConfiguration -> protected void useCachingConfigurer(C config);1400596774;Extract the configuration from the nominated {@link CachingConfigurer}.;protected void useCachingConfigurer(C config) {_		this.cacheManager = config.cacheManager()__		this.cacheResolver = config.cacheResolver()__		this.keyGenerator = config.keyGenerator()__		this.errorHandler = config.errorHandler()__	};extract,the,configuration,from,the,nominated,link,caching,configurer;protected,void,use,caching,configurer,c,config,this,cache,manager,config,cache,manager,this,cache,resolver,config,cache,resolver,this,key,generator,config,key,generator,this,error,handler,config,error,handler
AbstractCachingConfiguration -> protected void useCachingConfigurer(C config);1413848647;Extract the configuration from the nominated {@link CachingConfigurer}.;protected void useCachingConfigurer(C config) {_		this.cacheManager = config.cacheManager()__		this.cacheResolver = config.cacheResolver()__		this.keyGenerator = config.keyGenerator()__		this.errorHandler = config.errorHandler()__	};extract,the,configuration,from,the,nominated,link,caching,configurer;protected,void,use,caching,configurer,c,config,this,cache,manager,config,cache,manager,this,cache,resolver,config,cache,resolver,this,key,generator,config,key,generator,this,error,handler,config,error,handler
AbstractCachingConfiguration -> protected void useCachingConfigurer(C config);1414762650;Extract the configuration from the nominated {@link CachingConfigurer}.;protected void useCachingConfigurer(C config) {_		this.cacheManager = config.cacheManager()__		this.cacheResolver = config.cacheResolver()__		this.keyGenerator = config.keyGenerator()__		this.errorHandler = config.errorHandler()__	};extract,the,configuration,from,the,nominated,link,caching,configurer;protected,void,use,caching,configurer,c,config,this,cache,manager,config,cache,manager,this,cache,resolver,config,cache,resolver,this,key,generator,config,key,generator,this,error,handler,config,error,handler
AbstractCachingConfiguration -> protected void useCachingConfigurer(C config);1425330316;Extract the configuration from the nominated {@link CachingConfigurer}.;protected void useCachingConfigurer(C config) {_		this.cacheManager = config.cacheManager()__		this.cacheResolver = config.cacheResolver()__		this.keyGenerator = config.keyGenerator()__		this.errorHandler = config.errorHandler()__	};extract,the,configuration,from,the,nominated,link,caching,configurer;protected,void,use,caching,configurer,c,config,this,cache,manager,config,cache,manager,this,cache,resolver,config,cache,resolver,this,key,generator,config,key,generator,this,error,handler,config,error,handler
