commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int getOrder() {     return LOWEST_PRECEDENCE. }
true;public;1;3;/**  * Set the {@link org.springframework.scheduling.TaskScheduler} that will invoke  * the scheduled methods, or a {@link java.util.concurrent.ScheduledExecutorService}  * to be wrapped as a TaskScheduler.  * <p>If not specified, default scheduler resolution will apply: searching for a  * unique {@link TaskScheduler} bean in the context, or for a {@link TaskScheduler}  * bean named "taskScheduler" otherwise. the same lookup will also be performed for  * a {@link ScheduledExecutorService} bean. If neither of the two is resolvable,  * a local single-threaded default scheduler will be created within the registrar.  * @see #DEFAULT_TASK_SCHEDULER_BEAN_NAME  */ ;/**  * Set the {@link org.springframework.scheduling.TaskScheduler} that will invoke  * the scheduled methods, or a {@link java.util.concurrent.ScheduledExecutorService}  * to be wrapped as a TaskScheduler.  * <p>If not specified, default scheduler resolution will apply: searching for a  * unique {@link TaskScheduler} bean in the context, or for a {@link TaskScheduler}  * bean named "taskScheduler" otherwise. the same lookup will also be performed for  * a {@link ScheduledExecutorService} bean. If neither of the two is resolvable,  * a local single-threaded default scheduler will be created within the registrar.  * @see #DEFAULT_TASK_SCHEDULER_BEAN_NAME  */ public void setScheduler(Object scheduler) {     this.scheduler = scheduler. }
false;public;1;4;;@Override public void setEmbeddedValueResolver(StringValueResolver resolver) {     this.embeddedValueResolver = resolver. }
false;public;1;4;;@Override public void setBeanName(String beanName) {     this.beanName = beanName. }
true;public;1;4;/**  * Making a {@link BeanFactory} available is optional. if not set,  * {@link SchedulingConfigurer} beans won't get autodetected and  * a {@link #setScheduler scheduler} has to be explicitly configured.  */ ;/**  * Making a {@link BeanFactory} available is optional. if not set,  * {@link SchedulingConfigurer} beans won't get autodetected and  * a {@link #setScheduler scheduler} has to be explicitly configured.  */ @Override public void setBeanFactory(BeanFactory beanFactory) {     this.beanFactory = beanFactory. }
true;public;1;7;/**  * Setting an {@link ApplicationContext} is optional: If set, registered  * tasks will be activated in the {@link ContextRefreshedEvent} phase.  * if not set, it will happen at {@link #afterSingletonsInstantiated} time.  */ ;/**  * Setting an {@link ApplicationContext} is optional: If set, registered  * tasks will be activated in the {@link ContextRefreshedEvent} phase.  * if not set, it will happen at {@link #afterSingletonsInstantiated} time.  */ @Override public void setApplicationContext(ApplicationContext applicationContext) {     this.applicationContext = applicationContext.     if (this.beanFactory == null) {         this.beanFactory = applicationContext.     } }
false;public;0;10;;@Override public void afterSingletonsInstantiated() {     // Remove resolved singleton classes from cache     this.nonAnnotatedClasses.clear().     if (this.applicationContext == null) {         // Not running in an ApplicationContext -> register tasks early...         finishRegistration().     } }
false;public;1;9;;@Override public void onApplicationEvent(ContextRefreshedEvent event) {     if (event.getApplicationContext() == this.applicationContext) {         // Running in an ApplicationContext -> register tasks this late...         // giving other ContextRefreshedEvent listeners a chance to perform         // their work at the same time (e.g. Spring Batch's job registration).         finishRegistration().     } }
false;private;0;67;;private void finishRegistration() {     if (this.scheduler != null) {         this.registrar.setScheduler(this.scheduler).     }     if (this.beanFactory instanceof ListableBeanFactory) {         Map<String, SchedulingConfigurer> beans = ((ListableBeanFactory) this.beanFactory).getBeansOfType(SchedulingConfigurer.class).         List<SchedulingConfigurer> configurers = new ArrayList<>(beans.values()).         AnnotationAwareOrderComparator.sort(configurers).         for (SchedulingConfigurer configurer : configurers) {             configurer.configureTasks(this.registrar).         }     }     if (this.registrar.hasTasks() && this.registrar.getScheduler() == null) {         Assert.state(this.beanFactory != null, "BeanFactory must be set to find scheduler by type").         try {             // Search for TaskScheduler bean...             this.registrar.setTaskScheduler(resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false)).         } catch (NoUniqueBeanDefinitionException ex) {             logger.trace("Could not find unique TaskScheduler bean", ex).             try {                 this.registrar.setTaskScheduler(resolveSchedulerBean(this.beanFactory, TaskScheduler.class, true)).             } catch (NoSuchBeanDefinitionException ex2) {                 if (logger.isInfoEnabled()) {                     logger.info("More than one TaskScheduler bean exists within the context, and " + "none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' " + "(possibly as an alias). or implement the SchedulingConfigurer interface and call " + "ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: " + ex.getBeanNamesFound()).                 }             }         } catch (NoSuchBeanDefinitionException ex) {             logger.trace("Could not find default TaskScheduler bean", ex).             // Search for ScheduledExecutorService bean next...             try {                 this.registrar.setScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, false)).             } catch (NoUniqueBeanDefinitionException ex2) {                 logger.trace("Could not find unique ScheduledExecutorService bean", ex2).                 try {                     this.registrar.setScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, true)).                 } catch (NoSuchBeanDefinitionException ex3) {                     if (logger.isInfoEnabled()) {                         logger.info("More than one ScheduledExecutorService bean exists within the context, and " + "none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' " + "(possibly as an alias). or implement the SchedulingConfigurer interface and call " + "ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: " + ex2.getBeanNamesFound()).                     }                 }             } catch (NoSuchBeanDefinitionException ex2) {                 logger.trace("Could not find default ScheduledExecutorService bean", ex2).                 // Giving up -> falling back to default scheduler within the registrar...                 logger.info("No TaskScheduler/ScheduledExecutorService bean found for scheduled processing").             }         }     }     this.registrar.afterPropertiesSet(). }
false;private;3;20;;private <T> T resolveSchedulerBean(BeanFactory beanFactory, Class<T> schedulerType, boolean byName) {     if (byName) {         T scheduler = beanFactory.getBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, schedulerType).         if (this.beanName != null && this.beanFactory instanceof ConfigurableBeanFactory) {             ((ConfigurableBeanFactory) this.beanFactory).registerDependentBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, this.beanName).         }         return scheduler.     } else if (beanFactory instanceof AutowireCapableBeanFactory) {         NamedBeanHolder<T> holder = ((AutowireCapableBeanFactory) beanFactory).resolveNamedBean(schedulerType).         if (this.beanName != null && beanFactory instanceof ConfigurableBeanFactory) {             ((ConfigurableBeanFactory) beanFactory).registerDependentBean(holder.getBeanName(), this.beanName).         }         return holder.getBeanInstance().     } else {         return beanFactory.getBean(schedulerType).     } }
false;public;3;3;;@Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) { }
false;public;2;4;;@Override public Object postProcessBeforeInitialization(Object bean, String beanName) {     return bean. }
false;public;2;34;;@Override public Object postProcessAfterInitialization(Object bean, String beanName) {     if (bean instanceof AopInfrastructureBean || bean instanceof TaskScheduler || bean instanceof ScheduledExecutorService) {         // Ignore AOP infrastructure such as scoped proxies.         return bean.     }     Class<?> targetClass = AopProxyUtils.ultimateTargetClass(bean).     if (!this.nonAnnotatedClasses.contains(targetClass)) {         Map<Method, Set<Scheduled>> annotatedMethods = MethodIntrospector.selectMethods(targetClass, (MethodIntrospector.MetadataLookup<Set<Scheduled>>) method -> {             Set<Scheduled> scheduledMethods = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, Scheduled.class, Schedules.class).             return (!scheduledMethods.isEmpty() ? scheduledMethods : null).         }).         if (annotatedMethods.isEmpty()) {             this.nonAnnotatedClasses.add(targetClass).             if (logger.isTraceEnabled()) {                 logger.trace("No @Scheduled annotations found on bean class: " + targetClass).             }         } else {             // Non-empty set of methods             annotatedMethods.forEach((method, scheduledMethods) -> scheduledMethods.forEach(scheduled -> processScheduled(scheduled, method, bean))).             if (logger.isTraceEnabled()) {                 logger.trace(annotatedMethods.size() + " @Scheduled methods processed on bean '" + beanName + "': " + annotatedMethods).             }         }     }     return bean. }
true;protected;3;123;/**  * Process the given {@code @Scheduled} method declaration on the given bean.  * @param scheduled the @Scheduled annotation  * @param method the method that the annotation has been declared on  * @param bean the target bean instance  * @see #createRunnable(Object, Method)  */ ;/**  * Process the given {@code @Scheduled} method declaration on the given bean.  * @param scheduled the @Scheduled annotation  * @param method the method that the annotation has been declared on  * @param bean the target bean instance  * @see #createRunnable(Object, Method)  */ protected void processScheduled(Scheduled scheduled, Method method, Object bean) {     try {         Runnable runnable = createRunnable(bean, method).         boolean processedSchedule = false.         String errorMessage = "Exactly one of the 'cron', 'fixedDelay(String)', or 'fixedRate(String)' attributes is required".         Set<ScheduledTask> tasks = new LinkedHashSet<>(4).         // Determine initial delay         long initialDelay = scheduled.initialDelay().         String initialDelayString = scheduled.initialDelayString().         if (StringUtils.hasText(initialDelayString)) {             Assert.isTrue(initialDelay < 0, "Specify 'initialDelay' or 'initialDelayString', not both").             if (this.embeddedValueResolver != null) {                 initialDelayString = this.embeddedValueResolver.resolveStringValue(initialDelayString).             }             if (StringUtils.hasLength(initialDelayString)) {                 try {                     initialDelay = parseDelayAsLong(initialDelayString).                 } catch (RuntimeException ex) {                     throw new IllegalArgumentException("Invalid initialDelayString value \"" + initialDelayString + "\" - cannot parse into long").                 }             }         }         // Check cron expression         String cron = scheduled.cron().         if (StringUtils.hasText(cron)) {             String zone = scheduled.zone().             if (this.embeddedValueResolver != null) {                 cron = this.embeddedValueResolver.resolveStringValue(cron).                 zone = this.embeddedValueResolver.resolveStringValue(zone).             }             if (StringUtils.hasLength(cron)) {                 Assert.isTrue(initialDelay == -1, "'initialDelay' not supported for cron triggers").                 processedSchedule = true.                 if (!Scheduled.CRON_DISABLED.equals(cron)) {                     TimeZone timeZone.                     if (StringUtils.hasText(zone)) {                         timeZone = StringUtils.parseTimeZoneString(zone).                     } else {                         timeZone = TimeZone.getDefault().                     }                     tasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone)))).                 }             }         }         // At this point we don't need to differentiate between initial delay set or not anymore         if (initialDelay < 0) {             initialDelay = 0.         }         // Check fixed delay         long fixedDelay = scheduled.fixedDelay().         if (fixedDelay >= 0) {             Assert.isTrue(!processedSchedule, errorMessage).             processedSchedule = true.             tasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay))).         }         String fixedDelayString = scheduled.fixedDelayString().         if (StringUtils.hasText(fixedDelayString)) {             if (this.embeddedValueResolver != null) {                 fixedDelayString = this.embeddedValueResolver.resolveStringValue(fixedDelayString).             }             if (StringUtils.hasLength(fixedDelayString)) {                 Assert.isTrue(!processedSchedule, errorMessage).                 processedSchedule = true.                 try {                     fixedDelay = parseDelayAsLong(fixedDelayString).                 } catch (RuntimeException ex) {                     throw new IllegalArgumentException("Invalid fixedDelayString value \"" + fixedDelayString + "\" - cannot parse into long").                 }                 tasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay))).             }         }         // Check fixed rate         long fixedRate = scheduled.fixedRate().         if (fixedRate >= 0) {             Assert.isTrue(!processedSchedule, errorMessage).             processedSchedule = true.             tasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay))).         }         String fixedRateString = scheduled.fixedRateString().         if (StringUtils.hasText(fixedRateString)) {             if (this.embeddedValueResolver != null) {                 fixedRateString = this.embeddedValueResolver.resolveStringValue(fixedRateString).             }             if (StringUtils.hasLength(fixedRateString)) {                 Assert.isTrue(!processedSchedule, errorMessage).                 processedSchedule = true.                 try {                     fixedRate = parseDelayAsLong(fixedRateString).                 } catch (RuntimeException ex) {                     throw new IllegalArgumentException("Invalid fixedRateString value \"" + fixedRateString + "\" - cannot parse into long").                 }                 tasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay))).             }         }         // Check whether we had any attribute set         Assert.isTrue(processedSchedule, errorMessage).         // Finally register the scheduled tasks         synchronized (this.scheduledTasks) {             Set<ScheduledTask> regTasks = this.scheduledTasks.computeIfAbsent(bean, key -> new LinkedHashSet<>(4)).             regTasks.addAll(tasks).         }     } catch (IllegalArgumentException ex) {         throw new IllegalStateException("Encountered invalid @Scheduled method '" + method.getName() + "': " + ex.getMessage()).     } }
true;protected;2;5;/**  * Create a {@link Runnable} for the given bean instance,  * calling the specified scheduled method.  * <p>The default implementation creates a {@link ScheduledMethodRunnable}.  * @param target the target bean instance  * @param method the scheduled method to call  * @since 5.1  * @see ScheduledMethodRunnable#ScheduledMethodRunnable(Object, Method)  */ ;/**  * Create a {@link Runnable} for the given bean instance,  * calling the specified scheduled method.  * <p>The default implementation creates a {@link ScheduledMethodRunnable}.  * @param target the target bean instance  * @param method the scheduled method to call  * @since 5.1  * @see ScheduledMethodRunnable#ScheduledMethodRunnable(Object, Method)  */ protected Runnable createRunnable(Object target, Method method) {     Assert.isTrue(method.getParameterCount() == 0, "Only no-arg methods may be annotated with @Scheduled").     Method invocableMethod = AopUtils.selectInvocableMethod(method, target.getClass()).     return new ScheduledMethodRunnable(target, invocableMethod). }
false;private,static;1;6;;private static long parseDelayAsLong(String value) throws RuntimeException {     if (value.length() > 1 && (isP(value.charAt(0)) || isP(value.charAt(1)))) {         return Duration.parse(value).toMillis().     }     return Long.parseLong(value). }
false;private,static;1;3;;private static boolean isP(char ch) {     return (ch == 'P' || ch == 'p'). }
true;public;0;12;/**  * Return all currently scheduled tasks, from {@link Scheduled} methods  * as well as from programmatic {@link SchedulingConfigurer} interaction.  * @since 5.0.2  */ ;/**  * Return all currently scheduled tasks, from {@link Scheduled} methods  * as well as from programmatic {@link SchedulingConfigurer} interaction.  * @since 5.0.2  */ @Override public Set<ScheduledTask> getScheduledTasks() {     Set<ScheduledTask> result = new LinkedHashSet<>().     synchronized (this.scheduledTasks) {         Collection<Set<ScheduledTask>> allTasks = this.scheduledTasks.values().         for (Set<ScheduledTask> tasks : allTasks) {             result.addAll(tasks).         }     }     result.addAll(this.registrar.getScheduledTasks()).     return result. }
false;public;2;12;;@Override public void postProcessBeforeDestruction(Object bean, String beanName) {     Set<ScheduledTask> tasks.     synchronized (this.scheduledTasks) {         tasks = this.scheduledTasks.remove(bean).     }     if (tasks != null) {         for (ScheduledTask task : tasks) {             task.cancel().         }     } }
false;public;1;6;;@Override public boolean requiresDestruction(Object bean) {     synchronized (this.scheduledTasks) {         return this.scheduledTasks.containsKey(bean).     } }
false;public;0;13;;@Override public void destroy() {     synchronized (this.scheduledTasks) {         Collection<Set<ScheduledTask>> allTasks = this.scheduledTasks.values().         for (Set<ScheduledTask> tasks : allTasks) {             for (ScheduledTask task : tasks) {                 task.cancel().             }         }         this.scheduledTasks.clear().     }     this.registrar.destroy(). }
