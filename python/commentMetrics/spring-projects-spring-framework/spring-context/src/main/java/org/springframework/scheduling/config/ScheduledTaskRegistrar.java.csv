commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the {@link TaskScheduler} to register scheduled tasks with.  */ ;/**  * Set the {@link TaskScheduler} to register scheduled tasks with.  */ public void setTaskScheduler(TaskScheduler taskScheduler) {     Assert.notNull(taskScheduler, "TaskScheduler must not be null").     this.taskScheduler = taskScheduler. }
true;public;1;14;/**  * Set the {@link TaskScheduler} to register scheduled tasks with, or a  * {@link java.util.concurrent.ScheduledExecutorService} to be wrapped as a  * {@code TaskScheduler}.  */ ;/**  * Set the {@link TaskScheduler} to register scheduled tasks with, or a  * {@link java.util.concurrent.ScheduledExecutorService} to be wrapped as a  * {@code TaskScheduler}.  */ public void setScheduler(@Nullable Object scheduler) {     if (scheduler == null) {         this.taskScheduler = null.     } else if (scheduler instanceof TaskScheduler) {         this.taskScheduler = (TaskScheduler) scheduler.     } else if (scheduler instanceof ScheduledExecutorService) {         this.taskScheduler = new ConcurrentTaskScheduler(((ScheduledExecutorService) scheduler)).     } else {         throw new IllegalArgumentException("Unsupported scheduler type: " + scheduler.getClass()).     } }
true;public;0;4;/**  * Return the {@link TaskScheduler} instance for this registrar (may be {@code null}).  */ ;/**  * Return the {@link TaskScheduler} instance for this registrar (may be {@code null}).  */ @Nullable public TaskScheduler getScheduler() {     return this.taskScheduler. }
true;public;1;4;/**  * Specify triggered tasks as a Map of Runnables (the tasks) and Trigger objects  * (typically custom implementations of the {@link Trigger} interface).  */ ;/**  * Specify triggered tasks as a Map of Runnables (the tasks) and Trigger objects  * (typically custom implementations of the {@link Trigger} interface).  */ public void setTriggerTasks(Map<Runnable, Trigger> triggerTasks) {     this.triggerTasks = new ArrayList<>().     triggerTasks.forEach((task, trigger) -> addTriggerTask(new TriggerTask(task, trigger))). }
true;public;1;3;/**  * Specify triggered tasks as a list of {@link TriggerTask} objects. Primarily used  * by {@code <task:*>} namespace parsing.  * @since 3.2  * @see ScheduledTasksBeanDefinitionParser  */ ;/**  * Specify triggered tasks as a list of {@link TriggerTask} objects. Primarily used  * by {@code <task:*>} namespace parsing.  * @since 3.2  * @see ScheduledTasksBeanDefinitionParser  */ public void setTriggerTasksList(List<TriggerTask> triggerTasks) {     this.triggerTasks = triggerTasks. }
true;public;0;4;/**  * Get the trigger tasks as an unmodifiable list of {@link TriggerTask} objects.  * @return the list of tasks (never {@code null})  * @since 4.2  */ ;/**  * Get the trigger tasks as an unmodifiable list of {@link TriggerTask} objects.  * @return the list of tasks (never {@code null})  * @since 4.2  */ public List<TriggerTask> getTriggerTaskList() {     return (this.triggerTasks != null ? Collections.unmodifiableList(this.triggerTasks) : Collections.emptyList()). }
true;public;1;4;/**  * Specify triggered tasks as a Map of Runnables (the tasks) and cron expressions.  * @see CronTrigger  */ ;/**  * Specify triggered tasks as a Map of Runnables (the tasks) and cron expressions.  * @see CronTrigger  */ public void setCronTasks(Map<Runnable, String> cronTasks) {     this.cronTasks = new ArrayList<>().     cronTasks.forEach(this::addCronTask). }
true;public;1;3;/**  * Specify triggered tasks as a list of {@link CronTask} objects. Primarily used by  * {@code <task:*>} namespace parsing.  * @since 3.2  * @see ScheduledTasksBeanDefinitionParser  */ ;/**  * Specify triggered tasks as a list of {@link CronTask} objects. Primarily used by  * {@code <task:*>} namespace parsing.  * @since 3.2  * @see ScheduledTasksBeanDefinitionParser  */ public void setCronTasksList(List<CronTask> cronTasks) {     this.cronTasks = cronTasks. }
true;public;0;4;/**  * Get the cron tasks as an unmodifiable list of {@link CronTask} objects.  * @return the list of tasks (never {@code null})  * @since 4.2  */ ;/**  * Get the cron tasks as an unmodifiable list of {@link CronTask} objects.  * @return the list of tasks (never {@code null})  * @since 4.2  */ public List<CronTask> getCronTaskList() {     return (this.cronTasks != null ? Collections.unmodifiableList(this.cronTasks) : Collections.emptyList()). }
true;public;1;4;/**  * Specify triggered tasks as a Map of Runnables (the tasks) and fixed-rate values.  * @see TaskScheduler#scheduleAtFixedRate(Runnable, long)  */ ;/**  * Specify triggered tasks as a Map of Runnables (the tasks) and fixed-rate values.  * @see TaskScheduler#scheduleAtFixedRate(Runnable, long)  */ public void setFixedRateTasks(Map<Runnable, Long> fixedRateTasks) {     this.fixedRateTasks = new ArrayList<>().     fixedRateTasks.forEach(this::addFixedRateTask). }
true;public;1;3;/**  * Specify fixed-rate tasks as a list of {@link IntervalTask} objects. Primarily used  * by {@code <task:*>} namespace parsing.  * @since 3.2  * @see ScheduledTasksBeanDefinitionParser  */ ;/**  * Specify fixed-rate tasks as a list of {@link IntervalTask} objects. Primarily used  * by {@code <task:*>} namespace parsing.  * @since 3.2  * @see ScheduledTasksBeanDefinitionParser  */ public void setFixedRateTasksList(List<IntervalTask> fixedRateTasks) {     this.fixedRateTasks = fixedRateTasks. }
true;public;0;4;/**  * Get the fixed-rate tasks as an unmodifiable list of {@link IntervalTask} objects.  * @return the list of tasks (never {@code null})  * @since 4.2  */ ;/**  * Get the fixed-rate tasks as an unmodifiable list of {@link IntervalTask} objects.  * @return the list of tasks (never {@code null})  * @since 4.2  */ public List<IntervalTask> getFixedRateTaskList() {     return (this.fixedRateTasks != null ? Collections.unmodifiableList(this.fixedRateTasks) : Collections.emptyList()). }
true;public;1;4;/**  * Specify triggered tasks as a Map of Runnables (the tasks) and fixed-delay values.  * @see TaskScheduler#scheduleWithFixedDelay(Runnable, long)  */ ;/**  * Specify triggered tasks as a Map of Runnables (the tasks) and fixed-delay values.  * @see TaskScheduler#scheduleWithFixedDelay(Runnable, long)  */ public void setFixedDelayTasks(Map<Runnable, Long> fixedDelayTasks) {     this.fixedDelayTasks = new ArrayList<>().     fixedDelayTasks.forEach(this::addFixedDelayTask). }
true;public;1;3;/**  * Specify fixed-delay tasks as a list of {@link IntervalTask} objects. Primarily used  * by {@code <task:*>} namespace parsing.  * @since 3.2  * @see ScheduledTasksBeanDefinitionParser  */ ;/**  * Specify fixed-delay tasks as a list of {@link IntervalTask} objects. Primarily used  * by {@code <task:*>} namespace parsing.  * @since 3.2  * @see ScheduledTasksBeanDefinitionParser  */ public void setFixedDelayTasksList(List<IntervalTask> fixedDelayTasks) {     this.fixedDelayTasks = fixedDelayTasks. }
true;public;0;4;/**  * Get the fixed-delay tasks as an unmodifiable list of {@link IntervalTask} objects.  * @return the list of tasks (never {@code null})  * @since 4.2  */ ;/**  * Get the fixed-delay tasks as an unmodifiable list of {@link IntervalTask} objects.  * @return the list of tasks (never {@code null})  * @since 4.2  */ public List<IntervalTask> getFixedDelayTaskList() {     return (this.fixedDelayTasks != null ? Collections.unmodifiableList(this.fixedDelayTasks) : Collections.emptyList()). }
true;public;2;3;/**  * Add a Runnable task to be triggered per the given {@link Trigger}.  * @see TaskScheduler#scheduleAtFixedRate(Runnable, long)  */ ;/**  * Add a Runnable task to be triggered per the given {@link Trigger}.  * @see TaskScheduler#scheduleAtFixedRate(Runnable, long)  */ public void addTriggerTask(Runnable task, Trigger trigger) {     addTriggerTask(new TriggerTask(task, trigger)). }
true;public;1;6;/**  * Add a {@code TriggerTask}.  * @since 3.2  * @see TaskScheduler#scheduleAtFixedRate(Runnable, long)  */ ;/**  * Add a {@code TriggerTask}.  * @since 3.2  * @see TaskScheduler#scheduleAtFixedRate(Runnable, long)  */ public void addTriggerTask(TriggerTask task) {     if (this.triggerTasks == null) {         this.triggerTasks = new ArrayList<>().     }     this.triggerTasks.add(task). }
true;public;2;3;/**  * Add a Runnable task to be triggered per the given cron expression.  */ ;/**  * Add a Runnable task to be triggered per the given cron expression.  */ public void addCronTask(Runnable task, String expression) {     addCronTask(new CronTask(task, expression)). }
true;public;1;6;/**  * Add a {@link CronTask}.  * @since 3.2  */ ;/**  * Add a {@link CronTask}.  * @since 3.2  */ public void addCronTask(CronTask task) {     if (this.cronTasks == null) {         this.cronTasks = new ArrayList<>().     }     this.cronTasks.add(task). }
true;public;2;3;/**  * Add a {@code Runnable} task to be triggered at the given fixed-rate interval.  * @see TaskScheduler#scheduleAtFixedRate(Runnable, long)  */ ;/**  * Add a {@code Runnable} task to be triggered at the given fixed-rate interval.  * @see TaskScheduler#scheduleAtFixedRate(Runnable, long)  */ public void addFixedRateTask(Runnable task, long interval) {     addFixedRateTask(new IntervalTask(task, interval, 0)). }
true;public;1;6;/**  * Add a fixed-rate {@link IntervalTask}.  * @since 3.2  * @see TaskScheduler#scheduleAtFixedRate(Runnable, long)  */ ;/**  * Add a fixed-rate {@link IntervalTask}.  * @since 3.2  * @see TaskScheduler#scheduleAtFixedRate(Runnable, long)  */ public void addFixedRateTask(IntervalTask task) {     if (this.fixedRateTasks == null) {         this.fixedRateTasks = new ArrayList<>().     }     this.fixedRateTasks.add(task). }
true;public;2;3;/**  * Add a Runnable task to be triggered with the given fixed delay.  * @see TaskScheduler#scheduleWithFixedDelay(Runnable, long)  */ ;/**  * Add a Runnable task to be triggered with the given fixed delay.  * @see TaskScheduler#scheduleWithFixedDelay(Runnable, long)  */ public void addFixedDelayTask(Runnable task, long delay) {     addFixedDelayTask(new IntervalTask(task, delay, 0)). }
true;public;1;6;/**  * Add a fixed-delay {@link IntervalTask}.  * @since 3.2  * @see TaskScheduler#scheduleWithFixedDelay(Runnable, long)  */ ;/**  * Add a fixed-delay {@link IntervalTask}.  * @since 3.2  * @see TaskScheduler#scheduleWithFixedDelay(Runnable, long)  */ public void addFixedDelayTask(IntervalTask task) {     if (this.fixedDelayTasks == null) {         this.fixedDelayTasks = new ArrayList<>().     }     this.fixedDelayTasks.add(task). }
true;public;0;6;/**  * Return whether this {@code ScheduledTaskRegistrar} has any tasks registered.  * @since 3.2  */ ;/**  * Return whether this {@code ScheduledTaskRegistrar} has any tasks registered.  * @since 3.2  */ public boolean hasTasks() {     return (!CollectionUtils.isEmpty(this.triggerTasks) || !CollectionUtils.isEmpty(this.cronTasks) || !CollectionUtils.isEmpty(this.fixedRateTasks) || !CollectionUtils.isEmpty(this.fixedDelayTasks)). }
true;public;0;4;/**  * Calls {@link #scheduleTasks()} at bean construction time.  */ ;/**  * Calls {@link #scheduleTasks()} at bean construction time.  */ @Override public void afterPropertiesSet() {     scheduleTasks(). }
true;protected;0;27;/**  * Schedule all registered tasks against the underlying  * {@linkplain #setTaskScheduler(TaskScheduler) task scheduler}.  */ ;/**  * Schedule all registered tasks against the underlying  * {@linkplain #setTaskScheduler(TaskScheduler) task scheduler}.  */ @SuppressWarnings("deprecation") protected void scheduleTasks() {     if (this.taskScheduler == null) {         this.localExecutor = Executors.newSingleThreadScheduledExecutor().         this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor).     }     if (this.triggerTasks != null) {         for (TriggerTask task : this.triggerTasks) {             addScheduledTask(scheduleTriggerTask(task)).         }     }     if (this.cronTasks != null) {         for (CronTask task : this.cronTasks) {             addScheduledTask(scheduleCronTask(task)).         }     }     if (this.fixedRateTasks != null) {         for (IntervalTask task : this.fixedRateTasks) {             addScheduledTask(scheduleFixedRateTask(task)).         }     }     if (this.fixedDelayTasks != null) {         for (IntervalTask task : this.fixedDelayTasks) {             addScheduledTask(scheduleFixedDelayTask(task)).         }     } }
false;private;1;5;;private void addScheduledTask(@Nullable ScheduledTask task) {     if (task != null) {         this.scheduledTasks.add(task).     } }
true;public;1;17;/**  * Schedule the specified trigger task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * @since 4.3  */ ;/**  * Schedule the specified trigger task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * @since 4.3  */ @Nullable public ScheduledTask scheduleTriggerTask(TriggerTask task) {     ScheduledTask scheduledTask = this.unresolvedTasks.remove(task).     boolean newTask = false.     if (scheduledTask == null) {         scheduledTask = new ScheduledTask(task).         newTask = true.     }     if (this.taskScheduler != null) {         scheduledTask.future = this.taskScheduler.schedule(task.getRunnable(), task.getTrigger()).     } else {         addTriggerTask(task).         this.unresolvedTasks.put(task, scheduledTask).     }     return (newTask ? scheduledTask : null). }
true;public;1;17;/**  * Schedule the specified cron task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * (or {@code null} if processing a previously registered task)  * @since 4.3  */ ;/**  * Schedule the specified cron task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * (or {@code null} if processing a previously registered task)  * @since 4.3  */ @Nullable public ScheduledTask scheduleCronTask(CronTask task) {     ScheduledTask scheduledTask = this.unresolvedTasks.remove(task).     boolean newTask = false.     if (scheduledTask == null) {         scheduledTask = new ScheduledTask(task).         newTask = true.     }     if (this.taskScheduler != null) {         scheduledTask.future = this.taskScheduler.schedule(task.getRunnable(), task.getTrigger()).     } else {         addCronTask(task).         this.unresolvedTasks.put(task, scheduledTask).     }     return (newTask ? scheduledTask : null). }
true;public;1;7;/**  * Schedule the specified fixed-rate task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * (or {@code null} if processing a previously registered task)  * @since 4.3  * @deprecated as of 5.0.2, in favor of {@link #scheduleFixedRateTask(FixedRateTask)}  */ ;/**  * Schedule the specified fixed-rate task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * (or {@code null} if processing a previously registered task)  * @since 4.3  * @deprecated as of 5.0.2, in favor of {@link #scheduleFixedRateTask(FixedRateTask)}  */ @Deprecated @Nullable public ScheduledTask scheduleFixedRateTask(IntervalTask task) {     FixedRateTask taskToUse = (task instanceof FixedRateTask ? (FixedRateTask) task : new FixedRateTask(task.getRunnable(), task.getInterval(), task.getInitialDelay())).     return scheduleFixedRateTask(taskToUse). }
true;public;1;25;/**  * Schedule the specified fixed-rate task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * (or {@code null} if processing a previously registered task)  * @since 5.0.2  */ ;/**  * Schedule the specified fixed-rate task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * (or {@code null} if processing a previously registered task)  * @since 5.0.2  */ @Nullable public ScheduledTask scheduleFixedRateTask(FixedRateTask task) {     ScheduledTask scheduledTask = this.unresolvedTasks.remove(task).     boolean newTask = false.     if (scheduledTask == null) {         scheduledTask = new ScheduledTask(task).         newTask = true.     }     if (this.taskScheduler != null) {         if (task.getInitialDelay() > 0) {             Date startTime = new Date(System.currentTimeMillis() + task.getInitialDelay()).             scheduledTask.future = this.taskScheduler.scheduleAtFixedRate(task.getRunnable(), startTime, task.getInterval()).         } else {             scheduledTask.future = this.taskScheduler.scheduleAtFixedRate(task.getRunnable(), task.getInterval()).         }     } else {         addFixedRateTask(task).         this.unresolvedTasks.put(task, scheduledTask).     }     return (newTask ? scheduledTask : null). }
true;public;1;7;/**  * Schedule the specified fixed-delay task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * (or {@code null} if processing a previously registered task)  * @since 4.3  * @deprecated as of 5.0.2, in favor of {@link #scheduleFixedDelayTask(FixedDelayTask)}  */ ;/**  * Schedule the specified fixed-delay task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * (or {@code null} if processing a previously registered task)  * @since 4.3  * @deprecated as of 5.0.2, in favor of {@link #scheduleFixedDelayTask(FixedDelayTask)}  */ @Deprecated @Nullable public ScheduledTask scheduleFixedDelayTask(IntervalTask task) {     FixedDelayTask taskToUse = (task instanceof FixedDelayTask ? (FixedDelayTask) task : new FixedDelayTask(task.getRunnable(), task.getInterval(), task.getInitialDelay())).     return scheduleFixedDelayTask(taskToUse). }
true;public;1;25;/**  * Schedule the specified fixed-delay task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * (or {@code null} if processing a previously registered task)  * @since 5.0.2  */ ;/**  * Schedule the specified fixed-delay task, either right away if possible  * or on initialization of the scheduler.  * @return a handle to the scheduled task, allowing to cancel it  * (or {@code null} if processing a previously registered task)  * @since 5.0.2  */ @Nullable public ScheduledTask scheduleFixedDelayTask(FixedDelayTask task) {     ScheduledTask scheduledTask = this.unresolvedTasks.remove(task).     boolean newTask = false.     if (scheduledTask == null) {         scheduledTask = new ScheduledTask(task).         newTask = true.     }     if (this.taskScheduler != null) {         if (task.getInitialDelay() > 0) {             Date startTime = new Date(System.currentTimeMillis() + task.getInitialDelay()).             scheduledTask.future = this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(), startTime, task.getInterval()).         } else {             scheduledTask.future = this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(), task.getInterval()).         }     } else {         addFixedDelayTask(task).         this.unresolvedTasks.put(task, scheduledTask).     }     return (newTask ? scheduledTask : null). }
true;public;0;4;/**  * Return all locally registered tasks that have been scheduled by this registrar.  * @since 5.0.2  * @see #addTriggerTask  * @see #addCronTask  * @see #addFixedRateTask  * @see #addFixedDelayTask  */ ;/**  * Return all locally registered tasks that have been scheduled by this registrar.  * @since 5.0.2  * @see #addTriggerTask  * @see #addCronTask  * @see #addFixedRateTask  * @see #addFixedDelayTask  */ @Override public Set<ScheduledTask> getScheduledTasks() {     return Collections.unmodifiableSet(this.scheduledTasks). }
false;public;0;9;;@Override public void destroy() {     for (ScheduledTask task : this.scheduledTasks) {         task.cancel().     }     if (this.localExecutor != null) {         this.localExecutor.shutdownNow().     } }
