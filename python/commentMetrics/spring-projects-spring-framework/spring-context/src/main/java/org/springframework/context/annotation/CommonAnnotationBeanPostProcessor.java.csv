commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Ignore the given resource type when resolving {@code @Resource}  * annotations.  * <p>By default, the {@code javax.xml.ws.WebServiceContext} interface  * will be ignored, since it will be resolved by the JAX-WS runtime.  * @param resourceType the resource type to ignore  */ ;/**  * Ignore the given resource type when resolving {@code @Resource}  * annotations.  * <p>By default, the {@code javax.xml.ws.WebServiceContext} interface  * will be ignored, since it will be resolved by the JAX-WS runtime.  * @param resourceType the resource type to ignore  */ public void ignoreResourceType(String resourceType) {     Assert.notNull(resourceType, "Ignored resource type must not be null").     this.ignoredResourceTypes.add(resourceType). }
true;public;1;3;/**  * Set whether to allow a fallback to a type match if no explicit name has been  * specified. The default name (i.e. the field name or bean property name) will  * still be checked first. if a bean of that name exists, it will be taken.  * However, if no bean of that name exists, a by-type resolution of the  * dependency will be attempted if this flag is "true".  * <p>Default is "true". Switch this flag to "false" in order to enforce a  * by-name lookup in all cases, throwing an exception in case of no name match.  * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#resolveDependency  */ ;/**  * Set whether to allow a fallback to a type match if no explicit name has been  * specified. The default name (i.e. the field name or bean property name) will  * still be checked first. if a bean of that name exists, it will be taken.  * However, if no bean of that name exists, a by-type resolution of the  * dependency will be attempted if this flag is "true".  * <p>Default is "true". Switch this flag to "false" in order to enforce a  * by-name lookup in all cases, throwing an exception in case of no name match.  * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#resolveDependency  */ public void setFallbackToDefaultTypeMatch(boolean fallbackToDefaultTypeMatch) {     this.fallbackToDefaultTypeMatch = fallbackToDefaultTypeMatch. }
true;public;1;3;/**  * Set whether to always use JNDI lookups equivalent to standard Java EE 5 resource  * injection, <b>even for {@code name} attributes and default names</b>.  * <p>Default is "false": Resource names are used for Spring bean lookups in the  * containing BeanFactory. only {@code mappedName} attributes point directly  * into JNDI. Switch this flag to "true" for enforcing Java EE style JNDI lookups  * in any case, even for {@code name} attributes and default names.  * @see #setJndiFactory  * @see #setResourceFactory  */ ;/**  * Set whether to always use JNDI lookups equivalent to standard Java EE 5 resource  * injection, <b>even for {@code name} attributes and default names</b>.  * <p>Default is "false": Resource names are used for Spring bean lookups in the  * containing BeanFactory. only {@code mappedName} attributes point directly  * into JNDI. Switch this flag to "true" for enforcing Java EE style JNDI lookups  * in any case, even for {@code name} attributes and default names.  * @see #setJndiFactory  * @see #setResourceFactory  */ public void setAlwaysUseJndiLookup(boolean alwaysUseJndiLookup) {     this.alwaysUseJndiLookup = alwaysUseJndiLookup. }
true;public;1;4;/**  * Specify the factory for objects to be injected into {@code @Resource} /  * {@code @WebServiceRef} / {@code @EJB} annotated fields and setter methods,  * <b>for {@code mappedName} attributes that point directly into JNDI</b>.  * This factory will also be used if "alwaysUseJndiLookup" is set to "true" in order  * to enforce JNDI lookups even for {@code name} attributes and default names.  * <p>The default is a {@link org.springframework.jndi.support.SimpleJndiBeanFactory}  * for JNDI lookup behavior equivalent to standard Java EE 5 resource injection.  * @see #setResourceFactory  * @see #setAlwaysUseJndiLookup  */ ;/**  * Specify the factory for objects to be injected into {@code @Resource} /  * {@code @WebServiceRef} / {@code @EJB} annotated fields and setter methods,  * <b>for {@code mappedName} attributes that point directly into JNDI</b>.  * This factory will also be used if "alwaysUseJndiLookup" is set to "true" in order  * to enforce JNDI lookups even for {@code name} attributes and default names.  * <p>The default is a {@link org.springframework.jndi.support.SimpleJndiBeanFactory}  * for JNDI lookup behavior equivalent to standard Java EE 5 resource injection.  * @see #setResourceFactory  * @see #setAlwaysUseJndiLookup  */ public void setJndiFactory(BeanFactory jndiFactory) {     Assert.notNull(jndiFactory, "BeanFactory must not be null").     this.jndiFactory = jndiFactory. }
true;public;1;4;/**  * Specify the factory for objects to be injected into {@code @Resource} /  * {@code @WebServiceRef} / {@code @EJB} annotated fields and setter methods,  * <b>for {@code name} attributes and default names</b>.  * <p>The default is the BeanFactory that this post-processor is defined in,  * if any, looking up resource names as Spring bean names. Specify the resource  * factory explicitly for programmatic usage of this post-processor.  * <p>Specifying Spring's {@link org.springframework.jndi.support.SimpleJndiBeanFactory}  * leads to JNDI lookup behavior equivalent to standard Java EE 5 resource injection,  * even for {@code name} attributes and default names. This is the same behavior  * that the "alwaysUseJndiLookup" flag enables.  * @see #setAlwaysUseJndiLookup  */ ;/**  * Specify the factory for objects to be injected into {@code @Resource} /  * {@code @WebServiceRef} / {@code @EJB} annotated fields and setter methods,  * <b>for {@code name} attributes and default names</b>.  * <p>The default is the BeanFactory that this post-processor is defined in,  * if any, looking up resource names as Spring bean names. Specify the resource  * factory explicitly for programmatic usage of this post-processor.  * <p>Specifying Spring's {@link org.springframework.jndi.support.SimpleJndiBeanFactory}  * leads to JNDI lookup behavior equivalent to standard Java EE 5 resource injection,  * even for {@code name} attributes and default names. This is the same behavior  * that the "alwaysUseJndiLookup" flag enables.  * @see #setAlwaysUseJndiLookup  */ public void setResourceFactory(BeanFactory resourceFactory) {     Assert.notNull(resourceFactory, "BeanFactory must not be null").     this.resourceFactory = resourceFactory. }
false;public;1;11;;@Override public void setBeanFactory(BeanFactory beanFactory) {     Assert.notNull(beanFactory, "BeanFactory must not be null").     this.beanFactory = beanFactory.     if (this.resourceFactory == null) {         this.resourceFactory = beanFactory.     }     if (beanFactory instanceof ConfigurableBeanFactory) {         this.embeddedValueResolver = new EmbeddedValueResolver((ConfigurableBeanFactory) beanFactory).     } }
false;public;3;6;;@Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {     super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName).     InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null).     metadata.checkConfigMembers(beanDefinition). }
false;public;1;4;;@Override public void resetBeanDefinition(String beanName) {     this.injectionMetadataCache.remove(beanName). }
false;public;2;4;;@Override public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {     return null. }
false;public;2;4;;@Override public boolean postProcessAfterInstantiation(Object bean, String beanName) {     return true. }
false;public;3;11;;@Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {     InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs).     try {         metadata.inject(bean, beanName, pvs).     } catch (Throwable ex) {         throw new BeanCreationException(beanName, "Injection of resource dependencies failed", ex).     }     return pvs. }
false;public;4;7;;@Deprecated @Override public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) {     return postProcessProperties(pvs, bean, beanName). }
false;private;3;19;;private InjectionMetadata findResourceMetadata(String beanName, final Class<?> clazz, @Nullable PropertyValues pvs) {     // Fall back to class name as cache key, for backwards compatibility with custom callers.     String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName()).     // Quick check on the concurrent map first, with minimal locking.     InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey).     if (InjectionMetadata.needsRefresh(metadata, clazz)) {         synchronized (this.injectionMetadataCache) {             metadata = this.injectionMetadataCache.get(cacheKey).             if (InjectionMetadata.needsRefresh(metadata, clazz)) {                 if (metadata != null) {                     metadata.clear(pvs).                 }                 metadata = buildResourceMetadata(clazz).                 this.injectionMetadataCache.put(cacheKey, metadata).             }         }     }     return metadata. }
false;private;1;79;;private InjectionMetadata buildResourceMetadata(final Class<?> clazz) {     List<InjectionMetadata.InjectedElement> elements = new ArrayList<>().     Class<?> targetClass = clazz.     do {         final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>().         ReflectionUtils.doWithLocalFields(targetClass, field -> {             if (webServiceRefClass != null && field.isAnnotationPresent(webServiceRefClass)) {                 if (Modifier.isStatic(field.getModifiers())) {                     throw new IllegalStateException("@WebServiceRef annotation is not supported on static fields").                 }                 currElements.add(new WebServiceRefElement(field, field, null)).             } else if (ejbRefClass != null && field.isAnnotationPresent(ejbRefClass)) {                 if (Modifier.isStatic(field.getModifiers())) {                     throw new IllegalStateException("@EJB annotation is not supported on static fields").                 }                 currElements.add(new EjbRefElement(field, field, null)).             } else if (field.isAnnotationPresent(Resource.class)) {                 if (Modifier.isStatic(field.getModifiers())) {                     throw new IllegalStateException("@Resource annotation is not supported on static fields").                 }                 if (!this.ignoredResourceTypes.contains(field.getType().getName())) {                     currElements.add(new ResourceElement(field, field, null)).                 }             }         }).         ReflectionUtils.doWithLocalMethods(targetClass, method -> {             Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method).             if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {                 return.             }             if (method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {                 if (webServiceRefClass != null && bridgedMethod.isAnnotationPresent(webServiceRefClass)) {                     if (Modifier.isStatic(method.getModifiers())) {                         throw new IllegalStateException("@WebServiceRef annotation is not supported on static methods").                     }                     if (method.getParameterCount() != 1) {                         throw new IllegalStateException("@WebServiceRef annotation requires a single-arg method: " + method).                     }                     PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz).                     currElements.add(new WebServiceRefElement(method, bridgedMethod, pd)).                 } else if (ejbRefClass != null && bridgedMethod.isAnnotationPresent(ejbRefClass)) {                     if (Modifier.isStatic(method.getModifiers())) {                         throw new IllegalStateException("@EJB annotation is not supported on static methods").                     }                     if (method.getParameterCount() != 1) {                         throw new IllegalStateException("@EJB annotation requires a single-arg method: " + method).                     }                     PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz).                     currElements.add(new EjbRefElement(method, bridgedMethod, pd)).                 } else if (bridgedMethod.isAnnotationPresent(Resource.class)) {                     if (Modifier.isStatic(method.getModifiers())) {                         throw new IllegalStateException("@Resource annotation is not supported on static methods").                     }                     Class<?>[] paramTypes = method.getParameterTypes().                     if (paramTypes.length != 1) {                         throw new IllegalStateException("@Resource annotation requires a single-arg method: " + method).                     }                     if (!this.ignoredResourceTypes.contains(paramTypes[0].getName())) {                         PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz).                         currElements.add(new ResourceElement(method, bridgedMethod, pd)).                     }                 }             }         }).         elements.addAll(0, currElements).         targetClass = targetClass.getSuperclass().     } while (targetClass != null && targetClass != Object.class).     return new InjectionMetadata(clazz, elements). }
false;public;0;4;;@Override public Class<?> getTargetClass() {     return element.lookupType. }
false;public;0;4;;@Override public boolean isStatic() {     return false. }
false;public;0;4;;@Override public Object getTarget() {     return getResource(element, requestingBeanName). }
false;public;1;3;;@Override public void releaseTarget(Object target) { }
true;protected;2;27;/**  * Obtain a lazily resolving resource proxy for the given name and type,  * delegating to {@link #getResource} on demand once a method call comes in.  * @param element the descriptor for the annotated field/method  * @param requestingBeanName the name of the requesting bean  * @return the resource object (never {@code null})  * @since 4.2  * @see #getResource  * @see Lazy  */ ;/**  * Obtain a lazily resolving resource proxy for the given name and type,  * delegating to {@link #getResource} on demand once a method call comes in.  * @param element the descriptor for the annotated field/method  * @param requestingBeanName the name of the requesting bean  * @return the resource object (never {@code null})  * @since 4.2  * @see #getResource  * @see Lazy  */ protected Object buildLazyResourceProxy(final LookupElement element, @Nullable final String requestingBeanName) {     TargetSource ts = new TargetSource() {          @Override         public Class<?> getTargetClass() {             return element.lookupType.         }          @Override         public boolean isStatic() {             return false.         }          @Override         public Object getTarget() {             return getResource(element, requestingBeanName).         }          @Override         public void releaseTarget(Object target) {         }     }.     ProxyFactory pf = new ProxyFactory().     pf.setTargetSource(ts).     if (element.lookupType.isInterface()) {         pf.addInterface(element.lookupType).     }     ClassLoader classLoader = (this.beanFactory instanceof ConfigurableBeanFactory ? ((ConfigurableBeanFactory) this.beanFactory).getBeanClassLoader() : null).     return pf.getProxy(classLoader). }
true;protected;2;15;/**  * Obtain the resource object for the given name and type.  * @param element the descriptor for the annotated field/method  * @param requestingBeanName the name of the requesting bean  * @return the resource object (never {@code null})  * @throws NoSuchBeanDefinitionException if no corresponding target resource found  */ ;/**  * Obtain the resource object for the given name and type.  * @param element the descriptor for the annotated field/method  * @param requestingBeanName the name of the requesting bean  * @return the resource object (never {@code null})  * @throws NoSuchBeanDefinitionException if no corresponding target resource found  */ protected Object getResource(LookupElement element, @Nullable String requestingBeanName) throws NoSuchBeanDefinitionException {     if (StringUtils.hasLength(element.mappedName)) {         return this.jndiFactory.getBean(element.mappedName, element.lookupType).     }     if (this.alwaysUseJndiLookup) {         return this.jndiFactory.getBean(element.name, element.lookupType).     }     if (this.resourceFactory == null) {         throw new NoSuchBeanDefinitionException(element.lookupType, "No resource factory configured - specify the 'resourceFactory' property").     }     return autowireResource(this.resourceFactory, element, requestingBeanName). }
true;protected;3;38;/**  * Obtain a resource object for the given name and type through autowiring  * based on the given factory.  * @param factory the factory to autowire against  * @param element the descriptor for the annotated field/method  * @param requestingBeanName the name of the requesting bean  * @return the resource object (never {@code null})  * @throws NoSuchBeanDefinitionException if no corresponding target resource found  */ ;/**  * Obtain a resource object for the given name and type through autowiring  * based on the given factory.  * @param factory the factory to autowire against  * @param element the descriptor for the annotated field/method  * @param requestingBeanName the name of the requesting bean  * @return the resource object (never {@code null})  * @throws NoSuchBeanDefinitionException if no corresponding target resource found  */ protected Object autowireResource(BeanFactory factory, LookupElement element, @Nullable String requestingBeanName) throws NoSuchBeanDefinitionException {     Object resource.     Set<String> autowiredBeanNames.     String name = element.name.     if (factory instanceof AutowireCapableBeanFactory) {         AutowireCapableBeanFactory beanFactory = (AutowireCapableBeanFactory) factory.         DependencyDescriptor descriptor = element.getDependencyDescriptor().         if (this.fallbackToDefaultTypeMatch && element.isDefaultName && !factory.containsBean(name)) {             autowiredBeanNames = new LinkedHashSet<>().             resource = beanFactory.resolveDependency(descriptor, requestingBeanName, autowiredBeanNames, null).             if (resource == null) {                 throw new NoSuchBeanDefinitionException(element.getLookupType(), "No resolvable resource object").             }         } else {             resource = beanFactory.resolveBeanByName(name, descriptor).             autowiredBeanNames = Collections.singleton(name).         }     } else {         resource = factory.getBean(name, element.lookupType).         autowiredBeanNames = Collections.singleton(name).     }     if (factory instanceof ConfigurableBeanFactory) {         ConfigurableBeanFactory beanFactory = (ConfigurableBeanFactory) factory.         for (String autowiredBeanName : autowiredBeanNames) {             if (requestingBeanName != null && beanFactory.containsBean(autowiredBeanName)) {                 beanFactory.registerDependentBean(autowiredBeanName, requestingBeanName).             }         }     }     return resource. }
true;public,final;0;3;/**  * Return the resource name for the lookup.  */ ;/**  * Return the resource name for the lookup.  */ public final String getName() {     return this.name. }
true;public,final;0;3;/**  * Return the desired type for the lookup.  */ ;/**  * Return the desired type for the lookup.  */ public final Class<?> getLookupType() {     return this.lookupType. }
true;public,final;0;8;/**  * Build a DependencyDescriptor for the underlying field/method.  */ ;/**  * Build a DependencyDescriptor for the underlying field/method.  */ public final DependencyDescriptor getDependencyDescriptor() {     if (this.isField) {         return new LookupDependencyDescriptor((Field) this.member, this.lookupType).     } else {         return new LookupDependencyDescriptor((Method) this.member, this.lookupType).     } }
false;protected;2;5;;@Override protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {     return (this.lazyLookup ? buildLazyResourceProxy(this, requestingBeanName) : getResource(this, requestingBeanName)). }
false;protected;2;41;;@Override protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {     Service service.     try {         service = (Service) getResource(this, requestingBeanName).     } catch (NoSuchBeanDefinitionException notFound) {         // Service to be created through generated class.         if (Service.class == this.lookupType) {             throw new IllegalStateException("No resource with name '" + this.name + "' found in context, " + "and no specific JAX-WS Service subclass specified. The typical solution is to either specify " + "a LocalJaxWsServiceFactoryBean with the given name or to specify the (generated) Service " + "subclass as @WebServiceRef(...) value.").         }         if (StringUtils.hasLength(this.wsdlLocation)) {             try {                 Constructor<?> ctor = this.lookupType.getConstructor(URL.class, QName.class).                 WebServiceClient clientAnn = this.lookupType.getAnnotation(WebServiceClient.class).                 if (clientAnn == null) {                     throw new IllegalStateException("JAX-WS Service class [" + this.lookupType.getName() + "] does not carry a WebServiceClient annotation").                 }                 service = (Service) BeanUtils.instantiateClass(ctor, new URL(this.wsdlLocation), new QName(clientAnn.targetNamespace(), clientAnn.name())).             } catch (NoSuchMethodException ex) {                 throw new IllegalStateException("JAX-WS Service class [" + this.lookupType.getName() + "] does not have a (URL, QName) constructor. Cannot apply specified WSDL location [" + this.wsdlLocation + "].").             } catch (MalformedURLException ex) {                 throw new IllegalArgumentException("Specified WSDL location [" + this.wsdlLocation + "] isn't a valid URL").             }         } else {             service = (Service) BeanUtils.instantiateClass(this.lookupType).         }     }     return service.getPort(this.elementType). }
false;protected;2;19;;@Override protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {     if (StringUtils.hasLength(this.beanName)) {         if (beanFactory != null && beanFactory.containsBean(this.beanName)) {             // Local match found for explicitly specified local bean name.             Object bean = beanFactory.getBean(this.beanName, this.lookupType).             if (requestingBeanName != null && beanFactory instanceof ConfigurableBeanFactory) {                 ((ConfigurableBeanFactory) beanFactory).registerDependentBean(this.beanName, requestingBeanName).             }             return bean.         } else if (this.isDefaultName && !StringUtils.hasLength(this.mappedName)) {             throw new NoSuchBeanDefinitionException(this.beanName, "Cannot resolve 'beanName' in local BeanFactory. Consider specifying a general 'name' value instead.").         }     }     // JNDI name lookup - may still go to a local BeanFactory.     return getResource(this, requestingBeanName). }
false;public;0;4;;@Override public Class<?> getDependencyType() {     return this.lookupType. }
