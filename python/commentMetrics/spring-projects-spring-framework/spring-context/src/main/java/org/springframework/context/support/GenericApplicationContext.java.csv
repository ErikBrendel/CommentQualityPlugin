commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Set the parent of this application context, also setting  * the parent of the internal BeanFactory accordingly.  * @see org.springframework.beans.factory.config.ConfigurableBeanFactory#setParentBeanFactory  */ ;/**  * Set the parent of this application context, also setting  * the parent of the internal BeanFactory accordingly.  * @see org.springframework.beans.factory.config.ConfigurableBeanFactory#setParentBeanFactory  */ @Override public void setParent(@Nullable ApplicationContext parent) {     super.setParent(parent).     this.beanFactory.setParentBeanFactory(getInternalParentBeanFactory()). }
true;public;1;3;/**  * Set whether it should be allowed to override bean definitions by registering  * a different definition with the same name, automatically replacing the former.  * If not, an exception will be thrown. Default is "true".  * @since 3.0  * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding  */ ;/**  * Set whether it should be allowed to override bean definitions by registering  * a different definition with the same name, automatically replacing the former.  * If not, an exception will be thrown. Default is "true".  * @since 3.0  * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding  */ public void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {     this.beanFactory.setAllowBeanDefinitionOverriding(allowBeanDefinitionOverriding). }
true;public;1;3;/**  * Set whether to allow circular references between beans - and automatically  * try to resolve them.  * <p>Default is "true". Turn this off to throw an exception when encountering  * a circular reference, disallowing them completely.  * @since 3.0  * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowCircularReferences  */ ;/**  * Set whether to allow circular references between beans - and automatically  * try to resolve them.  * <p>Default is "true". Turn this off to throw an exception when encountering  * a circular reference, disallowing them completely.  * @since 3.0  * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowCircularReferences  */ public void setAllowCircularReferences(boolean allowCircularReferences) {     this.beanFactory.setAllowCircularReferences(allowCircularReferences). }
true;public;1;3;/**  * Set a ResourceLoader to use for this context. If set, the context will  * delegate all {@code getResource} calls to the given ResourceLoader.  * If not set, default resource loading will apply.  * <p>The main reason to specify a custom ResourceLoader is to resolve  * resource paths (without URL prefix) in a specific fashion.  * The default behavior is to resolve such paths as class path locations.  * To resolve resource paths as file system locations, specify a  * FileSystemResourceLoader here.  * <p>You can also pass in a full ResourcePatternResolver, which will  * be autodetected by the context and used for {@code getResources}  * calls as well. Else, default resource pattern matching will apply.  * @see #getResource  * @see org.springframework.core.io.DefaultResourceLoader  * @see org.springframework.core.io.FileSystemResourceLoader  * @see org.springframework.core.io.support.ResourcePatternResolver  * @see #getResources  */ ;/**  * Set a ResourceLoader to use for this context. If set, the context will  * delegate all {@code getResource} calls to the given ResourceLoader.  * If not set, default resource loading will apply.  * <p>The main reason to specify a custom ResourceLoader is to resolve  * resource paths (without URL prefix) in a specific fashion.  * The default behavior is to resolve such paths as class path locations.  * To resolve resource paths as file system locations, specify a  * FileSystemResourceLoader here.  * <p>You can also pass in a full ResourcePatternResolver, which will  * be autodetected by the context and used for {@code getResources}  * calls as well. Else, default resource pattern matching will apply.  * @see #getResource  * @see org.springframework.core.io.DefaultResourceLoader  * @see org.springframework.core.io.FileSystemResourceLoader  * @see org.springframework.core.io.support.ResourcePatternResolver  * @see #getResources  */ public void setResourceLoader(ResourceLoader resourceLoader) {     this.resourceLoader = resourceLoader. }
true;public;1;7;/**  * This implementation delegates to this context's ResourceLoader if set,  * falling back to the default superclass behavior else.  * @see #setResourceLoader  */ ;// --------------------------------------------------------------------- // ResourceLoader / ResourcePatternResolver override if necessary // --------------------------------------------------------------------- /**  * This implementation delegates to this context's ResourceLoader if set,  * falling back to the default superclass behavior else.  * @see #setResourceLoader  */ @Override public Resource getResource(String location) {     if (this.resourceLoader != null) {         return this.resourceLoader.getResource(location).     }     return super.getResource(location). }
true;public;1;7;/**  * This implementation delegates to this context's ResourceLoader if it  * implements the ResourcePatternResolver interface, falling back to the  * default superclass behavior else.  * @see #setResourceLoader  */ ;/**  * This implementation delegates to this context's ResourceLoader if it  * implements the ResourcePatternResolver interface, falling back to the  * default superclass behavior else.  * @see #setResourceLoader  */ @Override public Resource[] getResources(String locationPattern) throws IOException {     if (this.resourceLoader instanceof ResourcePatternResolver) {         return ((ResourcePatternResolver) this.resourceLoader).getResources(locationPattern).     }     return super.getResources(locationPattern). }
false;public;1;5;;@Override public void setClassLoader(@Nullable ClassLoader classLoader) {     super.setClassLoader(classLoader).     this.customClassLoader = true. }
false;public;0;8;;@Override @Nullable public ClassLoader getClassLoader() {     if (this.resourceLoader != null && !this.customClassLoader) {         return this.resourceLoader.getClassLoader().     }     return super.getClassLoader(). }
true;protected,final;0;8;/**  * Do nothing: We hold a single internal BeanFactory and rely on callers  * to register beans through our public methods (or the BeanFactory's).  * @see #registerBeanDefinition  */ ;// --------------------------------------------------------------------- // Implementations of AbstractApplicationContext's template methods // --------------------------------------------------------------------- /**  * Do nothing: We hold a single internal BeanFactory and rely on callers  * to register beans through our public methods (or the BeanFactory's).  * @see #registerBeanDefinition  */ @Override protected final void refreshBeanFactory() throws IllegalStateException {     if (!this.refreshed.compareAndSet(false, true)) {         throw new IllegalStateException("GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once").     }     this.beanFactory.setSerializationId(getId()). }
false;protected;1;5;;@Override protected void cancelRefresh(BeansException ex) {     this.beanFactory.setSerializationId(null).     super.cancelRefresh(ex). }
true;protected,final;0;4;/**  * Not much to do: We hold a single internal BeanFactory that will never  * get released.  */ ;/**  * Not much to do: We hold a single internal BeanFactory that will never  * get released.  */ @Override protected final void closeBeanFactory() {     this.beanFactory.setSerializationId(null). }
true;public,final;0;4;/**  * Return the single internal BeanFactory held by this context  * (as ConfigurableListableBeanFactory).  */ ;/**  * Return the single internal BeanFactory held by this context  * (as ConfigurableListableBeanFactory).  */ @Override public final ConfigurableListableBeanFactory getBeanFactory() {     return this.beanFactory. }
true;public,final;0;3;/**  * Return the underlying bean factory of this context,  * available for registering bean definitions.  * <p><b>NOTE:</b> You need to call {@link #refresh()} to initialize the  * bean factory and its contained beans with application context semantics  * (autodetecting BeanFactoryPostProcessors, etc).  * @return the internal bean factory (as DefaultListableBeanFactory)  */ ;/**  * Return the underlying bean factory of this context,  * available for registering bean definitions.  * <p><b>NOTE:</b> You need to call {@link #refresh()} to initialize the  * bean factory and its contained beans with application context semantics  * (autodetecting BeanFactoryPostProcessors, etc).  * @return the internal bean factory (as DefaultListableBeanFactory)  */ public final DefaultListableBeanFactory getDefaultListableBeanFactory() {     return this.beanFactory. }
false;public;0;5;;@Override public AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException {     assertBeanFactoryActive().     return this.beanFactory. }
false;public;2;6;;// --------------------------------------------------------------------- // Implementation of BeanDefinitionRegistry // --------------------------------------------------------------------- @Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException {     this.beanFactory.registerBeanDefinition(beanName, beanDefinition). }
false;public;1;4;;@Override public void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {     this.beanFactory.removeBeanDefinition(beanName). }
false;public;1;4;;@Override public BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {     return this.beanFactory.getBeanDefinition(beanName). }
false;public;1;4;;@Override public boolean isBeanNameInUse(String beanName) {     return this.beanFactory.isBeanNameInUse(beanName). }
false;public;2;4;;@Override public void registerAlias(String beanName, String alias) {     this.beanFactory.registerAlias(beanName, alias). }
false;public;1;4;;@Override public void removeAlias(String alias) {     this.beanFactory.removeAlias(alias). }
false;public;1;4;;@Override public boolean isAlias(String beanName) {     return this.beanFactory.isAlias(beanName). }
true;public,final;2;3;/**  * Register a bean from the given bean class, optionally customizing its  * bean definition metadata (typically declared as a lambda expression  * or method reference).  * @param beanClass the class of the bean (resolving a public constructor  * to be autowired, possibly simply the default constructor)  * @param customizers one or more callbacks for customizing the factory's  * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag  * @since 5.0  * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)  */ ;// --------------------------------------------------------------------- // Convenient methods for registering individual beans // --------------------------------------------------------------------- /**  * Register a bean from the given bean class, optionally customizing its  * bean definition metadata (typically declared as a lambda expression  * or method reference).  * @param beanClass the class of the bean (resolving a public constructor  * to be autowired, possibly simply the default constructor)  * @param customizers one or more callbacks for customizing the factory's  * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag  * @since 5.0  * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)  */ public final <T> void registerBean(Class<T> beanClass, BeanDefinitionCustomizer... customizers) {     registerBean(null, beanClass, null, customizers). }
true;public,final;3;5;/**  * Register a bean from the given bean class, using the given supplier for  * obtaining a new instance (typically declared as a lambda expression or  * method reference), optionally customizing its bean definition metadata  * (again typically declared as a lambda expression or method reference).  * @param beanName the name of the bean (may be {@code null})  * @param beanClass the class of the bean (resolving a public constructor  * to be autowired, possibly simply the default constructor)  * @param customizers one or more callbacks for customizing the factory's  * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag  * @since 5.0  * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)  */ ;/**  * Register a bean from the given bean class, using the given supplier for  * obtaining a new instance (typically declared as a lambda expression or  * method reference), optionally customizing its bean definition metadata  * (again typically declared as a lambda expression or method reference).  * @param beanName the name of the bean (may be {@code null})  * @param beanClass the class of the bean (resolving a public constructor  * to be autowired, possibly simply the default constructor)  * @param customizers one or more callbacks for customizing the factory's  * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag  * @since 5.0  * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)  */ public final <T> void registerBean(@Nullable String beanName, Class<T> beanClass, BeanDefinitionCustomizer... customizers) {     registerBean(beanName, beanClass, null, customizers). }
true;public,final;3;5;/**  * Register a bean from the given bean class, using the given supplier for  * obtaining a new instance (typically declared as a lambda expression or  * method reference), optionally customizing its bean definition metadata  * (again typically declared as a lambda expression or method reference).  * @param beanClass the class of the bean  * @param supplier a callback for creating an instance of the bean  * @param customizers one or more callbacks for customizing the factory's  * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag  * @since 5.0  * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)  */ ;/**  * Register a bean from the given bean class, using the given supplier for  * obtaining a new instance (typically declared as a lambda expression or  * method reference), optionally customizing its bean definition metadata  * (again typically declared as a lambda expression or method reference).  * @param beanClass the class of the bean  * @param supplier a callback for creating an instance of the bean  * @param customizers one or more callbacks for customizing the factory's  * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag  * @since 5.0  * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)  */ public final <T> void registerBean(Class<T> beanClass, Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {     registerBean(null, beanClass, supplier, customizers). }
true;public;4;14;/**  * Register a bean from the given bean class, using the given supplier for  * obtaining a new instance (typically declared as a lambda expression or  * method reference), optionally customizing its bean definition metadata  * (again typically declared as a lambda expression or method reference).  * <p>This method can be overridden to adapt the registration mechanism for  * all {@code registerBean} methods (since they all delegate to this one).  * @param beanName the name of the bean (may be {@code null})  * @param beanClass the class of the bean  * @param supplier a callback for creating an instance of the bean (in case  * of {@code null}, resolving a public constructor to be autowired instead)  * @param customizers one or more callbacks for customizing the factory's  * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag  * @since 5.0  */ ;/**  * Register a bean from the given bean class, using the given supplier for  * obtaining a new instance (typically declared as a lambda expression or  * method reference), optionally customizing its bean definition metadata  * (again typically declared as a lambda expression or method reference).  * <p>This method can be overridden to adapt the registration mechanism for  * all {@code registerBean} methods (since they all delegate to this one).  * @param beanName the name of the bean (may be {@code null})  * @param beanClass the class of the bean  * @param supplier a callback for creating an instance of the bean (in case  * of {@code null}, resolving a public constructor to be autowired instead)  * @param customizers one or more callbacks for customizing the factory's  * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag  * @since 5.0  */ public <T> void registerBean(@Nullable String beanName, Class<T> beanClass, @Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {     ClassDerivedBeanDefinition beanDefinition = new ClassDerivedBeanDefinition(beanClass).     if (supplier != null) {         beanDefinition.setInstanceSupplier(supplier).     }     for (BeanDefinitionCustomizer customizer : customizers) {         customizer.customize(beanDefinition).     }     String nameToUse = (beanName != null ? beanName : beanClass.getName()).     registerBeanDefinition(nameToUse, beanDefinition). }
false;public;0;14;;@Override @Nullable public Constructor<?>[] getPreferredConstructors() {     Class<?> clazz = getBeanClass().     Constructor<?> primaryCtor = BeanUtils.findPrimaryConstructor(clazz).     if (primaryCtor != null) {         return new Constructor<?>[] { primaryCtor }.     }     Constructor<?>[] publicCtors = clazz.getConstructors().     if (publicCtors.length > 0) {         return publicCtors.     }     return null. }
false;public;0;4;;@Override public RootBeanDefinition cloneBeanDefinition() {     return new ClassDerivedBeanDefinition(this). }
