commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.beanClassLoader = classLoader. }
false;public;1;11;;@Override public void setBeanFactory(BeanFactory beanFactory) {     this.beanFactory = beanFactory.     if (beanFactory instanceof ConfigurableBeanFactory) {         ConfigurableBeanFactory cbf = (ConfigurableBeanFactory) beanFactory.         if (this.beanClassLoader == null) {             this.beanClassLoader = cbf.getBeanClassLoader().         }         this.retrievalMutex = cbf.getSingletonMutex().     } }
false;private;0;7;;private BeanFactory getBeanFactory() {     if (this.beanFactory == null) {         throw new IllegalStateException("ApplicationEventMulticaster cannot retrieve listener beans " + "because it is not associated with a BeanFactory").     }     return this.beanFactory. }
false;public;1;13;;@Override public void addApplicationListener(ApplicationListener<?> listener) {     synchronized (this.retrievalMutex) {         // Explicitly remove target for a proxy, if registered already,         // in order to avoid double invocations of the same listener.         Object singletonTarget = AopProxyUtils.getSingletonTarget(listener).         if (singletonTarget instanceof ApplicationListener) {             this.defaultRetriever.applicationListeners.remove(singletonTarget).         }         this.defaultRetriever.applicationListeners.add(listener).         this.retrieverCache.clear().     } }
false;public;1;7;;@Override public void addApplicationListenerBean(String listenerBeanName) {     synchronized (this.retrievalMutex) {         this.defaultRetriever.applicationListenerBeans.add(listenerBeanName).         this.retrieverCache.clear().     } }
false;public;1;7;;@Override public void removeApplicationListener(ApplicationListener<?> listener) {     synchronized (this.retrievalMutex) {         this.defaultRetriever.applicationListeners.remove(listener).         this.retrieverCache.clear().     } }
false;public;1;7;;@Override public void removeApplicationListenerBean(String listenerBeanName) {     synchronized (this.retrievalMutex) {         this.defaultRetriever.applicationListenerBeans.remove(listenerBeanName).         this.retrieverCache.clear().     } }
false;public;0;8;;@Override public void removeAllListeners() {     synchronized (this.retrievalMutex) {         this.defaultRetriever.applicationListeners.clear().         this.defaultRetriever.applicationListenerBeans.clear().         this.retrieverCache.clear().     } }
true;protected;0;5;/**  * Return a Collection containing all ApplicationListeners.  * @return a Collection of ApplicationListeners  * @see org.springframework.context.ApplicationListener  */ ;/**  * Return a Collection containing all ApplicationListeners.  * @return a Collection of ApplicationListeners  * @see org.springframework.context.ApplicationListener  */ protected Collection<ApplicationListener<?>> getApplicationListeners() {     synchronized (this.retrievalMutex) {         return this.defaultRetriever.getApplicationListeners().     } }
true;protected;2;34;/**  * Return a Collection of ApplicationListeners matching the given  * event type. Non-matching listeners get excluded early.  * @param event the event to be propagated. Allows for excluding  * non-matching listeners early, based on cached matching information.  * @param eventType the event type  * @return a Collection of ApplicationListeners  * @see org.springframework.context.ApplicationListener  */ ;/**  * Return a Collection of ApplicationListeners matching the given  * event type. Non-matching listeners get excluded early.  * @param event the event to be propagated. Allows for excluding  * non-matching listeners early, based on cached matching information.  * @param eventType the event type  * @return a Collection of ApplicationListeners  * @see org.springframework.context.ApplicationListener  */ protected Collection<ApplicationListener<?>> getApplicationListeners(ApplicationEvent event, ResolvableType eventType) {     Object source = event.getSource().     Class<?> sourceType = (source != null ? source.getClass() : null).     ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType).     // Quick check for existing entry on ConcurrentHashMap...     ListenerRetriever retriever = this.retrieverCache.get(cacheKey).     if (retriever != null) {         return retriever.getApplicationListeners().     }     if (this.beanClassLoader == null || (ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) && (sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) {         // Fully synchronized building and caching of a ListenerRetriever         synchronized (this.retrievalMutex) {             retriever = this.retrieverCache.get(cacheKey).             if (retriever != null) {                 return retriever.getApplicationListeners().             }             retriever = new ListenerRetriever(true).             Collection<ApplicationListener<?>> listeners = retrieveApplicationListeners(eventType, sourceType, retriever).             this.retrieverCache.put(cacheKey, retriever).             return listeners.         }     } else {         // No ListenerRetriever caching -> no synchronization necessary         return retrieveApplicationListeners(eventType, sourceType, null).     } }
true;private;3;52;/**  * Actually retrieve the application listeners for the given event and source type.  * @param eventType the event type  * @param sourceType the event source type  * @param retriever the ListenerRetriever, if supposed to populate one (for caching purposes)  * @return the pre-filtered list of application listeners for the given event and source type  */ ;/**  * Actually retrieve the application listeners for the given event and source type.  * @param eventType the event type  * @param sourceType the event source type  * @param retriever the ListenerRetriever, if supposed to populate one (for caching purposes)  * @return the pre-filtered list of application listeners for the given event and source type  */ private Collection<ApplicationListener<?>> retrieveApplicationListeners(ResolvableType eventType, @Nullable Class<?> sourceType, @Nullable ListenerRetriever retriever) {     List<ApplicationListener<?>> allListeners = new ArrayList<>().     Set<ApplicationListener<?>> listeners.     Set<String> listenerBeans.     synchronized (this.retrievalMutex) {         listeners = new LinkedHashSet<>(this.defaultRetriever.applicationListeners).         listenerBeans = new LinkedHashSet<>(this.defaultRetriever.applicationListenerBeans).     }     for (ApplicationListener<?> listener : listeners) {         if (supportsEvent(listener, eventType, sourceType)) {             if (retriever != null) {                 retriever.applicationListeners.add(listener).             }             allListeners.add(listener).         }     }     if (!listenerBeans.isEmpty()) {         BeanFactory beanFactory = getBeanFactory().         for (String listenerBeanName : listenerBeans) {             try {                 Class<?> listenerType = beanFactory.getType(listenerBeanName).                 if (listenerType == null || supportsEvent(listenerType, eventType)) {                     ApplicationListener<?> listener = beanFactory.getBean(listenerBeanName, ApplicationListener.class).                     if (!allListeners.contains(listener) && supportsEvent(listener, eventType, sourceType)) {                         if (retriever != null) {                             if (beanFactory.isSingleton(listenerBeanName)) {                                 retriever.applicationListeners.add(listener).                             } else {                                 retriever.applicationListenerBeans.add(listenerBeanName).                             }                         }                         allListeners.add(listener).                     }                 }             } catch (NoSuchBeanDefinitionException ex) {             // Singleton listener instance (without backing bean definition) disappeared -             // probably in the middle of the destruction phase             }         }     }     AnnotationAwareOrderComparator.sort(allListeners).     if (retriever != null && retriever.applicationListenerBeans.isEmpty()) {         retriever.applicationListeners.clear().         retriever.applicationListeners.addAll(allListeners).     }     return allListeners. }
true;protected;2;8;/**  * Filter a listener early through checking its generically declared event  * type before trying to instantiate it.  * <p>If this method returns {@code true} for a given listener as a first pass,  * the listener instance will get retrieved and fully evaluated through a  * {@link #supportsEvent(ApplicationListener, ResolvableType, Class)} call afterwards.  * @param listenerType the listener's type as determined by the BeanFactory  * @param eventType the event type to check  * @return whether the given listener should be included in the candidates  * for the given event type  */ ;/**  * Filter a listener early through checking its generically declared event  * type before trying to instantiate it.  * <p>If this method returns {@code true} for a given listener as a first pass,  * the listener instance will get retrieved and fully evaluated through a  * {@link #supportsEvent(ApplicationListener, ResolvableType, Class)} call afterwards.  * @param listenerType the listener's type as determined by the BeanFactory  * @param eventType the event type to check  * @return whether the given listener should be included in the candidates  * for the given event type  */ protected boolean supportsEvent(Class<?> listenerType, ResolvableType eventType) {     if (GenericApplicationListener.class.isAssignableFrom(listenerType) || SmartApplicationListener.class.isAssignableFrom(listenerType)) {         return true.     }     ResolvableType declaredEventType = GenericApplicationListenerAdapter.resolveDeclaredEventType(listenerType).     return (declaredEventType == null || declaredEventType.isAssignableFrom(eventType)). }
true;protected;3;7;/**  * Determine whether the given listener supports the given event.  * <p>The default implementation detects the {@link SmartApplicationListener}  * and {@link GenericApplicationListener} interfaces. In case of a standard  * {@link ApplicationListener}, a {@link GenericApplicationListenerAdapter}  * will be used to introspect the generically declared type of the target listener.  * @param listener the target listener to check  * @param eventType the event type to check against  * @param sourceType the source type to check against  * @return whether the given listener should be included in the candidates  * for the given event type  */ ;/**  * Determine whether the given listener supports the given event.  * <p>The default implementation detects the {@link SmartApplicationListener}  * and {@link GenericApplicationListener} interfaces. In case of a standard  * {@link ApplicationListener}, a {@link GenericApplicationListenerAdapter}  * will be used to introspect the generically declared type of the target listener.  * @param listener the target listener to check  * @param eventType the event type to check against  * @param sourceType the source type to check against  * @return whether the given listener should be included in the candidates  * for the given event type  */ protected boolean supportsEvent(ApplicationListener<?> listener, ResolvableType eventType, @Nullable Class<?> sourceType) {     GenericApplicationListener smartListener = (listener instanceof GenericApplicationListener ? (GenericApplicationListener) listener : new GenericApplicationListenerAdapter(listener)).     return (smartListener.supportsEventType(eventType) && smartListener.supportsSourceType(sourceType)). }
false;public;1;9;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     ListenerCacheKey otherKey = (ListenerCacheKey) other.     return (this.eventType.equals(otherKey.eventType) && ObjectUtils.nullSafeEquals(this.sourceType, otherKey.sourceType)). }
false;public;0;4;;@Override public int hashCode() {     return this.eventType.hashCode() * 29 + ObjectUtils.nullSafeHashCode(this.sourceType). }
false;public;0;4;;@Override public String toString() {     return "ListenerCacheKey [eventType = " + this.eventType + ", sourceType = " + this.sourceType + "]". }
false;public;1;14;;@Override public int compareTo(ListenerCacheKey other) {     int result = this.eventType.toString().compareTo(other.eventType.toString()).     if (result == 0) {         if (this.sourceType == null) {             return (other.sourceType == null ? 0 : -1).         }         if (other.sourceType == null) {             return 1.         }         result = this.sourceType.getName().compareTo(other.sourceType.getName()).     }     return result. }
false;public;0;24;;public Collection<ApplicationListener<?>> getApplicationListeners() {     List<ApplicationListener<?>> allListeners = new ArrayList<>(this.applicationListeners.size() + this.applicationListenerBeans.size()).     allListeners.addAll(this.applicationListeners).     if (!this.applicationListenerBeans.isEmpty()) {         BeanFactory beanFactory = getBeanFactory().         for (String listenerBeanName : this.applicationListenerBeans) {             try {                 ApplicationListener<?> listener = beanFactory.getBean(listenerBeanName, ApplicationListener.class).                 if (this.preFiltered || !allListeners.contains(listener)) {                     allListeners.add(listener).                 }             } catch (NoSuchBeanDefinitionException ex) {             // Singleton listener instance (without backing bean definition) disappeared -             // probably in the middle of the destruction phase             }         }     }     if (!this.preFiltered || !this.applicationListenerBeans.isEmpty()) {         AnnotationAwareOrderComparator.sort(allListeners).     }     return allListeners. }
