commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.beanClassLoader = classLoader. }
false;public;0;4;;@Override public String getScriptSourceLocator() {     return this.scriptSourceLocator. }
false;public;0;5;;@Override @Nullable public Class<?>[] getScriptInterfaces() {     return this.scriptInterfaces. }
false;public;0;4;;@Override public boolean requiresConfigInterface() {     return false. }
true;public;2;45;/**  * Load and parse the script via JSR-223's ScriptEngine.  */ ;/**  * Load and parse the script via JSR-223's ScriptEngine.  */ @Override @Nullable public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces) throws IOException, ScriptCompilationException {     Object script = evaluateScript(scriptSource).     if (!ObjectUtils.isEmpty(actualInterfaces)) {         boolean adaptationRequired = false.         for (Class<?> requestedIfc : actualInterfaces) {             if (script instanceof Class ? !requestedIfc.isAssignableFrom((Class<?>) script) : !requestedIfc.isInstance(script)) {                 adaptationRequired = true.             }         }         if (adaptationRequired) {             script = adaptToInterfaces(script, scriptSource, actualInterfaces).         }     }     if (script instanceof Class) {         Class<?> scriptClass = (Class<?>) script.         try {             return ReflectionUtils.accessibleConstructor(scriptClass).newInstance().         } catch (NoSuchMethodException ex) {             throw new ScriptCompilationException("No default constructor on script class: " + scriptClass.getName(), ex).         } catch (InstantiationException ex) {             throw new ScriptCompilationException(scriptSource, "Unable to instantiate script class: " + scriptClass.getName(), ex).         } catch (IllegalAccessException ex) {             throw new ScriptCompilationException(scriptSource, "Could not access script constructor: " + scriptClass.getName(), ex).         } catch (InvocationTargetException ex) {             throw new ScriptCompilationException("Failed to invoke script constructor: " + scriptClass.getName(), ex.getTargetException()).         }     }     return script. }
false;protected;1;16;;protected Object evaluateScript(ScriptSource scriptSource) {     try {         ScriptEngine scriptEngine = this.scriptEngine.         if (scriptEngine == null) {             scriptEngine = retrieveScriptEngine(scriptSource).             if (scriptEngine == null) {                 throw new IllegalStateException("Could not determine script engine for " + scriptSource).             }             this.scriptEngine = scriptEngine.         }         return scriptEngine.eval(scriptSource.getScriptAsString()).     } catch (Exception ex) {         throw new ScriptCompilationException(scriptSource, ex).     } }
false;protected;1;23;;@Nullable protected ScriptEngine retrieveScriptEngine(ScriptSource scriptSource) {     ScriptEngineManager scriptEngineManager = new ScriptEngineManager(this.beanClassLoader).     if (this.scriptEngineName != null) {         return StandardScriptUtils.retrieveEngineByName(scriptEngineManager, this.scriptEngineName).     }     if (scriptSource instanceof ResourceScriptSource) {         String filename = ((ResourceScriptSource) scriptSource).getResource().getFilename().         if (filename != null) {             String extension = StringUtils.getFilenameExtension(filename).             if (extension != null) {                 ScriptEngine engine = scriptEngineManager.getEngineByExtension(extension).                 if (engine != null) {                     return engine.                 }             }         }     }     return null. }
false;protected;3;33;;@Nullable protected Object adaptToInterfaces(@Nullable Object script, ScriptSource scriptSource, Class<?>... actualInterfaces) {     Class<?> adaptedIfc.     if (actualInterfaces.length == 1) {         adaptedIfc = actualInterfaces[0].     } else {         adaptedIfc = ClassUtils.createCompositeInterface(actualInterfaces, this.beanClassLoader).     }     if (adaptedIfc != null) {         ScriptEngine scriptEngine = this.scriptEngine.         if (!(scriptEngine instanceof Invocable)) {             throw new ScriptCompilationException(scriptSource, "ScriptEngine must implement Invocable in order to adapt it to an interface: " + scriptEngine).         }         Invocable invocable = (Invocable) scriptEngine.         if (script != null) {             script = invocable.getInterface(script, adaptedIfc).         }         if (script == null) {             script = invocable.getInterface(adaptedIfc).             if (script == null) {                 throw new ScriptCompilationException(scriptSource, "Could not adapt script to interface [" + adaptedIfc.getName() + "]").             }         }     }     return script. }
false;public;1;7;;@Override @Nullable public Class<?> getScriptedObjectType(ScriptSource scriptSource) throws IOException, ScriptCompilationException {     return null. }
false;public;1;4;;@Override public boolean requiresScriptedObjectRefresh(ScriptSource scriptSource) {     return scriptSource.isModified(). }
false;public;0;4;;@Override public String toString() {     return "StandardScriptFactory: script source locator [" + this.scriptSourceLocator + "]". }
