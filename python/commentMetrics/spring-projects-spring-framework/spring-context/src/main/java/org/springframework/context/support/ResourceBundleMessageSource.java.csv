commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the ClassLoader to load resource bundles with.  * <p>Default is the containing BeanFactory's  * {@link org.springframework.beans.factory.BeanClassLoaderAware bean ClassLoader},  * or the default ClassLoader determined by  * {@link org.springframework.util.ClassUtils#getDefaultClassLoader()}  * if not running within a BeanFactory.  */ ;/**  * Set the ClassLoader to load resource bundles with.  * <p>Default is the containing BeanFactory's  * {@link org.springframework.beans.factory.BeanClassLoaderAware bean ClassLoader},  * or the default ClassLoader determined by  * {@link org.springframework.util.ClassUtils#getDefaultClassLoader()}  * if not running within a BeanFactory.  */ public void setBundleClassLoader(ClassLoader classLoader) {     this.bundleClassLoader = classLoader. }
true;protected;0;4;/**  * Return the ClassLoader to load resource bundles with.  * <p>Default is the containing BeanFactory's bean ClassLoader.  * @see #setBundleClassLoader  */ ;/**  * Return the ClassLoader to load resource bundles with.  * <p>Default is the containing BeanFactory's bean ClassLoader.  * @see #setBundleClassLoader  */ @Nullable protected ClassLoader getBundleClassLoader() {     return (this.bundleClassLoader != null ? this.bundleClassLoader : this.beanClassLoader). }
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.beanClassLoader = classLoader. }
true;protected;2;14;/**  * Resolves the given message code as key in the registered resource bundles,  * returning the value found in the bundle as-is (without MessageFormat parsing).  */ ;/**  * Resolves the given message code as key in the registered resource bundles,  * returning the value found in the bundle as-is (without MessageFormat parsing).  */ @Override protected String resolveCodeWithoutArguments(String code, Locale locale) {     Set<String> basenames = getBasenameSet().     for (String basename : basenames) {         ResourceBundle bundle = getResourceBundle(basename, locale).         if (bundle != null) {             String result = getStringOrNull(bundle, code).             if (result != null) {                 return result.             }         }     }     return null. }
true;protected;2;15;/**  * Resolves the given message code as key in the registered resource bundles,  * using a cached MessageFormat instance per message code.  */ ;/**  * Resolves the given message code as key in the registered resource bundles,  * using a cached MessageFormat instance per message code.  */ @Override @Nullable protected MessageFormat resolveCode(String code, Locale locale) {     Set<String> basenames = getBasenameSet().     for (String basename : basenames) {         ResourceBundle bundle = getResourceBundle(basename, locale).         if (bundle != null) {             MessageFormat messageFormat = getMessageFormat(bundle, code, locale).             if (messageFormat != null) {                 return messageFormat.             }         }     }     return null. }
true;protected;2;38;/**  * Return a ResourceBundle for the given basename and code,  * fetching already generated MessageFormats from the cache.  * @param basename the basename of the ResourceBundle  * @param locale the Locale to find the ResourceBundle for  * @return the resulting ResourceBundle, or {@code null} if none  * found for the given basename and Locale  */ ;/**  * Return a ResourceBundle for the given basename and code,  * fetching already generated MessageFormats from the cache.  * @param basename the basename of the ResourceBundle  * @param locale the Locale to find the ResourceBundle for  * @return the resulting ResourceBundle, or {@code null} if none  * found for the given basename and Locale  */ @Nullable protected ResourceBundle getResourceBundle(String basename, Locale locale) {     if (getCacheMillis() >= 0) {         // do its native caching, at the expense of more extensive lookup steps.         return doGetBundle(basename, locale).     } else {         // Cache forever: prefer locale cache over repeated getBundle calls.         Map<Locale, ResourceBundle> localeMap = this.cachedResourceBundles.get(basename).         if (localeMap != null) {             ResourceBundle bundle = localeMap.get(locale).             if (bundle != null) {                 return bundle.             }         }         try {             ResourceBundle bundle = doGetBundle(basename, locale).             if (localeMap == null) {                 localeMap = new ConcurrentHashMap<>().                 Map<Locale, ResourceBundle> existing = this.cachedResourceBundles.putIfAbsent(basename, localeMap).                 if (existing != null) {                     localeMap = existing.                 }             }             localeMap.put(locale, bundle).             return bundle.         } catch (MissingResourceException ex) {             if (logger.isWarnEnabled()) {                 logger.warn("ResourceBundle [" + basename + "] not found for MessageSource: " + ex.getMessage()).             }             // -> do NOT throw the exception to allow for checking parent message source.             return null.         }     } }
true;protected;2;26;/**  * Obtain the resource bundle for the given basename and Locale.  * @param basename the basename to look for  * @param locale the Locale to look for  * @return the corresponding ResourceBundle  * @throws MissingResourceException if no matching bundle could be found  * @see java.util.ResourceBundle#getBundle(String, Locale, ClassLoader)  * @see #getBundleClassLoader()  */ ;/**  * Obtain the resource bundle for the given basename and Locale.  * @param basename the basename to look for  * @param locale the Locale to look for  * @return the corresponding ResourceBundle  * @throws MissingResourceException if no matching bundle could be found  * @see java.util.ResourceBundle#getBundle(String, Locale, ClassLoader)  * @see #getBundleClassLoader()  */ protected ResourceBundle doGetBundle(String basename, Locale locale) throws MissingResourceException {     ClassLoader classLoader = getBundleClassLoader().     Assert.state(classLoader != null, "No bundle ClassLoader set").     MessageSourceControl control = this.control.     if (control != null) {         try {             return ResourceBundle.getBundle(basename, locale, classLoader, control).         } catch (UnsupportedOperationException ex) {             // Probably in a Jigsaw environment on JDK 9+             this.control = null.             String encoding = getDefaultEncoding().             if (encoding != null && logger.isInfoEnabled()) {                 logger.info("ResourceBundleMessageSource is configured to read resources with encoding '" + encoding + "' but ResourceBundle.Control not supported in current system environment: " + ex.getMessage() + " - falling back to plain ResourceBundle.getBundle retrieval with the " + "platform default encoding. Consider setting the 'defaultEncoding' property to 'null' " + "for participating in the platform default and therefore avoiding this log message.").             }         }     }     // Fallback: plain getBundle lookup without Control handle     return ResourceBundle.getBundle(basename, locale, classLoader). }
true;protected;1;3;/**  * Load a property-based resource bundle from the given reader.  * <p>This will be called in case of a {@link #setDefaultEncoding "defaultEncoding"},  * including {@link ResourceBundleMessageSource}'s default ISO-8859-1 encoding.  * Note that this method can only be called with a {@code ResourceBundle.Control}:  * When running on the JDK 9+ module path where such control handles are not  * supported, any overrides in custom subclasses will effectively get ignored.  * <p>The default implementation returns a {@link PropertyResourceBundle}.  * @param reader the reader for the target resource  * @return the fully loaded bundle  * @throws IOException in case of I/O failure  * @since 4.2  * @see #loadBundle(InputStream)  * @see PropertyResourceBundle#PropertyResourceBundle(Reader)  */ ;/**  * Load a property-based resource bundle from the given reader.  * <p>This will be called in case of a {@link #setDefaultEncoding "defaultEncoding"},  * including {@link ResourceBundleMessageSource}'s default ISO-8859-1 encoding.  * Note that this method can only be called with a {@code ResourceBundle.Control}:  * When running on the JDK 9+ module path where such control handles are not  * supported, any overrides in custom subclasses will effectively get ignored.  * <p>The default implementation returns a {@link PropertyResourceBundle}.  * @param reader the reader for the target resource  * @return the fully loaded bundle  * @throws IOException in case of I/O failure  * @since 4.2  * @see #loadBundle(InputStream)  * @see PropertyResourceBundle#PropertyResourceBundle(Reader)  */ protected ResourceBundle loadBundle(Reader reader) throws IOException {     return new PropertyResourceBundle(reader). }
true;protected;1;3;/**  * Load a property-based resource bundle from the given input stream,  * picking up the default properties encoding on JDK 9+.  * <p>This will only be called with {@link #setDefaultEncoding "defaultEncoding"}  * set to {@code null}, explicitly enforcing the platform default encoding  * (which is UTF-8 with a ISO-8859-1 fallback on JDK 9+ but configurable  * through the "java.util.PropertyResourceBundle.encoding" system property).  * Note that this method can only be called with a {@code ResourceBundle.Control}:  * When running on the JDK 9+ module path where such control handles are not  * supported, any overrides in custom subclasses will effectively get ignored.  * <p>The default implementation returns a {@link PropertyResourceBundle}.  * @param inputStream the input stream for the target resource  * @return the fully loaded bundle  * @throws IOException in case of I/O failure  * @since 5.1  * @see #loadBundle(Reader)  * @see PropertyResourceBundle#PropertyResourceBundle(InputStream)  */ ;/**  * Load a property-based resource bundle from the given input stream,  * picking up the default properties encoding on JDK 9+.  * <p>This will only be called with {@link #setDefaultEncoding "defaultEncoding"}  * set to {@code null}, explicitly enforcing the platform default encoding  * (which is UTF-8 with a ISO-8859-1 fallback on JDK 9+ but configurable  * through the "java.util.PropertyResourceBundle.encoding" system property).  * Note that this method can only be called with a {@code ResourceBundle.Control}:  * When running on the JDK 9+ module path where such control handles are not  * supported, any overrides in custom subclasses will effectively get ignored.  * <p>The default implementation returns a {@link PropertyResourceBundle}.  * @param inputStream the input stream for the target resource  * @return the fully loaded bundle  * @throws IOException in case of I/O failure  * @since 5.1  * @see #loadBundle(Reader)  * @see PropertyResourceBundle#PropertyResourceBundle(InputStream)  */ protected ResourceBundle loadBundle(InputStream inputStream) throws IOException {     return new PropertyResourceBundle(inputStream). }
true;protected;3;40;/**  * Return a MessageFormat for the given bundle and code,  * fetching already generated MessageFormats from the cache.  * @param bundle the ResourceBundle to work on  * @param code the message code to retrieve  * @param locale the Locale to use to build the MessageFormat  * @return the resulting MessageFormat, or {@code null} if no message  * defined for the given code  * @throws MissingResourceException if thrown by the ResourceBundle  */ ;/**  * Return a MessageFormat for the given bundle and code,  * fetching already generated MessageFormats from the cache.  * @param bundle the ResourceBundle to work on  * @param code the message code to retrieve  * @param locale the Locale to use to build the MessageFormat  * @return the resulting MessageFormat, or {@code null} if no message  * defined for the given code  * @throws MissingResourceException if thrown by the ResourceBundle  */ @Nullable protected MessageFormat getMessageFormat(ResourceBundle bundle, String code, Locale locale) throws MissingResourceException {     Map<String, Map<Locale, MessageFormat>> codeMap = this.cachedBundleMessageFormats.get(bundle).     Map<Locale, MessageFormat> localeMap = null.     if (codeMap != null) {         localeMap = codeMap.get(code).         if (localeMap != null) {             MessageFormat result = localeMap.get(locale).             if (result != null) {                 return result.             }         }     }     String msg = getStringOrNull(bundle, code).     if (msg != null) {         if (codeMap == null) {             codeMap = new ConcurrentHashMap<>().             Map<String, Map<Locale, MessageFormat>> existing = this.cachedBundleMessageFormats.putIfAbsent(bundle, codeMap).             if (existing != null) {                 codeMap = existing.             }         }         if (localeMap == null) {             localeMap = new ConcurrentHashMap<>().             Map<Locale, MessageFormat> existing = codeMap.putIfAbsent(code, localeMap).             if (existing != null) {                 localeMap = existing.             }         }         MessageFormat result = createMessageFormat(msg, locale).         localeMap.put(locale, result).         return result.     }     return null. }
true;protected;2;13;/**  * Efficiently retrieve the String value for the specified key,  * or return {@code null} if not found.  * <p>As of 4.2, the default implementation checks {@code containsKey}  * before it attempts to call {@code getString} (which would require  * catching {@code MissingResourceException} for key not found).  * <p>Can be overridden in subclasses.  * @param bundle the ResourceBundle to perform the lookup in  * @param key the key to look up  * @return the associated value, or {@code null} if none  * @since 4.2  * @see ResourceBundle#getString(String)  * @see ResourceBundle#containsKey(String)  */ ;/**  * Efficiently retrieve the String value for the specified key,  * or return {@code null} if not found.  * <p>As of 4.2, the default implementation checks {@code containsKey}  * before it attempts to call {@code getString} (which would require  * catching {@code MissingResourceException} for key not found).  * <p>Can be overridden in subclasses.  * @param bundle the ResourceBundle to perform the lookup in  * @param key the key to look up  * @return the associated value, or {@code null} if none  * @since 4.2  * @see ResourceBundle#getString(String)  * @see ResourceBundle#containsKey(String)  */ @Nullable protected String getStringOrNull(ResourceBundle bundle, String key) {     if (bundle.containsKey(key)) {         try {             return bundle.getString(key).         } catch (MissingResourceException ex) {         // Assume key not found for some other reason         // -> do NOT throw the exception to allow for checking parent message source.         }     }     return null. }
true;public;0;4;/**  * Show the configuration of this MessageSource.  */ ;/**  * Show the configuration of this MessageSource.  */ @Override public String toString() {     return getClass().getName() + ": basenames=" + getBasenameSet(). }
false;public;5;56;;@Override @Nullable public ResourceBundle newBundle(String baseName, Locale locale, String format, ClassLoader loader, boolean reload) throws IllegalAccessException, InstantiationException, IOException {     // Special handling of default encoding     if (format.equals("java.properties")) {         String bundleName = toBundleName(baseName, locale).         final String resourceName = toResourceName(bundleName, "properties").         final ClassLoader classLoader = loader.         final boolean reloadFlag = reload.         InputStream inputStream.         try {             inputStream = AccessController.doPrivileged((PrivilegedExceptionAction<InputStream>) () -> {                 InputStream is = null.                 if (reloadFlag) {                     URL url = classLoader.getResource(resourceName).                     if (url != null) {                         URLConnection connection = url.openConnection().                         if (connection != null) {                             connection.setUseCaches(false).                             is = connection.getInputStream().                         }                     }                 } else {                     is = classLoader.getResourceAsStream(resourceName).                 }                 return is.             }).         } catch (PrivilegedActionException ex) {             throw (IOException) ex.getException().         }         if (inputStream != null) {             String encoding = getDefaultEncoding().             if (encoding != null) {                 try (InputStreamReader bundleReader = new InputStreamReader(inputStream, encoding)) {                     return loadBundle(bundleReader).                 }             } else {                 try (InputStream bundleStream = inputStream) {                     return loadBundle(bundleStream).                 }             }         } else {             return null.         }     } else {         // Delegate handling of "java.class" format to standard Control         return super.newBundle(baseName, locale, format, loader, reload).     } }
false;public;2;5;;@Override @Nullable public Locale getFallbackLocale(String baseName, Locale locale) {     return (isFallbackToSystemLocale() ? super.getFallbackLocale(baseName, locale) : null). }
false;public;2;5;;@Override public long getTimeToLive(String baseName, Locale locale) {     long cacheMillis = getCacheMillis().     return (cacheMillis >= 0 ? cacheMillis : super.getTimeToLive(baseName, locale)). }
false;public;6;12;;@Override public boolean needsReload(String baseName, Locale locale, String format, ClassLoader loader, ResourceBundle bundle, long loadTime) {     if (super.needsReload(baseName, locale, format, loader, bundle, loadTime)) {         cachedBundleMessageFormats.remove(bundle).         return true.     } else {         return false.     } }
