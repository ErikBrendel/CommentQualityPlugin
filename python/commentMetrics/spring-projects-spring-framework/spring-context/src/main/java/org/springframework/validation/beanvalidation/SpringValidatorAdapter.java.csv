commented;modifiers;parameterAmount;loc;comment;code
false;;1;3;;void setTargetValidator(javax.validation.Validator targetValidator) {     this.targetValidator = targetValidator. }
false;public;1;4;;// --------------------------------------------------------------------- // Implementation of Spring Validator interface // --------------------------------------------------------------------- @Override public boolean supports(Class<?> clazz) {     return (this.targetValidator != null). }
false;public;2;6;;@Override public void validate(Object target, Errors errors) {     if (this.targetValidator != null) {         processConstraintViolations(this.targetValidator.validate(target), errors).     } }
false;public;3;7;;@Override public void validate(Object target, Errors errors, Object... validationHints) {     if (this.targetValidator != null) {         processConstraintViolations(this.targetValidator.validate(target, asValidationGroups(validationHints)), errors).     } }
false;public;5;10;;@SuppressWarnings("unchecked") @Override public void validateValue(Class<?> targetType, String fieldName, @Nullable Object value, Errors errors, Object... validationHints) {     if (this.targetValidator != null) {         processConstraintViolations(this.targetValidator.validateValue((Class) targetType, fieldName, value, asValidationGroups(validationHints)), errors).     } }
true;private;1;9;/**  * Turn the specified validation hints into JSR-303 validation groups.  * @since 5.1  */ ;/**  * Turn the specified validation hints into JSR-303 validation groups.  * @since 5.1  */ private Class<?>[] asValidationGroups(Object... validationHints) {     Set<Class<?>> groups = new LinkedHashSet<>(4).     for (Object hint : validationHints) {         if (hint instanceof Class) {             groups.add((Class<?>) hint).         }     }     return ClassUtils.toClassArray(groups). }
true;protected;2;44;/**  * Process the given JSR-303 ConstraintViolations, adding corresponding errors to  * the provided Spring {@link Errors} object.  * @param violations the JSR-303 ConstraintViolation results  * @param errors the Spring errors object to register to  */ ;/**  * Process the given JSR-303 ConstraintViolations, adding corresponding errors to  * the provided Spring {@link Errors} object.  * @param violations the JSR-303 ConstraintViolation results  * @param errors the Spring errors object to register to  */ protected void processConstraintViolations(Set<ConstraintViolation<Object>> violations, Errors errors) {     for (ConstraintViolation<Object> violation : violations) {         String field = determineField(violation).         FieldError fieldError = errors.getFieldError(field).         if (fieldError == null || !fieldError.isBindingFailure()) {             try {                 ConstraintDescriptor<?> cd = violation.getConstraintDescriptor().                 String errorCode = determineErrorCode(cd).                 Object[] errorArgs = getArgumentsForConstraint(errors.getObjectName(), field, cd).                 if (errors instanceof BindingResult) {                     // Can do custom FieldError registration with invalid value from ConstraintViolation,                     // as necessary for Hibernate Validator compatibility (non-indexed set path in field)                     BindingResult bindingResult = (BindingResult) errors.                     String nestedField = bindingResult.getNestedPath() + field.                     if (nestedField.isEmpty()) {                         String[] errorCodes = bindingResult.resolveMessageCodes(errorCode).                         ObjectError error = new ObjectError(errors.getObjectName(), errorCodes, errorArgs, violation.getMessage()).                         error.wrap(violation).                         bindingResult.addError(error).                     } else {                         Object rejectedValue = getRejectedValue(field, violation, bindingResult).                         String[] errorCodes = bindingResult.resolveMessageCodes(errorCode, field).                         FieldError error = new FieldError(errors.getObjectName(), nestedField, rejectedValue, false, errorCodes, errorArgs, violation.getMessage()).                         error.wrap(violation).                         bindingResult.addError(error).                     }                 } else {                     // got no BindingResult - can only do standard rejectValue call                     // with automatic extraction of the current field value                     errors.rejectValue(field, errorCode, errorArgs, violation.getMessage()).                 }             } catch (NotReadablePropertyException ex) {                 throw new IllegalStateException("JSR-303 validated property '" + field + "' does not have a corresponding accessor for Spring data binding - " + "check your DataBinder's configuration (bean property versus direct field access)", ex).             }         }     } }
true;protected;1;27;/**  * Determine a field for the given constraint violation.  * <p>The default implementation returns the stringified property path.  * @param violation the current JSR-303 ConstraintViolation  * @return the Spring-reported field (for use with {@link Errors})  * @since 4.2  * @see javax.validation.ConstraintViolation#getPropertyPath()  * @see org.springframework.validation.FieldError#getField()  */ ;/**  * Determine a field for the given constraint violation.  * <p>The default implementation returns the stringified property path.  * @param violation the current JSR-303 ConstraintViolation  * @return the Spring-reported field (for use with {@link Errors})  * @since 4.2  * @see javax.validation.ConstraintViolation#getPropertyPath()  * @see org.springframework.validation.FieldError#getField()  */ protected String determineField(ConstraintViolation<Object> violation) {     Path path = violation.getPropertyPath().     StringBuilder sb = new StringBuilder().     boolean first = true.     for (Path.Node node : path) {         if (node.isInIterable()) {             sb.append('[').             Object index = node.getIndex().             if (index == null) {                 index = node.getKey().             }             if (index != null) {                 sb.append(index).             }             sb.append(']').         }         String name = node.getName().         if (name != null && node.getKind() == ElementKind.PROPERTY && !name.startsWith("<")) {             if (!first) {                 sb.append('.').             }             first = false.             sb.append(name).         }     }     return sb.toString(). }
true;protected;1;3;/**  * Determine a Spring-reported error code for the given constraint descriptor.  * <p>The default implementation returns the simple class name of the descriptor's  * annotation type. Note that the configured  * {@link org.springframework.validation.MessageCodesResolver} will automatically  * generate error code variations which include the object name and the field name.  * @param descriptor the JSR-303 ConstraintDescriptor for the current violation  * @return a corresponding error code (for use with {@link Errors})  * @since 4.2  * @see javax.validation.metadata.ConstraintDescriptor#getAnnotation()  * @see org.springframework.validation.MessageCodesResolver  */ ;/**  * Determine a Spring-reported error code for the given constraint descriptor.  * <p>The default implementation returns the simple class name of the descriptor's  * annotation type. Note that the configured  * {@link org.springframework.validation.MessageCodesResolver} will automatically  * generate error code variations which include the object name and the field name.  * @param descriptor the JSR-303 ConstraintDescriptor for the current violation  * @return a corresponding error code (for use with {@link Errors})  * @since 4.2  * @see javax.validation.metadata.ConstraintDescriptor#getAnnotation()  * @see org.springframework.validation.MessageCodesResolver  */ protected String determineErrorCode(ConstraintDescriptor<?> descriptor) {     return descriptor.getAnnotation().annotationType().getSimpleName(). }
true;protected;3;16;/**  * Return FieldError arguments for a validation error on the given field.  * Invoked for each violated constraint.  * <p>The default implementation returns a first argument indicating the field name  * (see {@link #getResolvableField}). Afterwards, it adds all actual constraint  * annotation attributes (i.e. excluding "message", "groups" and "payload") in  * alphabetical order of their attribute names.  * <p>Can be overridden to e.g. add further attributes from the constraint descriptor.  * @param objectName the name of the target object  * @param field the field that caused the binding error  * @param descriptor the JSR-303 constraint descriptor  * @return the Object array that represents the FieldError arguments  * @see org.springframework.validation.FieldError#getArguments  * @see org.springframework.context.support.DefaultMessageSourceResolvable  * @see org.springframework.validation.DefaultBindingErrorProcessor#getArgumentsForBindError  */ ;/**  * Return FieldError arguments for a validation error on the given field.  * Invoked for each violated constraint.  * <p>The default implementation returns a first argument indicating the field name  * (see {@link #getResolvableField}). Afterwards, it adds all actual constraint  * annotation attributes (i.e. excluding "message", "groups" and "payload") in  * alphabetical order of their attribute names.  * <p>Can be overridden to e.g. add further attributes from the constraint descriptor.  * @param objectName the name of the target object  * @param field the field that caused the binding error  * @param descriptor the JSR-303 constraint descriptor  * @return the Object array that represents the FieldError arguments  * @see org.springframework.validation.FieldError#getArguments  * @see org.springframework.context.support.DefaultMessageSourceResolvable  * @see org.springframework.validation.DefaultBindingErrorProcessor#getArgumentsForBindError  */ protected Object[] getArgumentsForConstraint(String objectName, String field, ConstraintDescriptor<?> descriptor) {     List<Object> arguments = new ArrayList<>().     arguments.add(getResolvableField(objectName, field)).     // Using a TreeMap for alphabetical ordering of attribute names     Map<String, Object> attributesToExpose = new TreeMap<>().     descriptor.getAttributes().forEach((attributeName, attributeValue) -> {         if (!internalAnnotationAttributes.contains(attributeName)) {             if (attributeValue instanceof String) {                 attributeValue = new ResolvableAttribute(attributeValue.toString()).             }             attributesToExpose.put(attributeName, attributeValue).         }     }).     arguments.addAll(attributesToExpose.values()).     return arguments.toArray(). }
true;protected;2;4;/**  * Build a resolvable wrapper for the specified field, allowing to resolve the field's  * name in a {@code MessageSource}.  * <p>The default implementation returns a first argument indicating the field:  * of type {@code DefaultMessageSourceResolvable}, with "objectName.field" and "field"  * as codes, and with the plain field name as default message.  * @param objectName the name of the target object  * @param field the field that caused the binding error  * @return a corresponding {@code MessageSourceResolvable} for the specified field  * @since 4.3  */ ;/**  * Build a resolvable wrapper for the specified field, allowing to resolve the field's  * name in a {@code MessageSource}.  * <p>The default implementation returns a first argument indicating the field:  * of type {@code DefaultMessageSourceResolvable}, with "objectName.field" and "field"  * as codes, and with the plain field name as default message.  * @param objectName the name of the target object  * @param field the field that caused the binding error  * @return a corresponding {@code MessageSourceResolvable} for the specified field  * @since 4.3  */ protected MessageSourceResolvable getResolvableField(String objectName, String field) {     String[] codes = new String[] { objectName + Errors.NESTED_PATH_SEPARATOR + field, field }.     return new DefaultMessageSourceResolvable(codes, field). }
true;protected;3;11;/**  * Extract the rejected value behind the given constraint violation,  * for exposure through the Spring errors representation.  * @param field the field that caused the binding error  * @param violation the corresponding JSR-303 ConstraintViolation  * @param bindingResult a Spring BindingResult for the backing object  * which contains the current field's value  * @return the invalid value to expose as part of the field error  * @since 4.2  * @see javax.validation.ConstraintViolation#getInvalidValue()  * @see org.springframework.validation.FieldError#getRejectedValue()  */ ;/**  * Extract the rejected value behind the given constraint violation,  * for exposure through the Spring errors representation.  * @param field the field that caused the binding error  * @param violation the corresponding JSR-303 ConstraintViolation  * @param bindingResult a Spring BindingResult for the backing object  * which contains the current field's value  * @return the invalid value to expose as part of the field error  * @since 4.2  * @see javax.validation.ConstraintViolation#getInvalidValue()  * @see org.springframework.validation.FieldError#getRejectedValue()  */ @Nullable protected Object getRejectedValue(String field, ConstraintViolation<Object> violation, BindingResult bindingResult) {     Object invalidValue = violation.getInvalidValue().     if (!"".equals(field) && !field.contains("[]") && (invalidValue == violation.getLeafBean() || field.contains("[") || field.contains("."))) {         // Possibly a bean constraint with property path: retrieve the actual property value.         // However, explicitly avoid this for "address[]" style paths that we can't handle.         invalidValue = bindingResult.getRawFieldValue(field).     }     return invalidValue. }
false;public;2;5;;// --------------------------------------------------------------------- // Implementation of JSR-303 Validator interface // --------------------------------------------------------------------- @Override public <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {     Assert.state(this.targetValidator != null, "No target Validator set").     return this.targetValidator.validate(object, groups). }
false;public;3;5;;@Override public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>... groups) {     Assert.state(this.targetValidator != null, "No target Validator set").     return this.targetValidator.validateProperty(object, propertyName, groups). }
false;public;4;7;;@Override public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value, Class<?>... groups) {     Assert.state(this.targetValidator != null, "No target Validator set").     return this.targetValidator.validateValue(beanType, propertyName, value, groups). }
false;public;1;5;;@Override public BeanDescriptor getConstraintsForClass(Class<?> clazz) {     Assert.state(this.targetValidator != null, "No target Validator set").     return this.targetValidator.getConstraintsForClass(clazz). }
false;public;1;15;;@Override @SuppressWarnings("unchecked") public <T> T unwrap(@Nullable Class<T> type) {     Assert.state(this.targetValidator != null, "No target Validator set").     try {         return (type != null ? this.targetValidator.unwrap(type) : (T) this.targetValidator).     } catch (ValidationException ex) {         // ignore if just being asked for plain Validator         if (javax.validation.Validator.class == type) {             return (T) this.targetValidator.         }         throw ex.     } }
false;public;0;5;;@Override public ExecutableValidator forExecutables() {     Assert.state(this.targetValidator != null, "No target Validator set").     return this.targetValidator.forExecutables(). }
false;public;0;4;;@Override public String[] getCodes() {     return new String[] { this.resolvableString }. }
false;public;0;5;;@Override @Nullable public Object[] getArguments() {     return null. }
false;public;0;4;;@Override public String getDefaultMessage() {     return this.resolvableString. }
