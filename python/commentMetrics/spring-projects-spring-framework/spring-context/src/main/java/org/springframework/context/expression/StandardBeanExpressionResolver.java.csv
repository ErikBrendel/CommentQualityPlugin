commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isTemplate() {     return true. }
false;public;0;4;;@Override public String getExpressionPrefix() {     return expressionPrefix. }
false;public;0;4;;@Override public String getExpressionSuffix() {     return expressionSuffix. }
true;public;1;4;/**  * Set the prefix that an expression string starts with.  * The default is "#{".  * @see #DEFAULT_EXPRESSION_PREFIX  */ ;/**  * Set the prefix that an expression string starts with.  * The default is "#{".  * @see #DEFAULT_EXPRESSION_PREFIX  */ public void setExpressionPrefix(String expressionPrefix) {     Assert.hasText(expressionPrefix, "Expression prefix must not be empty").     this.expressionPrefix = expressionPrefix. }
true;public;1;4;/**  * Set the suffix that an expression string ends with.  * The default is "}".  * @see #DEFAULT_EXPRESSION_SUFFIX  */ ;/**  * Set the suffix that an expression string ends with.  * The default is "}".  * @see #DEFAULT_EXPRESSION_SUFFIX  */ public void setExpressionSuffix(String expressionSuffix) {     Assert.hasText(expressionSuffix, "Expression suffix must not be empty").     this.expressionSuffix = expressionSuffix. }
true;public;1;4;/**  * Specify the EL parser to use for expression parsing.  * <p>Default is a {@link org.springframework.expression.spel.standard.SpelExpressionParser},  * compatible with standard Unified EL style expression syntax.  */ ;/**  * Specify the EL parser to use for expression parsing.  * <p>Default is a {@link org.springframework.expression.spel.standard.SpelExpressionParser},  * compatible with standard Unified EL style expression syntax.  */ public void setExpressionParser(ExpressionParser expressionParser) {     Assert.notNull(expressionParser, "ExpressionParser must not be null").     this.expressionParser = expressionParser. }
false;public;2;34;;@Override @Nullable public Object evaluate(@Nullable String value, BeanExpressionContext evalContext) throws BeansException {     if (!StringUtils.hasLength(value)) {         return value.     }     try {         Expression expr = this.expressionCache.get(value).         if (expr == null) {             expr = this.expressionParser.parseExpression(value, this.beanExpressionParserContext).             this.expressionCache.put(value, expr).         }         StandardEvaluationContext sec = this.evaluationCache.get(evalContext).         if (sec == null) {             sec = new StandardEvaluationContext(evalContext).             sec.addPropertyAccessor(new BeanExpressionContextAccessor()).             sec.addPropertyAccessor(new BeanFactoryAccessor()).             sec.addPropertyAccessor(new MapAccessor()).             sec.addPropertyAccessor(new EnvironmentAccessor()).             sec.setBeanResolver(new BeanFactoryResolver(evalContext.getBeanFactory())).             sec.setTypeLocator(new StandardTypeLocator(evalContext.getBeanFactory().getBeanClassLoader())).             ConversionService conversionService = evalContext.getBeanFactory().getConversionService().             if (conversionService != null) {                 sec.setTypeConverter(new StandardTypeConverter(conversionService)).             }             customizeEvaluationContext(sec).             this.evaluationCache.put(evalContext, sec).         }         return expr.getValue(sec).     } catch (Throwable ex) {         throw new BeanExpressionException("Expression parsing failed", ex).     } }
true;protected;1;2;/**  * Template method for customizing the expression evaluation context.  * <p>The default implementation is empty.  */ ;/**  * Template method for customizing the expression evaluation context.  * <p>The default implementation is empty.  */ protected void customizeEvaluationContext(StandardEvaluationContext evalContext) { }
