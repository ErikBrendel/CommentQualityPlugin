commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;4;/**  * Return the BeanDefinitionRegistry that this scanner operates on.  */ ;/**  * Return the BeanDefinitionRegistry that this scanner operates on.  */ @Override public final BeanDefinitionRegistry getRegistry() {     return this.registry. }
true;public;1;4;/**  * Set the defaults to use for detected beans.  * @see BeanDefinitionDefaults  */ ;/**  * Set the defaults to use for detected beans.  * @see BeanDefinitionDefaults  */ public void setBeanDefinitionDefaults(@Nullable BeanDefinitionDefaults beanDefinitionDefaults) {     this.beanDefinitionDefaults = (beanDefinitionDefaults != null ? beanDefinitionDefaults : new BeanDefinitionDefaults()). }
true;public;0;3;/**  * Return the defaults to use for detected beans (never {@code null}).  * @since 4.1  */ ;/**  * Return the defaults to use for detected beans (never {@code null}).  * @since 4.1  */ public BeanDefinitionDefaults getBeanDefinitionDefaults() {     return this.beanDefinitionDefaults. }
true;public;1;3;/**  * Set the name-matching patterns for determining autowire candidates.  * @param autowireCandidatePatterns the patterns to match against  */ ;/**  * Set the name-matching patterns for determining autowire candidates.  * @param autowireCandidatePatterns the patterns to match against  */ public void setAutowireCandidatePatterns(@Nullable String... autowireCandidatePatterns) {     this.autowireCandidatePatterns = autowireCandidatePatterns. }
true;public;1;3;/**  * Set the BeanNameGenerator to use for detected bean classes.  * <p>Default is a {@link AnnotationBeanNameGenerator}.  */ ;/**  * Set the BeanNameGenerator to use for detected bean classes.  * <p>Default is a {@link AnnotationBeanNameGenerator}.  */ public void setBeanNameGenerator(@Nullable BeanNameGenerator beanNameGenerator) {     this.beanNameGenerator = (beanNameGenerator != null ? beanNameGenerator : new AnnotationBeanNameGenerator()). }
true;public;1;4;/**  * Set the ScopeMetadataResolver to use for detected bean classes.  * Note that this will override any custom "scopedProxyMode" setting.  * <p>The default is an {@link AnnotationScopeMetadataResolver}.  * @see #setScopedProxyMode  */ ;/**  * Set the ScopeMetadataResolver to use for detected bean classes.  * Note that this will override any custom "scopedProxyMode" setting.  * <p>The default is an {@link AnnotationScopeMetadataResolver}.  * @see #setScopedProxyMode  */ public void setScopeMetadataResolver(@Nullable ScopeMetadataResolver scopeMetadataResolver) {     this.scopeMetadataResolver = (scopeMetadataResolver != null ? scopeMetadataResolver : new AnnotationScopeMetadataResolver()). }
true;public;1;3;/**  * Specify the proxy behavior for non-singleton scoped beans.  * Note that this will override any custom "scopeMetadataResolver" setting.  * <p>The default is {@link ScopedProxyMode#NO}.  * @see #setScopeMetadataResolver  */ ;/**  * Specify the proxy behavior for non-singleton scoped beans.  * Note that this will override any custom "scopeMetadataResolver" setting.  * <p>The default is {@link ScopedProxyMode#NO}.  * @see #setScopeMetadataResolver  */ public void setScopedProxyMode(ScopedProxyMode scopedProxyMode) {     this.scopeMetadataResolver = new AnnotationScopeMetadataResolver(scopedProxyMode). }
true;public;1;3;/**  * Specify whether to register annotation config post-processors.  * <p>The default is to register the post-processors. Turn this off  * to be able to ignore the annotations or to process them differently.  */ ;/**  * Specify whether to register annotation config post-processors.  * <p>The default is to register the post-processors. Turn this off  * to be able to ignore the annotations or to process them differently.  */ public void setIncludeAnnotationConfig(boolean includeAnnotationConfig) {     this.includeAnnotationConfig = includeAnnotationConfig. }
true;public;1;12;/**  * Perform a scan within the specified base packages.  * @param basePackages the packages to check for annotated classes  * @return number of beans registered  */ ;/**  * Perform a scan within the specified base packages.  * @param basePackages the packages to check for annotated classes  * @return number of beans registered  */ public int scan(String... basePackages) {     int beanCountAtScanStart = this.registry.getBeanDefinitionCount().     doScan(basePackages).     // Register annotation config processors, if necessary.     if (this.includeAnnotationConfig) {         AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry).     }     return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart). }
true;protected;1;26;/**  * Perform a scan within the specified base packages,  * returning the registered bean definitions.  * <p>This method does <i>not</i> register an annotation config processor  * but rather leaves this up to the caller.  * @param basePackages the packages to check for annotated classes  * @return set of beans registered if any for tooling registration purposes (never {@code null})  */ ;/**  * Perform a scan within the specified base packages,  * returning the registered bean definitions.  * <p>This method does <i>not</i> register an annotation config processor  * but rather leaves this up to the caller.  * @param basePackages the packages to check for annotated classes  * @return set of beans registered if any for tooling registration purposes (never {@code null})  */ protected Set<BeanDefinitionHolder> doScan(String... basePackages) {     Assert.notEmpty(basePackages, "At least one base package must be specified").     Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>().     for (String basePackage : basePackages) {         Set<BeanDefinition> candidates = findCandidateComponents(basePackage).         for (BeanDefinition candidate : candidates) {             ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate).             candidate.setScope(scopeMetadata.getScopeName()).             String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry).             if (candidate instanceof AbstractBeanDefinition) {                 postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName).             }             if (candidate instanceof AnnotatedBeanDefinition) {                 AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate).             }             if (checkCandidate(beanName, candidate)) {                 BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName).                 definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry).                 beanDefinitions.add(definitionHolder).                 registerBeanDefinition(definitionHolder, this.registry).             }         }     }     return beanDefinitions. }
true;protected;2;6;/**  * Apply further settings to the given bean definition,  * beyond the contents retrieved from scanning the component class.  * @param beanDefinition the scanned bean definition  * @param beanName the generated bean name for the given bean  */ ;/**  * Apply further settings to the given bean definition,  * beyond the contents retrieved from scanning the component class.  * @param beanDefinition the scanned bean definition  * @param beanName the generated bean name for the given bean  */ protected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) {     beanDefinition.applyDefaults(this.beanDefinitionDefaults).     if (this.autowireCandidatePatterns != null) {         beanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(this.autowireCandidatePatterns, beanName)).     } }
true;protected;2;3;/**  * Register the specified bean with the given registry.  * <p>Can be overridden in subclasses, e.g. to adapt the registration  * process or to register further bean definitions for each scanned bean.  * @param definitionHolder the bean definition plus bean name for the bean  * @param registry the BeanDefinitionRegistry to register the bean with  */ ;/**  * Register the specified bean with the given registry.  * <p>Can be overridden in subclasses, e.g. to adapt the registration  * process or to register further bean definitions for each scanned bean.  * @param definitionHolder the bean definition plus bean name for the bean  * @param registry the BeanDefinitionRegistry to register the bean with  */ protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {     BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry). }
true;protected;2;16;/**  * Check the given candidate's bean name, determining whether the corresponding  * bean definition needs to be registered or conflicts with an existing definition.  * @param beanName the suggested name for the bean  * @param beanDefinition the corresponding bean definition  * @return {@code true} if the bean can be registered as-is.  * {@code false} if it should be skipped because there is an  * existing, compatible bean definition for the specified name  * @throws ConflictingBeanDefinitionException if an existing, incompatible  * bean definition has been found for the specified name  */ ;/**  * Check the given candidate's bean name, determining whether the corresponding  * bean definition needs to be registered or conflicts with an existing definition.  * @param beanName the suggested name for the bean  * @param beanDefinition the corresponding bean definition  * @return {@code true} if the bean can be registered as-is.  * {@code false} if it should be skipped because there is an  * existing, compatible bean definition for the specified name  * @throws ConflictingBeanDefinitionException if an existing, incompatible  * bean definition has been found for the specified name  */ protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {     if (!this.registry.containsBeanDefinition(beanName)) {         return true.     }     BeanDefinition existingDef = this.registry.getBeanDefinition(beanName).     BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition().     if (originatingDef != null) {         existingDef = originatingDef.     }     if (isCompatible(beanDefinition, existingDef)) {         return false.     }     throw new ConflictingBeanDefinitionException("Annotation-specified bean name '" + beanName + "' for bean class [" + beanDefinition.getBeanClassName() + "] conflicts with existing, " + "non-compatible bean definition of same name and class [" + existingDef.getBeanClassName() + "]"). }
true;protected;2;5;/**  * Determine whether the given new bean definition is compatible with  * the given existing bean definition.  * <p>The default implementation considers them as compatible when the existing  * bean definition comes from the same source or from a non-scanning source.  * @param newDefinition the new bean definition, originated from scanning  * @param existingDefinition the existing bean definition, potentially an  * explicitly defined one or a previously generated one from scanning  * @return whether the definitions are considered as compatible, with the  * new definition to be skipped in favor of the existing definition  */ ;/**  * Determine whether the given new bean definition is compatible with  * the given existing bean definition.  * <p>The default implementation considers them as compatible when the existing  * bean definition comes from the same source or from a non-scanning source.  * @param newDefinition the new bean definition, originated from scanning  * @param existingDefinition the existing bean definition, potentially an  * explicitly defined one or a previously generated one from scanning  * @return whether the definitions are considered as compatible, with the  * new definition to be skipped in favor of the existing definition  */ protected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) {     return (// explicitly registered overriding bean     !(existingDefinition instanceof ScannedGenericBeanDefinition) || // scanned same file twice     (newDefinition.getSource() != null && newDefinition.getSource().equals(existingDefinition.getSource())) || // scanned equivalent class twice     newDefinition.equals(existingDefinition)). }
true;private,static;1;7;/**  * Get the Environment from the given registry if possible, otherwise return a new  * StandardEnvironment.  */ ;/**  * Get the Environment from the given registry if possible, otherwise return a new  * StandardEnvironment.  */ private static Environment getOrCreateEnvironment(BeanDefinitionRegistry registry) {     Assert.notNull(registry, "BeanDefinitionRegistry must not be null").     if (registry instanceof EnvironmentCapable) {         return ((EnvironmentCapable) registry).getEnvironment().     }     return new StandardEnvironment(). }
