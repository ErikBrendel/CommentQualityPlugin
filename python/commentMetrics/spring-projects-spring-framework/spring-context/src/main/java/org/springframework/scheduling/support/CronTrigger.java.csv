commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the cron pattern that this trigger has been built with.  */ ;/**  * Return the cron pattern that this trigger has been built with.  */ public String getExpression() {     return this.sequenceGenerator.getExpression(). }
true;public;1;17;/**  * Determine the next execution time according to the given trigger context.  * <p>Next execution times are calculated based on the  * {@linkplain TriggerContext#lastCompletionTime completion time} of the  * previous execution. therefore, overlapping executions won't occur.  */ ;/**  * Determine the next execution time according to the given trigger context.  * <p>Next execution times are calculated based on the  * {@linkplain TriggerContext#lastCompletionTime completion time} of the  * previous execution. therefore, overlapping executions won't occur.  */ @Override public Date nextExecutionTime(TriggerContext triggerContext) {     Date date = triggerContext.lastCompletionTime().     if (date != null) {         Date scheduled = triggerContext.lastScheduledExecutionTime().         if (scheduled != null && date.before(scheduled)) {             // Previous task apparently executed too early...             // Let's simply use the last calculated execution time then,             // in order to prevent accidental re-fires in the same second.             date = scheduled.         }     } else {         date = new Date().     }     return this.sequenceGenerator.next(date). }
false;public;1;5;;@Override public boolean equals(Object other) {     return (this == other || (other instanceof CronTrigger && this.sequenceGenerator.equals(((CronTrigger) other).sequenceGenerator))). }
false;public;0;4;;@Override public int hashCode() {     return this.sequenceGenerator.hashCode(). }
false;public;0;4;;@Override public String toString() {     return this.sequenceGenerator.toString(). }
