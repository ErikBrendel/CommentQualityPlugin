commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * Read {@code configurationModel}, registering bean definitions  * with the registry based on its contents.  */ ;/**  * Read {@code configurationModel}, registering bean definitions  * with the registry based on its contents.  */ public void loadBeanDefinitions(Set<ConfigurationClass> configurationModel) {     TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator().     for (ConfigurationClass configClass : configurationModel) {         loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator).     } }
true;private;2;22;/**  * Read a particular {@link ConfigurationClass}, registering bean definitions  * for the class itself and all of its {@link Bean} methods.  */ ;/**  * Read a particular {@link ConfigurationClass}, registering bean definitions  * for the class itself and all of its {@link Bean} methods.  */ private void loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {     if (trackedConditionEvaluator.shouldSkip(configClass)) {         String beanName = configClass.getBeanName().         if (StringUtils.hasLength(beanName) && this.registry.containsBeanDefinition(beanName)) {             this.registry.removeBeanDefinition(beanName).         }         this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName()).         return.     }     if (configClass.isImported()) {         registerBeanDefinitionForImportedConfigurationClass(configClass).     }     for (BeanMethod beanMethod : configClass.getBeanMethods()) {         loadBeanDefinitionsForBeanMethod(beanMethod).     }     loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()).     loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()). }
true;private;1;18;/**  * Register the {@link Configuration} class itself as a bean definition.  */ ;/**  * Register the {@link Configuration} class itself as a bean definition.  */ private void registerBeanDefinitionForImportedConfigurationClass(ConfigurationClass configClass) {     AnnotationMetadata metadata = configClass.getMetadata().     AnnotatedGenericBeanDefinition configBeanDef = new AnnotatedGenericBeanDefinition(metadata).     ScopeMetadata scopeMetadata = scopeMetadataResolver.resolveScopeMetadata(configBeanDef).     configBeanDef.setScope(scopeMetadata.getScopeName()).     String configBeanName = this.importBeanNameGenerator.generateBeanName(configBeanDef, this.registry).     AnnotationConfigUtils.processCommonDefinitionAnnotations(configBeanDef, metadata).     BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(configBeanDef, configBeanName).     definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry).     this.registry.registerBeanDefinition(definitionHolder.getBeanName(), definitionHolder.getBeanDefinition()).     configClass.setBeanName(configBeanName).     if (logger.isTraceEnabled()) {         logger.trace("Registered bean definition for imported class '" + configBeanName + "'").     } }
true;private;1;102;/**  * Read the given {@link BeanMethod}, registering bean definitions  * with the BeanDefinitionRegistry based on its contents.  */ ;/**  * Read the given {@link BeanMethod}, registering bean definitions  * with the BeanDefinitionRegistry based on its contents.  */ // for RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE @SuppressWarnings("deprecation") private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {     ConfigurationClass configClass = beanMethod.getConfigurationClass().     MethodMetadata metadata = beanMethod.getMetadata().     String methodName = metadata.getMethodName().     // Do we need to mark the bean as skipped by its condition?     if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {         configClass.skippedBeanMethods.add(methodName).         return.     }     if (configClass.skippedBeanMethods.contains(methodName)) {         return.     }     AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class).     Assert.state(bean != null, "No @Bean annotation attributes").     // Consider name and any aliases     List<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray("name"))).     String beanName = (!names.isEmpty() ? names.remove(0) : methodName).     // Register aliases even when overridden     for (String alias : names) {         this.registry.registerAlias(beanName, alias).     }     // Has this effectively been overridden before (e.g. via XML)?     if (isOverriddenByExistingDefinition(beanMethod, beanName)) {         if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {             throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(), beanName, "Bean name derived from @Bean method '" + beanMethod.getMetadata().getMethodName() + "' clashes with bean name for containing configuration class. please make those names unique!").         }         return.     }     ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata).     beanDef.setResource(configClass.getResource()).     beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource())).     if (metadata.isStatic()) {         // static @Bean method         beanDef.setBeanClassName(configClass.getMetadata().getClassName()).         beanDef.setFactoryMethodName(methodName).     } else {         // instance @Bean method         beanDef.setFactoryBeanName(configClass.getBeanName()).         beanDef.setUniqueFactoryMethodName(methodName).     }     beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR).     beanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE).     AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata).     Autowire autowire = bean.getEnum("autowire").     if (autowire.isAutowire()) {         beanDef.setAutowireMode(autowire.value()).     }     boolean autowireCandidate = bean.getBoolean("autowireCandidate").     if (!autowireCandidate) {         beanDef.setAutowireCandidate(false).     }     String initMethodName = bean.getString("initMethod").     if (StringUtils.hasText(initMethodName)) {         beanDef.setInitMethodName(initMethodName).     }     String destroyMethodName = bean.getString("destroyMethod").     beanDef.setDestroyMethodName(destroyMethodName).     // Consider scoping     ScopedProxyMode proxyMode = ScopedProxyMode.NO.     AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class).     if (attributes != null) {         beanDef.setScope(attributes.getString("value")).         proxyMode = attributes.getEnum("proxyMode").         if (proxyMode == ScopedProxyMode.DEFAULT) {             proxyMode = ScopedProxyMode.NO.         }     }     // Replace the original bean definition with the target one, if necessary     BeanDefinition beanDefToRegister = beanDef.     if (proxyMode != ScopedProxyMode.NO) {         BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(new BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS).         beanDefToRegister = new ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata).     }     if (logger.isTraceEnabled()) {         logger.trace(String.format("Registering bean definition for @Bean method %s.%s()", configClass.getMetadata().getClassName(), beanName)).     }     this.registry.registerBeanDefinition(beanName, beanDefToRegister). }
false;protected;2;42;;protected boolean isOverriddenByExistingDefinition(BeanMethod beanMethod, String beanName) {     if (!this.registry.containsBeanDefinition(beanName)) {         return false.     }     BeanDefinition existingBeanDef = this.registry.getBeanDefinition(beanName).     // preserve the existing bean definition.     if (existingBeanDef instanceof ConfigurationClassBeanDefinition) {         ConfigurationClassBeanDefinition ccbd = (ConfigurationClassBeanDefinition) existingBeanDef.         return ccbd.getMetadata().getClassName().equals(beanMethod.getConfigurationClass().getMetadata().getClassName()).     }     // by an @Bean method, as of 4.2...     if (existingBeanDef instanceof ScannedGenericBeanDefinition) {         return false.     }     // -> allow the current bean method to override it, since it is application-level     if (existingBeanDef.getRole() > BeanDefinition.ROLE_APPLICATION) {         return false.     }     // before configuration class processing kicks in...     if (this.registry instanceof DefaultListableBeanFactory && !((DefaultListableBeanFactory) this.registry).isAllowBeanDefinitionOverriding()) {         throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(), beanName, "@Bean definition illegally overridden by existing bean definition: " + existingBeanDef).     }     if (logger.isDebugEnabled()) {         logger.debug(String.format("Skipping bean definition for %s: a definition for bean '%s' " + "already exists. This top-level bean definition is considered as an override.", beanMethod, beanName)).     }     return true. }
false;private;1;41;;private void loadBeanDefinitionsFromImportedResources(Map<String, Class<? extends BeanDefinitionReader>> importedResources) {     Map<Class<?>, BeanDefinitionReader> readerInstanceCache = new HashMap<>().     importedResources.forEach((resource, readerClass) -> {         // Default reader selection necessary?         if (BeanDefinitionReader.class == readerClass) {             if (StringUtils.endsWithIgnoreCase(resource, ".groovy")) {                 // When clearly asking for Groovy, that's what they'll get...                 readerClass = GroovyBeanDefinitionReader.class.             } else {                 // Primarily ".xml" files but for any other extension as well                 readerClass = XmlBeanDefinitionReader.class.             }         }         BeanDefinitionReader reader = readerInstanceCache.get(readerClass).         if (reader == null) {             try {                 // Instantiate the specified BeanDefinitionReader                 reader = readerClass.getConstructor(BeanDefinitionRegistry.class).newInstance(this.registry).                 // Delegate the current ResourceLoader to it if possible                 if (reader instanceof AbstractBeanDefinitionReader) {                     AbstractBeanDefinitionReader abdr = ((AbstractBeanDefinitionReader) reader).                     abdr.setResourceLoader(this.resourceLoader).                     abdr.setEnvironment(this.environment).                 }                 readerInstanceCache.put(readerClass, reader).             } catch (Throwable ex) {                 throw new IllegalStateException("Could not instantiate BeanDefinitionReader class [" + readerClass.getName() + "]").             }         }         // TODO SPR-6310: qualify relative path locations as done in AbstractContextLoader.modifyLocations         reader.loadBeanDefinitions(resource).     }). }
false;private;1;4;;private void loadBeanDefinitionsFromRegistrars(Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> registrars) {     registrars.forEach((registrar, metadata) -> registrar.registerBeanDefinitions(metadata, this.registry)). }
false;public;0;4;;@Override public AnnotationMetadata getMetadata() {     return this.annotationMetadata. }
false;public;0;4;;@Override public MethodMetadata getFactoryMethodMetadata() {     return this.factoryMethodMetadata. }
false;public;1;4;;@Override public boolean isFactoryMethod(Method candidate) {     return (super.isFactoryMethod(candidate) && BeanAnnotationHelper.isBeanAnnotated(candidate)). }
false;public;0;4;;@Override public ConfigurationClassBeanDefinition cloneBeanDefinition() {     return new ConfigurationClassBeanDefinition(this). }
false;public;1;23;;public boolean shouldSkip(ConfigurationClass configClass) {     Boolean skip = this.skipped.get(configClass).     if (skip == null) {         if (configClass.isImported()) {             boolean allSkipped = true.             for (ConfigurationClass importedBy : configClass.getImportedBy()) {                 if (!shouldSkip(importedBy)) {                     allSkipped = false.                     break.                 }             }             if (allSkipped) {                 // The config classes that imported this one were all skipped, therefore we are skipped...                 skip = true.             }         }         if (skip == null) {             skip = conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN).         }         this.skipped.put(configClass, skip).     }     return skip. }
