commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the delay between refresh checks, in milliseconds.  * Default is -1, indicating no refresh checks at all.  * <p>Note that an actual refresh will only happen when  * the {@link org.springframework.scripting.ScriptSource} indicates  * that it has been modified.  * @see org.springframework.scripting.ScriptSource#isModified()  */ ;/**  * Set the delay between refresh checks, in milliseconds.  * Default is -1, indicating no refresh checks at all.  * <p>Note that an actual refresh will only happen when  * the {@link org.springframework.scripting.ScriptSource} indicates  * that it has been modified.  * @see org.springframework.scripting.ScriptSource#isModified()  */ public void setDefaultRefreshCheckDelay(long defaultRefreshCheckDelay) {     this.defaultRefreshCheckDelay = defaultRefreshCheckDelay. }
true;public;1;3;/**  * Flag to signal that refreshable proxies should be created to proxy the target class not its interfaces.  * @param defaultProxyTargetClass the flag value to set  */ ;/**  * Flag to signal that refreshable proxies should be created to proxy the target class not its interfaces.  * @param defaultProxyTargetClass the flag value to set  */ public void setDefaultProxyTargetClass(boolean defaultProxyTargetClass) {     this.defaultProxyTargetClass = defaultProxyTargetClass. }
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.beanClassLoader = classLoader. }
false;public;1;19;;@Override public void setBeanFactory(BeanFactory beanFactory) {     if (!(beanFactory instanceof ConfigurableBeanFactory)) {         throw new IllegalStateException("ScriptFactoryPostProcessor doesn't work with " + "non-ConfigurableBeanFactory: " + beanFactory.getClass()).     }     this.beanFactory = (ConfigurableBeanFactory) beanFactory.     // Required so that references (up container hierarchies) are correctly resolved.     this.scriptBeanFactory.setParentBeanFactory(this.beanFactory).     // Required so that all BeanPostProcessors, Scopes, etc become available.     this.scriptBeanFactory.copyConfigurationFrom(this.beanFactory).     // Filter out BeanPostProcessors that are part of the AOP infrastructure,     // since those are only meant to apply to beans defined in the original factory.     this.scriptBeanFactory.getBeanPostProcessors().removeIf(beanPostProcessor -> beanPostProcessor instanceof AopInfrastructureBean). }
false;public;1;4;;@Override public void setResourceLoader(ResourceLoader resourceLoader) {     this.resourceLoader = resourceLoader. }
false;public;0;4;;@Override public int getOrder() {     return Integer.MIN_VALUE. }
false;public;2;50;;@Override @Nullable public Class<?> predictBeanType(Class<?> beanClass, String beanName) {     // We only apply special treatment to ScriptFactory implementations here.     if (!ScriptFactory.class.isAssignableFrom(beanClass)) {         return null.     }     Assert.state(this.beanFactory != null, "No BeanFactory set").     BeanDefinition bd = this.beanFactory.getMergedBeanDefinition(beanName).     try {         String scriptFactoryBeanName = SCRIPT_FACTORY_NAME_PREFIX + beanName.         String scriptedObjectBeanName = SCRIPTED_OBJECT_NAME_PREFIX + beanName.         prepareScriptBeans(bd, scriptFactoryBeanName, scriptedObjectBeanName).         ScriptFactory scriptFactory = this.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class).         ScriptSource scriptSource = getScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator()).         Class<?>[] interfaces = scriptFactory.getScriptInterfaces().         Class<?> scriptedType = scriptFactory.getScriptedObjectType(scriptSource).         if (scriptedType != null) {             return scriptedType.         } else if (!ObjectUtils.isEmpty(interfaces)) {             return (interfaces.length == 1 ? interfaces[0] : createCompositeInterface(interfaces)).         } else {             if (bd.isSingleton()) {                 return this.scriptBeanFactory.getBean(scriptedObjectBeanName).getClass().             }         }     } catch (Exception ex) {         if (ex instanceof BeanCreationException && ((BeanCreationException) ex).getMostSpecificCause() instanceof BeanCurrentlyInCreationException) {             if (logger.isTraceEnabled()) {                 logger.trace("Could not determine scripted object type for bean '" + beanName + "': " + ex.getMessage()).             }         } else {             if (logger.isDebugEnabled()) {                 logger.debug("Could not determine scripted object type for bean '" + beanName + "'", ex).             }         }     }     return null. }
false;public;3;4;;@Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {     return pvs. }
false;public;2;49;;@Override public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {     // We only apply special treatment to ScriptFactory implementations here.     if (!ScriptFactory.class.isAssignableFrom(beanClass)) {         return null.     }     Assert.state(this.beanFactory != null, "No BeanFactory set").     BeanDefinition bd = this.beanFactory.getMergedBeanDefinition(beanName).     String scriptFactoryBeanName = SCRIPT_FACTORY_NAME_PREFIX + beanName.     String scriptedObjectBeanName = SCRIPTED_OBJECT_NAME_PREFIX + beanName.     prepareScriptBeans(bd, scriptFactoryBeanName, scriptedObjectBeanName).     ScriptFactory scriptFactory = this.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class).     ScriptSource scriptSource = getScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator()).     boolean isFactoryBean = false.     try {         Class<?> scriptedObjectType = scriptFactory.getScriptedObjectType(scriptSource).         // Returned type may be null if the factory is unable to determine the type.         if (scriptedObjectType != null) {             isFactoryBean = FactoryBean.class.isAssignableFrom(scriptedObjectType).         }     } catch (Exception ex) {         throw new BeanCreationException(beanName, "Could not determine scripted object type for " + scriptFactory, ex).     }     long refreshCheckDelay = resolveRefreshCheckDelay(bd).     if (refreshCheckDelay >= 0) {         Class<?>[] interfaces = scriptFactory.getScriptInterfaces().         RefreshableScriptTargetSource ts = new RefreshableScriptTargetSource(this.scriptBeanFactory, scriptedObjectBeanName, scriptFactory, scriptSource, isFactoryBean).         boolean proxyTargetClass = resolveProxyTargetClass(bd).         String language = (String) bd.getAttribute(LANGUAGE_ATTRIBUTE).         if (proxyTargetClass && (language == null || !language.equals("groovy"))) {             throw new BeanDefinitionValidationException("Cannot use proxyTargetClass=true with script beans where language is not 'groovy': '" + language + "'").         }         ts.setRefreshCheckDelay(refreshCheckDelay).         return createRefreshableProxy(ts, interfaces, proxyTargetClass).     }     if (isFactoryBean) {         scriptedObjectBeanName = BeanFactory.FACTORY_BEAN_PREFIX + scriptedObjectBeanName.     }     return this.scriptBeanFactory.getBean(scriptedObjectBeanName). }
true;protected;3;30;/**  * Prepare the script beans in the internal BeanFactory that this  * post-processor uses. Each original bean definition will be split  * into a ScriptFactory definition and a scripted object definition.  * @param bd the original bean definition in the main BeanFactory  * @param scriptFactoryBeanName the name of the internal ScriptFactory bean  * @param scriptedObjectBeanName the name of the internal scripted object bean  */ ;/**  * Prepare the script beans in the internal BeanFactory that this  * post-processor uses. Each original bean definition will be split  * into a ScriptFactory definition and a scripted object definition.  * @param bd the original bean definition in the main BeanFactory  * @param scriptFactoryBeanName the name of the internal ScriptFactory bean  * @param scriptedObjectBeanName the name of the internal scripted object bean  */ protected void prepareScriptBeans(BeanDefinition bd, String scriptFactoryBeanName, String scriptedObjectBeanName) {     // Avoid recreation of the script bean definition in case of a prototype.     synchronized (this.scriptBeanFactory) {         if (!this.scriptBeanFactory.containsBeanDefinition(scriptedObjectBeanName)) {             this.scriptBeanFactory.registerBeanDefinition(scriptFactoryBeanName, createScriptFactoryBeanDefinition(bd)).             ScriptFactory scriptFactory = this.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class).             ScriptSource scriptSource = getScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator()).             Class<?>[] interfaces = scriptFactory.getScriptInterfaces().             Class<?>[] scriptedInterfaces = interfaces.             if (scriptFactory.requiresConfigInterface() && !bd.getPropertyValues().isEmpty()) {                 Class<?> configInterface = createConfigInterface(bd, interfaces).                 scriptedInterfaces = ObjectUtils.addObjectToArray(interfaces, configInterface).             }             BeanDefinition objectBd = createScriptedObjectBeanDefinition(bd, scriptFactoryBeanName, scriptSource, scriptedInterfaces).             long refreshCheckDelay = resolveRefreshCheckDelay(bd).             if (refreshCheckDelay >= 0) {                 objectBd.setScope(BeanDefinition.SCOPE_PROTOTYPE).             }             this.scriptBeanFactory.registerBeanDefinition(scriptedObjectBeanName, objectBd).         }     } }
true;protected;1;16;/**  * Get the refresh check delay for the given {@link ScriptFactory} {@link BeanDefinition}.  * If the {@link BeanDefinition} has a  * {@link org.springframework.core.AttributeAccessor metadata attribute}  * under the key {@link #REFRESH_CHECK_DELAY_ATTRIBUTE} which is a valid {@link Number}  * type, then this value is used. Otherwise, the {@link #defaultRefreshCheckDelay}  * value is used.  * @param beanDefinition the BeanDefinition to check  * @return the refresh check delay  */ ;/**  * Get the refresh check delay for the given {@link ScriptFactory} {@link BeanDefinition}.  * If the {@link BeanDefinition} has a  * {@link org.springframework.core.AttributeAccessor metadata attribute}  * under the key {@link #REFRESH_CHECK_DELAY_ATTRIBUTE} which is a valid {@link Number}  * type, then this value is used. Otherwise, the {@link #defaultRefreshCheckDelay}  * value is used.  * @param beanDefinition the BeanDefinition to check  * @return the refresh check delay  */ protected long resolveRefreshCheckDelay(BeanDefinition beanDefinition) {     long refreshCheckDelay = this.defaultRefreshCheckDelay.     Object attributeValue = beanDefinition.getAttribute(REFRESH_CHECK_DELAY_ATTRIBUTE).     if (attributeValue instanceof Number) {         refreshCheckDelay = ((Number) attributeValue).longValue().     } else if (attributeValue instanceof String) {         refreshCheckDelay = Long.parseLong((String) attributeValue).     } else if (attributeValue != null) {         throw new BeanDefinitionStoreException("Invalid refresh check delay attribute [" + REFRESH_CHECK_DELAY_ATTRIBUTE + "] with value '" + attributeValue + "': needs to be of type Number or String").     }     return refreshCheckDelay. }
false;protected;1;16;;protected boolean resolveProxyTargetClass(BeanDefinition beanDefinition) {     boolean proxyTargetClass = this.defaultProxyTargetClass.     Object attributeValue = beanDefinition.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE).     if (attributeValue instanceof Boolean) {         proxyTargetClass = (Boolean) attributeValue.     } else if (attributeValue instanceof String) {         proxyTargetClass = Boolean.valueOf((String) attributeValue).     } else if (attributeValue != null) {         throw new BeanDefinitionStoreException("Invalid proxy target class attribute [" + PROXY_TARGET_CLASS_ATTRIBUTE + "] with value '" + attributeValue + "': needs to be of type Boolean or String").     }     return proxyTargetClass. }
true;protected;1;6;/**  * Create a ScriptFactory bean definition based on the given script definition,  * extracting only the definition data that is relevant for the ScriptFactory  * (that is, only bean class and constructor arguments).  * @param bd the full script bean definition  * @return the extracted ScriptFactory bean definition  * @see org.springframework.scripting.ScriptFactory  */ ;/**  * Create a ScriptFactory bean definition based on the given script definition,  * extracting only the definition data that is relevant for the ScriptFactory  * (that is, only bean class and constructor arguments).  * @param bd the full script bean definition  * @return the extracted ScriptFactory bean definition  * @see org.springframework.scripting.ScriptFactory  */ protected BeanDefinition createScriptFactoryBeanDefinition(BeanDefinition bd) {     GenericBeanDefinition scriptBd = new GenericBeanDefinition().     scriptBd.setBeanClassName(bd.getBeanClassName()).     scriptBd.getConstructorArgumentValues().addArgumentValues(bd.getConstructorArgumentValues()).     return scriptBd. }
true;protected;2;10;/**  * Obtain a ScriptSource for the given bean, lazily creating it  * if not cached already.  * @param beanName the name of the scripted bean  * @param scriptSourceLocator the script source locator associated with the bean  * @return the corresponding ScriptSource instance  * @see #convertToScriptSource  */ ;/**  * Obtain a ScriptSource for the given bean, lazily creating it  * if not cached already.  * @param beanName the name of the scripted bean  * @param scriptSourceLocator the script source locator associated with the bean  * @return the corresponding ScriptSource instance  * @see #convertToScriptSource  */ protected ScriptSource getScriptSource(String beanName, String scriptSourceLocator) {     synchronized (this.scriptSourceCache) {         ScriptSource scriptSource = this.scriptSourceCache.get(beanName).         if (scriptSource == null) {             scriptSource = convertToScriptSource(beanName, scriptSourceLocator, this.resourceLoader).             this.scriptSourceCache.put(beanName, scriptSource).         }         return scriptSource.     } }
true;protected;3;10;/**  * Convert the given script source locator to a ScriptSource instance.  * <p>By default, supported locators are Spring resource locations  * (such as "file:C:/myScript.bsh" or "classpath:myPackage/myScript.bsh")  * and inline scripts ("inline:myScriptText...").  * @param beanName the name of the scripted bean  * @param scriptSourceLocator the script source locator  * @param resourceLoader the ResourceLoader to use (if necessary)  * @return the ScriptSource instance  */ ;/**  * Convert the given script source locator to a ScriptSource instance.  * <p>By default, supported locators are Spring resource locations  * (such as "file:C:/myScript.bsh" or "classpath:myPackage/myScript.bsh")  * and inline scripts ("inline:myScriptText...").  * @param beanName the name of the scripted bean  * @param scriptSourceLocator the script source locator  * @param resourceLoader the ResourceLoader to use (if necessary)  * @return the ScriptSource instance  */ protected ScriptSource convertToScriptSource(String beanName, String scriptSourceLocator, ResourceLoader resourceLoader) {     if (scriptSourceLocator.startsWith(INLINE_SCRIPT_PREFIX)) {         return new StaticScriptSource(scriptSourceLocator.substring(INLINE_SCRIPT_PREFIX.length()), beanName).     } else {         return new ResourceScriptSource(resourceLoader.getResource(scriptSourceLocator)).     } }
true;protected;2;20;/**  * Create a config interface for the given bean definition, defining setter  * methods for the defined property values as well as an init method and  * a destroy method (if defined).  * <p>This implementation creates the interface via CGLIB's InterfaceMaker,  * determining the property types from the given interfaces (as far as possible).  * @param bd the bean definition (property values etc) to create a  * config interface for  * @param interfaces the interfaces to check against (might define  * getters corresponding to the setters we're supposed to generate)  * @return the config interface  * @see org.springframework.cglib.proxy.InterfaceMaker  * @see org.springframework.beans.BeanUtils#findPropertyType  */ ;/**  * Create a config interface for the given bean definition, defining setter  * methods for the defined property values as well as an init method and  * a destroy method (if defined).  * <p>This implementation creates the interface via CGLIB's InterfaceMaker,  * determining the property types from the given interfaces (as far as possible).  * @param bd the bean definition (property values etc) to create a  * config interface for  * @param interfaces the interfaces to check against (might define  * getters corresponding to the setters we're supposed to generate)  * @return the config interface  * @see org.springframework.cglib.proxy.InterfaceMaker  * @see org.springframework.beans.BeanUtils#findPropertyType  */ protected Class<?> createConfigInterface(BeanDefinition bd, @Nullable Class<?>[] interfaces) {     InterfaceMaker maker = new InterfaceMaker().     PropertyValue[] pvs = bd.getPropertyValues().getPropertyValues().     for (PropertyValue pv : pvs) {         String propertyName = pv.getName().         Class<?> propertyType = BeanUtils.findPropertyType(propertyName, interfaces).         String setterName = "set" + StringUtils.capitalize(propertyName).         Signature signature = new Signature(setterName, Type.VOID_TYPE, new Type[] { Type.getType(propertyType) }).         maker.add(signature, new Type[0]).     }     if (bd.getInitMethodName() != null) {         Signature signature = new Signature(bd.getInitMethodName(), Type.VOID_TYPE, new Type[0]).         maker.add(signature, new Type[0]).     }     if (StringUtils.hasText(bd.getDestroyMethodName())) {         Signature signature = new Signature(bd.getDestroyMethodName(), Type.VOID_TYPE, new Type[0]).         maker.add(signature, new Type[0]).     }     return maker.create(). }
true;protected;1;3;/**  * Create a composite interface Class for the given interfaces,  * implementing the given interfaces in one single Class.  * <p>The default implementation builds a JDK proxy class  * for the given interfaces.  * @param interfaces the interfaces to merge  * @return the merged interface as Class  * @see java.lang.reflect.Proxy#getProxyClass  */ ;/**  * Create a composite interface Class for the given interfaces,  * implementing the given interfaces in one single Class.  * <p>The default implementation builds a JDK proxy class  * for the given interfaces.  * @param interfaces the interfaces to merge  * @return the merged interface as Class  * @see java.lang.reflect.Proxy#getProxyClass  */ protected Class<?> createCompositeInterface(Class<?>[] interfaces) {     return ClassUtils.createCompositeInterface(interfaces, this.beanClassLoader). }
true;protected;4;11;/**  * Create a bean definition for the scripted object, based on the given script  * definition, extracting the definition data that is relevant for the scripted  * object (that is, everything but bean class and constructor arguments).  * @param bd the full script bean definition  * @param scriptFactoryBeanName the name of the internal ScriptFactory bean  * @param scriptSource the ScriptSource for the scripted bean  * @param interfaces the interfaces that the scripted bean is supposed to implement  * @return the extracted ScriptFactory bean definition  * @see org.springframework.scripting.ScriptFactory#getScriptedObject  */ ;/**  * Create a bean definition for the scripted object, based on the given script  * definition, extracting the definition data that is relevant for the scripted  * object (that is, everything but bean class and constructor arguments).  * @param bd the full script bean definition  * @param scriptFactoryBeanName the name of the internal ScriptFactory bean  * @param scriptSource the ScriptSource for the scripted bean  * @param interfaces the interfaces that the scripted bean is supposed to implement  * @return the extracted ScriptFactory bean definition  * @see org.springframework.scripting.ScriptFactory#getScriptedObject  */ protected BeanDefinition createScriptedObjectBeanDefinition(BeanDefinition bd, String scriptFactoryBeanName, ScriptSource scriptSource, @Nullable Class<?>[] interfaces) {     GenericBeanDefinition objectBd = new GenericBeanDefinition(bd).     objectBd.setFactoryBeanName(scriptFactoryBeanName).     objectBd.setFactoryMethodName("getScriptedObject").     objectBd.getConstructorArgumentValues().clear().     objectBd.getConstructorArgumentValues().addIndexedArgumentValue(0, scriptSource).     objectBd.getConstructorArgumentValues().addIndexedArgumentValue(1, interfaces).     return objectBd. }
true;protected;3;26;/**  * Create a refreshable proxy for the given AOP TargetSource.  * @param ts the refreshable TargetSource  * @param interfaces the proxy interfaces (may be {@code null} to  * indicate proxying of all interfaces implemented by the target class)  * @return the generated proxy  * @see RefreshableScriptTargetSource  */ ;/**  * Create a refreshable proxy for the given AOP TargetSource.  * @param ts the refreshable TargetSource  * @param interfaces the proxy interfaces (may be {@code null} to  * indicate proxying of all interfaces implemented by the target class)  * @return the generated proxy  * @see RefreshableScriptTargetSource  */ protected Object createRefreshableProxy(TargetSource ts, @Nullable Class<?>[] interfaces, boolean proxyTargetClass) {     ProxyFactory proxyFactory = new ProxyFactory().     proxyFactory.setTargetSource(ts).     ClassLoader classLoader = this.beanClassLoader.     if (interfaces != null) {         proxyFactory.setInterfaces(interfaces).     } else {         Class<?> targetClass = ts.getTargetClass().         if (targetClass != null) {             proxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.beanClassLoader)).         }     }     if (proxyTargetClass) {         // force use of Class.getClassLoader()         classLoader = null.         proxyFactory.setProxyTargetClass(true).     }     DelegatingIntroductionInterceptor introduction = new DelegatingIntroductionInterceptor(ts).     introduction.suppressInterface(TargetSource.class).     proxyFactory.addAdvice(introduction).     return proxyFactory.getProxy(classLoader). }
true;public;0;4;/**  * Destroy the inner bean factory (used for scripts) on shutdown.  */ ;/**  * Destroy the inner bean factory (used for scripts) on shutdown.  */ @Override public void destroy() {     this.scriptBeanFactory.destroySingletons(). }
