commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the strategy to use for resolving errors into message codes.  * Default is DefaultMessageCodesResolver.  * @see DefaultMessageCodesResolver  */ ;/**  * Set the strategy to use for resolving errors into message codes.  * Default is DefaultMessageCodesResolver.  * @see DefaultMessageCodesResolver  */ public void setMessageCodesResolver(MessageCodesResolver messageCodesResolver) {     Assert.notNull(messageCodesResolver, "MessageCodesResolver must not be null").     this.messageCodesResolver = messageCodesResolver. }
true;public;0;3;/**  * Return the strategy to use for resolving errors into message codes.  */ ;/**  * Return the strategy to use for resolving errors into message codes.  */ public MessageCodesResolver getMessageCodesResolver() {     return this.messageCodesResolver. }
false;public;0;4;;// --------------------------------------------------------------------- // Implementation of the Errors interface // --------------------------------------------------------------------- @Override public String getObjectName() {     return this.objectName. }
false;public;3;4;;@Override public void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {     addError(new ObjectError(getObjectName(), resolveMessageCodes(errorCode), errorArgs, defaultMessage)). }
false;public;4;18;;@Override public void rejectValue(@Nullable String field, String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {     if ("".equals(getNestedPath()) && !StringUtils.hasLength(field)) {         // We're at the top of the nested object hierarchy,         // so the present level is not a field but rather the top object.         // The best we can do is register a global error here...         reject(errorCode, errorArgs, defaultMessage).         return.     }     String fixedField = fixedField(field).     Object newVal = getActualFieldValue(fixedField).     FieldError fe = new FieldError(getObjectName(), fixedField, newVal, false, resolveMessageCodes(errorCode, field), errorArgs, defaultMessage).     addError(fe). }
false;public;1;7;;@Override public void addAllErrors(Errors errors) {     if (!errors.getObjectName().equals(getObjectName())) {         throw new IllegalArgumentException("Errors object needs to have same object name").     }     this.errors.addAll(errors.getAllErrors()). }
false;public;0;4;;@Override public boolean hasErrors() {     return !this.errors.isEmpty(). }
false;public;0;4;;@Override public int getErrorCount() {     return this.errors.size(). }
false;public;0;4;;@Override public List<ObjectError> getAllErrors() {     return Collections.unmodifiableList(this.errors). }
false;public;0;10;;@Override public List<ObjectError> getGlobalErrors() {     List<ObjectError> result = new LinkedList<>().     for (ObjectError objectError : this.errors) {         if (!(objectError instanceof FieldError)) {             result.add(objectError).         }     }     return Collections.unmodifiableList(result). }
false;public;0;10;;@Override @Nullable public ObjectError getGlobalError() {     for (ObjectError objectError : this.errors) {         if (!(objectError instanceof FieldError)) {             return objectError.         }     }     return null. }
false;public;0;10;;@Override public List<FieldError> getFieldErrors() {     List<FieldError> result = new LinkedList<>().     for (ObjectError objectError : this.errors) {         if (objectError instanceof FieldError) {             result.add((FieldError) objectError).         }     }     return Collections.unmodifiableList(result). }
false;public;0;10;;@Override @Nullable public FieldError getFieldError() {     for (ObjectError objectError : this.errors) {         if (objectError instanceof FieldError) {             return (FieldError) objectError.         }     }     return null. }
false;public;1;11;;@Override public List<FieldError> getFieldErrors(String field) {     List<FieldError> result = new LinkedList<>().     String fixedField = fixedField(field).     for (ObjectError objectError : this.errors) {         if (objectError instanceof FieldError && isMatchingFieldError(fixedField, (FieldError) objectError)) {             result.add((FieldError) objectError).         }     }     return Collections.unmodifiableList(result). }
false;public;1;14;;@Override @Nullable public FieldError getFieldError(String field) {     String fixedField = fixedField(field).     for (ObjectError objectError : this.errors) {         if (objectError instanceof FieldError) {             FieldError fieldError = (FieldError) objectError.             if (isMatchingFieldError(fixedField, fieldError)) {                 return fieldError.             }         }     }     return null. }
false;public;1;18;;@Override @Nullable public Object getFieldValue(String field) {     FieldError fieldError = getFieldError(field).     // Use rejected value in case of error, current field value otherwise.     if (fieldError != null) {         Object value = fieldError.getRejectedValue().         // Do not apply formatting on binding failures like type mismatches.         return (fieldError.isBindingFailure() || getTarget() == null ? value : formatFieldValue(field, value)).     } else if (getTarget() != null) {         Object value = getActualFieldValue(fixedField(field)).         return formatFieldValue(field, value).     } else {         return this.fieldValues.get(field).     } }
true;public;1;11;/**  * This default implementation determines the type based on the actual  * field value, if any. Subclasses should override this to determine  * the type from a descriptor, even for {@code null} values.  * @see #getActualFieldValue  */ ;/**  * This default implementation determines the type based on the actual  * field value, if any. Subclasses should override this to determine  * the type from a descriptor, even for {@code null} values.  * @see #getActualFieldValue  */ @Override @Nullable public Class<?> getFieldType(@Nullable String field) {     if (getTarget() != null) {         Object value = getActualFieldValue(fixedField(field)).         if (value != null) {             return value.getClass().         }     }     return this.fieldTypes.get(field). }
true;public;0;9;/**  * Return a model Map for the obtained state, exposing an Errors  * instance as '{@link #MODEL_KEY_PREFIX MODEL_KEY_PREFIX} + objectName'  * and the object itself.  * <p>Note that the Map is constructed every time you're calling this method.  * Adding things to the map and then re-calling this method will not work.  * <p>The attributes in the model Map returned by this method are usually  * included in the ModelAndView for a form view that uses Spring's bind tag,  * which needs access to the Errors instance.  * @see #getObjectName  * @see #MODEL_KEY_PREFIX  */ ;// --------------------------------------------------------------------- // Implementation of BindingResult interface // --------------------------------------------------------------------- /**  * Return a model Map for the obtained state, exposing an Errors  * instance as '{@link #MODEL_KEY_PREFIX MODEL_KEY_PREFIX} + objectName'  * and the object itself.  * <p>Note that the Map is constructed every time you're calling this method.  * Adding things to the map and then re-calling this method will not work.  * <p>The attributes in the model Map returned by this method are usually  * included in the ModelAndView for a form view that uses Spring's bind tag,  * which needs access to the Errors instance.  * @see #getObjectName  * @see #MODEL_KEY_PREFIX  */ @Override public Map<String, Object> getModel() {     Map<String, Object> model = new LinkedHashMap<>(2).     // Mapping from name to target object.     model.put(getObjectName(), getTarget()).     // Errors instance, even if no errors.     model.put(MODEL_KEY_PREFIX + getObjectName(), this).     return model. }
false;public;1;5;;@Override @Nullable public Object getRawFieldValue(String field) {     return (getTarget() != null ? getActualFieldValue(fixedField(field)) : null). }
true;public;2;15;/**  * This implementation delegates to the  * {@link #getPropertyEditorRegistry() PropertyEditorRegistry}'s  * editor lookup facility, if available.  */ ;/**  * This implementation delegates to the  * {@link #getPropertyEditorRegistry() PropertyEditorRegistry}'s  * editor lookup facility, if available.  */ @Override @Nullable public PropertyEditor findEditor(@Nullable String field, @Nullable Class<?> valueType) {     PropertyEditorRegistry editorRegistry = getPropertyEditorRegistry().     if (editorRegistry != null) {         Class<?> valueTypeToUse = valueType.         if (valueTypeToUse == null) {             valueTypeToUse = getFieldType(field).         }         return editorRegistry.findCustomEditor(valueTypeToUse, fixedField(field)).     } else {         return null.     } }
true;public;0;5;/**  * This implementation returns {@code null}.  */ ;/**  * This implementation returns {@code null}.  */ @Override @Nullable public PropertyEditorRegistry getPropertyEditorRegistry() {     return null. }
false;public;1;4;;@Override public String[] resolveMessageCodes(String errorCode) {     return getMessageCodesResolver().resolveMessageCodes(errorCode, getObjectName()). }
false;public;2;5;;@Override public String[] resolveMessageCodes(String errorCode, @Nullable String field) {     return getMessageCodesResolver().resolveMessageCodes(errorCode, getObjectName(), fixedField(field), getFieldType(field)). }
false;public;1;4;;@Override public void addError(ObjectError error) {     this.errors.add(error). }
false;public;3;5;;@Override public void recordFieldValue(String field, Class<?> type, @Nullable Object value) {     this.fieldTypes.put(field, type).     this.fieldValues.put(field, value). }
true;public;1;4;/**  * Mark the specified disallowed field as suppressed.  * <p>The data binder invokes this for each field value that was  * detected to target a disallowed field.  * @see DataBinder#setAllowedFields  */ ;/**  * Mark the specified disallowed field as suppressed.  * <p>The data binder invokes this for each field value that was  * detected to target a disallowed field.  * @see DataBinder#setAllowedFields  */ @Override public void recordSuppressedField(String field) {     this.suppressedFields.add(field). }
true;public;0;4;/**  * Return the list of fields that were suppressed during the bind process.  * <p>Can be used to determine whether any field values were targeting  * disallowed fields.  * @see DataBinder#setAllowedFields  */ ;/**  * Return the list of fields that were suppressed during the bind process.  * <p>Can be used to determine whether any field values were targeting  * disallowed fields.  * @see DataBinder#setAllowedFields  */ @Override public String[] getSuppressedFields() {     return StringUtils.toStringArray(this.suppressedFields). }
false;public;1;13;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof BindingResult)) {         return false.     }     BindingResult otherResult = (BindingResult) other.     return (getObjectName().equals(otherResult.getObjectName()) && ObjectUtils.nullSafeEquals(getTarget(), otherResult.getTarget()) && getAllErrors().equals(otherResult.getAllErrors())). }
false;public;0;4;;@Override public int hashCode() {     return getObjectName().hashCode(). }
true;public,abstract;0;3;/**  * Return the wrapped target object.  */ ;// --------------------------------------------------------------------- // Template methods to be implemented/overridden by subclasses // --------------------------------------------------------------------- /**  * Return the wrapped target object.  */ @Override @Nullable public abstract Object getTarget().
true;protected,abstract;1;2;/**  * Extract the actual field value for the given field.  * @param field the field to check  * @return the current value of the field  */ ;/**  * Extract the actual field value for the given field.  * @param field the field to check  * @return the current value of the field  */ @Nullable protected abstract Object getActualFieldValue(String field).
true;protected;2;4;/**  * Format the given value for the specified field.  * <p>The default implementation simply returns the field value as-is.  * @param field the field to check  * @param value the value of the field (either a rejected value  * other than from a binding error, or an actual field value)  * @return the formatted value  */ ;/**  * Format the given value for the specified field.  * <p>The default implementation simply returns the field value as-is.  * @param field the field to check  * @param value the value of the field (either a rejected value  * other than from a binding error, or an actual field value)  * @return the formatted value  */ @Nullable protected Object formatFieldValue(String field, @Nullable Object value) {     return value. }
