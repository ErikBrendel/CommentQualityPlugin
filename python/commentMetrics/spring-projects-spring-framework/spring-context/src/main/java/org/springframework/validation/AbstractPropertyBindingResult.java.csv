commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;public void initConversion(ConversionService conversionService) {     Assert.notNull(conversionService, "ConversionService must not be null").     this.conversionService = conversionService.     if (getTarget() != null) {         getPropertyAccessor().setConversionService(conversionService).     } }
true;public;0;4;/**  * Returns the underlying PropertyAccessor.  * @see #getPropertyAccessor()  */ ;/**  * Returns the underlying PropertyAccessor.  * @see #getPropertyAccessor()  */ @Override public PropertyEditorRegistry getPropertyEditorRegistry() {     return (getTarget() != null ? getPropertyAccessor() : null). }
true;protected;1;4;/**  * Returns the canonical property name.  * @see org.springframework.beans.PropertyAccessorUtils#canonicalPropertyName  */ ;/**  * Returns the canonical property name.  * @see org.springframework.beans.PropertyAccessorUtils#canonicalPropertyName  */ @Override protected String canonicalFieldName(String field) {     return PropertyAccessorUtils.canonicalPropertyName(field). }
true;public;1;6;/**  * Determines the field type from the property type.  * @see #getPropertyAccessor()  */ ;/**  * Determines the field type from the property type.  * @see #getPropertyAccessor()  */ @Override @Nullable public Class<?> getFieldType(@Nullable String field) {     return (getTarget() != null ? getPropertyAccessor().getPropertyType(fixedField(field)) : super.getFieldType(field)). }
true;protected;1;5;/**  * Fetches the field value from the PropertyAccessor.  * @see #getPropertyAccessor()  */ ;/**  * Fetches the field value from the PropertyAccessor.  * @see #getPropertyAccessor()  */ @Override @Nullable protected Object getActualFieldValue(String field) {     return getPropertyAccessor().getPropertyValue(field). }
true;protected;2;24;/**  * Formats the field value based on registered PropertyEditors.  * @see #getCustomEditor  */ ;/**  * Formats the field value based on registered PropertyEditors.  * @see #getCustomEditor  */ @Override protected Object formatFieldValue(String field, @Nullable Object value) {     String fixedField = fixedField(field).     // Try custom editor...     PropertyEditor customEditor = getCustomEditor(fixedField).     if (customEditor != null) {         customEditor.setValue(value).         String textValue = customEditor.getAsText().         // text representation for this value: only use it if non-null.         if (textValue != null) {             return textValue.         }     }     if (this.conversionService != null) {         // Try custom converter...         TypeDescriptor fieldDesc = getPropertyAccessor().getPropertyTypeDescriptor(fixedField).         TypeDescriptor strDesc = TypeDescriptor.valueOf(String.class).         if (fieldDesc != null && this.conversionService.canConvert(fieldDesc, strDesc)) {             return this.conversionService.convert(value, fieldDesc, strDesc).         }     }     return value. }
true;protected;1;9;/**  * Retrieve the custom PropertyEditor for the given field, if any.  * @param fixedField the fully qualified field name  * @return the custom PropertyEditor, or {@code null}  */ ;/**  * Retrieve the custom PropertyEditor for the given field, if any.  * @param fixedField the fully qualified field name  * @return the custom PropertyEditor, or {@code null}  */ @Nullable protected PropertyEditor getCustomEditor(String fixedField) {     Class<?> targetType = getPropertyAccessor().getPropertyType(fixedField).     PropertyEditor editor = getPropertyAccessor().findCustomEditor(targetType, fixedField).     if (editor == null) {         editor = BeanUtils.findEditorByConvention(targetType).     }     return editor. }
true;public;2;25;/**  * This implementation exposes a PropertyEditor adapter for a Formatter,  * if applicable.  */ ;/**  * This implementation exposes a PropertyEditor adapter for a Formatter,  * if applicable.  */ @Override @Nullable public PropertyEditor findEditor(@Nullable String field, @Nullable Class<?> valueType) {     Class<?> valueTypeForLookup = valueType.     if (valueTypeForLookup == null) {         valueTypeForLookup = getFieldType(field).     }     PropertyEditor editor = super.findEditor(field, valueTypeForLookup).     if (editor == null && this.conversionService != null) {         TypeDescriptor td = null.         if (field != null && getTarget() != null) {             TypeDescriptor ptd = getPropertyAccessor().getPropertyTypeDescriptor(fixedField(field)).             if (ptd != null && (valueType == null || valueType.isAssignableFrom(ptd.getType()))) {                 td = ptd.             }         }         if (td == null) {             td = TypeDescriptor.valueOf(valueTypeForLookup).         }         if (this.conversionService.canConvert(TypeDescriptor.valueOf(String.class), td)) {             editor = new ConvertingPropertyEditorAdapter(this.conversionService, td).         }     }     return editor. }
true;public,abstract;0;1;/**  * Provide the PropertyAccessor to work with, according to the  * concrete strategy of access.  * <p>Note that a PropertyAccessor used by a BindingResult should  * always have its "extractOldValueForEditor" flag set to "true"  * by default, since this is typically possible without side effects  * for model objects that serve as data binding target.  * @see ConfigurablePropertyAccessor#setExtractOldValueForEditor  */ ;/**  * Provide the PropertyAccessor to work with, according to the  * concrete strategy of access.  * <p>Note that a PropertyAccessor used by a BindingResult should  * always have its "extractOldValueForEditor" flag set to "true"  * by default, since this is typically possible without side effects  * for model objects that serve as data binding target.  * @see ConfigurablePropertyAccessor#setExtractOldValueForEditor  */ public abstract ConfigurablePropertyAccessor getPropertyAccessor().
