commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set a custom executor (typically a {@link org.springframework.core.task.TaskExecutor})  * to invoke each listener with.  * <p>Default is equivalent to {@link org.springframework.core.task.SyncTaskExecutor},  * executing all listeners synchronously in the calling thread.  * <p>Consider specifying an asynchronous task executor here to not block the  * caller until all listeners have been executed. However, note that asynchronous  * execution will not participate in the caller's thread context (class loader,  * transaction association) unless the TaskExecutor explicitly supports this.  * @see org.springframework.core.task.SyncTaskExecutor  * @see org.springframework.core.task.SimpleAsyncTaskExecutor  */ ;/**  * Set a custom executor (typically a {@link org.springframework.core.task.TaskExecutor})  * to invoke each listener with.  * <p>Default is equivalent to {@link org.springframework.core.task.SyncTaskExecutor},  * executing all listeners synchronously in the calling thread.  * <p>Consider specifying an asynchronous task executor here to not block the  * caller until all listeners have been executed. However, note that asynchronous  * execution will not participate in the caller's thread context (class loader,  * transaction association) unless the TaskExecutor explicitly supports this.  * @see org.springframework.core.task.SyncTaskExecutor  * @see org.springframework.core.task.SimpleAsyncTaskExecutor  */ public void setTaskExecutor(@Nullable Executor taskExecutor) {     this.taskExecutor = taskExecutor. }
true;protected;0;4;/**  * Return the current task executor for this multicaster.  */ ;/**  * Return the current task executor for this multicaster.  */ @Nullable protected Executor getTaskExecutor() {     return this.taskExecutor. }
true;public;1;3;/**  * Set the {@link ErrorHandler} to invoke in case an exception is thrown  * from a listener.  * <p>Default is none, with a listener exception stopping the current  * multicast and getting propagated to the publisher of the current event.  * If a {@linkplain #setTaskExecutor task executor} is specified, each  * individual listener exception will get propagated to the executor but  * won't necessarily stop execution of other listeners.  * <p>Consider setting an {@link ErrorHandler} implementation that catches  * and logs exceptions (a la  * {@link org.springframework.scheduling.support.TaskUtils#LOG_AND_SUPPRESS_ERROR_HANDLER})  * or an implementation that logs exceptions while nevertheless propagating them  * (e.g. {@link org.springframework.scheduling.support.TaskUtils#LOG_AND_PROPAGATE_ERROR_HANDLER}).  * @since 4.1  */ ;/**  * Set the {@link ErrorHandler} to invoke in case an exception is thrown  * from a listener.  * <p>Default is none, with a listener exception stopping the current  * multicast and getting propagated to the publisher of the current event.  * If a {@linkplain #setTaskExecutor task executor} is specified, each  * individual listener exception will get propagated to the executor but  * won't necessarily stop execution of other listeners.  * <p>Consider setting an {@link ErrorHandler} implementation that catches  * and logs exceptions (a la  * {@link org.springframework.scheduling.support.TaskUtils#LOG_AND_SUPPRESS_ERROR_HANDLER})  * or an implementation that logs exceptions while nevertheless propagating them  * (e.g. {@link org.springframework.scheduling.support.TaskUtils#LOG_AND_PROPAGATE_ERROR_HANDLER}).  * @since 4.1  */ public void setErrorHandler(@Nullable ErrorHandler errorHandler) {     this.errorHandler = errorHandler. }
true;protected;0;4;/**  * Return the current error handler for this multicaster.  * @since 4.1  */ ;/**  * Return the current error handler for this multicaster.  * @since 4.1  */ @Nullable protected ErrorHandler getErrorHandler() {     return this.errorHandler. }
false;public;1;4;;@Override public void multicastEvent(ApplicationEvent event) {     multicastEvent(event, resolveDefaultEventType(event)). }
false;public;2;13;;@Override public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {     ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)).     Executor executor = getTaskExecutor().     for (ApplicationListener<?> listener : getApplicationListeners(event, type)) {         if (executor != null) {             executor.execute(() -> invokeListener(listener, event)).         } else {             invokeListener(listener, event).         }     } }
false;private;1;3;;private ResolvableType resolveDefaultEventType(ApplicationEvent event) {     return ResolvableType.forInstance(event). }
true;protected;2;14;/**  * Invoke the given listener with the given event.  * @param listener the ApplicationListener to invoke  * @param event the current event to propagate  * @since 4.1  */ ;/**  * Invoke the given listener with the given event.  * @param listener the ApplicationListener to invoke  * @param event the current event to propagate  * @since 4.1  */ protected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) {     ErrorHandler errorHandler = getErrorHandler().     if (errorHandler != null) {         try {             doInvokeListener(listener, event).         } catch (Throwable err) {             errorHandler.handleError(err).         }     } else {         doInvokeListener(listener, event).     } }
false;private;2;20;;@SuppressWarnings({ "unchecked", "rawtypes" }) private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {     try {         listener.onApplicationEvent(event).     } catch (ClassCastException ex) {         String msg = ex.getMessage().         if (msg == null || matchesClassCastMessage(msg, event.getClass())) {             // Possibly a lambda-defined listener which we could not resolve the generic event type for             // -> let's suppress the exception and just log a debug message.             Log logger = LogFactory.getLog(getClass()).             if (logger.isDebugEnabled()) {                 logger.debug("Non-matching event type for listener: " + listener, ex).             }         } else {             throw ex.         }     } }
false;private;2;17;;private boolean matchesClassCastMessage(String classCastMessage, Class<?> eventClass) {     // On Java 8, the message starts with the class name: "java.lang.String cannot be cast..."     if (classCastMessage.startsWith(eventClass.getName())) {         return true.     }     // On Java 11, the message starts with "class ..." a.k.a. Class.toString()     if (classCastMessage.startsWith(eventClass.toString())) {         return true.     }     // On Java 9, the message used to contain the module name: "java.base/java.lang.String cannot be cast..."     int moduleSeparatorIndex = classCastMessage.indexOf('/').     if (moduleSeparatorIndex != -1 && classCastMessage.startsWith(eventClass.getName(), moduleSeparatorIndex + 1)) {         return true.     }     // Assuming an unrelated class cast failure...     return false. }
