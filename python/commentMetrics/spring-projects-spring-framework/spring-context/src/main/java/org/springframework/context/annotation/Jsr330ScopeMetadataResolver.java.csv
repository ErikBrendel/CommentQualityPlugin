commented;modifiers;parameterAmount;loc;comment;code
true;public,final;2;3;/**  * Register an extended JSR-330 scope annotation, mapping it onto a  * specific Spring scope by name.  * @param annotationType the JSR-330 annotation type as a Class  * @param scopeName the Spring scope name  */ ;/**  * Register an extended JSR-330 scope annotation, mapping it onto a  * specific Spring scope by name.  * @param annotationType the JSR-330 annotation type as a Class  * @param scopeName the Spring scope name  */ public final void registerScope(Class<?> annotationType, String scopeName) {     this.scopeMap.put(annotationType.getName(), scopeName). }
true;public,final;2;3;/**  * Register an extended JSR-330 scope annotation, mapping it onto a  * specific Spring scope by name.  * @param annotationType the JSR-330 annotation type by name  * @param scopeName the Spring scope name  */ ;/**  * Register an extended JSR-330 scope annotation, mapping it onto a  * specific Spring scope by name.  * @param annotationType the JSR-330 annotation type by name  * @param scopeName the Spring scope name  */ public final void registerScope(String annotationType, String scopeName) {     this.scopeMap.put(annotationType, scopeName). }
true;protected;1;4;/**  * Resolve the given annotation type into a named Spring scope.  * <p>The default implementation simply checks against registered scopes.  * Can be overridden for custom mapping rules, e.g. naming conventions.  * @param annotationType the JSR-330 annotation type  * @return the Spring scope name  */ ;/**  * Resolve the given annotation type into a named Spring scope.  * <p>The default implementation simply checks against registered scopes.  * Can be overridden for custom mapping rules, e.g. naming conventions.  * @param annotationType the JSR-330 annotation type  * @return the Spring scope name  */ @Nullable protected String resolveScopeName(String annotationType) {     return this.scopeMap.get(annotationType). }
false;public;1;27;;@Override public ScopeMetadata resolveScopeMetadata(BeanDefinition definition) {     ScopeMetadata metadata = new ScopeMetadata().     metadata.setScopeName(BeanDefinition.SCOPE_PROTOTYPE).     if (definition instanceof AnnotatedBeanDefinition) {         AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition.         Set<String> annTypes = annDef.getMetadata().getAnnotationTypes().         String found = null.         for (String annType : annTypes) {             Set<String> metaAnns = annDef.getMetadata().getMetaAnnotationTypes(annType).             if (metaAnns.contains("javax.inject.Scope")) {                 if (found != null) {                     throw new IllegalStateException("Found ambiguous scope annotations on bean class [" + definition.getBeanClassName() + "]: " + found + ", " + annType).                 }                 found = annType.                 String scopeName = resolveScopeName(annType).                 if (scopeName == null) {                     throw new IllegalStateException("Unsupported scope annotation - not mapped onto Spring scope name: " + annType).                 }                 metadata.setScopeName(scopeName).             }         }     }     return metadata. }
