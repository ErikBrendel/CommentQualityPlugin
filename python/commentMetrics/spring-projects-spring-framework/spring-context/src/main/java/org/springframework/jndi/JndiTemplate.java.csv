commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the environment for the JNDI InitialContext.  */ ;/**  * Set the environment for the JNDI InitialContext.  */ public void setEnvironment(@Nullable Properties environment) {     this.environment = environment. }
true;public;0;4;/**  * Return the environment for the JNDI InitialContext, if any.  */ ;/**  * Return the environment for the JNDI InitialContext, if any.  */ @Nullable public Properties getEnvironment() {     return this.environment. }
true;public;1;10;/**  * Execute the given JNDI context callback implementation.  * @param contextCallback the JndiCallback implementation to use  * @return a result object returned by the callback, or {@code null}  * @throws NamingException thrown by the callback implementation  * @see #createInitialContext  */ ;/**  * Execute the given JNDI context callback implementation.  * @param contextCallback the JndiCallback implementation to use  * @return a result object returned by the callback, or {@code null}  * @throws NamingException thrown by the callback implementation  * @see #createInitialContext  */ @Nullable public <T> T execute(JndiCallback<T> contextCallback) throws NamingException {     Context ctx = getContext().     try {         return contextCallback.doInContext(ctx).     } finally {         releaseContext(ctx).     } }
true;public;0;3;/**  * Obtain a JNDI context corresponding to this template's configuration.  * Called by {@link #execute}. may also be called directly.  * <p>The default implementation delegates to {@link #createInitialContext()}.  * @return the JNDI context (never {@code null})  * @throws NamingException if context retrieval failed  * @see #releaseContext  */ ;/**  * Obtain a JNDI context corresponding to this template's configuration.  * Called by {@link #execute}. may also be called directly.  * <p>The default implementation delegates to {@link #createInitialContext()}.  * @return the JNDI context (never {@code null})  * @throws NamingException if context retrieval failed  * @see #releaseContext  */ public Context getContext() throws NamingException {     return createInitialContext(). }
true;public;1;10;/**  * Release a JNDI context as obtained from {@link #getContext()}.  * @param ctx the JNDI context to release (may be {@code null})  * @see #getContext  */ ;/**  * Release a JNDI context as obtained from {@link #getContext()}.  * @param ctx the JNDI context to release (may be {@code null})  * @see #getContext  */ public void releaseContext(@Nullable Context ctx) {     if (ctx != null) {         try {             ctx.close().         } catch (NamingException ex) {             logger.debug("Could not close JNDI InitialContext", ex).         }     } }
true;protected;0;9;/**  * Create a new JNDI initial context. Invoked by {@link #getContext}.  * <p>The default implementation use this template's environment settings.  * Can be subclassed for custom contexts, e.g. for testing.  * @return the initial Context instance  * @throws NamingException in case of initialization errors  */ ;/**  * Create a new JNDI initial context. Invoked by {@link #getContext}.  * <p>The default implementation use this template's environment settings.  * Can be subclassed for custom contexts, e.g. for testing.  * @return the initial Context instance  * @throws NamingException in case of initialization errors  */ protected Context createInitialContext() throws NamingException {     Hashtable<?, ?> icEnv = null.     Properties env = getEnvironment().     if (env != null) {         icEnv = new Hashtable<>(env.size()).         CollectionUtils.mergePropertiesIntoMap(env, icEnv).     }     return new InitialContext(icEnv). }
true;public;1;11;/**  * Look up the object with the given name in the current JNDI context.  * @param name the JNDI name of the object  * @return object found (cannot be {@code null}. if a not so well-behaved  * JNDI implementations returns null, a NamingException gets thrown)  * @throws NamingException if there is no object with the given  * name bound to JNDI  */ ;/**  * Look up the object with the given name in the current JNDI context.  * @param name the JNDI name of the object  * @return object found (cannot be {@code null}. if a not so well-behaved  * JNDI implementations returns null, a NamingException gets thrown)  * @throws NamingException if there is no object with the given  * name bound to JNDI  */ public Object lookup(final String name) throws NamingException {     if (logger.isDebugEnabled()) {         logger.debug("Looking up JNDI object with name [" + name + "]").     }     Object result = execute(ctx -> ctx.lookup(name)).     if (result == null) {         throw new NameNotFoundException("JNDI object with [" + name + "] not found: JNDI implementation returned null").     }     return result. }
true;public;2;8;/**  * Look up the object with the given name in the current JNDI context.  * @param name the JNDI name of the object  * @param requiredType type the JNDI object must match. Can be an interface or  * superclass of the actual class, or {@code null} for any match. For example,  * if the value is {@code Object.class}, this method will succeed whatever  * the class of the returned instance.  * @return object found (cannot be {@code null}. if a not so well-behaved  * JNDI implementations returns null, a NamingException gets thrown)  * @throws NamingException if there is no object with the given  * name bound to JNDI  */ ;/**  * Look up the object with the given name in the current JNDI context.  * @param name the JNDI name of the object  * @param requiredType type the JNDI object must match. Can be an interface or  * superclass of the actual class, or {@code null} for any match. For example,  * if the value is {@code Object.class}, this method will succeed whatever  * the class of the returned instance.  * @return object found (cannot be {@code null}. if a not so well-behaved  * JNDI implementations returns null, a NamingException gets thrown)  * @throws NamingException if there is no object with the given  * name bound to JNDI  */ @SuppressWarnings("unchecked") public <T> T lookup(String name, @Nullable Class<T> requiredType) throws NamingException {     Object jndiObject = lookup(name).     if (requiredType != null && !requiredType.isInstance(jndiObject)) {         throw new TypeMismatchNamingException(name, requiredType, jndiObject.getClass()).     }     return (T) jndiObject. }
true;public;2;9;/**  * Bind the given object to the current JNDI context, using the given name.  * @param name the JNDI name of the object  * @param object the object to bind  * @throws NamingException thrown by JNDI, mostly name already bound  */ ;/**  * Bind the given object to the current JNDI context, using the given name.  * @param name the JNDI name of the object  * @param object the object to bind  * @throws NamingException thrown by JNDI, mostly name already bound  */ public void bind(final String name, final Object object) throws NamingException {     if (logger.isDebugEnabled()) {         logger.debug("Binding JNDI object with name [" + name + "]").     }     execute(ctx -> {         ctx.bind(name, object).         return null.     }). }
true;public;2;9;/**  * Rebind the given object to the current JNDI context, using the given name.  * Overwrites any existing binding.  * @param name the JNDI name of the object  * @param object the object to rebind  * @throws NamingException thrown by JNDI  */ ;/**  * Rebind the given object to the current JNDI context, using the given name.  * Overwrites any existing binding.  * @param name the JNDI name of the object  * @param object the object to rebind  * @throws NamingException thrown by JNDI  */ public void rebind(final String name, final Object object) throws NamingException {     if (logger.isDebugEnabled()) {         logger.debug("Rebinding JNDI object with name [" + name + "]").     }     execute(ctx -> {         ctx.rebind(name, object).         return null.     }). }
true;public;1;9;/**  * Remove the binding for the given name from the current JNDI context.  * @param name the JNDI name of the object  * @throws NamingException thrown by JNDI, mostly name not found  */ ;/**  * Remove the binding for the given name from the current JNDI context.  * @param name the JNDI name of the object  * @throws NamingException thrown by JNDI, mostly name not found  */ public void unbind(final String name) throws NamingException {     if (logger.isDebugEnabled()) {         logger.debug("Unbinding JNDI object with name [" + name + "]").     }     execute(ctx -> {         ctx.unbind(name).         return null.     }). }
