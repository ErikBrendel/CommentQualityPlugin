commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set a name/attribute map, consisting of method names  * (e.g. "myMethod") and CacheOperation instances  * (or Strings to be converted to CacheOperation instances).  * @see CacheOperation  */ ;/**  * Set a name/attribute map, consisting of method names  * (e.g. "myMethod") and CacheOperation instances  * (or Strings to be converted to CacheOperation instances).  * @see CacheOperation  */ public void setNameMap(Map<String, Collection<CacheOperation>> nameMap) {     nameMap.forEach(this::addCacheMethod). }
true;public;2;6;/**  * Add an attribute for a cacheable method.  * <p>Method names can be exact matches, or of the pattern "xxx*",  * "*xxx" or "*xxx*" for matching multiple methods.  * @param methodName the name of the method  * @param ops operation associated with the method  */ ;/**  * Add an attribute for a cacheable method.  * <p>Method names can be exact matches, or of the pattern "xxx*",  * "*xxx" or "*xxx*" for matching multiple methods.  * @param methodName the name of the method  * @param ops operation associated with the method  */ public void addCacheMethod(String methodName, Collection<CacheOperation> ops) {     if (logger.isDebugEnabled()) {         logger.debug("Adding method [" + methodName + "] with cache operations [" + ops + "]").     }     this.nameMap.put(methodName, ops). }
false;public;2;21;;@Override @Nullable public Collection<CacheOperation> getCacheOperations(Method method, @Nullable Class<?> targetClass) {     // look for direct name match     String methodName = method.getName().     Collection<CacheOperation> ops = this.nameMap.get(methodName).     if (ops == null) {         // Look for most specific name match.         String bestNameMatch = null.         for (String mappedName : this.nameMap.keySet()) {             if (isMatch(methodName, mappedName) && (bestNameMatch == null || bestNameMatch.length() <= mappedName.length())) {                 ops = this.nameMap.get(mappedName).                 bestNameMatch = mappedName.             }         }     }     return ops. }
true;protected;2;3;/**  * Return if the given method name matches the mapped name.  * <p>The default implementation checks for "xxx*", "*xxx" and "*xxx*" matches,  * as well as direct equality. Can be overridden in subclasses.  * @param methodName the method name of the class  * @param mappedName the name in the descriptor  * @return if the names match  * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)  */ ;/**  * Return if the given method name matches the mapped name.  * <p>The default implementation checks for "xxx*", "*xxx" and "*xxx*" matches,  * as well as direct equality. Can be overridden in subclasses.  * @param methodName the method name of the class  * @param mappedName the name in the descriptor  * @return if the names match  * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)  */ protected boolean isMatch(String methodName, String mappedName) {     return PatternMatchUtils.simpleMatch(mappedName, methodName). }
false;public;1;11;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof NameMatchCacheOperationSource)) {         return false.     }     NameMatchCacheOperationSource otherTas = (NameMatchCacheOperationSource) other.     return ObjectUtils.nullSafeEquals(this.nameMap, otherTas.nameMap). }
false;public;0;4;;@Override public int hashCode() {     return NameMatchCacheOperationSource.class.hashCode(). }
false;public;0;4;;@Override public String toString() {     return getClass().getName() + ": " + this.nameMap. }
