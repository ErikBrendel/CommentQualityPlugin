commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the name of the affected object.  */ ;/**  * Return the name of the affected object.  */ public String getObjectName() {     return this.objectName. }
true;public;1;6;/**  * Preserve the source behind this error: possibly an {@link Exception}  * (typically {@link org.springframework.beans.PropertyAccessException})  * or a Bean Validation {@link javax.validation.ConstraintViolation}.  * <p>Note that any such source object is being stored as transient:  * that is, it won't be part of a serialized error representation.  * @param source the source object  * @since 5.0.4  */ ;/**  * Preserve the source behind this error: possibly an {@link Exception}  * (typically {@link org.springframework.beans.PropertyAccessException})  * or a Bean Validation {@link javax.validation.ConstraintViolation}.  * <p>Note that any such source object is being stored as transient:  * that is, it won't be part of a serialized error representation.  * @param source the source object  * @since 5.0.4  */ public void wrap(Object source) {     if (this.source != null) {         throw new IllegalStateException("Already wrapping " + this.source).     }     this.source = source. }
true;public;1;12;/**  * Unwrap the source behind this error: possibly an {@link Exception}  * (typically {@link org.springframework.beans.PropertyAccessException})  * or a Bean Validation {@link javax.validation.ConstraintViolation}.  * <p>The cause of the outermost exception will be introspected as well,  * e.g. the underlying conversion exception or exception thrown from a setter  * (instead of having to unwrap the {@code PropertyAccessException} in turn).  * @return the source object of the given type  * @throws IllegalArgumentException if no such source object is available  * (i.e. none specified or not available anymore after deserialization)  * @since 5.0.4  */ ;/**  * Unwrap the source behind this error: possibly an {@link Exception}  * (typically {@link org.springframework.beans.PropertyAccessException})  * or a Bean Validation {@link javax.validation.ConstraintViolation}.  * <p>The cause of the outermost exception will be introspected as well,  * e.g. the underlying conversion exception or exception thrown from a setter  * (instead of having to unwrap the {@code PropertyAccessException} in turn).  * @return the source object of the given type  * @throws IllegalArgumentException if no such source object is available  * (i.e. none specified or not available anymore after deserialization)  * @since 5.0.4  */ public <T> T unwrap(Class<T> sourceType) {     if (sourceType.isInstance(this.source)) {         return sourceType.cast(this.source).     } else if (this.source instanceof Throwable) {         Throwable cause = ((Throwable) this.source).getCause().         if (sourceType.isInstance(cause)) {             return sourceType.cast(cause).         }     }     throw new IllegalArgumentException("No source object of the given type available: " + sourceType). }
true;public;1;4;/**  * Check the source behind this error: possibly an {@link Exception}  * (typically {@link org.springframework.beans.PropertyAccessException})  * or a Bean Validation {@link javax.validation.ConstraintViolation}.  * <p>The cause of the outermost exception will be introspected as well,  * e.g. the underlying conversion exception or exception thrown from a setter  * (instead of having to unwrap the {@code PropertyAccessException} in turn).  * @return whether this error has been caused by a source object of the given type  * @since 5.0.4  */ ;/**  * Check the source behind this error: possibly an {@link Exception}  * (typically {@link org.springframework.beans.PropertyAccessException})  * or a Bean Validation {@link javax.validation.ConstraintViolation}.  * <p>The cause of the outermost exception will be introspected as well,  * e.g. the underlying conversion exception or exception thrown from a setter  * (instead of having to unwrap the {@code PropertyAccessException} in turn).  * @return whether this error has been caused by a source object of the given type  * @since 5.0.4  */ public boolean contains(Class<?> sourceType) {     return (sourceType.isInstance(this.source) || (this.source instanceof Throwable && sourceType.isInstance(((Throwable) this.source).getCause()))). }
false;public;1;11;;@Override public boolean equals(@Nullable Object other) {     if (this == other) {         return true.     }     if (other == null || other.getClass() != getClass() || !super.equals(other)) {         return false.     }     ObjectError otherError = (ObjectError) other.     return getObjectName().equals(otherError.getObjectName()). }
false;public;0;4;;@Override public int hashCode() {     return super.hashCode() * 29 + getObjectName().hashCode(). }
false;public;0;4;;@Override public String toString() {     return "Error in object '" + this.objectName + "': " + resolvableToString(). }
