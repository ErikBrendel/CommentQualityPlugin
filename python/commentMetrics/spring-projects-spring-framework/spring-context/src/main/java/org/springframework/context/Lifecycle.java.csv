commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Start this component.  * <p>Should not throw an exception if the component is already running.  * <p>In the case of a container, this will propagate the start signal to all  * components that apply.  * @see SmartLifecycle#isAutoStartup()  */ ;/**  * Start this component.  * <p>Should not throw an exception if the component is already running.  * <p>In the case of a container, this will propagate the start signal to all  * components that apply.  * @see SmartLifecycle#isAutoStartup()  */ void start().
true;;0;1;/**  * Stop this component, typically in a synchronous fashion, such that the component is  * fully stopped upon return of this method. Consider implementing {@link SmartLifecycle}  * and its {@code stop(Runnable)} variant when asynchronous stop behavior is necessary.  * <p>Note that this stop notification is not guaranteed to come before destruction:  * On regular shutdown, {@code Lifecycle} beans will first receive a stop notification  * before the general destruction callbacks are being propagated. however, on hot  * refresh during a context's lifetime or on aborted refresh attempts, a given bean's  * destroy method will be called without any consideration of stop signals upfront.  * <p>Should not throw an exception if the component is not running (not started yet).  * <p>In the case of a container, this will propagate the stop signal to all components  * that apply.  * @see SmartLifecycle#stop(Runnable)  * @see org.springframework.beans.factory.DisposableBean#destroy()  */ ;/**  * Stop this component, typically in a synchronous fashion, such that the component is  * fully stopped upon return of this method. Consider implementing {@link SmartLifecycle}  * and its {@code stop(Runnable)} variant when asynchronous stop behavior is necessary.  * <p>Note that this stop notification is not guaranteed to come before destruction:  * On regular shutdown, {@code Lifecycle} beans will first receive a stop notification  * before the general destruction callbacks are being propagated. however, on hot  * refresh during a context's lifetime or on aborted refresh attempts, a given bean's  * destroy method will be called without any consideration of stop signals upfront.  * <p>Should not throw an exception if the component is not running (not started yet).  * <p>In the case of a container, this will propagate the stop signal to all components  * that apply.  * @see SmartLifecycle#stop(Runnable)  * @see org.springframework.beans.factory.DisposableBean#destroy()  */ void stop().
true;;0;1;/**  * Check whether this component is currently running.  * <p>In the case of a container, this will return {@code true} only if <i>all</i>  * components that apply are currently running.  * @return whether the component is currently running  */ ;/**  * Check whether this component is currently running.  * <p>In the case of a container, this will return {@code true} only if <i>all</i>  * components that apply are currently running.  * @return whether the component is currently running  */ boolean isRunning().
