commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;4;/**  * Specify the {@link java.util.concurrent.Executor} to delegate to.  * <p>Autodetects a JSR-236 {@link javax.enterprise.concurrent.ManagedExecutorService}  * in order to expose {@link javax.enterprise.concurrent.ManagedTask} adapters for it.  */ ;/**  * Specify the {@link java.util.concurrent.Executor} to delegate to.  * <p>Autodetects a JSR-236 {@link javax.enterprise.concurrent.ManagedExecutorService}  * in order to expose {@link javax.enterprise.concurrent.ManagedTask} adapters for it.  */ public final void setConcurrentExecutor(@Nullable Executor executor) {     this.concurrentExecutor = (executor != null ? executor : Executors.newSingleThreadExecutor()).     this.adaptedExecutor = getAdaptedExecutor(this.concurrentExecutor). }
true;public,final;0;3;/**  * Return the {@link java.util.concurrent.Executor} that this adapter delegates to.  */ ;/**  * Return the {@link java.util.concurrent.Executor} that this adapter delegates to.  */ public final Executor getConcurrentExecutor() {     return this.concurrentExecutor. }
true;public,final;1;3;/**  * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}  * about to be executed.  * <p>Note that such a decorator is not necessarily being applied to the  * user-supplied {@code Runnable}/{@code Callable} but rather to the actual  * execution callback (which may be a wrapper around the user-supplied task).  * <p>The primary use case is to set some execution context around the task's  * invocation, or to provide some monitoring/statistics for task execution.  * @since 4.3  */ ;/**  * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}  * about to be executed.  * <p>Note that such a decorator is not necessarily being applied to the  * user-supplied {@code Runnable}/{@code Callable} but rather to the actual  * execution callback (which may be a wrapper around the user-supplied task).  * <p>The primary use case is to set some execution context around the task's  * invocation, or to provide some monitoring/statistics for task execution.  * @since 4.3  */ public final void setTaskDecorator(TaskDecorator taskDecorator) {     this.adaptedExecutor.setTaskDecorator(taskDecorator). }
false;public;1;4;;@Override public void execute(Runnable task) {     this.adaptedExecutor.execute(task). }
false;public;2;4;;@Override public void execute(Runnable task, long startTimeout) {     this.adaptedExecutor.execute(task, startTimeout). }
false;public;1;4;;@Override public Future<?> submit(Runnable task) {     return this.adaptedExecutor.submit(task). }
false;public;1;4;;@Override public <T> Future<T> submit(Callable<T> task) {     return this.adaptedExecutor.submit(task). }
false;public;1;4;;@Override public ListenableFuture<?> submitListenable(Runnable task) {     return this.adaptedExecutor.submitListenable(task). }
false;public;1;4;;@Override public <T> ListenableFuture<T> submitListenable(Callable<T> task) {     return this.adaptedExecutor.submitListenable(task). }
false;private,static;1;6;;private static TaskExecutorAdapter getAdaptedExecutor(Executor concurrentExecutor) {     if (managedExecutorServiceClass != null && managedExecutorServiceClass.isInstance(concurrentExecutor)) {         return new ManagedTaskExecutorAdapter(concurrentExecutor).     }     return new TaskExecutorAdapter(concurrentExecutor). }
false;public;1;4;;@Override public void execute(Runnable task) {     super.execute(ManagedTaskBuilder.buildManagedTask(task, task.toString())). }
false;public;1;4;;@Override public Future<?> submit(Runnable task) {     return super.submit(ManagedTaskBuilder.buildManagedTask(task, task.toString())). }
false;public;1;4;;@Override public <T> Future<T> submit(Callable<T> task) {     return super.submit(ManagedTaskBuilder.buildManagedTask(task, task.toString())). }
false;public;1;4;;@Override public ListenableFuture<?> submitListenable(Runnable task) {     return super.submitListenable(ManagedTaskBuilder.buildManagedTask(task, task.toString())). }
false;public;1;4;;@Override public <T> ListenableFuture<T> submitListenable(Callable<T> task) {     return super.submitListenable(ManagedTaskBuilder.buildManagedTask(task, task.toString())). }
false;public,static;2;13;;public static Runnable buildManagedTask(Runnable task, String identityName) {     Map<String, String> properties.     if (task instanceof SchedulingAwareRunnable) {         properties = new HashMap<>(4).         properties.put(ManagedTask.LONGRUNNING_HINT, Boolean.toString(((SchedulingAwareRunnable) task).isLongLived())).     } else {         properties = new HashMap<>(2).     }     properties.put(ManagedTask.IDENTITY_NAME, identityName).     return ManagedExecutors.managedTask(task, properties, null). }
false;public,static;2;5;;public static <T> Callable<T> buildManagedTask(Callable<T> task, String identityName) {     Map<String, String> properties = new HashMap<>(2).     properties.put(ManagedTask.IDENTITY_NAME, identityName).     return ManagedExecutors.managedTask(task, properties, null). }
