commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the ScheduledExecutorService's pool size.  * Default is 1.  */ ;/**  * Set the ScheduledExecutorService's pool size.  * Default is 1.  */ public void setPoolSize(int poolSize) {     Assert.isTrue(poolSize > 0, "'poolSize' must be 1 or higher").     this.poolSize = poolSize. }
true;public;1;3;/**  * Register a list of ScheduledExecutorTask objects with the ScheduledExecutorService  * that this FactoryBean creates. Depending on each ScheduledExecutorTask's settings,  * it will be registered via one of ScheduledExecutorService's schedule methods.  * @see java.util.concurrent.ScheduledExecutorService#schedule(java.lang.Runnable, long, java.util.concurrent.TimeUnit)  * @see java.util.concurrent.ScheduledExecutorService#scheduleWithFixedDelay(java.lang.Runnable, long, long, java.util.concurrent.TimeUnit)  * @see java.util.concurrent.ScheduledExecutorService#scheduleAtFixedRate(java.lang.Runnable, long, long, java.util.concurrent.TimeUnit)  */ ;/**  * Register a list of ScheduledExecutorTask objects with the ScheduledExecutorService  * that this FactoryBean creates. Depending on each ScheduledExecutorTask's settings,  * it will be registered via one of ScheduledExecutorService's schedule methods.  * @see java.util.concurrent.ScheduledExecutorService#schedule(java.lang.Runnable, long, java.util.concurrent.TimeUnit)  * @see java.util.concurrent.ScheduledExecutorService#scheduleWithFixedDelay(java.lang.Runnable, long, long, java.util.concurrent.TimeUnit)  * @see java.util.concurrent.ScheduledExecutorService#scheduleAtFixedRate(java.lang.Runnable, long, long, java.util.concurrent.TimeUnit)  */ public void setScheduledExecutorTasks(ScheduledExecutorTask... scheduledExecutorTasks) {     this.scheduledExecutorTasks = scheduledExecutorTasks. }
true;public;1;3;/**  * Set the remove-on-cancel mode on {@link ScheduledThreadPoolExecutor}.  * <p>Default is {@code false}. If set to {@code true}, the target executor will be  * switched into remove-on-cancel mode (if possible, with a soft fallback otherwise).  */ ;/**  * Set the remove-on-cancel mode on {@link ScheduledThreadPoolExecutor}.  * <p>Default is {@code false}. If set to {@code true}, the target executor will be  * switched into remove-on-cancel mode (if possible, with a soft fallback otherwise).  */ public void setRemoveOnCancelPolicy(boolean removeOnCancelPolicy) {     this.removeOnCancelPolicy = removeOnCancelPolicy. }
true;public;1;3;/**  * Specify whether to continue the execution of a scheduled task  * after it threw an exception.  * <p>Default is "false", matching the native behavior of a  * {@link java.util.concurrent.ScheduledExecutorService}.  * Switch this flag to "true" for exception-proof execution of each task,  * continuing scheduled execution as in the case of successful execution.  * @see java.util.concurrent.ScheduledExecutorService#scheduleAtFixedRate  */ ;/**  * Specify whether to continue the execution of a scheduled task  * after it threw an exception.  * <p>Default is "false", matching the native behavior of a  * {@link java.util.concurrent.ScheduledExecutorService}.  * Switch this flag to "true" for exception-proof execution of each task,  * continuing scheduled execution as in the case of successful execution.  * @see java.util.concurrent.ScheduledExecutorService#scheduleAtFixedRate  */ public void setContinueScheduledExecutionAfterException(boolean continueScheduledExecutionAfterException) {     this.continueScheduledExecutionAfterException = continueScheduledExecutionAfterException. }
true;public;1;3;/**  * Specify whether this FactoryBean should expose an unconfigurable  * decorator for the created executor.  * <p>Default is "false", exposing the raw executor as bean reference.  * Switch this flag to "true" to strictly prevent clients from  * modifying the executor's configuration.  * @see java.util.concurrent.Executors#unconfigurableScheduledExecutorService  */ ;/**  * Specify whether this FactoryBean should expose an unconfigurable  * decorator for the created executor.  * <p>Default is "false", exposing the raw executor as bean reference.  * Switch this flag to "true" to strictly prevent clients from  * modifying the executor's configuration.  * @see java.util.concurrent.Executors#unconfigurableScheduledExecutorService  */ public void setExposeUnconfigurableExecutor(boolean exposeUnconfigurableExecutor) {     this.exposeUnconfigurableExecutor = exposeUnconfigurableExecutor. }
false;protected;2;27;;@Override protected ExecutorService initializeExecutor(ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {     ScheduledExecutorService executor = createExecutor(this.poolSize, threadFactory, rejectedExecutionHandler).     if (this.removeOnCancelPolicy) {         if (executor instanceof ScheduledThreadPoolExecutor) {             ((ScheduledThreadPoolExecutor) executor).setRemoveOnCancelPolicy(true).         } else {             logger.debug("Could not apply remove-on-cancel policy - not a ScheduledThreadPoolExecutor").         }     }     // Register specified ScheduledExecutorTasks, if necessary.     if (!ObjectUtils.isEmpty(this.scheduledExecutorTasks)) {         registerTasks(this.scheduledExecutorTasks, executor).     }     // Wrap executor with an unconfigurable decorator.     this.exposedExecutor = (this.exposeUnconfigurableExecutor ? Executors.unconfigurableScheduledExecutorService(executor) : executor).     return executor. }
true;protected;3;5;/**  * Create a new {@link ScheduledExecutorService} instance.  * <p>The default implementation creates a {@link ScheduledThreadPoolExecutor}.  * Can be overridden in subclasses to provide custom {@link ScheduledExecutorService} instances.  * @param poolSize the specified pool size  * @param threadFactory the ThreadFactory to use  * @param rejectedExecutionHandler the RejectedExecutionHandler to use  * @return a new ScheduledExecutorService instance  * @see #afterPropertiesSet()  * @see java.util.concurrent.ScheduledThreadPoolExecutor  */ ;/**  * Create a new {@link ScheduledExecutorService} instance.  * <p>The default implementation creates a {@link ScheduledThreadPoolExecutor}.  * Can be overridden in subclasses to provide custom {@link ScheduledExecutorService} instances.  * @param poolSize the specified pool size  * @param threadFactory the ThreadFactory to use  * @param rejectedExecutionHandler the RejectedExecutionHandler to use  * @return a new ScheduledExecutorService instance  * @see #afterPropertiesSet()  * @see java.util.concurrent.ScheduledThreadPoolExecutor  */ protected ScheduledExecutorService createExecutor(int poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {     return new ScheduledThreadPoolExecutor(poolSize, threadFactory, rejectedExecutionHandler). }
true;protected;2;16;/**  * Register the specified {@link ScheduledExecutorTask ScheduledExecutorTasks}  * on the given {@link ScheduledExecutorService}.  * @param tasks the specified ScheduledExecutorTasks (never empty)  * @param executor the ScheduledExecutorService to register the tasks on.  */ ;/**  * Register the specified {@link ScheduledExecutorTask ScheduledExecutorTasks}  * on the given {@link ScheduledExecutorService}.  * @param tasks the specified ScheduledExecutorTasks (never empty)  * @param executor the ScheduledExecutorService to register the tasks on.  */ protected void registerTasks(ScheduledExecutorTask[] tasks, ScheduledExecutorService executor) {     for (ScheduledExecutorTask task : tasks) {         Runnable runnable = getRunnableToSchedule(task).         if (task.isOneTimeTask()) {             executor.schedule(runnable, task.getDelay(), task.getTimeUnit()).         } else {             if (task.isFixedRate()) {                 executor.scheduleAtFixedRate(runnable, task.getDelay(), task.getPeriod(), task.getTimeUnit()).             } else {                 executor.scheduleWithFixedDelay(runnable, task.getDelay(), task.getPeriod(), task.getTimeUnit()).             }         }     } }
true;protected;1;5;/**  * Determine the actual Runnable to schedule for the given task.  * <p>Wraps the task's Runnable in a  * {@link org.springframework.scheduling.support.DelegatingErrorHandlingRunnable}  * that will catch and log the Exception. If necessary, it will suppress the  * Exception according to the  * {@link #setContinueScheduledExecutionAfterException "continueScheduledExecutionAfterException"}  * flag.  * @param task the ScheduledExecutorTask to schedule  * @return the actual Runnable to schedule (may be a decorator)  */ ;/**  * Determine the actual Runnable to schedule for the given task.  * <p>Wraps the task's Runnable in a  * {@link org.springframework.scheduling.support.DelegatingErrorHandlingRunnable}  * that will catch and log the Exception. If necessary, it will suppress the  * Exception according to the  * {@link #setContinueScheduledExecutionAfterException "continueScheduledExecutionAfterException"}  * flag.  * @param task the ScheduledExecutorTask to schedule  * @return the actual Runnable to schedule (may be a decorator)  */ protected Runnable getRunnableToSchedule(ScheduledExecutorTask task) {     return (this.continueScheduledExecutionAfterException ? new DelegatingErrorHandlingRunnable(task.getRunnable(), TaskUtils.LOG_AND_SUPPRESS_ERROR_HANDLER) : new DelegatingErrorHandlingRunnable(task.getRunnable(), TaskUtils.LOG_AND_PROPAGATE_ERROR_HANDLER)). }
false;public;0;5;;@Override @Nullable public ScheduledExecutorService getObject() {     return this.exposedExecutor. }
false;public;0;4;;@Override public Class<? extends ScheduledExecutorService> getObjectType() {     return (this.exposedExecutor != null ? this.exposedExecutor.getClass() : ScheduledExecutorService.class). }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
