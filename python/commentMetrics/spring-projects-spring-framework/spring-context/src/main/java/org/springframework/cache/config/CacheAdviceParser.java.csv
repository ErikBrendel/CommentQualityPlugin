commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected Class<?> getBeanClass(Element element) {     return CacheInterceptor.class. }
false;protected;3;17;;@Override protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {     builder.addPropertyReference("cacheManager", CacheNamespaceHandler.extractCacheManager(element)).     CacheNamespaceHandler.parseKeyGenerator(element, builder.getBeanDefinition()).     List<Element> cacheDefs = DomUtils.getChildElementsByTagName(element, DEFS_ELEMENT).     if (!cacheDefs.isEmpty()) {         // Using attributes source.         List<RootBeanDefinition> attributeSourceDefinitions = parseDefinitionsSources(cacheDefs, parserContext).         builder.addPropertyValue("cacheOperationSources", attributeSourceDefinitions).     } else {         // Assume annotations source.         builder.addPropertyValue("cacheOperationSources", new RootBeanDefinition("org.springframework.cache.annotation.AnnotationCacheOperationSource")).     } }
false;private;2;10;;private List<RootBeanDefinition> parseDefinitionsSources(List<Element> definitions, ParserContext parserContext) {     ManagedList<RootBeanDefinition> defs = new ManagedList<>(definitions.size()).     // extract default param for the definition     for (Element element : definitions) {         defs.add(parseDefinitionSource(element, parserContext)).     }     return defs. }
false;private;2;76;;private RootBeanDefinition parseDefinitionSource(Element definition, ParserContext parserContext) {     Props prop = new Props(definition).     // add cacheable first     ManagedMap<TypedStringValue, Collection<CacheOperation>> cacheOpMap = new ManagedMap<>().     cacheOpMap.setSource(parserContext.extractSource(definition)).     List<Element> cacheableCacheMethods = DomUtils.getChildElementsByTagName(definition, CACHEABLE_ELEMENT).     for (Element opElement : cacheableCacheMethods) {         String name = prop.merge(opElement, parserContext.getReaderContext()).         TypedStringValue nameHolder = new TypedStringValue(name).         nameHolder.setSource(parserContext.extractSource(opElement)).         CacheableOperation.Builder builder = prop.merge(opElement, parserContext.getReaderContext(), new CacheableOperation.Builder()).         builder.setUnless(getAttributeValue(opElement, "unless", "")).         builder.setSync(Boolean.valueOf(getAttributeValue(opElement, "sync", "false"))).         Collection<CacheOperation> col = cacheOpMap.get(nameHolder).         if (col == null) {             col = new ArrayList<>(2).             cacheOpMap.put(nameHolder, col).         }         col.add(builder.build()).     }     List<Element> evictCacheMethods = DomUtils.getChildElementsByTagName(definition, CACHE_EVICT_ELEMENT).     for (Element opElement : evictCacheMethods) {         String name = prop.merge(opElement, parserContext.getReaderContext()).         TypedStringValue nameHolder = new TypedStringValue(name).         nameHolder.setSource(parserContext.extractSource(opElement)).         CacheEvictOperation.Builder builder = prop.merge(opElement, parserContext.getReaderContext(), new CacheEvictOperation.Builder()).         String wide = opElement.getAttribute("all-entries").         if (StringUtils.hasText(wide)) {             builder.setCacheWide(Boolean.valueOf(wide.trim())).         }         String after = opElement.getAttribute("before-invocation").         if (StringUtils.hasText(after)) {             builder.setBeforeInvocation(Boolean.valueOf(after.trim())).         }         Collection<CacheOperation> col = cacheOpMap.get(nameHolder).         if (col == null) {             col = new ArrayList<>(2).             cacheOpMap.put(nameHolder, col).         }         col.add(builder.build()).     }     List<Element> putCacheMethods = DomUtils.getChildElementsByTagName(definition, CACHE_PUT_ELEMENT).     for (Element opElement : putCacheMethods) {         String name = prop.merge(opElement, parserContext.getReaderContext()).         TypedStringValue nameHolder = new TypedStringValue(name).         nameHolder.setSource(parserContext.extractSource(opElement)).         CachePutOperation.Builder builder = prop.merge(opElement, parserContext.getReaderContext(), new CachePutOperation.Builder()).         builder.setUnless(getAttributeValue(opElement, "unless", "")).         Collection<CacheOperation> col = cacheOpMap.get(nameHolder).         if (col == null) {             col = new ArrayList<>(2).             cacheOpMap.put(nameHolder, col).         }         col.add(builder.build()).     }     RootBeanDefinition attributeSourceDefinition = new RootBeanDefinition(NameMatchCacheOperationSource.class).     attributeSourceDefinition.setSource(parserContext.extractSource(definition)).     attributeSourceDefinition.getPropertyValues().add("nameMap", cacheOpMap).     return attributeSourceDefinition. }
false;private,static;3;7;;private static String getAttributeValue(Element element, String attributeName, String defaultValue) {     String attribute = element.getAttribute(attributeName).     if (StringUtils.hasText(attribute)) {         return attribute.trim().     }     return defaultValue. }
false;;3;29;;<T extends CacheOperation.Builder> T merge(Element element, ReaderContext readerCtx, T builder) {     String cache = element.getAttribute("cache").     // sanity check     String[] localCaches = this.caches.     if (StringUtils.hasText(cache)) {         localCaches = StringUtils.commaDelimitedListToStringArray(cache.trim()).     }     if (localCaches != null) {         builder.setCacheNames(localCaches).     } else {         readerCtx.error("No cache specified for " + element.getNodeName(), element).     }     builder.setKey(getAttributeValue(element, "key", this.key)).     builder.setKeyGenerator(getAttributeValue(element, "key-generator", this.keyGenerator)).     builder.setCacheManager(getAttributeValue(element, "cache-manager", this.cacheManager)).     builder.setCondition(getAttributeValue(element, "condition", this.condition)).     if (StringUtils.hasText(builder.getKey()) && StringUtils.hasText(builder.getKeyGenerator())) {         throw new IllegalStateException("Invalid cache advice configuration on '" + element.toString() + "'. Both 'key' and 'keyGenerator' attributes have been set. " + "These attributes are mutually exclusive: either set the SpEL expression used to" + "compute the key at runtime or set the name of the KeyGenerator bean to use.").     }     return builder. }
false;;2;12;;@Nullable String merge(Element element, ReaderContext readerCtx) {     String method = element.getAttribute(METHOD_ATTRIBUTE).     if (StringUtils.hasText(method)) {         return method.trim().     }     if (StringUtils.hasText(this.method)) {         return this.method.     }     readerCtx.error("No method specified for " + element.getNodeName(), element).     return null. }
