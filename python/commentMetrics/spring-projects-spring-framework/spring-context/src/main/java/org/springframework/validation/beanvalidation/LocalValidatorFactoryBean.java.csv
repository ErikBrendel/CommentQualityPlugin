commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Specify the desired provider class, if any.  * <p>If not specified, JSR-303's default search mechanism will be used.  * @see javax.validation.Validation#byProvider(Class)  * @see javax.validation.Validation#byDefaultProvider()  */ ;/**  * Specify the desired provider class, if any.  * <p>If not specified, JSR-303's default search mechanism will be used.  * @see javax.validation.Validation#byProvider(Class)  * @see javax.validation.Validation#byDefaultProvider()  */ @SuppressWarnings("rawtypes") public void setProviderClass(Class providerClass) {     this.providerClass = providerClass. }
true;public;1;3;/**  * Specify a JSR-303 {@link ValidationProviderResolver} for bootstrapping the  * provider of choice, as an alternative to {@code META-INF} driven resolution.  * @since 4.3  */ ;/**  * Specify a JSR-303 {@link ValidationProviderResolver} for bootstrapping the  * provider of choice, as an alternative to {@code META-INF} driven resolution.  * @since 4.3  */ public void setValidationProviderResolver(ValidationProviderResolver validationProviderResolver) {     this.validationProviderResolver = validationProviderResolver. }
true;public;1;3;/**  * Specify a custom MessageInterpolator to use for this ValidatorFactory  * and its exposed default Validator.  */ ;/**  * Specify a custom MessageInterpolator to use for this ValidatorFactory  * and its exposed default Validator.  */ public void setMessageInterpolator(MessageInterpolator messageInterpolator) {     this.messageInterpolator = messageInterpolator. }
true;public;1;3;/**  * Specify a custom Spring MessageSource for resolving validation messages,  * instead of relying on JSR-303's default "ValidationMessages.properties" bundle  * in the classpath. This may refer to a Spring context's shared "messageSource" bean,  * or to some special MessageSource setup for validation purposes only.  * <p><b>NOTE:</b> This feature requires Hibernate Validator 4.3 or higher on the classpath.  * You may nevertheless use a different validation provider but Hibernate Validator's  * {@link ResourceBundleMessageInterpolator} class must be accessible during configuration.  * <p>Specify either this property or {@link #setMessageInterpolator "messageInterpolator"},  * not both. If you would like to build a custom MessageInterpolator, consider deriving from  * Hibernate Validator's {@link ResourceBundleMessageInterpolator} and passing in a  * Spring-based {@code ResourceBundleLocator} when constructing your interpolator.  * <p>In order for Hibernate's default validation messages to be resolved still, your  * {@link MessageSource} must be configured for optional resolution (usually the default).  * In particular, the {@code MessageSource} instance specified here should not apply  * {@link org.springframework.context.support.AbstractMessageSource#setUseCodeAsDefaultMessage  * "useCodeAsDefaultMessage"} behavior. Please double-check your setup accordingly.  * @see ResourceBundleMessageInterpolator  */ ;/**  * Specify a custom Spring MessageSource for resolving validation messages,  * instead of relying on JSR-303's default "ValidationMessages.properties" bundle  * in the classpath. This may refer to a Spring context's shared "messageSource" bean,  * or to some special MessageSource setup for validation purposes only.  * <p><b>NOTE:</b> This feature requires Hibernate Validator 4.3 or higher on the classpath.  * You may nevertheless use a different validation provider but Hibernate Validator's  * {@link ResourceBundleMessageInterpolator} class must be accessible during configuration.  * <p>Specify either this property or {@link #setMessageInterpolator "messageInterpolator"},  * not both. If you would like to build a custom MessageInterpolator, consider deriving from  * Hibernate Validator's {@link ResourceBundleMessageInterpolator} and passing in a  * Spring-based {@code ResourceBundleLocator} when constructing your interpolator.  * <p>In order for Hibernate's default validation messages to be resolved still, your  * {@link MessageSource} must be configured for optional resolution (usually the default).  * In particular, the {@code MessageSource} instance specified here should not apply  * {@link org.springframework.context.support.AbstractMessageSource#setUseCodeAsDefaultMessage  * "useCodeAsDefaultMessage"} behavior. Please double-check your setup accordingly.  * @see ResourceBundleMessageInterpolator  */ public void setValidationMessageSource(MessageSource messageSource) {     this.messageInterpolator = HibernateValidatorDelegate.buildMessageInterpolator(messageSource). }
true;public;1;3;/**  * Specify a custom TraversableResolver to use for this ValidatorFactory  * and its exposed default Validator.  */ ;/**  * Specify a custom TraversableResolver to use for this ValidatorFactory  * and its exposed default Validator.  */ public void setTraversableResolver(TraversableResolver traversableResolver) {     this.traversableResolver = traversableResolver. }
true;public;1;3;/**  * Specify a custom ConstraintValidatorFactory to use for this ValidatorFactory.  * <p>Default is a {@link SpringConstraintValidatorFactory}, delegating to the  * containing ApplicationContext for creating autowired ConstraintValidator instances.  */ ;/**  * Specify a custom ConstraintValidatorFactory to use for this ValidatorFactory.  * <p>Default is a {@link SpringConstraintValidatorFactory}, delegating to the  * containing ApplicationContext for creating autowired ConstraintValidator instances.  */ public void setConstraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory) {     this.constraintValidatorFactory = constraintValidatorFactory. }
true;public;1;3;/**  * Set the ParameterNameDiscoverer to use for resolving method and constructor  * parameter names if needed for message interpolation.  * <p>Default is a {@link org.springframework.core.DefaultParameterNameDiscoverer}.  */ ;/**  * Set the ParameterNameDiscoverer to use for resolving method and constructor  * parameter names if needed for message interpolation.  * <p>Default is a {@link org.springframework.core.DefaultParameterNameDiscoverer}.  */ public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {     this.parameterNameDiscoverer = parameterNameDiscoverer. }
true;public;1;3;/**  * Specify resource locations to load XML constraint mapping files from, if any.  */ ;/**  * Specify resource locations to load XML constraint mapping files from, if any.  */ public void setMappingLocations(Resource... mappingLocations) {     this.mappingLocations = mappingLocations. }
true;public;1;3;/**  * Specify bean validation properties to be passed to the validation provider.  * <p>Can be populated with a String "value" (parsed via PropertiesEditor)  * or a "props" element in XML bean definitions.  * @see javax.validation.Configuration#addProperty(String, String)  */ ;/**  * Specify bean validation properties to be passed to the validation provider.  * <p>Can be populated with a String "value" (parsed via PropertiesEditor)  * or a "props" element in XML bean definitions.  * @see javax.validation.Configuration#addProperty(String, String)  */ public void setValidationProperties(Properties jpaProperties) {     CollectionUtils.mergePropertiesIntoMap(jpaProperties, this.validationPropertyMap). }
true;public;1;5;/**  * Specify bean validation properties to be passed to the validation provider as a Map.  * <p>Can be populated with a "map" or "props" element in XML bean definitions.  * @see javax.validation.Configuration#addProperty(String, String)  */ ;/**  * Specify bean validation properties to be passed to the validation provider as a Map.  * <p>Can be populated with a "map" or "props" element in XML bean definitions.  * @see javax.validation.Configuration#addProperty(String, String)  */ public void setValidationPropertyMap(@Nullable Map<String, String> validationProperties) {     if (validationProperties != null) {         this.validationPropertyMap.putAll(validationProperties).     } }
true;public;0;3;/**  * Allow Map access to the bean validation properties to be passed to the validation provider,  * with the option to add or override specific entries.  * <p>Useful for specifying entries directly, for example via "validationPropertyMap[myKey]".  */ ;/**  * Allow Map access to the bean validation properties to be passed to the validation provider,  * with the option to add or override specific entries.  * <p>Useful for specifying entries directly, for example via "validationPropertyMap[myKey]".  */ public Map<String, String> getValidationPropertyMap() {     return this.validationPropertyMap. }
false;public;1;4;;@Override public void setApplicationContext(ApplicationContext applicationContext) {     this.applicationContext = applicationContext. }
false;public;0;72;;@Override @SuppressWarnings({ "rawtypes", "unchecked" }) public void afterPropertiesSet() {     Configuration<?> configuration.     if (this.providerClass != null) {         ProviderSpecificBootstrap bootstrap = Validation.byProvider(this.providerClass).         if (this.validationProviderResolver != null) {             bootstrap = bootstrap.providerResolver(this.validationProviderResolver).         }         configuration = bootstrap.configure().     } else {         GenericBootstrap bootstrap = Validation.byDefaultProvider().         if (this.validationProviderResolver != null) {             bootstrap = bootstrap.providerResolver(this.validationProviderResolver).         }         configuration = bootstrap.configure().     }     // Try Hibernate Validator 5.2's externalClassLoader(ClassLoader) method     if (this.applicationContext != null) {         try {             Method eclMethod = configuration.getClass().getMethod("externalClassLoader", ClassLoader.class).             ReflectionUtils.invokeMethod(eclMethod, configuration, this.applicationContext.getClassLoader()).         } catch (NoSuchMethodException ex) {         // Ignore - no Hibernate Validator 5.2+ or similar provider         }     }     MessageInterpolator targetInterpolator = this.messageInterpolator.     if (targetInterpolator == null) {         targetInterpolator = configuration.getDefaultMessageInterpolator().     }     configuration.messageInterpolator(new LocaleContextMessageInterpolator(targetInterpolator)).     if (this.traversableResolver != null) {         configuration.traversableResolver(this.traversableResolver).     }     ConstraintValidatorFactory targetConstraintValidatorFactory = this.constraintValidatorFactory.     if (targetConstraintValidatorFactory == null && this.applicationContext != null) {         targetConstraintValidatorFactory = new SpringConstraintValidatorFactory(this.applicationContext.getAutowireCapableBeanFactory()).     }     if (targetConstraintValidatorFactory != null) {         configuration.constraintValidatorFactory(targetConstraintValidatorFactory).     }     if (this.parameterNameDiscoverer != null) {         configureParameterNameProvider(this.parameterNameDiscoverer, configuration).     }     if (this.mappingLocations != null) {         for (Resource location : this.mappingLocations) {             try {                 configuration.addMapping(location.getInputStream()).             } catch (IOException ex) {                 throw new IllegalStateException("Cannot read mapping resource: " + location).             }         }     }     this.validationPropertyMap.forEach(configuration::addProperty).     // Allow for custom post-processing before we actually build the ValidatorFactory.     postProcessConfiguration(configuration).     this.validatorFactory = configuration.buildValidatorFactory().     setTargetValidator(this.validatorFactory.getValidator()). }
false;public;1;6;;@Override public List<String> getParameterNames(Constructor<?> constructor) {     String[] paramNames = discoverer.getParameterNames(constructor).     return (paramNames != null ? Arrays.asList(paramNames) : defaultProvider.getParameterNames(constructor)). }
false;public;1;6;;@Override public List<String> getParameterNames(Method method) {     String[] paramNames = discoverer.getParameterNames(method).     return (paramNames != null ? Arrays.asList(paramNames) : defaultProvider.getParameterNames(method)). }
false;private;2;17;;private void configureParameterNameProvider(ParameterNameDiscoverer discoverer, Configuration<?> configuration) {     final ParameterNameProvider defaultProvider = configuration.getDefaultParameterNameProvider().     configuration.parameterNameProvider(new ParameterNameProvider() {          @Override         public List<String> getParameterNames(Constructor<?> constructor) {             String[] paramNames = discoverer.getParameterNames(constructor).             return (paramNames != null ? Arrays.asList(paramNames) : defaultProvider.getParameterNames(constructor)).         }          @Override         public List<String> getParameterNames(Method method) {             String[] paramNames = discoverer.getParameterNames(method).             return (paramNames != null ? Arrays.asList(paramNames) : defaultProvider.getParameterNames(method)).         }     }). }
true;protected;1;2;/**  * Post-process the given Bean Validation configuration,  * adding to or overriding any of its settings.  * <p>Invoked right before building the {@link ValidatorFactory}.  * @param configuration the Configuration object, pre-populated with  * settings driven by LocalValidatorFactoryBean's properties  */ ;/**  * Post-process the given Bean Validation configuration,  * adding to or overriding any of its settings.  * <p>Invoked right before building the {@link ValidatorFactory}.  * @param configuration the Configuration object, pre-populated with  * settings driven by LocalValidatorFactoryBean's properties  */ protected void postProcessConfiguration(Configuration<?> configuration) { }
false;public;0;5;;@Override public Validator getValidator() {     Assert.notNull(this.validatorFactory, "No target ValidatorFactory set").     return this.validatorFactory.getValidator(). }
false;public;0;5;;@Override public ValidatorContext usingContext() {     Assert.notNull(this.validatorFactory, "No target ValidatorFactory set").     return this.validatorFactory.usingContext(). }
false;public;0;5;;@Override public MessageInterpolator getMessageInterpolator() {     Assert.notNull(this.validatorFactory, "No target ValidatorFactory set").     return this.validatorFactory.getMessageInterpolator(). }
false;public;0;5;;@Override public TraversableResolver getTraversableResolver() {     Assert.notNull(this.validatorFactory, "No target ValidatorFactory set").     return this.validatorFactory.getTraversableResolver(). }
false;public;0;5;;@Override public ConstraintValidatorFactory getConstraintValidatorFactory() {     Assert.notNull(this.validatorFactory, "No target ValidatorFactory set").     return this.validatorFactory.getConstraintValidatorFactory(). }
false;public;0;5;;@Override public ParameterNameProvider getParameterNameProvider() {     Assert.notNull(this.validatorFactory, "No target ValidatorFactory set").     return this.validatorFactory.getParameterNameProvider(). }
false;public;1;25;;// Bean Validation 2.0: currently not implemented here since it would imply // a hard dependency on the new javax.validation.ClockProvider interface. // To be resolved once Spring Framework requires Bean Validation 2.0+. // Obtain the native ValidatorFactory through unwrap(ValidatorFactory.class) // instead which will fully support a getClockProvider() call as well. /* 	@Override 	public javax.validation.ClockProvider getClockProvider() { 		Assert.notNull(this.validatorFactory, "No target ValidatorFactory set"). 		return this.validatorFactory.getClockProvider(). 	} 	*/ @Override @SuppressWarnings("unchecked") public <T> T unwrap(@Nullable Class<T> type) {     if (type == null || !ValidatorFactory.class.isAssignableFrom(type)) {         try {             return super.unwrap(type).         } catch (ValidationException ex) {         // ignore - we'll try ValidatorFactory unwrapping next         }     }     if (this.validatorFactory != null) {         try {             return this.validatorFactory.unwrap(type).         } catch (ValidationException ex) {             // ignore if just being asked for ValidatorFactory             if (ValidatorFactory.class == type) {                 return (T) this.validatorFactory.             }             throw ex.         }     }     throw new ValidationException("Cannot unwrap to " + type). }
false;public;0;5;;public void close() {     if (this.validatorFactory != null) {         this.validatorFactory.close().     } }
false;public;0;4;;@Override public void destroy() {     close(). }
false;public,static;1;3;;public static MessageInterpolator buildMessageInterpolator(MessageSource messageSource) {     return new ResourceBundleMessageInterpolator(new MessageSourceResourceBundleLocator(messageSource)). }
