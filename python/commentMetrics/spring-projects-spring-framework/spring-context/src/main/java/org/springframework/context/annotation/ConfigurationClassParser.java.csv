commented;modifiers;parameterAmount;loc;comment;code
false;public;1;25;;public void parse(Set<BeanDefinitionHolder> configCandidates) {     for (BeanDefinitionHolder holder : configCandidates) {         BeanDefinition bd = holder.getBeanDefinition().         try {             if (bd instanceof AnnotatedBeanDefinition) {                 parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()).             } else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {                 parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName()).             } else {                 parse(bd.getBeanClassName(), holder.getBeanName()).             }         } catch (BeanDefinitionStoreException ex) {             throw ex.         } catch (Throwable ex) {             throw new BeanDefinitionStoreException("Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex).         }     }     this.deferredImportSelectorHandler.process(). }
false;protected,final;2;5;;protected final void parse(@Nullable String className, String beanName) throws IOException {     Assert.notNull(className, "No bean class name for configuration class bean definition").     MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className).     processConfigurationClass(new ConfigurationClass(reader, beanName)). }
false;protected,final;2;3;;protected final void parse(Class<?> clazz, String beanName) throws IOException {     processConfigurationClass(new ConfigurationClass(clazz, beanName)). }
false;protected,final;2;3;;protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {     processConfigurationClass(new ConfigurationClass(metadata, beanName)). }
true;public;0;5;/**  * Validate each {@link ConfigurationClass} object.  * @see ConfigurationClass#validate  */ ;/**  * Validate each {@link ConfigurationClass} object.  * @see ConfigurationClass#validate  */ public void validate() {     for (ConfigurationClass configClass : this.configurationClasses.keySet()) {         configClass.validate(this.problemReporter).     } }
false;public;0;3;;public Set<ConfigurationClass> getConfigurationClasses() {     return this.configurationClasses.keySet(). }
false;protected;1;31;;protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {     if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {         return.     }     ConfigurationClass existingClass = this.configurationClasses.get(configClass).     if (existingClass != null) {         if (configClass.isImported()) {             if (existingClass.isImported()) {                 existingClass.mergeImportedBy(configClass).             }             // Otherwise ignore new imported config class. existing non-imported class overrides it.             return.         } else {             // Explicit bean definition found, probably replacing an import.             // Let's remove the old one and go with the new one.             this.configurationClasses.remove(configClass).             this.knownSuperclasses.values().removeIf(configClass::equals).         }     }     // Recursively process the configuration class and its superclass hierarchy.     SourceClass sourceClass = asSourceClass(configClass).     do {         sourceClass = doProcessConfigurationClass(configClass, sourceClass).     } while (sourceClass != null).     this.configurationClasses.put(configClass, configClass). }
true;protected,final;2;82;/**  * Apply processing and build a complete {@link ConfigurationClass} by reading the  * annotations, members and methods from the source class. This method can be called  * multiple times as relevant sources are discovered.  * @param configClass the configuration class being build  * @param sourceClass a source class  * @return the superclass, or {@code null} if none found or previously processed  */ ;/**  * Apply processing and build a complete {@link ConfigurationClass} by reading the  * annotations, members and methods from the source class. This method can be called  * multiple times as relevant sources are discovered.  * @param configClass the configuration class being build  * @param sourceClass a source class  * @return the superclass, or {@code null} if none found or previously processed  */ @Nullable protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {     if (configClass.getMetadata().isAnnotated(Component.class.getName())) {         // Recursively process any member (nested) classes first         processMemberClasses(configClass, sourceClass).     }     // Process any @PropertySource annotations     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {         if (this.environment instanceof ConfigurableEnvironment) {             processPropertySource(propertySource).         } else {             logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() + "]. Reason: Environment must implement ConfigurableEnvironment").         }     }     // Process any @ComponentScan annotations     Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class).     if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {         for (AnnotationAttributes componentScan : componentScans) {             // The config class is annotated with @ComponentScan -> perform the scan immediately             Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()).             // Check the set of scanned definitions for any further config classes and parse recursively if needed             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {                 BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition().                 if (bdCand == null) {                     bdCand = holder.getBeanDefinition().                 }                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {                     parse(bdCand.getBeanClassName(), holder.getBeanName()).                 }             }         }     }     // Process any @Import annotations     processImports(configClass, sourceClass, getImports(sourceClass), true).     // Process any @ImportResource annotations     AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class).     if (importResource != null) {         String[] resources = importResource.getStringArray("locations").         Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader").         for (String resource : resources) {             String resolvedResource = this.environment.resolveRequiredPlaceholders(resource).             configClass.addImportedResource(resolvedResource, readerClass).         }     }     // Process individual @Bean methods     Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass).     for (MethodMetadata methodMetadata : beanMethods) {         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)).     }     // Process default methods on interfaces     processInterfaces(configClass, sourceClass).     // Process superclass, if any     if (sourceClass.getMetadata().hasSuperClass()) {         String superclass = sourceClass.getMetadata().getSuperClassName().         if (superclass != null && !superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {             this.knownSuperclasses.put(superclass, configClass).             // Superclass found, return its annotation metadata and recurse             return sourceClass.getSuperClass().         }     }     // No superclass -> processing is complete     return null. }
true;private;2;27;/**  * Register member (nested) classes that happen to be configuration classes themselves.  */ ;/**  * Register member (nested) classes that happen to be configuration classes themselves.  */ private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {     Collection<SourceClass> memberClasses = sourceClass.getMemberClasses().     if (!memberClasses.isEmpty()) {         List<SourceClass> candidates = new ArrayList<>(memberClasses.size()).         for (SourceClass memberClass : memberClasses) {             if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) && !memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {                 candidates.add(memberClass).             }         }         OrderComparator.sort(candidates).         for (SourceClass candidate : candidates) {             if (this.importStack.contains(configClass)) {                 this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)).             } else {                 this.importStack.push(configClass).                 try {                     processConfigurationClass(candidate.asConfigClass(configClass)).                 } finally {                     this.importStack.pop().                 }             }         }     } }
true;private;2;12;/**  * Register default methods on interfaces implemented by the configuration class.  */ ;/**  * Register default methods on interfaces implemented by the configuration class.  */ private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {     for (SourceClass ifc : sourceClass.getInterfaces()) {         Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc).         for (MethodMetadata methodMetadata : beanMethods) {             if (!methodMetadata.isAbstract()) {                 // A default method or other concrete method on a Java 8+ interface...                 configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)).             }         }         processInterfaces(configClass, ifc).     } }
true;private;1;34;/**  * Retrieve the metadata for all <code>@Bean</code> methods.  */ ;/**  * Retrieve the metadata for all <code>@Bean</code> methods.  */ private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {     AnnotationMetadata original = sourceClass.getMetadata().     Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName()).     if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {         // order, even between different runs of the same application on the same JVM.         try {             AnnotationMetadata asm = this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata().             Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName()).             if (asmMethods.size() >= beanMethods.size()) {                 Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size()).                 for (MethodMetadata asmMethod : asmMethods) {                     for (MethodMetadata beanMethod : beanMethods) {                         if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {                             selectedMethods.add(beanMethod).                             break.                         }                     }                 }                 if (selectedMethods.size() == beanMethods.size()) {                     // All reflection-detected methods found in ASM method set -> proceed                     beanMethods = selectedMethods.                 }             }         } catch (IOException ex) {             logger.debug("Failed to read class file via ASM for determining @Bean method order", ex).         // No worries, let's continue with the reflection metadata we started with...         }     }     return beanMethods. }
true;private;1;36;/**  * Process the given <code>@PropertySource</code> annotation metadata.  * @param propertySource metadata for the <code>@PropertySource</code> annotation found  * @throws IOException if loading a property source failed  */ ;/**  * Process the given <code>@PropertySource</code> annotation metadata.  * @param propertySource metadata for the <code>@PropertySource</code> annotation found  * @throws IOException if loading a property source failed  */ private void processPropertySource(AnnotationAttributes propertySource) throws IOException {     String name = propertySource.getString("name").     if (!StringUtils.hasLength(name)) {         name = null.     }     String encoding = propertySource.getString("encoding").     if (!StringUtils.hasLength(encoding)) {         encoding = null.     }     String[] locations = propertySource.getStringArray("value").     Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required").     boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound").     Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory").     PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)).     for (String location : locations) {         try {             String resolvedLocation = this.environment.resolveRequiredPlaceholders(location).             Resource resource = this.resourceLoader.getResource(resolvedLocation).             addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))).         } catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {             // Placeholders not resolvable or resource not found when trying to open it             if (ignoreResourceNotFound) {                 if (logger.isInfoEnabled()) {                     logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage()).                 }             } else {                 throw ex.             }         }     } }
false;private;1;35;;private void addPropertySource(PropertySource<?> propertySource) {     String name = propertySource.getName().     MutablePropertySources propertySources = ((ConfigurableEnvironment) this.environment).getPropertySources().     if (this.propertySourceNames.contains(name)) {         // We've already added a version, we need to extend it         PropertySource<?> existing = propertySources.get(name).         if (existing != null) {             PropertySource<?> newSource = (propertySource instanceof ResourcePropertySource ? ((ResourcePropertySource) propertySource).withResourceName() : propertySource).             if (existing instanceof CompositePropertySource) {                 ((CompositePropertySource) existing).addFirstPropertySource(newSource).             } else {                 if (existing instanceof ResourcePropertySource) {                     existing = ((ResourcePropertySource) existing).withResourceName().                 }                 CompositePropertySource composite = new CompositePropertySource(name).                 composite.addPropertySource(newSource).                 composite.addPropertySource(existing).                 propertySources.replace(name, composite).             }             return.         }     }     if (this.propertySourceNames.isEmpty()) {         propertySources.addLast(propertySource).     } else {         String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size() - 1).         propertySources.addBefore(firstProcessed, propertySource).     }     this.propertySourceNames.add(name). }
true;private;1;6;/**  * Returns {@code @Import} class, considering all meta-annotations.  */ ;/**  * Returns {@code @Import} class, considering all meta-annotations.  */ private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {     Set<SourceClass> imports = new LinkedHashSet<>().     Set<SourceClass> visited = new LinkedHashSet<>().     collectImports(sourceClass, imports, visited).     return imports. }
true;private;3;13;/**  * Recursively collect all declared {@code @Import} values. Unlike most  * meta-annotations it is valid to have several {@code @Import}s declared with  * different values. the usual process of returning values from the first  * meta-annotation on a class is not sufficient.  * <p>For example, it is common for a {@code @Configuration} class to declare direct  * {@code @Import}s in addition to meta-imports originating from an {@code @Enable}  * annotation.  * @param sourceClass the class to search  * @param imports the imports collected so far  * @param visited used to track visited classes to prevent infinite recursion  * @throws IOException if there is any problem reading metadata from the named class  */ ;/**  * Recursively collect all declared {@code @Import} values. Unlike most  * meta-annotations it is valid to have several {@code @Import}s declared with  * different values. the usual process of returning values from the first  * meta-annotation on a class is not sufficient.  * <p>For example, it is common for a {@code @Configuration} class to declare direct  * {@code @Import}s in addition to meta-imports originating from an {@code @Enable}  * annotation.  * @param sourceClass the class to search  * @param imports the imports collected so far  * @param visited used to track visited classes to prevent infinite recursion  * @throws IOException if there is any problem reading metadata from the named class  */ private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {     if (visited.add(sourceClass)) {         for (SourceClass annotation : sourceClass.getAnnotations()) {             String annName = annotation.getMetadata().getClassName().             if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {                 collectImports(annotation, imports, visited).             }         }         imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value")).     } }
false;private;4;62;;private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection<SourceClass> importCandidates, boolean checkForCircularImports) {     if (importCandidates.isEmpty()) {         return.     }     if (checkForCircularImports && isChainedImportOnStack(configClass)) {         this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)).     } else {         this.importStack.push(configClass).         try {             for (SourceClass candidate : importCandidates) {                 if (candidate.isAssignable(ImportSelector.class)) {                     // Candidate class is an ImportSelector -> delegate to it to determine imports                     Class<?> candidateClass = candidate.loadClass().                     ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class).                     ParserStrategyUtils.invokeAwareMethods(selector, this.environment, this.resourceLoader, this.registry).                     if (selector instanceof DeferredImportSelector) {                         this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector).                     } else {                         String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()).                         Collection<SourceClass> importSourceClasses = asSourceClasses(importClassNames).                         processImports(configClass, currentSourceClass, importSourceClasses, false).                     }                 } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {                     // Candidate class is an ImportBeanDefinitionRegistrar ->                     // delegate to it to register additional bean definitions                     Class<?> candidateClass = candidate.loadClass().                     ImportBeanDefinitionRegistrar registrar = BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class).                     ParserStrategyUtils.invokeAwareMethods(registrar, this.environment, this.resourceLoader, this.registry).                     configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()).                 } else {                     // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar ->                     // process it as an @Configuration class                     this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()).                     processConfigurationClass(candidate.asConfigClass(configClass)).                 }             }         } catch (BeanDefinitionStoreException ex) {             throw ex.         } catch (Throwable ex) {             throw new BeanDefinitionStoreException("Failed to process import candidates for configuration class [" + configClass.getMetadata().getClassName() + "]", ex).         } finally {             this.importStack.pop().         }     } }
false;private;1;13;;private boolean isChainedImportOnStack(ConfigurationClass configClass) {     if (this.importStack.contains(configClass)) {         String configClassName = configClass.getMetadata().getClassName().         AnnotationMetadata importingClass = this.importStack.getImportingClassFor(configClassName).         while (importingClass != null) {             if (configClassName.equals(importingClass.getClassName())) {                 return true.             }             importingClass = this.importStack.getImportingClassFor(importingClass.getClassName()).         }     }     return false. }
false;;0;3;;ImportRegistry getImportRegistry() {     return this.importStack. }
true;private;1;7;/**  * Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.  */ ;/**  * Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.  */ private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {     AnnotationMetadata metadata = configurationClass.getMetadata().     if (metadata instanceof StandardAnnotationMetadata) {         return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass()).     }     return asSourceClass(metadata.getClassName()). }
true;;1;17;/**  * Factory method to obtain a {@link SourceClass} from a {@link Class}.  */ ;/**  * Factory method to obtain a {@link SourceClass} from a {@link Class}.  */ SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {     if (classType == null) {         return new SourceClass(Object.class).     }     try {         // including Class attributes. if not -> fall back to ASM         for (Annotation ann : classType.getAnnotations()) {             AnnotationUtils.validateAnnotation(ann).         }         return new SourceClass(classType).     } catch (Throwable ex) {         // Enforce ASM via class name resolution         return asSourceClass(classType.getName()).     } }
true;private;1;7;/**  * Factory method to obtain {@link SourceClass SourceClasss} from class names.  */ ;/**  * Factory method to obtain {@link SourceClass SourceClasss} from class names.  */ private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {     List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length).     for (String className : classNames) {         annotatedClasses.add(asSourceClass(className)).     }     return annotatedClasses. }
true;;1;15;/**  * Factory method to obtain a {@link SourceClass} from a class name.  */ ;/**  * Factory method to obtain a {@link SourceClass} from a class name.  */ SourceClass asSourceClass(@Nullable String className) throws IOException {     if (className == null) {         return new SourceClass(Object.class).     }     if (className.startsWith("java")) {         // Never use ASM for core java types         try {             return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader())).         } catch (ClassNotFoundException ex) {             throw new NestedIOException("Failed to load class [" + className + "]", ex).         }     }     return new SourceClass(this.metadataReaderFactory.getMetadataReader(className)). }
false;public;2;3;;public void registerImport(AnnotationMetadata importingClass, String importedClass) {     this.imports.add(importedClass, importingClass). }
false;public;1;5;;@Override @Nullable public AnnotationMetadata getImportingClassFor(String importedClass) {     return CollectionUtils.lastElement(this.imports.get(importedClass)). }
false;public;1;11;;@Override public void removeImportingClass(String importingClass) {     for (List<AnnotationMetadata> list : this.imports.values()) {         for (Iterator<AnnotationMetadata> iterator = list.iterator(). iterator.hasNext(). ) {             if (iterator.next().getClassName().equals(importingClass)) {                 iterator.remove().                 break.             }         }     } }
true;public;0;8;/**  * Given a stack containing (in order)  * <ul>  * <li>com.acme.Foo</li>  * <li>com.acme.Bar</li>  * <li>com.acme.Baz</li>  * </ul>  * return "[Foo->Bar->Baz]".  */ ;/**  * Given a stack containing (in order)  * <ul>  * <li>com.acme.Foo</li>  * <li>com.acme.Bar</li>  * <li>com.acme.Baz</li>  * </ul>  * return "[Foo->Bar->Baz]".  */ @Override public String toString() {     StringJoiner joiner = new StringJoiner("->", "[", "]").     for (ConfigurationClass configurationClass : this) {         joiner.add(configurationClass.getSimpleName()).     }     return joiner.toString(). }
true;public;2;12;/**  * Handle the specified {@link DeferredImportSelector}. If deferred import  * selectors are being collected, this registers this instance to the list. If  * they are being processed, the {@link DeferredImportSelector} is also processed  * immediately according to its {@link DeferredImportSelector.Group}.  * @param configClass the source configuration class  * @param importSelector the selector to handle  */ ;/**  * Handle the specified {@link DeferredImportSelector}. If deferred import  * selectors are being collected, this registers this instance to the list. If  * they are being processed, the {@link DeferredImportSelector} is also processed  * immediately according to its {@link DeferredImportSelector.Group}.  * @param configClass the source configuration class  * @param importSelector the selector to handle  */ public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {     DeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(configClass, importSelector).     if (this.deferredImportSelectors == null) {         DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler().         handler.register(holder).         handler.processGroupImports().     } else {         this.deferredImportSelectors.add(holder).     } }
false;public;0;15;;public void process() {     List<DeferredImportSelectorHolder> deferredImports = this.deferredImportSelectors.     this.deferredImportSelectors = null.     try {         if (deferredImports != null) {             DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler().             deferredImports.sort(DEFERRED_IMPORT_COMPARATOR).             deferredImports.forEach(handler::register).             handler.processGroupImports().         }     } finally {         this.deferredImportSelectors = new ArrayList<>().     } }
false;public;1;10;;public void register(DeferredImportSelectorHolder deferredImport) {     Class<? extends Group> group = deferredImport.getImportSelector().getImportGroup().     DeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent((group != null ? group : deferredImport), key -> new DeferredImportSelectorGrouping(createGroup(group))).     grouping.add(deferredImport).     this.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getConfigurationClass()). }
false;public;0;20;;public void processGroupImports() {     for (DeferredImportSelectorGrouping grouping : this.groupings.values()) {         grouping.getImports().forEach(entry -> {             ConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata()).             try {                 processImports(configurationClass, asSourceClass(configurationClass), asSourceClasses(entry.getImportClassName()), false).             } catch (BeanDefinitionStoreException ex) {                 throw ex.             } catch (Throwable ex) {                 throw new BeanDefinitionStoreException("Failed to process import candidates for configuration class [" + configurationClass.getMetadata().getClassName() + "]", ex).             }         }).     } }
false;private;1;10;;private Group createGroup(@Nullable Class<? extends Group> type) {     Class<? extends Group> effectiveType = (type != null ? type : DefaultDeferredImportSelectorGroup.class).     Group group = BeanUtils.instantiateClass(effectiveType).     ParserStrategyUtils.invokeAwareMethods(group, ConfigurationClassParser.this.environment, ConfigurationClassParser.this.resourceLoader, ConfigurationClassParser.this.registry).     return group. }
false;public;0;3;;public ConfigurationClass getConfigurationClass() {     return this.configurationClass. }
false;public;0;3;;public DeferredImportSelector getImportSelector() {     return this.importSelector. }
false;public;1;3;;public void add(DeferredImportSelectorHolder deferredImport) {     this.deferredImports.add(deferredImport). }
true;public;0;7;/**  * Return the imports defined by the group.  * @return each import with its associated configuration class  */ ;/**  * Return the imports defined by the group.  * @return each import with its associated configuration class  */ public Iterable<Group.Entry> getImports() {     for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {         this.group.process(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getImportSelector()).     }     return this.group.selectImports(). }
false;public;2;6;;@Override public void process(AnnotationMetadata metadata, DeferredImportSelector selector) {     for (String importClassName : selector.selectImports(metadata)) {         this.imports.add(new Entry(metadata, importClassName)).     } }
false;public;0;4;;@Override public Iterable<Entry> selectImports() {     return this.imports. }
false;public,final;0;3;;public final AnnotationMetadata getMetadata() {     return this.metadata. }
false;public;0;5;;@Override public int getOrder() {     Integer order = ConfigurationClassUtils.getOrder(this.metadata).     return (order != null ? order : Ordered.LOWEST_PRECEDENCE). }
false;public;0;7;;public Class<?> loadClass() throws ClassNotFoundException {     if (this.source instanceof Class) {         return (Class<?>) this.source.     }     String className = ((MetadataReader) this.source).getClassMetadata().getClassName().     return ClassUtils.forName(className, resourceLoader.getClassLoader()). }
false;public;1;6;;public boolean isAssignable(Class<?> clazz) throws IOException {     if (this.source instanceof Class) {         return clazz.isAssignableFrom((Class<?>) this.source).     }     return new AssignableTypeFilter(clazz).match((MetadataReader) this.source, metadataReaderFactory). }
false;public;1;6;;public ConfigurationClass asConfigClass(ConfigurationClass importedBy) {     if (this.source instanceof Class) {         return new ConfigurationClass((Class<?>) this.source, importedBy).     }     return new ConfigurationClass((MetadataReader) this.source, importedBy). }
false;public;0;37;;public Collection<SourceClass> getMemberClasses() throws IOException {     Object sourceToProcess = this.source.     if (sourceToProcess instanceof Class) {         Class<?> sourceClass = (Class<?>) sourceToProcess.         try {             Class<?>[] declaredClasses = sourceClass.getDeclaredClasses().             List<SourceClass> members = new ArrayList<>(declaredClasses.length).             for (Class<?> declaredClass : declaredClasses) {                 members.add(asSourceClass(declaredClass)).             }             return members.         } catch (NoClassDefFoundError err) {             // getDeclaredClasses() failed because of non-resolvable dependencies             // -> fall back to ASM below             sourceToProcess = metadataReaderFactory.getMetadataReader(sourceClass.getName()).         }     }     // ASM-based resolution - safe for non-resolvable classes as well     MetadataReader sourceReader = (MetadataReader) sourceToProcess.     String[] memberClassNames = sourceReader.getClassMetadata().getMemberClassNames().     List<SourceClass> members = new ArrayList<>(memberClassNames.length).     for (String memberClassName : memberClassNames) {         try {             members.add(asSourceClass(memberClassName)).         } catch (IOException ex) {             // Let's skip it if it's not resolvable - we're just looking for candidates             if (logger.isDebugEnabled()) {                 logger.debug("Failed to resolve member class [" + memberClassName + "] - not considering it as a configuration class candidate").             }         }     }     return members. }
false;public;0;6;;public SourceClass getSuperClass() throws IOException {     if (this.source instanceof Class) {         return asSourceClass(((Class<?>) this.source).getSuperclass()).     }     return asSourceClass(((MetadataReader) this.source).getClassMetadata().getSuperClassName()). }
false;public;0;15;;public Set<SourceClass> getInterfaces() throws IOException {     Set<SourceClass> result = new LinkedHashSet<>().     if (this.source instanceof Class) {         Class<?> sourceClass = (Class<?>) this.source.         for (Class<?> ifcClass : sourceClass.getInterfaces()) {             result.add(asSourceClass(ifcClass)).         }     } else {         for (String className : this.metadata.getInterfaceNames()) {             result.add(asSourceClass(className)).         }     }     return result. }
false;public;0;13;;public Set<SourceClass> getAnnotations() {     Set<SourceClass> result = new LinkedHashSet<>().     for (String className : this.metadata.getAnnotationTypes()) {         try {             result.add(getRelated(className)).         } catch (Throwable ex) {         // An annotation not present on the classpath is being ignored         // by the JVM's class loading -> ignore here as well.         }     }     return result. }
false;public;2;12;;public Collection<SourceClass> getAnnotationAttributes(String annType, String attribute) throws IOException {     Map<String, Object> annotationAttributes = this.metadata.getAnnotationAttributes(annType, true).     if (annotationAttributes == null || !annotationAttributes.containsKey(attribute)) {         return Collections.emptySet().     }     String[] classNames = (String[]) annotationAttributes.get(attribute).     Set<SourceClass> result = new LinkedHashSet<>().     for (String className : classNames) {         result.add(getRelated(className)).     }     return result. }
false;private;1;16;;private SourceClass getRelated(String className) throws IOException {     if (this.source instanceof Class) {         try {             Class<?> clazz = ClassUtils.forName(className, ((Class<?>) this.source).getClassLoader()).             return asSourceClass(clazz).         } catch (ClassNotFoundException ex) {             // Ignore -> fall back to ASM next, except for core java types.             if (className.startsWith("java")) {                 throw new NestedIOException("Failed to load class [" + className + "]", ex).             }             return new SourceClass(metadataReaderFactory.getMetadataReader(className)).         }     }     return asSourceClass(className). }
false;public;1;5;;@Override public boolean equals(Object other) {     return (this == other || (other instanceof SourceClass && this.metadata.getClassName().equals(((SourceClass) other).metadata.getClassName()))). }
false;public;0;4;;@Override public int hashCode() {     return this.metadata.getClassName().hashCode(). }
false;public;0;4;;@Override public String toString() {     return this.metadata.getClassName(). }
