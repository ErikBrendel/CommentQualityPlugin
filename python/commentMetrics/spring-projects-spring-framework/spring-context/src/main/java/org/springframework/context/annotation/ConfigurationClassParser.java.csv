# id;timestamp;commentText;codeText;commentWords;codeWords
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1520974346;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1522360217;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1525267242;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1530174524;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1530174524;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1530190293;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1532091916;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1536317783;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1536753765;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1537204195;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1539159551;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1539161108;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1551093117;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> DeferredImportSelectorGrouping -> public Iterable<Group.Entry> getImports();1551113869;Return the imports defined by the group._@return each import with its associated configuration class;public Iterable<Group.Entry> getImports() {_			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {_				this.group.process(deferredImport.getConfigurationClass().getMetadata(),_						deferredImport.getImportSelector())__			}_			return this.group.selectImports()__		};return,the,imports,defined,by,the,group,return,each,import,with,its,associated,configuration,class;public,iterable,group,entry,get,imports,for,deferred,import,selector,holder,deferred,import,this,deferred,imports,this,group,process,deferred,import,get,configuration,class,get,metadata,deferred,import,get,import,selector,return,this,group,select,imports
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1328020251;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1329142650;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1329393628;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1329743944;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1329744111;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1347282850;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1347311780;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1347375001;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1351673950;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1351687206;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1351701017;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1352741263;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1354731125;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1356735495;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1357119239;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1362408075;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1366717765;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1367880232;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1368621032;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> public void parse(Class<?> clazz, String beanName) throws IOException;1368631197;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);public void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;public,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1375216602;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		AnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,annotation,attributes,property,source,attributes,for,source,class,get,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1377269365;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		AnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,annotation,attributes,property,source,annotation,config,utils,attributes,for,source,class,get,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1377562322;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		AnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!shouldSkip(sourceClass, ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,annotation,attributes,property,source,annotation,config,utils,attributes,for,source,class,get,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,should,skip,source,class,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1377625191;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		AnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,annotation,attributes,property,source,annotation,config,utils,attributes,for,source,class,get,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1377640854;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		AnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,annotation,attributes,property,source,annotation,config,utils,attributes,for,source,class,get,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1381881109;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		AnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(),_				org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,annotation,attributes,property,source,annotation,config,utils,attributes,for,source,class,get,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1382386279;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		AnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(),_				org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,annotation,attributes,property,source,annotation,config,utils,attributes,for,source,class,get,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1382465750;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1384512601;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1385158940;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1385412762;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1385978370;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1393377752;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1394195941;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1397058189;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1398637994;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1398720297;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1400245582;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1402056098;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1405454692;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1407857001;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1408653788;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			processPropertySource(propertySource)__		}__		_		registerPropertySources()___		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,process,property,source,property,source,register,property,sources,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1408681275;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (!(this.environment instanceof ConfigurableEnvironment)) {_				logger.warn("Ignoring @PropertySource annotation on "_						+ sourceClass.getMetadata().getClassName()_						+ "Reason: Environment must implement ConfigurableEnvironment")__			} else {_				processPropertySource(propertySource)__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,else,process,property,source,property,source,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1408708479;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1408748821;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1409688471;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1409716050;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1409741991;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1410880110;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1411076915;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1411110630;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1411165756;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1413937661;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1414616928;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1426780215;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true, false)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,false,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,for,source,class,ifc,source,class,get,interfaces,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1427137082;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,for,source,class,ifc,source,class,get,interfaces,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1433381203;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getAliasedStringArray("locations", ImportResource.class, sourceClass)__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,aliased,string,array,locations,import,resource,class,source,class,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,for,source,class,ifc,source,class,get,interfaces,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1434009363;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getAliasedStringArray("locations", ImportResource.class, sourceClass)__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,aliased,string,array,locations,import,resource,class,source,class,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,for,source,class,ifc,source,class,get,interfaces,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1434375974;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getAliasedStringArray("locations", ImportResource.class, sourceClass)__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,annotation,attributes,component,scan,annotation,config,utils,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,aliased,string,array,locations,import,resource,class,source,class,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,for,source,class,ifc,source,class,get,interfaces,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1451421608;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getAliasedStringArray("locations", ImportResource.class, sourceClass)__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,aliased,string,array,locations,import,resource,class,source,class,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,for,source,class,ifc,source,class,get,interfaces,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1452685588;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getAliasedStringArray("locations", ImportResource.class, sourceClass)__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,aliased,string,array,locations,import,resource,class,source,class,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,for,source,class,ifc,source,class,get,interfaces,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1453827605;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getAliasedStringArray("locations", ImportResource.class, sourceClass)__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,aliased,string,array,locations,import,resource,class,source,class,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,for,source,class,ifc,source,class,get,interfaces,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1456179950;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getAliasedStringArray("locations", ImportResource.class, sourceClass)__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,aliased,string,array,locations,import,resource,class,source,class,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,for,source,class,ifc,source,class,get,interfaces,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1464381249;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getAliasedStringArray("locations", ImportResource.class, sourceClass)__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,aliased,string,array,locations,import,resource,class,source,class,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1467730834;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getAliasedStringArray("locations", ImportResource.class, sourceClass)__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,aliased,string,array,locations,import,resource,class,source,class,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1468583965;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1468595845;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1468948866;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1469629308;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						_						_						ImportStack previousStack = this.importStack__						this.importStack = new ImportStack()__						try {_							parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__						}_						finally {_							this.importStack = previousStack__						}_					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,import,stack,previous,stack,this,import,stack,this,import,stack,new,import,stack,try,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,finally,this,import,stack,previous,stack,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1469657173;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1473796164;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1477860027;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1481292081;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1482521352;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1482524610;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1482746422;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1485175042;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1486719670;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1486994827;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1491319023;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1491903930;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1329393628;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			for (String location : locations) {_				location = this.environment.resolveRequiredPlaceholders(location)__				ResourcePropertySource ps = StringUtils.hasText(name) ?_						new ResourcePropertySource(name, location, classLoader) :_						new ResourcePropertySource(location, classLoader)__				this.propertySources.push(ps)__			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan)___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		List<AnnotationAttributes> imports =_			findAllAnnotationAttributes(Import.class, metadata.getClassName(), true)__		for (AnnotationAttributes importAnno : imports) {_			processImport(configClass, importAnno.getStringArray("value"), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,class,loader,class,loader,this,resource,loader,get,class,loader,for,string,location,locations,location,this,environment,resolve,required,placeholders,location,resource,property,source,ps,string,utils,has,text,name,new,resource,property,source,name,location,class,loader,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,list,annotation,attributes,imports,find,all,annotation,attributes,import,class,metadata,get,class,name,true,for,annotation,attributes,import,anno,imports,process,import,config,class,import,anno,get,string,array,value,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1329743944;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[0] = this.environment.resolveRequiredPlaceholders(locations[0])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan)___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		List<AnnotationAttributes> imports =_			findAllAnnotationAttributes(Import.class, metadata.getClassName(), true)__		for (AnnotationAttributes importAnno : imports) {_			processImport(configClass, importAnno.getStringArray("value"), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,0,this,environment,resolve,required,placeholders,locations,0,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,list,annotation,attributes,imports,find,all,annotation,attributes,import,class,metadata,get,class,name,true,for,annotation,attributes,import,anno,imports,process,import,config,class,import,anno,get,string,array,value,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1329744111;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan)___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		List<AnnotationAttributes> imports =_			findAllAnnotationAttributes(Import.class, metadata.getClassName(), true)__		for (AnnotationAttributes importAnno : imports) {_			processImport(configClass, importAnno.getStringArray("value"), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,list,annotation,attributes,imports,find,all,annotation,attributes,import,class,metadata,get,class,name,true,for,annotation,attributes,import,anno,imports,process,import,config,class,import,anno,get,string,array,value,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1347282850;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan)___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		List<AnnotationAttributes> imports =_			findAllAnnotationAttributes(Import.class, metadata.getClassName(), true)__		for (AnnotationAttributes importAnno : imports) {_			processImport(configClass, importAnno.getStringArray("value"), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,list,annotation,attributes,imports,find,all,annotation,attributes,import,class,metadata,get,class,name,true,for,annotation,attributes,import,anno,imports,process,import,config,class,import,anno,get,string,array,value,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1347311780;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan)___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		List<AnnotationAttributes> imports =_			findAllAnnotationAttributes(Import.class, metadata.getClassName(), true)__		for (AnnotationAttributes importAnno : imports) {_			processImport(configClass, importAnno.getStringArray("value"), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,list,annotation,attributes,imports,find,all,annotation,attributes,import,class,metadata,get,class,name,true,for,annotation,attributes,import,anno,imports,process,import,config,class,import,anno,get,string,array,value,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1347375001;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		List<AnnotationAttributes> imports =_			findAllAnnotationAttributes(Import.class, metadata.getClassName(), true)__		for (AnnotationAttributes importAnno : imports) {_			processImport(configClass, importAnno.getStringArray("value"), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,list,annotation,attributes,imports,find,all,annotation,attributes,import,class,metadata,get,class,name,true,for,annotation,attributes,import,anno,imports,process,import,config,class,import,anno,get,string,array,value,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1351673950;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>())__		if (imports != null && !imports.isEmpty()) {_			processImport(configClass, imports.toArray(new String[imports.size()]), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,string,imports,get,imports,metadata,get,class,name,null,new,hash,set,string,if,imports,null,imports,is,empty,process,import,config,class,imports,to,array,new,string,imports,size,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1351687206;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		processImport(configClass, getImports(metadata.getClassName()), true)___		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,import,config,class,get,imports,metadata,get,class,name,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1351701017;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>())__		if (imports != null && !imports.isEmpty()) {_			processImport(configClass, imports.toArray(new String[imports.size()]), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,string,imports,get,imports,metadata,get,class,name,null,new,hash,set,string,if,imports,null,imports,is,empty,process,import,config,class,imports,to,array,new,string,imports,size,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1352741263;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>())__		if (imports != null && !imports.isEmpty()) {_			processImport(configClass, imports.toArray(new String[imports.size()]), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,string,imports,get,imports,metadata,get,class,name,null,new,hash,set,string,if,imports,null,imports,is,empty,process,import,config,class,imports,to,array,new,string,imports,size,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1354731125;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>())__		if (imports != null && !imports.isEmpty()) {_			processImport(configClass, imports.toArray(new String[imports.size()]), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else if (superclass.startsWith("java")) {_					_					try {_						return new StandardAnnotationMetadata(_								this.resourceLoader.getClassLoader().loadClass(superclass), true)__					}_					catch (ClassNotFoundException ex) {_						throw new IllegalStateException(ex)__					}_				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,string,imports,get,imports,metadata,get,class,name,null,new,hash,set,string,if,imports,null,imports,is,empty,process,import,config,class,imports,to,array,new,string,imports,size,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,if,superclass,starts,with,java,try,return,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,superclass,true,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1356735495;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>())__		if (imports != null && !imports.isEmpty()) {_			processImport(configClass, imports.toArray(new String[imports.size()]), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else if (superclass.startsWith("java")) {_					_					try {_						return new StandardAnnotationMetadata(_								this.resourceLoader.getClassLoader().loadClass(superclass), true)__					}_					catch (ClassNotFoundException ex) {_						throw new IllegalStateException(ex)__					}_				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,string,imports,get,imports,metadata,get,class,name,null,new,hash,set,string,if,imports,null,imports,is,empty,process,import,config,class,imports,to,array,new,string,imports,size,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,if,superclass,starts,with,java,try,return,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,superclass,true,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1357119239;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>())__		if (imports != null && !imports.isEmpty()) {_			processImport(configClass, imports.toArray(new String[imports.size()]), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else if (superclass.startsWith("java")) {_					_					try {_						return new StandardAnnotationMetadata(_								this.resourceLoader.getClassLoader().loadClass(superclass), true)__					}_					catch (ClassNotFoundException ex) {_						throw new IllegalStateException(ex)__					}_				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,string,imports,get,imports,metadata,get,class,name,null,new,hash,set,string,if,imports,null,imports,is,empty,process,import,config,class,imports,to,array,new,string,imports,size,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,if,superclass,starts,with,java,try,return,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,superclass,true,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1362408075;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		for (String memberClassName : metadata.getMemberClassNames()) {_			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__			if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_				processConfigurationClass(new ConfigurationClass(reader, true))__			}_		}__		_		AnnotationAttributes propertySource =_				attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			String name = propertySource.getString("name")__			String[] locations = propertySource.getStringArray("value")__			int nLocations = locations.length__			if (nLocations == 0) {_				throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__			}_			for (int i = 0_ i < nLocations_ i++) {_				locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__			}_			ClassLoader classLoader = this.resourceLoader.getClassLoader()__			if (!StringUtils.hasText(name)) {_				for (String location : locations) {_					this.propertySources.push(new ResourcePropertySource(location, classLoader))__				}_			}_			else {_				if (nLocations == 1) {_					this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__				}_				else {_					CompositePropertySource ps = new CompositePropertySource(name)__					for (String location : locations) {_						ps.addPropertySource(new ResourcePropertySource(location, classLoader))__					}_					this.propertySources.push(ps)__				}_			}_		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>())__		if (!CollectionUtils.isEmpty(imports)) {_			processImport(configClass, imports.toArray(new String[imports.size()]), true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else if (superclass.startsWith("java")) {_					_					try {_						return new StandardAnnotationMetadata(_								this.resourceLoader.getClassLoader().loadClass(superclass), true)__					}_					catch (ClassNotFoundException ex) {_						throw new IllegalStateException(ex)__					}_				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,string,imports,get,imports,metadata,get,class,name,null,new,hash,set,string,if,collection,utils,is,empty,imports,process,import,config,class,imports,to,array,new,string,imports,size,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,if,superclass,starts,with,java,try,return,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,superclass,true,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1366717765;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		processMemberClasses(metadata)___		_		AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		__		Set<Object> imports = new LinkedHashSet<Object>()__		Set<Object> visited = new LinkedHashSet<Object>()__		collectImports(metadata, imports, visited)__		if (!imports.isEmpty()) {_			processImport(configClass, imports, true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else if (superclass.startsWith("java")) {_					_					try {_						return new StandardAnnotationMetadata(_								this.resourceLoader.getClassLoader().loadClass(superclass), true)__					}_					catch (ClassNotFoundException ex) {_						throw new IllegalStateException(ex)__					}_				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,process,member,classes,metadata,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,object,imports,new,linked,hash,set,object,set,object,visited,new,linked,hash,set,object,collect,imports,metadata,imports,visited,if,imports,is,empty,process,import,config,class,imports,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,if,superclass,starts,with,java,try,return,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,superclass,true,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1367880232;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		processMemberClasses(metadata)___		_		AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		__		Set<Object> imports = new LinkedHashSet<Object>()__		Set<Object> visited = new LinkedHashSet<Object>()__		collectImports(metadata, imports, visited)__		if (!imports.isEmpty()) {_			processImport(configClass, imports, true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else if (superclass.startsWith("java")) {_					_					try {_						return new StandardAnnotationMetadata(_								this.resourceLoader.getClassLoader().loadClass(superclass), true)__					}_					catch (ClassNotFoundException ex) {_						throw new IllegalStateException(ex)__					}_				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,process,member,classes,metadata,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,object,imports,new,linked,hash,set,object,set,object,visited,new,linked,hash,set,object,collect,imports,metadata,imports,visited,if,imports,is,empty,process,import,config,class,imports,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,if,superclass,starts,with,java,try,return,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,superclass,true,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1368068203;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		processMemberClasses(configClass, metadata)___		_		AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		__		Set<Object> imports = new LinkedHashSet<Object>()__		Set<Object> visited = new LinkedHashSet<Object>()__		collectImports(metadata, imports, visited)__		if (!imports.isEmpty()) {_			processImport(configClass, imports, true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else if (superclass.startsWith("java")) {_					_					try {_						return new StandardAnnotationMetadata(_								this.resourceLoader.getClassLoader().loadClass(superclass), true)__					}_					catch (ClassNotFoundException ex) {_						throw new IllegalStateException(ex)__					}_				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,process,member,classes,config,class,metadata,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,object,imports,new,linked,hash,set,object,set,object,visited,new,linked,hash,set,object,collect,imports,metadata,imports,visited,if,imports,is,empty,process,import,config,class,imports,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,if,superclass,starts,with,java,try,return,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,superclass,true,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1368482696;@return annotation metadata of superclass, null if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		processMemberClasses(configClass, metadata)___		_		AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		__		Set<Object> imports = new LinkedHashSet<Object>()__		Set<Object> visited = new LinkedHashSet<Object>()__		collectImports(metadata, imports, visited)__		if (!imports.isEmpty()) {_			processImport(configClass, imports, true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (this.knownSuperclasses.add(superclass)) {_				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else if (superclass.startsWith("java")) {_					_					try {_						return new StandardAnnotationMetadata(_								this.resourceLoader.getClassLoader().loadClass(superclass), true)__					}_					catch (ClassNotFoundException ex) {_						throw new IllegalStateException(ex)__					}_				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,process,member,classes,config,class,metadata,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,object,imports,new,linked,hash,set,object,set,object,visited,new,linked,hash,set,object,collect,imports,metadata,imports,visited,if,imports,is,empty,process,import,config,class,imports,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,add,superclass,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,if,superclass,starts,with,java,try,return,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,superclass,true,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1368621032;@return annotation metadata of superclass, {@code null} if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		processMemberClasses(configClass, metadata)___		_		AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		Set<Object> imports = new LinkedHashSet<Object>()__		Set<Object> visited = new LinkedHashSet<Object>()__		collectImports(metadata, imports, visited)__		if (!imports.isEmpty()) {_			processImport(configClass, imports, true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else if (superclass.startsWith("java")) {_					_					try {_						return new StandardAnnotationMetadata(_								this.resourceLoader.getClassLoader().loadClass(superclass), true)__					}_					catch (ClassNotFoundException ex) {_						throw new IllegalStateException(ex)__					}_				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,code,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,process,member,classes,config,class,metadata,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,object,imports,new,linked,hash,set,object,set,object,visited,new,linked,hash,set,object,collect,imports,metadata,imports,visited,if,imports,is,empty,process,import,config,class,imports,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,if,superclass,starts,with,java,try,return,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,superclass,true,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> protected AnnotationMetadata doProcessConfigurationClass( 			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException;1368631197;@return annotation metadata of superclass, {@code null} if none found or previously processed;protected AnnotationMetadata doProcessConfigurationClass(_			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {__		_		processMemberClasses(configClass, metadata)___		_		AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class)__		if (componentScan != null) {_			_			Set<BeanDefinitionHolder> scannedBeanDefinitions =_					this.componentScanParser.parse(componentScan, metadata.getClassName())___			_			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_					this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__				}_			}_		}__		_		Set<Object> imports = new LinkedHashSet<Object>()__		Set<Object> visited = new LinkedHashSet<Object>()__		collectImports(metadata, imports, visited)__		if (!imports.isEmpty()) {_			processImport(configClass, imports, true)__		}__		_		if (metadata.isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (metadata.hasSuperClass()) {_			String superclass = metadata.getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				if (metadata instanceof StandardAnnotationMetadata) {_					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass()__					return new StandardAnnotationMetadata(clazz.getSuperclass(), true)__				}_				else if (superclass.startsWith("java")) {_					_					try {_						return new StandardAnnotationMetadata(_								this.resourceLoader.getClassLoader().loadClass(superclass), true)__					}_					catch (ClassNotFoundException ex) {_						throw new IllegalStateException(ex)__					}_				}_				else {_					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass)__					return reader.getAnnotationMetadata()__				}_			}_		}__		_		return null__	};return,annotation,metadata,of,superclass,code,null,if,none,found,or,previously,processed;protected,annotation,metadata,do,process,configuration,class,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,process,member,classes,config,class,metadata,annotation,attributes,property,source,attributes,for,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,attributes,for,metadata,component,scan,class,if,component,scan,null,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,this,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,set,object,imports,new,linked,hash,set,object,set,object,visited,new,linked,hash,set,object,collect,imports,metadata,imports,visited,if,imports,is,empty,process,import,config,class,imports,true,if,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,metadata,has,super,class,string,superclass,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,if,metadata,instanceof,standard,annotation,metadata,class,clazz,standard,annotation,metadata,metadata,get,introspected,class,return,new,standard,annotation,metadata,clazz,get,superclass,true,else,if,superclass,starts,with,java,try,return,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,superclass,true,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,else,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,superclass,return,reader,get,annotation,metadata,return,null
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1464381249;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1467730834;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1468583965;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1468595845;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1468948866;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1469629308;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1469657173;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1473796164;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1477860027;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1481292081;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName())__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,ifc,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1482521352;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1482524610;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1482746422;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1485175042;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1486719670;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1486994827;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1491319023;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1491903930;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1492434334;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1495868221;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1496263893;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1496837955;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1498780456;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1502974979;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1511268177;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1515777832;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1518772998;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1520858426;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1520974346;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1522360217;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1525267242;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1530174524;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1530174524;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1530190293;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1532091916;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1536317783;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1536753765;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1537204195;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1539159551;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1539161108;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1551093117;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1551113869;Register default methods on interfaces implemented by the configuration class.;private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass ifc : sourceClass.getInterfaces()) {_			Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc)__			for (MethodMetadata methodMetadata : beanMethods) {_				if (!methodMetadata.isAbstract()) {_					_					configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__				}_			}_			processInterfaces(configClass, ifc)__		}_	};register,default,methods,on,interfaces,implemented,by,the,configuration,class;private,void,process,interfaces,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,ifc,source,class,get,interfaces,set,method,metadata,bean,methods,retrieve,bean,method,metadata,ifc,for,method,metadata,method,metadata,bean,methods,if,method,metadata,is,abstract,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,ifc
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1496837955;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1498780456;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1502974979;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1511268177;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1515777832;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1518772998;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1520858426;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1520974346;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1522360217;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1525267242;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1530174524;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1530174524;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1530190293;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1532091916;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1536317783;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1536753765;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1537204195;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1539159551;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1539161108;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1551093117;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable String className) throws IOException;1551113869;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(@Nullable String className) throws IOException {_		if (className == null) {_			return new SourceClass(Object.class)__		}_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(ClassUtils.forName(className, this.resourceLoader.getClassLoader()))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,nullable,string,class,name,throws,ioexception,if,class,name,null,return,new,source,class,object,class,if,class,name,starts,with,java,try,return,new,source,class,class,utils,for,name,class,name,this,resource,loader,get,class,loader,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1375216602;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					if(!annotation.getMetadata().getClassName().startsWith("java") && !annotation.isAssignable(Import.class)) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,if,annotation,get,metadata,get,class,name,starts,with,java,annotation,is,assignable,import,class,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1377269365;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					if(!annotation.getMetadata().getClassName().startsWith("java") && !annotation.isAssignable(Import.class)) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,if,annotation,get,metadata,get,class,name,starts,with,java,annotation,is,assignable,import,class,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1377562322;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					if(!annotation.getMetadata().getClassName().startsWith("java") && !annotation.isAssignable(Import.class)) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,if,annotation,get,metadata,get,class,name,starts,with,java,annotation,is,assignable,import,class,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1377625191;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					if(!annotation.getMetadata().getClassName().startsWith("java") && !annotation.isAssignable(Import.class)) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,if,annotation,get,metadata,get,class,name,starts,with,java,annotation,is,assignable,import,class,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1377640854;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					if(!annotation.getMetadata().getClassName().startsWith("java") && !annotation.isAssignable(Import.class)) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,if,annotation,get,metadata,get,class,name,starts,with,java,annotation,is,assignable,import,class,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1381881109;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					if (!annotation.getMetadata().getClassName().startsWith("java") && !annotation.isAssignable(Import.class)) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,if,annotation,get,metadata,get,class,name,starts,with,java,annotation,is,assignable,import,class,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1382386279;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					if (!annotation.getMetadata().getClassName().startsWith("java") && !annotation.isAssignable(Import.class)) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,if,annotation,get,metadata,get,class,name,starts,with,java,annotation,is,assignable,import,class,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1382465750;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					if (!annotation.getMetadata().getClassName().startsWith("java") && !annotation.isAssignable(Import.class)) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,if,annotation,get,metadata,get,class,name,starts,with,java,annotation,is,assignable,import,class,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1384512601;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					String annName = annotation.getMetadata().getClassName()__					if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1385158940;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					String annName = annotation.getMetadata().getClassName()__					if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1385412762;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					String annName = annotation.getMetadata().getClassName()__					if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1385978370;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					String annName = annotation.getMetadata().getClassName()__					if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1393377752;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					String annName = annotation.getMetadata().getClassName()__					if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1394195941;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					String annName = annotation.getMetadata().getClassName()__					if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1397058189;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					String annName = annotation.getMetadata().getClassName()__					if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1398637994;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					String annName = annotation.getMetadata().getClassName()__					if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1398720297;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					String annName = annotation.getMetadata().getClassName()__					if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1400245582;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					String annName = annotation.getMetadata().getClassName()__					if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1402056098;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					String annName = annotation.getMetadata().getClassName()__					if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1405454692;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1407857001;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1408653788;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1408681275;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1408708479;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1408748821;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1409688471;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1409716050;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1409741991;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1410880110;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1411076915;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1411110630;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1411165756;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1413937661;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1414616928;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1426780215;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1427137082;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1433381203;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1434009363;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1434375974;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1451421608;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1452685588;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1453827605;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1456179950;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1464381249;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1467730834;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1468583965;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1468595845;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1468948866;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1469629308;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1469657173;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1473796164;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1477860027;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1481292081;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1482521352;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1482524610;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1482746422;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1485175042;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1486719670;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1486994827;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1491319023;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException;1491903930;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {_		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException;1366717765;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param metadata the metadata representation of the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException {_		String className = metadata.getClassName()__		if (visited.add(className)) {_			if (metadata instanceof StandardAnnotationMetadata) {_				StandardAnnotationMetadata stdMetadata = (StandardAnnotationMetadata) metadata__				for (Annotation ann : stdMetadata.getIntrospectedClass().getAnnotations()) {_					if (!ann.annotationType().getName().startsWith("java") && !(ann instanceof Import)) {_						collectImports(new StandardAnnotationMetadata(ann.annotationType()), imports, visited)__					}_				}_				Map<String, Object> attributes = stdMetadata.getAnnotationAttributes(Import.class.getName(), false)__				if (attributes != null) {_					Class[] value = (Class[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_			else {_				for (String annotationType : metadata.getAnnotationTypes()) {_					if (!className.startsWith("java") && !className.equals(Import.class.getName())) {_						try {_							collectImports(_									new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(annotationType)),_									imports, visited)__						}_						catch (ClassNotFoundException ex) {_							_						}_					}_				}_				Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__				if (attributes != null) {_					String[] value = (String[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,metadata,the,metadata,representation,of,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,annotation,metadata,metadata,set,object,imports,set,object,visited,throws,ioexception,string,class,name,metadata,get,class,name,if,visited,add,class,name,if,metadata,instanceof,standard,annotation,metadata,standard,annotation,metadata,std,metadata,standard,annotation,metadata,metadata,for,annotation,ann,std,metadata,get,introspected,class,get,annotations,if,ann,annotation,type,get,name,starts,with,java,ann,instanceof,import,collect,imports,new,standard,annotation,metadata,ann,annotation,type,imports,visited,map,string,object,attributes,std,metadata,get,annotation,attributes,import,class,get,name,false,if,attributes,null,class,value,class,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value,else,for,string,annotation,type,metadata,get,annotation,types,if,class,name,starts,with,java,class,name,equals,import,class,get,name,try,collect,imports,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,annotation,type,imports,visited,catch,class,not,found,exception,ex,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value
ConfigurationClassParser -> private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException;1367880232;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param metadata the metadata representation of the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException {_		String className = metadata.getClassName()__		if (visited.add(className)) {_			if (metadata instanceof StandardAnnotationMetadata) {_				StandardAnnotationMetadata stdMetadata = (StandardAnnotationMetadata) metadata__				for (Annotation ann : stdMetadata.getIntrospectedClass().getAnnotations()) {_					if (!ann.annotationType().getName().startsWith("java") && !(ann instanceof Import)) {_						collectImports(new StandardAnnotationMetadata(ann.annotationType()), imports, visited)__					}_				}_				Map<String, Object> attributes = stdMetadata.getAnnotationAttributes(Import.class.getName(), false)__				if (attributes != null) {_					Class[] value = (Class[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_			else {_				for (String annotationType : metadata.getAnnotationTypes()) {_					if (!className.startsWith("java") && !className.equals(Import.class.getName())) {_						try {_							collectImports(_									new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(annotationType)),_									imports, visited)__						}_						catch (ClassNotFoundException ex) {_							_						}_					}_				}_				Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__				if (attributes != null) {_					String[] value = (String[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,metadata,the,metadata,representation,of,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,annotation,metadata,metadata,set,object,imports,set,object,visited,throws,ioexception,string,class,name,metadata,get,class,name,if,visited,add,class,name,if,metadata,instanceof,standard,annotation,metadata,standard,annotation,metadata,std,metadata,standard,annotation,metadata,metadata,for,annotation,ann,std,metadata,get,introspected,class,get,annotations,if,ann,annotation,type,get,name,starts,with,java,ann,instanceof,import,collect,imports,new,standard,annotation,metadata,ann,annotation,type,imports,visited,map,string,object,attributes,std,metadata,get,annotation,attributes,import,class,get,name,false,if,attributes,null,class,value,class,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value,else,for,string,annotation,type,metadata,get,annotation,types,if,class,name,starts,with,java,class,name,equals,import,class,get,name,try,collect,imports,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,annotation,type,imports,visited,catch,class,not,found,exception,ex,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value
ConfigurationClassParser -> private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException;1368068203;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param metadata the metadata representation of the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException {_		String className = metadata.getClassName()__		if (visited.add(className)) {_			if (metadata instanceof StandardAnnotationMetadata) {_				StandardAnnotationMetadata stdMetadata = (StandardAnnotationMetadata) metadata__				for (Annotation ann : stdMetadata.getIntrospectedClass().getAnnotations()) {_					if (!ann.annotationType().getName().startsWith("java") && !(ann instanceof Import)) {_						collectImports(new StandardAnnotationMetadata(ann.annotationType()), imports, visited)__					}_				}_				Map<String, Object> attributes = stdMetadata.getAnnotationAttributes(Import.class.getName(), false)__				if (attributes != null) {_					Class[] value = (Class[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_			else {_				for (String annotationType : metadata.getAnnotationTypes()) {_					if (!className.startsWith("java") && !className.equals(Import.class.getName())) {_						try {_							collectImports(_									new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(annotationType)),_									imports, visited)__						}_						catch (ClassNotFoundException ex) {_							_						}_					}_				}_				Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__				if (attributes != null) {_					String[] value = (String[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,metadata,the,metadata,representation,of,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,annotation,metadata,metadata,set,object,imports,set,object,visited,throws,ioexception,string,class,name,metadata,get,class,name,if,visited,add,class,name,if,metadata,instanceof,standard,annotation,metadata,standard,annotation,metadata,std,metadata,standard,annotation,metadata,metadata,for,annotation,ann,std,metadata,get,introspected,class,get,annotations,if,ann,annotation,type,get,name,starts,with,java,ann,instanceof,import,collect,imports,new,standard,annotation,metadata,ann,annotation,type,imports,visited,map,string,object,attributes,std,metadata,get,annotation,attributes,import,class,get,name,false,if,attributes,null,class,value,class,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value,else,for,string,annotation,type,metadata,get,annotation,types,if,class,name,starts,with,java,class,name,equals,import,class,get,name,try,collect,imports,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,annotation,type,imports,visited,catch,class,not,found,exception,ex,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value
ConfigurationClassParser -> private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException;1368482696;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param metadata the metadata representation of the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException {_		String className = metadata.getClassName()__		if (visited.add(className)) {_			if (metadata instanceof StandardAnnotationMetadata) {_				StandardAnnotationMetadata stdMetadata = (StandardAnnotationMetadata) metadata__				for (Annotation ann : stdMetadata.getIntrospectedClass().getAnnotations()) {_					if (!ann.annotationType().getName().startsWith("java") && !(ann instanceof Import)) {_						collectImports(new StandardAnnotationMetadata(ann.annotationType()), imports, visited)__					}_				}_				Map<String, Object> attributes = stdMetadata.getAnnotationAttributes(Import.class.getName(), false)__				if (attributes != null) {_					Class[] value = (Class[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_			else {_				for (String annotationType : metadata.getAnnotationTypes()) {_					if (!className.startsWith("java") && !className.equals(Import.class.getName())) {_						try {_							collectImports(_									new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(annotationType)),_									imports, visited)__						}_						catch (ClassNotFoundException ex) {_							_						}_					}_				}_				Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__				if (attributes != null) {_					String[] value = (String[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,metadata,the,metadata,representation,of,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,annotation,metadata,metadata,set,object,imports,set,object,visited,throws,ioexception,string,class,name,metadata,get,class,name,if,visited,add,class,name,if,metadata,instanceof,standard,annotation,metadata,standard,annotation,metadata,std,metadata,standard,annotation,metadata,metadata,for,annotation,ann,std,metadata,get,introspected,class,get,annotations,if,ann,annotation,type,get,name,starts,with,java,ann,instanceof,import,collect,imports,new,standard,annotation,metadata,ann,annotation,type,imports,visited,map,string,object,attributes,std,metadata,get,annotation,attributes,import,class,get,name,false,if,attributes,null,class,value,class,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value,else,for,string,annotation,type,metadata,get,annotation,types,if,class,name,starts,with,java,class,name,equals,import,class,get,name,try,collect,imports,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,annotation,type,imports,visited,catch,class,not,found,exception,ex,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value
ConfigurationClassParser -> private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException;1368621032;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param metadata the metadata representation of the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException {_		String className = metadata.getClassName()__		if (visited.add(className)) {_			if (metadata instanceof StandardAnnotationMetadata) {_				StandardAnnotationMetadata stdMetadata = (StandardAnnotationMetadata) metadata__				for (Annotation ann : stdMetadata.getIntrospectedClass().getAnnotations()) {_					if (!ann.annotationType().getName().startsWith("java") && !(ann instanceof Import)) {_						collectImports(new StandardAnnotationMetadata(ann.annotationType()), imports, visited)__					}_				}_				Map<String, Object> attributes = stdMetadata.getAnnotationAttributes(Import.class.getName(), false)__				if (attributes != null) {_					Class[] value = (Class[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_			else {_				for (String annotationType : metadata.getAnnotationTypes()) {_					if (!className.startsWith("java") && !className.equals(Import.class.getName())) {_						try {_							collectImports(_									new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(annotationType)),_									imports, visited)__						}_						catch (ClassNotFoundException ex) {_							_						}_					}_				}_				Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__				if (attributes != null) {_					String[] value = (String[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,metadata,the,metadata,representation,of,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,annotation,metadata,metadata,set,object,imports,set,object,visited,throws,ioexception,string,class,name,metadata,get,class,name,if,visited,add,class,name,if,metadata,instanceof,standard,annotation,metadata,standard,annotation,metadata,std,metadata,standard,annotation,metadata,metadata,for,annotation,ann,std,metadata,get,introspected,class,get,annotations,if,ann,annotation,type,get,name,starts,with,java,ann,instanceof,import,collect,imports,new,standard,annotation,metadata,ann,annotation,type,imports,visited,map,string,object,attributes,std,metadata,get,annotation,attributes,import,class,get,name,false,if,attributes,null,class,value,class,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value,else,for,string,annotation,type,metadata,get,annotation,types,if,class,name,starts,with,java,class,name,equals,import,class,get,name,try,collect,imports,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,annotation,type,imports,visited,catch,class,not,found,exception,ex,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value
ConfigurationClassParser -> private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException;1368631197;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param metadata the metadata representation of the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(AnnotationMetadata metadata, Set<Object> imports, Set<Object> visited) throws IOException {_		String className = metadata.getClassName()__		if (visited.add(className)) {_			if (metadata instanceof StandardAnnotationMetadata) {_				StandardAnnotationMetadata stdMetadata = (StandardAnnotationMetadata) metadata__				for (Annotation ann : stdMetadata.getIntrospectedClass().getAnnotations()) {_					if (!ann.annotationType().getName().startsWith("java") && !(ann instanceof Import)) {_						collectImports(new StandardAnnotationMetadata(ann.annotationType()), imports, visited)__					}_				}_				Map<String, Object> attributes = stdMetadata.getAnnotationAttributes(Import.class.getName(), false)__				if (attributes != null) {_					Class[] value = (Class[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_			else {_				for (String annotationType : metadata.getAnnotationTypes()) {_					if (!className.startsWith("java") && !className.equals(Import.class.getName())) {_						try {_							collectImports(_									new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(annotationType)),_									imports, visited)__						}_						catch (ClassNotFoundException ex) {_							_						}_					}_				}_				Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__				if (attributes != null) {_					String[] value = (String[]) attributes.get("value")__					if (!ObjectUtils.isEmpty(value)) {_						imports.addAll(Arrays.asList(value))__					}_				}_			}_		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,metadata,the,metadata,representation,of,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,annotation,metadata,metadata,set,object,imports,set,object,visited,throws,ioexception,string,class,name,metadata,get,class,name,if,visited,add,class,name,if,metadata,instanceof,standard,annotation,metadata,standard,annotation,metadata,std,metadata,standard,annotation,metadata,metadata,for,annotation,ann,std,metadata,get,introspected,class,get,annotations,if,ann,annotation,type,get,name,starts,with,java,ann,instanceof,import,collect,imports,new,standard,annotation,metadata,ann,annotation,type,imports,visited,map,string,object,attributes,std,metadata,get,annotation,attributes,import,class,get,name,false,if,attributes,null,class,value,class,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value,else,for,string,annotation,type,metadata,get,annotation,types,if,class,name,starts,with,java,class,name,equals,import,class,get,name,try,collect,imports,new,standard,annotation,metadata,this,resource,loader,get,class,loader,load,class,annotation,type,imports,visited,catch,class,not,found,exception,ex,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,object,utils,is,empty,value,imports,add,all,arrays,as,list,value
ConfigurationClassParser -> public SourceClass asSourceClass(String className) 			throws ClassNotFoundException, IOException;1372363092;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className)_			throws ClassNotFoundException, IOException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(_					className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,class,not,found,exception,ioexception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) 			throws ClassNotFoundException, IOException;1374264616;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className)_			throws ClassNotFoundException, IOException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(_					className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,class,not,found,exception,ioexception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1375216602;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass( className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1377269365;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass( className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1377562322;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass( className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1377625191;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass( className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1377640854;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass( className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1381881109;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass( className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1382386279;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass( className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1382465750;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass( className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1384512601;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1385158940;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1385412762;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1385978370;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1393377752;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1394195941;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1397058189;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1398637994;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1398720297;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1400245582;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException;1402056098;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {_		if (className.startsWith("java")) {_			_			return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,class,not,found,exception,if,class,name,starts,with,java,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1375216602;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1377269365;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1377562322;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1377625191;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1377640854;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1381881109;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1382386279;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1382465750;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1384512601;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1385158940;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1385412762;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1385978370;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1393377752;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1394195941;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1397058189;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1398637994;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1398720297;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1400245582;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException;1402056098;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,class,not,found,exception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> SourceClass asSourceClass(String className) throws IOException;1486994827;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(String className) throws IOException;1491319023;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(String className) throws IOException;1491903930;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(String className) throws IOException;1492434334;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(String className) throws IOException;1495868221;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(String className) throws IOException;1496263893;Factory method to obtain a {@link SourceClass} from a class name.;SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1496837955;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1498780456;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1502974979;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1511268177;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1515777832;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1518772998;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1520858426;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1520974346;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1522360217;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1525267242;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1530174524;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1530174524;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1530190293;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1532091916;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1536317783;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1536753765;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1537204195;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1539159551;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1539161108;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1551093117;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException;1551113869;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(@Nullable Class<?> classType) throws IOException {_		if (classType == null) {_			return new SourceClass(Object.class)__		}_		try {_			_			_			for (Annotation ann : classType.getAnnotations()) {_				AnnotationUtils.validateAnnotation(ann)__			}_			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,nullable,class,class,type,throws,ioexception,if,class,type,null,return,new,source,class,object,class,try,for,annotation,ann,class,type,get,annotations,annotation,utils,validate,annotation,ann,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1372363092;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1374264616;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1375216602;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1377269365;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1377562322;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1377625191;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1377640854;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1381881109;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1382386279;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1382465750;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1384512601;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1385158940;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1385412762;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1385978370;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1393377752;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1394195941;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1397058189;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1398637994;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1398720297;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1400245582;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1402056098;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1405454692;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1407857001;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1408653788;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1408681275;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1408708479;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1408748821;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1409688471;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1409716050;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1409741991;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1410880110;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1411076915;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1411110630;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1411165756;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1413937661;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1414616928;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1426780215;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1427137082;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1433381203;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				processConfigurationClass(memberClass.asConfigClass(configClass))__			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,process,configuration,class,member,class,as,config,class,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1434009363;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1434375974;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1451421608;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1452685588;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1453827605;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1456179950;Register member (nested) classes that happen to be configuration classes themselves._@param sourceClass the source class to process_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,source,class,the,source,class,to,process,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1464381249;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1467730834;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1468583965;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1468595845;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1468948866;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1469629308;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1469657173;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1473796164;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1477860027;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1481292081;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1482521352;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1482524610;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1482746422;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1485175042;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1486719670;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1486994827;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		for (SourceClass memberClass : sourceClass.getMemberClasses()) {_			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(memberClass.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,for,source,class,member,class,source,class,get,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,member,class,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1491319023;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1491903930;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1492434334;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1495868221;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1496263893;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1496837955;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1498780456;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1502974979;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1511268177;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1515777832;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1518772998;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1520858426;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1520974346;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1522360217;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1525267242;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1530174524;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1530174524;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1530190293;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1532091916;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1536317783;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1536753765;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1537204195;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1539159551;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1539161108;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1551093117;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1551113869;Register member (nested) classes that happen to be configuration classes themselves.;private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {_		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses()__		if (!memberClasses.isEmpty()) {_			List<SourceClass> candidates = new ArrayList<>(memberClasses.size())__			for (SourceClass memberClass : memberClasses) {_				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&_						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {_					candidates.add(memberClass)__				}_			}_			OrderComparator.sort(candidates)__			for (SourceClass candidate : candidates) {_				if (this.importStack.contains(configClass)) {_					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack))__				}_				else {_					this.importStack.push(configClass)__					try {_						processConfigurationClass(candidate.asConfigClass(configClass))__					}_					finally {_						this.importStack.pop()__					}_				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves;private,void,process,member,classes,configuration,class,config,class,source,class,source,class,throws,ioexception,collection,source,class,member,classes,source,class,get,member,classes,if,member,classes,is,empty,list,source,class,candidates,new,array,list,member,classes,size,for,source,class,member,class,member,classes,if,configuration,class,utils,is,configuration,candidate,member,class,get,metadata,member,class,get,metadata,get,class,name,equals,config,class,get,metadata,get,class,name,candidates,add,member,class,order,comparator,sort,candidates,for,source,class,candidate,candidates,if,this,import,stack,contains,config,class,this,problem,reporter,error,new,circular,import,problem,config,class,this,import,stack,else,this,import,stack,push,config,class,try,process,configuration,class,candidate,as,config,class,config,class,finally,this,import,stack,pop
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNamess) 			throws ClassNotFoundException, IOException;1372363092;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNamess)_			throws ClassNotFoundException, IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNamess) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,namess,throws,class,not,found,exception,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,namess,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNamess) 			throws ClassNotFoundException, IOException;1374264616;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNamess)_			throws ClassNotFoundException, IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNamess) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,namess,throws,class,not,found,exception,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,namess,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1495868221;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(_							holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1496263893;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(_							holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource =_					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1496837955;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(_							holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1498780456;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(_							holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1502974979;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(_							holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1511268177;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(_							holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1515777832;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(_							holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1518772998;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(_							holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1520858426;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(_							holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1520974346;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(_							holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1522360217;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(_							holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1525267242;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1530174524;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1530174524;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1530190293;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,warn,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1532091916;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,info,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1536317783;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,info,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1536753765;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		if (sourceClass.getMetadata().isAnnotated(Component.class.getName())) {_			_			processMemberClasses(configClass, sourceClass)__		}__		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,if,source,class,get,metadata,is,annotated,component,class,get,name,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,info,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1537204195;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		if (configClass.getMetadata().isAnnotated(Component.class.getName())) {_			_			processMemberClasses(configClass, sourceClass)__		}__		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,if,config,class,get,metadata,is,annotated,component,class,get,name,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,info,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1539159551;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		if (configClass.getMetadata().isAnnotated(Component.class.getName())) {_			_			processMemberClasses(configClass, sourceClass)__		}__		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,if,config,class,get,metadata,is,annotated,component,class,get,name,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,info,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1539161108;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		if (configClass.getMetadata().isAnnotated(Component.class.getName())) {_			_			processMemberClasses(configClass, sourceClass)__		}__		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,if,config,class,get,metadata,is,annotated,component,class,get,name,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,info,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1551093117;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		if (configClass.getMetadata().isAnnotated(Component.class.getName())) {_			_			processMemberClasses(configClass, sourceClass)__		}__		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,if,config,class,get,metadata,is,annotated,component,class,get,name,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,info,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> @Nullable 	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 			throws IOException;1551113869;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, or {@code null} if none found or previously processed;@Nullable_	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)_			throws IOException {__		if (configClass.getMetadata().isAnnotated(Component.class.getName())) {_			_			processMemberClasses(configClass, sourceClass)__		}__		_		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), PropertySources.class,_				org.springframework.context.annotation.PropertySource.class)) {_			if (this.environment instanceof ConfigurableEnvironment) {_				processPropertySource(propertySource)__			}_			else {_				logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +_						"]. Reason: Environment must implement ConfigurableEnvironment")__			}_		}__		_		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(_				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class)__		if (!componentScans.isEmpty() &&_				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_			for (AnnotationAttributes componentScan : componentScans) {_				_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())__				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition()__					if (bdCand == null) {_						bdCand = holder.getBeanDefinition()__					}_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {_						parse(bdCand.getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, sourceClass, getImports(sourceClass), true)___		_		AnnotationAttributes importResource =_				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class)__		if (importResource != null) {_			String[] resources = importResource.getStringArray("locations")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass)__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		processInterfaces(configClass, sourceClass)___		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (superclass != null && !superclass.startsWith("java") &&_					!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				return sourceClass.getSuperClass()__			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,or,code,null,if,none,found,or,previously,processed;nullable,protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,if,config,class,get,metadata,is,annotated,component,class,get,name,process,member,classes,config,class,source,class,for,annotation,attributes,property,source,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,property,sources,class,org,springframework,context,annotation,property,source,class,if,this,environment,instanceof,configurable,environment,process,property,source,property,source,else,logger,info,ignoring,property,source,annotation,on,source,class,get,metadata,get,class,name,reason,environment,must,implement,configurable,environment,set,annotation,attributes,component,scans,annotation,config,utils,attributes,for,repeatable,source,class,get,metadata,component,scans,class,component,scan,class,if,component,scans,is,empty,this,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,for,annotation,attributes,component,scan,component,scans,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,bean,definition,bd,cand,holder,get,bean,definition,get,originating,bean,definition,if,bd,cand,null,bd,cand,holder,get,bean,definition,if,configuration,class,utils,check,configuration,class,candidate,bd,cand,this,metadata,reader,factory,parse,bd,cand,get,bean,class,name,holder,get,bean,name,process,imports,config,class,source,class,get,imports,source,class,true,annotation,attributes,import,resource,annotation,config,utils,attributes,for,source,class,get,metadata,import,resource,class,if,import,resource,null,string,resources,import,resource,get,string,array,locations,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,retrieve,bean,method,metadata,source,class,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,process,interfaces,config,class,source,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,superclass,null,superclass,starts,with,java,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,return,source,class,get,super,class,return,null
ConfigurationClassParser -> private Set<String> getImports(String className, Set<String> imports, 			Set<String> visited) throws IOException;1351673950;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param className the class name to search_@param imports the imports collected so far or {@code null}_@param visited used to track visited classes to prevent infinite recursion (must not be null)_@return a set of all {@link Import#value() import values} or {@code null}_@throws IOException if there is any problem reading metadata from the named class;private Set<String> getImports(String className, Set<String> imports,_			Set<String> visited) throws IOException {_		if (visited.add(className)) {_			AnnotationMetadata metadata = metadataReaderFactory.getMetadataReader(className).getAnnotationMetadata()__			Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__			if (attributes != null) {_				String[] value = (String[]) attributes.get("value")__				if (value != null && value.length > 0) {_					imports = (imports == null ? new LinkedHashSet<String>() : imports)__					imports.addAll(Arrays.asList(value))__				}_			}_			for (String annotationType : metadata.getAnnotationTypes()) {_				getImports(annotationType, imports, visited)__			}_		}_		return imports__	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,class,name,the,class,name,to,search,param,imports,the,imports,collected,so,far,or,code,null,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,must,not,be,null,return,a,set,of,all,link,import,value,import,values,or,code,null,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,set,string,get,imports,string,class,name,set,string,imports,set,string,visited,throws,ioexception,if,visited,add,class,name,annotation,metadata,metadata,metadata,reader,factory,get,metadata,reader,class,name,get,annotation,metadata,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,value,null,value,length,0,imports,imports,null,new,linked,hash,set,string,imports,imports,add,all,arrays,as,list,value,for,string,annotation,type,metadata,get,annotation,types,get,imports,annotation,type,imports,visited,return,imports
ConfigurationClassParser -> private Set<String> getImports(String className, Set<String> imports, 			Set<String> visited) throws IOException;1351701017;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param className the class name to search_@param imports the imports collected so far or {@code null}_@param visited used to track visited classes to prevent infinite recursion (must not be null)_@return a set of all {@link Import#value() import values} or {@code null}_@throws IOException if there is any problem reading metadata from the named class;private Set<String> getImports(String className, Set<String> imports,_			Set<String> visited) throws IOException {_		if (visited.add(className)) {_			AnnotationMetadata metadata = metadataReaderFactory.getMetadataReader(className).getAnnotationMetadata()__			for (String annotationType : metadata.getAnnotationTypes()) {_				imports = getImports(annotationType, imports, visited)__			}_			Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__			if (attributes != null) {_				String[] value = (String[]) attributes.get("value")__				if (value != null && value.length > 0) {_					imports = (imports == null ? new LinkedHashSet<String>() : imports)__					imports.addAll(Arrays.asList(value))__				}_			}_		}_		return imports__	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,class,name,the,class,name,to,search,param,imports,the,imports,collected,so,far,or,code,null,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,must,not,be,null,return,a,set,of,all,link,import,value,import,values,or,code,null,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,set,string,get,imports,string,class,name,set,string,imports,set,string,visited,throws,ioexception,if,visited,add,class,name,annotation,metadata,metadata,metadata,reader,factory,get,metadata,reader,class,name,get,annotation,metadata,for,string,annotation,type,metadata,get,annotation,types,imports,get,imports,annotation,type,imports,visited,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,value,null,value,length,0,imports,imports,null,new,linked,hash,set,string,imports,imports,add,all,arrays,as,list,value,return,imports
ConfigurationClassParser -> private Set<String> getImports(String className, Set<String> imports, 			Set<String> visited) throws IOException;1352741263;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param className the class name to search_@param imports the imports collected so far or {@code null}_@param visited used to track visited classes to prevent infinite recursion (must not be null)_@return a set of all {@link Import#value() import values} or {@code null}_@throws IOException if there is any problem reading metadata from the named class;private Set<String> getImports(String className, Set<String> imports,_			Set<String> visited) throws IOException {_		if (visited.add(className)) {_			AnnotationMetadata metadata = metadataReaderFactory.getMetadataReader(className).getAnnotationMetadata()__			for (String annotationType : metadata.getAnnotationTypes()) {_				imports = getImports(annotationType, imports, visited)__			}_			Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__			if (attributes != null) {_				String[] value = (String[]) attributes.get("value")__				if (value != null && value.length > 0) {_					imports = (imports == null ? new LinkedHashSet<String>() : imports)__					imports.addAll(Arrays.asList(value))__				}_			}_		}_		return imports__	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,class,name,the,class,name,to,search,param,imports,the,imports,collected,so,far,or,code,null,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,must,not,be,null,return,a,set,of,all,link,import,value,import,values,or,code,null,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,set,string,get,imports,string,class,name,set,string,imports,set,string,visited,throws,ioexception,if,visited,add,class,name,annotation,metadata,metadata,metadata,reader,factory,get,metadata,reader,class,name,get,annotation,metadata,for,string,annotation,type,metadata,get,annotation,types,imports,get,imports,annotation,type,imports,visited,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,value,null,value,length,0,imports,imports,null,new,linked,hash,set,string,imports,imports,add,all,arrays,as,list,value,return,imports
ConfigurationClassParser -> private Set<String> getImports(String className, Set<String> imports, 			Set<String> visited) throws IOException;1354731125;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param className the class name to search_@param imports the imports collected so far or {@code null}_@param visited used to track visited classes to prevent infinite recursion (must not be null)_@return a set of all {@link Import#value() import values} or {@code null}_@throws IOException if there is any problem reading metadata from the named class;private Set<String> getImports(String className, Set<String> imports,_			Set<String> visited) throws IOException {_		if (visited.add(className)) {_			AnnotationMetadata metadata = metadataReaderFactory.getMetadataReader(className).getAnnotationMetadata()__			for (String annotationType : metadata.getAnnotationTypes()) {_				imports = getImports(annotationType, imports, visited)__			}_			Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__			if (attributes != null) {_				String[] value = (String[]) attributes.get("value")__				if (value != null && value.length > 0) {_					imports = (imports == null ? new LinkedHashSet<String>() : imports)__					imports.addAll(Arrays.asList(value))__				}_			}_		}_		return imports__	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,class,name,the,class,name,to,search,param,imports,the,imports,collected,so,far,or,code,null,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,must,not,be,null,return,a,set,of,all,link,import,value,import,values,or,code,null,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,set,string,get,imports,string,class,name,set,string,imports,set,string,visited,throws,ioexception,if,visited,add,class,name,annotation,metadata,metadata,metadata,reader,factory,get,metadata,reader,class,name,get,annotation,metadata,for,string,annotation,type,metadata,get,annotation,types,imports,get,imports,annotation,type,imports,visited,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,value,null,value,length,0,imports,imports,null,new,linked,hash,set,string,imports,imports,add,all,arrays,as,list,value,return,imports
ConfigurationClassParser -> private Set<String> getImports(String className, Set<String> imports, 			Set<String> visited) throws IOException;1356735495;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param className the class name to search_@param imports the imports collected so far or {@code null}_@param visited used to track visited classes to prevent infinite recursion (must not be null)_@return a set of all {@link Import#value() import values} or {@code null}_@throws IOException if there is any problem reading metadata from the named class;private Set<String> getImports(String className, Set<String> imports,_			Set<String> visited) throws IOException {_		if (visited.add(className)) {_			AnnotationMetadata metadata = metadataReaderFactory.getMetadataReader(className).getAnnotationMetadata()__			for (String annotationType : metadata.getAnnotationTypes()) {_				imports = getImports(annotationType, imports, visited)__			}_			Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__			if (attributes != null) {_				String[] value = (String[]) attributes.get("value")__				if (value != null && value.length > 0) {_					imports = (imports == null ? new LinkedHashSet<String>() : imports)__					imports.addAll(Arrays.asList(value))__				}_			}_		}_		return imports__	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,class,name,the,class,name,to,search,param,imports,the,imports,collected,so,far,or,code,null,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,must,not,be,null,return,a,set,of,all,link,import,value,import,values,or,code,null,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,set,string,get,imports,string,class,name,set,string,imports,set,string,visited,throws,ioexception,if,visited,add,class,name,annotation,metadata,metadata,metadata,reader,factory,get,metadata,reader,class,name,get,annotation,metadata,for,string,annotation,type,metadata,get,annotation,types,imports,get,imports,annotation,type,imports,visited,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,value,null,value,length,0,imports,imports,null,new,linked,hash,set,string,imports,imports,add,all,arrays,as,list,value,return,imports
ConfigurationClassParser -> private Set<String> getImports(String className, Set<String> imports, 			Set<String> visited) throws IOException;1357119239;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param className the class name to search_@param imports the imports collected so far or {@code null}_@param visited used to track visited classes to prevent infinite recursion (must not be null)_@return a set of all {@link Import#value() import values} or {@code null}_@throws IOException if there is any problem reading metadata from the named class;private Set<String> getImports(String className, Set<String> imports,_			Set<String> visited) throws IOException {_		if (visited.add(className)) {_			AnnotationMetadata metadata = metadataReaderFactory.getMetadataReader(className).getAnnotationMetadata()__			for (String annotationType : metadata.getAnnotationTypes()) {_				imports = getImports(annotationType, imports, visited)__			}_			Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true)__			if (attributes != null) {_				String[] value = (String[]) attributes.get("value")__				if (value != null && value.length > 0) {_					imports = (imports == null ? new LinkedHashSet<String>() : imports)__					imports.addAll(Arrays.asList(value))__				}_			}_		}_		return imports__	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,class,name,the,class,name,to,search,param,imports,the,imports,collected,so,far,or,code,null,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,must,not,be,null,return,a,set,of,all,link,import,value,import,values,or,code,null,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,set,string,get,imports,string,class,name,set,string,imports,set,string,visited,throws,ioexception,if,visited,add,class,name,annotation,metadata,metadata,metadata,reader,factory,get,metadata,reader,class,name,get,annotation,metadata,for,string,annotation,type,metadata,get,annotation,types,imports,get,imports,annotation,type,imports,visited,map,string,object,attributes,metadata,get,annotation,attributes,import,class,get,name,true,if,attributes,null,string,value,string,attributes,get,value,if,value,null,value,length,0,imports,imports,null,new,linked,hash,set,string,imports,imports,add,all,arrays,as,list,value,return,imports
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1367880232;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1368068203;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1368482696;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1368621032;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1368631197;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1372363092;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1374264616;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1375216602;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1377269365;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1377562322;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1377625191;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1377640854;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1381881109;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1382386279;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1382465750;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1384512601;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1385158940;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1385412762;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1385978370;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1393377752;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1394195941;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1397058189;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1398637994;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1398720297;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1400245582;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1402056098;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1405454692;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1407857001;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1408653788;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1408681275;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1408708479;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1408748821;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1409688471;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1409716050;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1409741991;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1410880110;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1411076915;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1411110630;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1411165756;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1413937661;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1414616928;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1426780215;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1427137082;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1433381203;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1434009363;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1434375974;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1451421608;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1452685588;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1453827605;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1456179950;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1464381249;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1467730834;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1468583965;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1468595845;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1468948866;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1469629308;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(Object importStrategyBean);1469657173;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code bean}.;private void invokeAwareMethods(Object importStrategyBean) {_		if (importStrategyBean instanceof Aware) {_			if (importStrategyBean instanceof EnvironmentAware) {_				((EnvironmentAware) importStrategyBean).setEnvironment(this.environment)__			}_			if (importStrategyBean instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) importStrategyBean).setResourceLoader(this.resourceLoader)__			}_			if (importStrategyBean instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) importStrategyBean).setBeanClassLoader(classLoader)__			}_			if (importStrategyBean instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) importStrategyBean).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,bean;private,void,invoke,aware,methods,object,import,strategy,bean,if,import,strategy,bean,instanceof,aware,if,import,strategy,bean,instanceof,environment,aware,environment,aware,import,strategy,bean,set,environment,this,environment,if,import,strategy,bean,instanceof,resource,loader,aware,resource,loader,aware,import,strategy,bean,set,resource,loader,this,resource,loader,if,import,strategy,bean,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,import,strategy,bean,set,bean,class,loader,class,loader,if,import,strategy,bean,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,import,strategy,bean,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> SourceClass asSourceClass(Class<?> classType) throws IOException;1486994827;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(Class<?> classType) throws IOException;1491319023;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(Class<?> classType) throws IOException;1491903930;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(Class<?> classType) throws IOException;1492434334;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(Class<?> classType) throws IOException;1495868221;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> SourceClass asSourceClass(Class<?> classType) throws IOException;1496263893;Factory method to obtain a {@link SourceClass} from a {@link Class}.;SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) 			throws ClassNotFoundException, IOException;1372363092;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType)_			throws ClassNotFoundException, IOException {_		try {_			_			classType.getAnnotations()__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_		return new SourceClass(classType)__	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,class,not,found,exception,ioexception,try,class,type,get,annotations,catch,throwable,ex,return,as,source,class,class,type,get,name,return,new,source,class,class,type
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) 			throws ClassNotFoundException, IOException;1374264616;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType)_			throws ClassNotFoundException, IOException {_		try {_			_			classType.getAnnotations()__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_		return new SourceClass(classType)__	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,class,not,found,exception,ioexception,try,class,type,get,annotations,catch,throwable,ex,return,as,source,class,class,type,get,name,return,new,source,class,class,type
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1375216602;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1377269365;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1377562322;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1377625191;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1377640854;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1381881109;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1382386279;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1382465750;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1384512601;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1385158940;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1385412762;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1385978370;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1393377752;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1394195941;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1397058189;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1398637994;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1398720297;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1400245582;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1402056098;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1405454692;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1407857001;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1408653788;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1408681275;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1408708479;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1408748821;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1409688471;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1409716050;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1409741991;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1410880110;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1411076915;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1411110630;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1411165756;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1413937661;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1414616928;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1426780215;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1427137082;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1433381203;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1434009363;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1434375974;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1451421608;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1452685588;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1453827605;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1456179950;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1464381249;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1467730834;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1468583965;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1468595845;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1468948866;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1469629308;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1469657173;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1473796164;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1477860027;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1481292081;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(configurationClass.getMetadata().getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1482521352;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1482524610;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1482746422;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1485175042;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1486719670;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, 			ResourceLoader resourceLoader, BeanNameGenerator beanNameGenerator, 			BeanDefinitionRegistry registry);1329393628;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment,_			ResourceLoader resourceLoader, BeanNameGenerator beanNameGenerator,_			BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, beanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, 			ResourceLoader resourceLoader, BeanNameGenerator beanNameGenerator, 			BeanDefinitionRegistry registry);1329743944;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment,_			ResourceLoader resourceLoader, BeanNameGenerator beanNameGenerator,_			BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, beanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, 			ResourceLoader resourceLoader, BeanNameGenerator beanNameGenerator, 			BeanDefinitionRegistry registry);1329744111;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment,_			ResourceLoader resourceLoader, BeanNameGenerator beanNameGenerator,_			BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, beanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, 			ResourceLoader resourceLoader, BeanNameGenerator beanNameGenerator, 			BeanDefinitionRegistry registry);1347282850;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment,_			ResourceLoader resourceLoader, BeanNameGenerator beanNameGenerator,_			BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, beanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,bean,name,generator,registry
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, 			AnnotationMetadata metadata) throws IOException;1368068203;Register member (nested) classes that happen to be configuration classes themselves._@param metadata the metadata representation of the containing class_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass,_			AnnotationMetadata metadata) throws IOException {_		if (metadata instanceof StandardAnnotationMetadata) {_			for (Class<?> memberClass : ((StandardAnnotationMetadata) metadata).getIntrospectedClass().getDeclaredClasses()) {_				if (ConfigurationClassUtils.isConfigurationCandidate(new StandardAnnotationMetadata(memberClass))) {_					processConfigurationClass(new ConfigurationClass(memberClass, configClass))__				}_			}_		}_		else {_			for (String memberClassName : metadata.getMemberClassNames()) {_				MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__				AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__				if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_					processConfigurationClass(new ConfigurationClass(reader, configClass))__				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,metadata,the,metadata,representation,of,the,containing,class,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,if,metadata,instanceof,standard,annotation,metadata,for,class,member,class,standard,annotation,metadata,metadata,get,introspected,class,get,declared,classes,if,configuration,class,utils,is,configuration,candidate,new,standard,annotation,metadata,member,class,process,configuration,class,new,configuration,class,member,class,config,class,else,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, 			AnnotationMetadata metadata) throws IOException;1368482696;Register member (nested) classes that happen to be configuration classes themselves._@param metadata the metadata representation of the containing class_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass,_			AnnotationMetadata metadata) throws IOException {_		if (metadata instanceof StandardAnnotationMetadata) {_			for (Class<?> memberClass : ((StandardAnnotationMetadata) metadata).getIntrospectedClass().getDeclaredClasses()) {_				if (ConfigurationClassUtils.isConfigurationCandidate(new StandardAnnotationMetadata(memberClass))) {_					processConfigurationClass(new ConfigurationClass(memberClass, configClass))__				}_			}_		}_		else {_			for (String memberClassName : metadata.getMemberClassNames()) {_				MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__				AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__				if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_					processConfigurationClass(new ConfigurationClass(reader, configClass))__				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,metadata,the,metadata,representation,of,the,containing,class,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,if,metadata,instanceof,standard,annotation,metadata,for,class,member,class,standard,annotation,metadata,metadata,get,introspected,class,get,declared,classes,if,configuration,class,utils,is,configuration,candidate,new,standard,annotation,metadata,member,class,process,configuration,class,new,configuration,class,member,class,config,class,else,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,config,class
ConfigurationClassParser -> private void processMemberClasses(ConfigurationClass configClass, 			AnnotationMetadata metadata) throws IOException;1368621032;Register member (nested) classes that happen to be configuration classes themselves._@param metadata the metadata representation of the containing class_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(ConfigurationClass configClass,_			AnnotationMetadata metadata) throws IOException {_		if (metadata instanceof StandardAnnotationMetadata) {_			for (Class<?> memberClass : ((StandardAnnotationMetadata) metadata).getIntrospectedClass().getDeclaredClasses()) {_				if (ConfigurationClassUtils.isConfigurationCandidate(new StandardAnnotationMetadata(memberClass))) {_					processConfigurationClass(new ConfigurationClass(memberClass, configClass))__				}_			}_		}_		else {_			for (String memberClassName : metadata.getMemberClassNames()) {_				MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__				AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__				if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_					processConfigurationClass(new ConfigurationClass(reader, configClass))__				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,metadata,the,metadata,representation,of,the,containing,class,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,configuration,class,config,class,annotation,metadata,metadata,throws,ioexception,if,metadata,instanceof,standard,annotation,metadata,for,class,member,class,standard,annotation,metadata,metadata,get,introspected,class,get,declared,classes,if,configuration,class,utils,is,configuration,candidate,new,standard,annotation,metadata,member,class,process,configuration,class,new,configuration,class,member,class,config,class,else,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,config,class
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1520974346;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1522360217;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1525267242;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1530174524;Factory method to obtain {@link SourceClass SourceClasss} from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,source,classs,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1530174524;Factory method to obtain {@link SourceClass SourceClasss} from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,source,classs,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1530190293;Factory method to obtain {@link SourceClass SourceClasss} from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,source,classs,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1532091916;Factory method to obtain {@link SourceClass SourceClasss} from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,source,classs,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1536317783;Factory method to obtain {@link SourceClass SourceClasss} from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,source,classs,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1536753765;Factory method to obtain {@link SourceClass SourceClasss} from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,source,classs,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1537204195;Factory method to obtain {@link SourceClass SourceClasss} from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,source,classs,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1539159551;Factory method to obtain {@link SourceClass SourceClasss} from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,source,classs,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1539161108;Factory method to obtain {@link SourceClass SourceClasss} from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,source,classs,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1551093117;Factory method to obtain {@link SourceClass SourceClasss} from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,source,classs,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException;1551113869;Factory method to obtain {@link SourceClass SourceClasss} from class names.;private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,source,classs,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1405454692;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1407857001;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1408653788;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1408681275;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1408708479;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1408748821;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1409688471;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1409716050;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1409741991;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1410880110;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1411076915;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1411110630;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1411165756;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1413937661;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1414616928;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1426780215;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1427137082;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1433381203;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1434009363;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1434375974;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1451421608;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1452685588;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1453827605;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1456179950;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1464381249;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1467730834;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1468583965;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1468595845;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1468948866;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1469629308;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1469657173;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1473796164;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1477860027;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1481292081;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1482521352;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1482524610;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1482746422;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1485175042;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> public SourceClass asSourceClass(String className) throws IOException;1486719670;Factory method to obtain a {@link SourceClass} from a class name.;public SourceClass asSourceClass(String className) throws IOException {_		if (className.startsWith("java")) {_			_			try {_				return new SourceClass(this.resourceLoader.getClassLoader().loadClass(className))__			}_			catch (ClassNotFoundException ex) {_				throw new NestedIOException("Failed to load class [" + className + "]", ex)__			}_		}_		return new SourceClass(this.metadataReaderFactory.getMetadataReader(className))__	};factory,method,to,obtain,a,link,source,class,from,a,class,name;public,source,class,as,source,class,string,class,name,throws,ioexception,if,class,name,starts,with,java,try,return,new,source,class,this,resource,loader,get,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,nested,ioexception,failed,to,load,class,class,name,ex,return,new,source,class,this,metadata,reader,factory,get,metadata,reader,class,name
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1492434334;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1495868221;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1496263893;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1496837955;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1498780456;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1502974979;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1511268177;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1515777832;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1518772998;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1520858426;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1520974346;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1522360217;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1525267242;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1530174524;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1530174524;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1530190293;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1532091916;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1536317783;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1536753765;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1537204195;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1539159551;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1539161108;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1551093117;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) 			throws IOException;1551113869;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values_ the usual process of returning values from the first_meta-annotation on a class is not sufficient._<p>For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation._@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)_			throws IOException {__		if (visited.add(sourceClass)) {_			for (SourceClass annotation : sourceClass.getAnnotations()) {_				String annName = annotation.getMetadata().getClassName()__				if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {_					collectImports(annotation, imports, visited)__				}_			}_			imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,of,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,string,ann,name,annotation,get,metadata,get,class,name,if,ann,name,starts,with,java,ann,name,equals,import,class,get,name,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1405454692;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1407857001;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1408653788;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1408681275;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1408708479;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1408748821;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1409688471;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1409716050;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1409741991;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1410880110;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1411076915;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1411110630;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1411165756;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1413937661;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1414616928;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1426780215;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1427137082;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1433381203;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1434009363;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1434375974;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1451421608;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1452685588;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1453827605;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1456179950;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1464381249;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1467730834;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1468583965;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1468595845;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1468948866;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1469629308;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1469657173;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1473796164;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1477860027;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1481292081;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1482521352;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1482524610;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1482746422;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1485175042;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException;1486719670;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> private void processMemberClasses(AnnotationMetadata metadata) throws IOException;1366717765;Register member (nested) classes that happen to be configuration classes themselves._@param metadata the metadata representation of the containing class_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(AnnotationMetadata metadata) throws IOException {_		if (metadata instanceof StandardAnnotationMetadata) {_			for (Class<?> memberClass : ((StandardAnnotationMetadata) metadata).getIntrospectedClass().getDeclaredClasses()) {_				if (ConfigurationClassUtils.isConfigurationCandidate(new StandardAnnotationMetadata(memberClass))) {_					processConfigurationClass(new ConfigurationClass(memberClass, true))__				}_			}_		}_		else {_			for (String memberClassName : metadata.getMemberClassNames()) {_				MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__				AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__				if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_					processConfigurationClass(new ConfigurationClass(reader, true))__				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,metadata,the,metadata,representation,of,the,containing,class,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,annotation,metadata,metadata,throws,ioexception,if,metadata,instanceof,standard,annotation,metadata,for,class,member,class,standard,annotation,metadata,metadata,get,introspected,class,get,declared,classes,if,configuration,class,utils,is,configuration,candidate,new,standard,annotation,metadata,member,class,process,configuration,class,new,configuration,class,member,class,true,else,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true
ConfigurationClassParser -> private void processMemberClasses(AnnotationMetadata metadata) throws IOException;1367880232;Register member (nested) classes that happen to be configuration classes themselves._@param metadata the metadata representation of the containing class_@throws IOException if there is any problem reading metadata from a member class;private void processMemberClasses(AnnotationMetadata metadata) throws IOException {_		if (metadata instanceof StandardAnnotationMetadata) {_			for (Class<?> memberClass : ((StandardAnnotationMetadata) metadata).getIntrospectedClass().getDeclaredClasses()) {_				if (ConfigurationClassUtils.isConfigurationCandidate(new StandardAnnotationMetadata(memberClass))) {_					processConfigurationClass(new ConfigurationClass(memberClass, true))__				}_			}_		}_		else {_			for (String memberClassName : metadata.getMemberClassNames()) {_				MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName)__				AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata()__				if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {_					processConfigurationClass(new ConfigurationClass(reader, true))__				}_			}_		}_	};register,member,nested,classes,that,happen,to,be,configuration,classes,themselves,param,metadata,the,metadata,representation,of,the,containing,class,throws,ioexception,if,there,is,any,problem,reading,metadata,from,a,member,class;private,void,process,member,classes,annotation,metadata,metadata,throws,ioexception,if,metadata,instanceof,standard,annotation,metadata,for,class,member,class,standard,annotation,metadata,metadata,get,introspected,class,get,declared,classes,if,configuration,class,utils,is,configuration,candidate,new,standard,annotation,metadata,member,class,process,configuration,class,new,configuration,class,member,class,true,else,for,string,member,class,name,metadata,get,member,class,names,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,member,class,name,annotation,metadata,member,class,metadata,reader,get,annotation,metadata,if,configuration,class,utils,is,configuration,candidate,member,class,metadata,process,configuration,class,new,configuration,class,reader,true
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass( 			ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1372363092;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(_			ConfigurationClass configClass, SourceClass sourceClass) throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		AnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				configClass.addImportedResource(resource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,annotation,attributes,property,source,attributes,for,source,class,get,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,config,class,add,imported,resource,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> protected final SourceClass doProcessConfigurationClass( 			ConfigurationClass configClass, SourceClass sourceClass) throws IOException;1374264616;Apply processing and build a complete {@link ConfigurationClass} by reading the_annotations, members and methods from the source class. This method can be called_multiple times as relevant sources are discovered._@param configClass the configuration class being build_@param sourceClass a source class_@return the superclass, {@code null} if none found or previously processed;protected final SourceClass doProcessConfigurationClass(_			ConfigurationClass configClass, SourceClass sourceClass) throws IOException {__		_		processMemberClasses(configClass, sourceClass)___		_		AnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class)__		if (propertySource != null) {_			processPropertySource(propertySource)__		}__		_		AnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class)__		if (componentScan != null) {_			_			if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {_				Set<BeanDefinitionHolder> scannedBeanDefinitions =_						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())___				_				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {_					if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {_						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName())__					}_				}_			}_		}__		_		processImports(configClass, getImports(sourceClass), true)___		_		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {_			AnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class)__			String[] resources = importResource.getStringArray("value")__			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader")__			for (String resource : resources) {_				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource)__				configClass.addImportedResource(resolvedResource, readerClass)__			}_		}__		_		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName())__		for (MethodMetadata methodMetadata : beanMethods) {_			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))__		}__		_		if (sourceClass.getMetadata().hasSuperClass()) {_			String superclass = sourceClass.getMetadata().getSuperClassName()__			if (!this.knownSuperclasses.containsKey(superclass)) {_				this.knownSuperclasses.put(superclass, configClass)__				_				try {_					return sourceClass.getSuperClass()__				}_				catch (ClassNotFoundException ex) {_					throw new IllegalStateException(ex)__				}_			}_		}__		_		return null__	};apply,processing,and,build,a,complete,link,configuration,class,by,reading,the,annotations,members,and,methods,from,the,source,class,this,method,can,be,called,multiple,times,as,relevant,sources,are,discovered,param,config,class,the,configuration,class,being,build,param,source,class,a,source,class,return,the,superclass,code,null,if,none,found,or,previously,processed;protected,final,source,class,do,process,configuration,class,configuration,class,config,class,source,class,source,class,throws,ioexception,process,member,classes,config,class,source,class,annotation,attributes,property,source,attributes,for,source,class,get,metadata,org,springframework,context,annotation,property,source,class,if,property,source,null,process,property,source,property,source,annotation,attributes,component,scan,attributes,for,source,class,get,metadata,component,scan,class,if,component,scan,null,if,condition,evaluator,should,skip,source,class,get,metadata,configuration,phase,set,bean,definition,holder,scanned,bean,definitions,this,component,scan,parser,parse,component,scan,source,class,get,metadata,get,class,name,for,bean,definition,holder,holder,scanned,bean,definitions,if,configuration,class,utils,check,configuration,class,candidate,holder,get,bean,definition,this,metadata,reader,factory,parse,holder,get,bean,definition,get,bean,class,name,holder,get,bean,name,process,imports,config,class,get,imports,source,class,true,if,source,class,get,metadata,is,annotated,import,resource,class,get,name,annotation,attributes,import,resource,attributes,for,source,class,get,metadata,import,resource,class,string,resources,import,resource,get,string,array,value,class,extends,bean,definition,reader,reader,class,import,resource,get,class,reader,for,string,resource,resources,string,resolved,resource,this,environment,resolve,required,placeholders,resource,config,class,add,imported,resource,resolved,resource,reader,class,set,method,metadata,bean,methods,source,class,get,metadata,get,annotated,methods,bean,class,get,name,for,method,metadata,method,metadata,bean,methods,config,class,add,bean,method,new,bean,method,method,metadata,config,class,if,source,class,get,metadata,has,super,class,string,superclass,source,class,get,metadata,get,super,class,name,if,this,known,superclasses,contains,key,superclass,this,known,superclasses,put,superclass,config,class,try,return,source,class,get,super,class,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex,return,null
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1482521352;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				beanMethods = asm.getAnnotatedMethods(Bean.class.getName())__			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,bean,methods,asm,get,annotated,methods,bean,class,get,name,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1482524610;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				beanMethods = asm.getAnnotatedMethods(Bean.class.getName())__			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,bean,methods,asm,get,annotated,methods,bean,class,get,name,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1482746422;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				Set<MethodMetadata> reflectionMethods = beanMethods__				beanMethods = new LinkedHashSet<>()__				for (MethodMetadata asmMethod : asmMethods) {_					for (MethodMetadata reflectionMethod : reflectionMethods) {_						if (reflectionMethod.getMethodName().equals(asmMethod.getMethodName())) {_							beanMethods.add(reflectionMethod)__							break__						}_					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,set,method,metadata,reflection,methods,bean,methods,bean,methods,new,linked,hash,set,for,method,metadata,asm,method,asm,methods,for,method,metadata,reflection,method,reflection,methods,if,reflection,method,get,method,name,equals,asm,method,get,method,name,bean,methods,add,reflection,method,break,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1485175042;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1486719670;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1486994827;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1491319023;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1491903930;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1492434334;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1495868221;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1496263893;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1496837955;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1498780456;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1502974979;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1511268177;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1515777832;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1518772998;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1520858426;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1520974346;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1522360217;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1525267242;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1530174524;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1530174524;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1530190293;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1532091916;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1536317783;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1536753765;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1537204195;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1539159551;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1539161108;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1551093117;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass);1551113869;Retrieve the metadata for all <code>@Bean</code> methods.;private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {_		AnnotationMetadata original = sourceClass.getMetadata()__		Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName())__		if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {_			_			_			_			try {_				AnnotationMetadata asm =_						this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata()__				Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName())__				if (asmMethods.size() >= beanMethods.size()) {_					Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size())__					for (MethodMetadata asmMethod : asmMethods) {_						for (MethodMetadata beanMethod : beanMethods) {_							if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {_								selectedMethods.add(beanMethod)__								break__							}_						}_					}_					if (selectedMethods.size() == beanMethods.size()) {_						_						beanMethods = selectedMethods__					}_				}_			}_			catch (IOException ex) {_				logger.debug("Failed to read class file via ASM for determining @Bean method order", ex)__				_			}_		}_		return beanMethods__	};retrieve,the,metadata,for,all,code,bean,code,methods;private,set,method,metadata,retrieve,bean,method,metadata,source,class,source,class,annotation,metadata,original,source,class,get,metadata,set,method,metadata,bean,methods,original,get,annotated,methods,bean,class,get,name,if,bean,methods,size,1,original,instanceof,standard,annotation,metadata,try,annotation,metadata,asm,this,metadata,reader,factory,get,metadata,reader,original,get,class,name,get,annotation,metadata,set,method,metadata,asm,methods,asm,get,annotated,methods,bean,class,get,name,if,asm,methods,size,bean,methods,size,set,method,metadata,selected,methods,new,linked,hash,set,asm,methods,size,for,method,metadata,asm,method,asm,methods,for,method,metadata,bean,method,bean,methods,if,bean,method,get,method,name,equals,asm,method,get,method,name,selected,methods,add,bean,method,break,if,selected,methods,size,bean,methods,size,bean,methods,selected,methods,catch,ioexception,ex,logger,debug,failed,to,read,class,file,via,asm,for,determining,bean,method,order,ex,return,bean,methods
ConfigurationClassParser -> protected void parse(Class<?> clazz, String beanName) throws IOException;1368068203;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected void parse(Class<?> clazz, String beanName) throws IOException;1368482696;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1372363092;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1374264616;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1375216602;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1377269365;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1377562322;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1377625191;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1377640854;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1381881109;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1382386279;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1382465750;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1384512601;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1385158940;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1385412762;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1385978370;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1393377752;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1394195941;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1397058189;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1398637994;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1398720297;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1400245582;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1402056098;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1405454692;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1407857001;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1408653788;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1408681275;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1408708479;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1408748821;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1409688471;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1409716050;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1409741991;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1410880110;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1411076915;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1411110630;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1411165756;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> protected final void parse(Class<?> clazz, String beanName) throws IOException;1413937661;Parse the specified {@link Configuration @Configuration} class._@param clazz the Class to parse_@param beanName must not be null (as of Spring 3.1.1);protected final void parse(Class<?> clazz, String beanName) throws IOException {_		processConfigurationClass(new ConfigurationClass(clazz, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,clazz,the,class,to,parse,param,bean,name,must,not,be,null,as,of,spring,3,1,1;protected,final,void,parse,class,clazz,string,bean,name,throws,ioexception,process,configuration,class,new,configuration,class,clazz,bean,name
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, 			Set<SourceClass> visited) throws IOException;1372363092;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>_For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation.__@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports,_			Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					if(!annotation.getMetadata().getClassName().startsWith("java") && !annotation.isAssignable(Import.class)) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,if,annotation,get,metadata,get,class,name,starts,with,java,annotation,is,assignable,import,class,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, 			Set<SourceClass> visited) throws IOException;1374264616;Recursively collect all declared {@code @Import} values. Unlike most_meta-annotations it is valid to have several {@code @Import}s declared with_different values, the usual process or returning values from the first_meta-annotation on a class is not sufficient._<p>_For example, it is common for a {@code @Configuration} class to declare direct_{@code @Import}s in addition to meta-imports originating from an {@code @Enable}_annotation.__@param sourceClass the class to search_@param imports the imports collected so far_@param visited used to track visited classes to prevent infinite recursion_@throws IOException if there is any problem reading metadata from the named class;private void collectImports(SourceClass sourceClass, Set<SourceClass> imports,_			Set<SourceClass> visited) throws IOException {_		try {_			if (visited.add(sourceClass)) {_				for (SourceClass annotation : sourceClass.getAnnotations()) {_					if(!annotation.getMetadata().getClassName().startsWith("java") && !annotation.isAssignable(Import.class)) {_						collectImports(annotation, imports, visited)__					}_				}_				imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"))__			}_		}_		catch (ClassNotFoundException ex) {_			throw new NestedIOException("Unable to collect imports", ex)__		}_	};recursively,collect,all,declared,code,import,values,unlike,most,meta,annotations,it,is,valid,to,have,several,code,import,s,declared,with,different,values,the,usual,process,or,returning,values,from,the,first,meta,annotation,on,a,class,is,not,sufficient,p,for,example,it,is,common,for,a,code,configuration,class,to,declare,direct,code,import,s,in,addition,to,meta,imports,originating,from,an,code,enable,annotation,param,source,class,the,class,to,search,param,imports,the,imports,collected,so,far,param,visited,used,to,track,visited,classes,to,prevent,infinite,recursion,throws,ioexception,if,there,is,any,problem,reading,metadata,from,the,named,class;private,void,collect,imports,source,class,source,class,set,source,class,imports,set,source,class,visited,throws,ioexception,try,if,visited,add,source,class,for,source,class,annotation,source,class,get,annotations,if,annotation,get,metadata,get,class,name,starts,with,java,annotation,is,assignable,import,class,collect,imports,annotation,imports,visited,imports,add,all,source,class,get,annotation,attributes,import,class,get,name,value,catch,class,not,found,exception,ex,throw,new,nested,ioexception,unable,to,collect,imports,ex
ConfigurationClassParser -> public void validate();1328020251;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1329142650;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1329393628;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1329743944;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1329744111;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1347282850;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1347311780;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1347375001;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1351673950;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1351687206;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1351701017;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1352741263;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1354731125;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1356735495;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1357119239;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1362408075;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1366717765;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1367880232;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1368068203;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1368482696;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1368621032;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1368631197;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1372363092;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1374264616;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1375216602;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1377269365;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1377562322;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1377625191;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1377640854;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1381881109;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1382386279;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1382465750;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1384512601;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1385158940;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1385412762;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1385978370;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1393377752;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1394195941;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1397058189;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1398637994;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1398720297;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1400245582;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1402056098;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1405454692;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1407857001;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1408653788;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1408681275;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1408708479;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1408748821;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1409688471;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1409716050;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1409741991;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1410880110;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1411076915;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1411110630;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1411165756;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1413937661;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1414616928;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1426780215;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1427137082;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1433381203;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1434009363;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1434375974;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1451421608;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1452685588;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1453827605;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1456179950;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1464381249;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1467730834;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1468583965;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1468595845;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1468948866;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1469629308;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1469657173;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1473796164;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1477860027;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1481292081;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1482521352;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1482524610;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1482746422;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1485175042;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1486719670;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1486994827;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1491319023;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1491903930;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1492434334;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1495868221;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1496263893;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1496837955;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1498780456;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1502974979;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1511268177;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1515777832;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1518772998;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1520858426;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1520974346;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1522360217;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1525267242;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1530174524;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1530174524;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1530190293;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1532091916;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1536317783;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1536753765;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1537204195;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1539159551;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1539161108;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1551093117;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> public void validate();1551113869;Validate each {@link ConfigurationClass} object._@see ConfigurationClass#validate;public void validate() {_		for (ConfigurationClass configClass : this.configurationClasses.keySet()) {_			configClass.validate(this.problemReporter)__		}_	};validate,each,link,configuration,class,object,see,configuration,class,validate;public,void,validate,for,configuration,class,config,class,this,configuration,classes,key,set,config,class,validate,this,problem,reporter
ConfigurationClassParser -> DeferredImportSelectorHandler -> public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector);1539159551;Handle the specified {@link DeferredImportSelector}. If deferred import_selectors are being collected, this registers this instance to the list. If_they are being processed, the {@link DeferredImportSelector} is also processed_immediately according to its {@link DeferredImportSelector.Group}._@param configClass the source configuration class_@param importSelector the selector to handle;public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {_			DeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(_					configClass, importSelector)__			if (this.deferredImportSelectors == null) {_				DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler()__				handler.register(holder)__				handler.processGroupImports()__			}_			else {_				this.deferredImportSelectors.add(holder)__			}_		};handle,the,specified,link,deferred,import,selector,if,deferred,import,selectors,are,being,collected,this,registers,this,instance,to,the,list,if,they,are,being,processed,the,link,deferred,import,selector,is,also,processed,immediately,according,to,its,link,deferred,import,selector,group,param,config,class,the,source,configuration,class,param,import,selector,the,selector,to,handle;public,void,handle,configuration,class,config,class,deferred,import,selector,import,selector,deferred,import,selector,holder,holder,new,deferred,import,selector,holder,config,class,import,selector,if,this,deferred,import,selectors,null,deferred,import,selector,grouping,handler,handler,new,deferred,import,selector,grouping,handler,handler,register,holder,handler,process,group,imports,else,this,deferred,import,selectors,add,holder
ConfigurationClassParser -> DeferredImportSelectorHandler -> public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector);1539161108;Handle the specified {@link DeferredImportSelector}. If deferred import_selectors are being collected, this registers this instance to the list. If_they are being processed, the {@link DeferredImportSelector} is also processed_immediately according to its {@link DeferredImportSelector.Group}._@param configClass the source configuration class_@param importSelector the selector to handle;public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {_			DeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(_					configClass, importSelector)__			if (this.deferredImportSelectors == null) {_				DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler()__				handler.register(holder)__				handler.processGroupImports()__			}_			else {_				this.deferredImportSelectors.add(holder)__			}_		};handle,the,specified,link,deferred,import,selector,if,deferred,import,selectors,are,being,collected,this,registers,this,instance,to,the,list,if,they,are,being,processed,the,link,deferred,import,selector,is,also,processed,immediately,according,to,its,link,deferred,import,selector,group,param,config,class,the,source,configuration,class,param,import,selector,the,selector,to,handle;public,void,handle,configuration,class,config,class,deferred,import,selector,import,selector,deferred,import,selector,holder,holder,new,deferred,import,selector,holder,config,class,import,selector,if,this,deferred,import,selectors,null,deferred,import,selector,grouping,handler,handler,new,deferred,import,selector,grouping,handler,handler,register,holder,handler,process,group,imports,else,this,deferred,import,selectors,add,holder
ConfigurationClassParser -> DeferredImportSelectorHandler -> public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector);1551093117;Handle the specified {@link DeferredImportSelector}. If deferred import_selectors are being collected, this registers this instance to the list. If_they are being processed, the {@link DeferredImportSelector} is also processed_immediately according to its {@link DeferredImportSelector.Group}._@param configClass the source configuration class_@param importSelector the selector to handle;public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {_			DeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(_					configClass, importSelector)__			if (this.deferredImportSelectors == null) {_				DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler()__				handler.register(holder)__				handler.processGroupImports()__			}_			else {_				this.deferredImportSelectors.add(holder)__			}_		};handle,the,specified,link,deferred,import,selector,if,deferred,import,selectors,are,being,collected,this,registers,this,instance,to,the,list,if,they,are,being,processed,the,link,deferred,import,selector,is,also,processed,immediately,according,to,its,link,deferred,import,selector,group,param,config,class,the,source,configuration,class,param,import,selector,the,selector,to,handle;public,void,handle,configuration,class,config,class,deferred,import,selector,import,selector,deferred,import,selector,holder,holder,new,deferred,import,selector,holder,config,class,import,selector,if,this,deferred,import,selectors,null,deferred,import,selector,grouping,handler,handler,new,deferred,import,selector,grouping,handler,handler,register,holder,handler,process,group,imports,else,this,deferred,import,selectors,add,holder
ConfigurationClassParser -> DeferredImportSelectorHandler -> public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector);1551113869;Handle the specified {@link DeferredImportSelector}. If deferred import_selectors are being collected, this registers this instance to the list. If_they are being processed, the {@link DeferredImportSelector} is also processed_immediately according to its {@link DeferredImportSelector.Group}._@param configClass the source configuration class_@param importSelector the selector to handle;public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {_			DeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(_					configClass, importSelector)__			if (this.deferredImportSelectors == null) {_				DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler()__				handler.register(holder)__				handler.processGroupImports()__			}_			else {_				this.deferredImportSelectors.add(holder)__			}_		};handle,the,specified,link,deferred,import,selector,if,deferred,import,selectors,are,being,collected,this,registers,this,instance,to,the,list,if,they,are,being,processed,the,link,deferred,import,selector,is,also,processed,immediately,according,to,its,link,deferred,import,selector,group,param,config,class,the,source,configuration,class,param,import,selector,the,selector,to,handle;public,void,handle,configuration,class,config,class,deferred,import,selector,import,selector,deferred,import,selector,holder,holder,new,deferred,import,selector,holder,config,class,import,selector,if,this,deferred,import,selectors,null,deferred,import,selector,grouping,handler,handler,new,deferred,import,selector,grouping,handler,handler,register,holder,handler,process,group,imports,else,this,deferred,import,selectors,add,holder
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1328020251;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1329142650;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1329393628;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1329743944;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1329744111;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1347282850;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1347311780;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1347375001;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1351673950;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1351687206;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1351701017;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1352741263;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1354731125;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1356735495;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1357119239;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1362408075;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1366717765;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1367880232;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1368068203;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1368482696;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1368621032;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1368631197;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1372363092;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1374264616;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1375216602;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1377269365;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1377562322;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1377625191;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1377640854;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1381881109;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1382386279;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1382465750;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1384512601;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1385158940;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1385412762;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1385978370;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1393377752;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1394195941;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1397058189;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1398637994;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1398720297;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1400245582;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1402056098;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1405454692;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1407857001;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1408653788;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1408681275;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1408708479;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1408748821;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1409688471;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1409716050;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1409741991;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1410880110;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1411076915;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1411110630;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1411165756;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1413937661;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1414616928;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1426780215;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1427137082;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1433381203;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1434009363;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return (first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1)__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1434375974;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return (first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1)__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> ImportStack -> @Override 		public boolean contains(Object elem);1451421608;Simplified contains() implementation that tests to see if any {@link ConfigurationClass}_exists within this stack that has the same name as <var>elem</var>. Elem must be of_type ConfigurationClass.;@Override_		public boolean contains(Object elem) {_			ConfigurationClass configClass = (ConfigurationClass) elem__			Comparator<ConfigurationClass> comparator = new Comparator<ConfigurationClass>() {_				@Override_				public int compare(ConfigurationClass first, ConfigurationClass second) {_					return (first.getMetadata().getClassName().equals(second.getMetadata().getClassName()) ? 0 : 1)__				}_			}__			return (Collections.binarySearch(this, configClass, comparator) != -1)__		};simplified,contains,implementation,that,tests,to,see,if,any,link,configuration,class,exists,within,this,stack,that,has,the,same,name,as,var,elem,var,elem,must,be,of,type,configuration,class;override,public,boolean,contains,object,elem,configuration,class,config,class,configuration,class,elem,comparator,configuration,class,comparator,new,comparator,configuration,class,override,public,int,compare,configuration,class,first,configuration,class,second,return,first,get,metadata,get,class,name,equals,second,get,metadata,get,class,name,0,1,return,collections,binary,search,this,config,class,comparator,1
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1372363092;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1374264616;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1375216602;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1377269365;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1377562322;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1377625191;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1377640854;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1381881109;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1382386279;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1382465750;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1384512601;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1385158940;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1385412762;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1385978370;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1393377752;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1394195941;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1397058189;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1398637994;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1398720297;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1400245582;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1402056098;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1405454692;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1407857001;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1408653788;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1408681275;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1408708479;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1408748821;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1409688471;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1409716050;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1409741991;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1410880110;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1411076915;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1411110630;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1411165756;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1413937661;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1414616928;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1426780215;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1427137082;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1433381203;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1434009363;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1434375974;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1451421608;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1452685588;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1453827605;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1456179950;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1464381249;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<SourceClass>()__		Set<SourceClass> visited = new LinkedHashSet<SourceClass>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,source,class,set,source,class,visited,new,linked,hash,set,source,class,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1467730834;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1468583965;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1468595845;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1468948866;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1469629308;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1469657173;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1473796164;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1477860027;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1481292081;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1482521352;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1482524610;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1482746422;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1485175042;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1486719670;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1486994827;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1491319023;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1491903930;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1492434334;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1495868221;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1496263893;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1496837955;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1498780456;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1502974979;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1511268177;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1515777832;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1518772998;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1520858426;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1520974346;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1522360217;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1525267242;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1530174524;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1530174524;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1530190293;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1532091916;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1536317783;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1536753765;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1537204195;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1539159551;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1539161108;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1551093117;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException;1551113869;Returns {@code @Import} class, considering all meta-annotations.;private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {_		Set<SourceClass> imports = new LinkedHashSet<>()__		Set<SourceClass> visited = new LinkedHashSet<>()__		collectImports(sourceClass, imports, visited)__		return imports__	};returns,code,import,class,considering,all,meta,annotations;private,set,source,class,get,imports,source,class,source,class,throws,ioexception,set,source,class,imports,new,linked,hash,set,set,source,class,visited,new,linked,hash,set,collect,imports,source,class,imports,visited,return,imports
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1486994827;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1491319023;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1491903930;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1492434334;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1495868221;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1496263893;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1496837955;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1498780456;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1502974979;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1511268177;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1515777832;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1518772998;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1520858426;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1520974346;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1522360217;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1525267242;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1530174524;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1530174524;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1530190293;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1532091916;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1536317783;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1536753765;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1537204195;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1539159551;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1539161108;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1551093117;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException;1551113869;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;private SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {_		AnnotationMetadata metadata = configurationClass.getMetadata()__		if (metadata instanceof StandardAnnotationMetadata) {_			return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__		}_		return asSourceClass(metadata.getClassName())__	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;private,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,metadata,get,class,name
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1486994827;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1491319023;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1491903930;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1492434334;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1495868221;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1496263893;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1496837955;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1498780456;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1502974979;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1511268177;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1515777832;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1518772998;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1520858426;Factory method to obtain {@link SourceClass}s from class names.;private Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>(classNames.length)__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;private,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,class,names,length,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1328020251;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1329142650;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1329393628;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1329743944;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1329744111;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1347282850;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1347311780;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1347375001;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1351673950;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1351687206;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1351701017;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1352741263;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1354731125;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1356735495;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1357119239;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1362408075;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1366717765;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1367880232;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1368068203;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1368482696;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1368621032;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1368631197;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1372363092;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1374264616;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1375216602;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1377269365;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1377562322;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1377625191;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1377640854;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1381881109;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1382386279;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1382465750;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1384512601;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1385158940;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1385412762;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1385978370;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1393377752;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1394195941;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1397058189;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1398637994;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1398720297;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1400245582;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1402056098;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1405454692;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1407857001;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1408653788;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1408681275;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1408708479;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1408748821;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1409688471;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1409716050;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1409741991;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1410880110;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1411076915;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1411110630;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1411165756;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1413937661;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1414616928;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1426780215;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1427137082;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1433381203;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "ImportStack: [Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("ImportStack: [")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,import,stack,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,import,stack,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1434009363;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1434375974;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1451421608;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1452685588;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1453827605;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1456179950;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1464381249;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1467730834;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1468583965;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1468595845;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1468948866;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1469629308;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1469657173;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1473796164;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1477860027;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1481292081;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1482521352;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1482524610;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1482746422;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1485175042;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1486719670;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1486994827;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1491319023;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1491903930;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1492434334;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1495868221;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1496263893;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1496837955;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1498780456;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1502974979;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1511268177;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1515777832;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1518772998;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1520858426;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1520974346;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1522360217;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1525267242;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1530174524;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1530174524;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1530190293;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1532091916;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1536317783;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1536753765;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1537204195;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1539159551;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1539161108;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringBuilder builder = new StringBuilder("[")__			Iterator<ConfigurationClass> iterator = iterator()__			while (iterator.hasNext()) {_				builder.append(iterator.next().getSimpleName())__				if (iterator.hasNext()) {_					builder.append("->")__				}_			}_			return builder.append(']').toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,builder,builder,new,string,builder,iterator,configuration,class,iterator,iterator,while,iterator,has,next,builder,append,iterator,next,get,simple,name,if,iterator,has,next,builder,append,return,builder,append,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1551093117;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringJoiner joiner = new StringJoiner("->", "[", "]")__			for (ConfigurationClass configurationClass : this) {_				joiner.add(configurationClass.getSimpleName())__			}_			return joiner.toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,joiner,joiner,new,string,joiner,for,configuration,class,configuration,class,this,joiner,add,configuration,class,get,simple,name,return,joiner,to,string
ConfigurationClassParser -> ImportStack -> @Override 		public String toString();1551113869;Given a stack containing (in order)_<ul>_<li>com.acme.Foo</li>_<li>com.acme.Bar</li>_<li>com.acme.Baz</li>_</ul>_return "[Foo->Bar->Baz]".;@Override_		public String toString() {_			StringJoiner joiner = new StringJoiner("->", "[", "]")__			for (ConfigurationClass configurationClass : this) {_				joiner.add(configurationClass.getSimpleName())__			}_			return joiner.toString()__		};given,a,stack,containing,in,order,ul,li,com,acme,foo,li,li,com,acme,bar,li,li,com,acme,baz,li,ul,return,foo,bar,baz;override,public,string,to,string,string,joiner,joiner,new,string,joiner,for,configuration,class,configuration,class,this,joiner,add,configuration,class,get,simple,name,return,joiner,to,string
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry, 			ApplicationContext applicationContext);1372363092;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry,_			ApplicationContext applicationContext) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment,_				applicationContext, null, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,application,context,application,context,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,application,context,null,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry, 			ApplicationContext applicationContext);1374264616;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry,_			ApplicationContext applicationContext) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment,_				applicationContext, null, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,application,context,application,context,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,application,context,null,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry, 			ApplicationContext applicationContext);1375216602;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry,_			ApplicationContext applicationContext) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment,_				applicationContext, null, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,application,context,application,context,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,application,context,null,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry, 			ApplicationContext applicationContext);1377269365;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry,_			ApplicationContext applicationContext) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment,_				applicationContext, null, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,application,context,application,context,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,application,context,null,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry, 			ApplicationContext applicationContext);1377562322;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry,_			ApplicationContext applicationContext) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment,_				applicationContext, null, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,application,context,application,context,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,application,context,null,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry, 			ApplicationContext applicationContext);1377625191;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry,_			ApplicationContext applicationContext) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment,_				applicationContext, null, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,application,context,application,context,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,application,context,null,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, 			ResourceLoader resourceLoader, BeanDefinitionRegistry registry);1328020251;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment,_			ResourceLoader resourceLoader, BeanDefinitionRegistry registry) {_		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser =_			new ComponentScanAnnotationParser(this.resourceLoader, this.environment, this.registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,this,resource,loader,this,environment,this,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, 			ResourceLoader resourceLoader, BeanDefinitionRegistry registry);1329142650;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment,_			ResourceLoader resourceLoader, BeanDefinitionRegistry registry) {_		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser =_			new ComponentScanAnnotationParser(this.resourceLoader, this.environment, this.registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,this,resource,loader,this,environment,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar);1352741263;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code registrar}.;private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar) {_		if (registrar instanceof Aware) {_			if (registrar instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) registrar).setResourceLoader(resourceLoader)__			}_			if (registrar instanceof BeanClassLoaderAware) {_				ClassLoader classLoader =_						registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) registry).getBeanClassLoader() :_						resourceLoader.getClassLoader()__				((BeanClassLoaderAware) registrar).setBeanClassLoader(classLoader)__			}_			if (registrar instanceof BeanFactoryAware && registry instanceof BeanFactory) {_				((BeanFactoryAware) registrar).setBeanFactory((BeanFactory) registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,registrar;private,void,invoke,aware,methods,import,bean,definition,registrar,registrar,if,registrar,instanceof,aware,if,registrar,instanceof,resource,loader,aware,resource,loader,aware,registrar,set,resource,loader,resource,loader,if,registrar,instanceof,bean,class,loader,aware,class,loader,class,loader,registry,instanceof,configurable,bean,factory,configurable,bean,factory,registry,get,bean,class,loader,resource,loader,get,class,loader,bean,class,loader,aware,registrar,set,bean,class,loader,class,loader,if,registrar,instanceof,bean,factory,aware,registry,instanceof,bean,factory,bean,factory,aware,registrar,set,bean,factory,bean,factory,registry
ConfigurationClassParser -> private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar);1354731125;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code registrar}.;private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar) {_		if (registrar instanceof Aware) {_			if (registrar instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) registrar).setResourceLoader(resourceLoader)__			}_			if (registrar instanceof BeanClassLoaderAware) {_				ClassLoader classLoader =_						registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) registry).getBeanClassLoader() :_						resourceLoader.getClassLoader()__				((BeanClassLoaderAware) registrar).setBeanClassLoader(classLoader)__			}_			if (registrar instanceof BeanFactoryAware && registry instanceof BeanFactory) {_				((BeanFactoryAware) registrar).setBeanFactory((BeanFactory) registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,registrar;private,void,invoke,aware,methods,import,bean,definition,registrar,registrar,if,registrar,instanceof,aware,if,registrar,instanceof,resource,loader,aware,resource,loader,aware,registrar,set,resource,loader,resource,loader,if,registrar,instanceof,bean,class,loader,aware,class,loader,class,loader,registry,instanceof,configurable,bean,factory,configurable,bean,factory,registry,get,bean,class,loader,resource,loader,get,class,loader,bean,class,loader,aware,registrar,set,bean,class,loader,class,loader,if,registrar,instanceof,bean,factory,aware,registry,instanceof,bean,factory,bean,factory,aware,registrar,set,bean,factory,bean,factory,registry
ConfigurationClassParser -> private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar);1356735495;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code registrar}.;private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar) {_		if (registrar instanceof Aware) {_			if (registrar instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) registrar).setResourceLoader(resourceLoader)__			}_			if (registrar instanceof BeanClassLoaderAware) {_				ClassLoader classLoader =_						registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) registry).getBeanClassLoader() :_						resourceLoader.getClassLoader()__				((BeanClassLoaderAware) registrar).setBeanClassLoader(classLoader)__			}_			if (registrar instanceof BeanFactoryAware && registry instanceof BeanFactory) {_				((BeanFactoryAware) registrar).setBeanFactory((BeanFactory) registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,registrar;private,void,invoke,aware,methods,import,bean,definition,registrar,registrar,if,registrar,instanceof,aware,if,registrar,instanceof,resource,loader,aware,resource,loader,aware,registrar,set,resource,loader,resource,loader,if,registrar,instanceof,bean,class,loader,aware,class,loader,class,loader,registry,instanceof,configurable,bean,factory,configurable,bean,factory,registry,get,bean,class,loader,resource,loader,get,class,loader,bean,class,loader,aware,registrar,set,bean,class,loader,class,loader,if,registrar,instanceof,bean,factory,aware,registry,instanceof,bean,factory,bean,factory,aware,registrar,set,bean,factory,bean,factory,registry
ConfigurationClassParser -> private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar);1357119239;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code registrar}.;private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar) {_		if (registrar instanceof Aware) {_			if (registrar instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) registrar).setResourceLoader(resourceLoader)__			}_			if (registrar instanceof BeanClassLoaderAware) {_				ClassLoader classLoader =_						registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) registry).getBeanClassLoader() :_						resourceLoader.getClassLoader()__				((BeanClassLoaderAware) registrar).setBeanClassLoader(classLoader)__			}_			if (registrar instanceof BeanFactoryAware && registry instanceof BeanFactory) {_				((BeanFactoryAware) registrar).setBeanFactory((BeanFactory) registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,registrar;private,void,invoke,aware,methods,import,bean,definition,registrar,registrar,if,registrar,instanceof,aware,if,registrar,instanceof,resource,loader,aware,resource,loader,aware,registrar,set,resource,loader,resource,loader,if,registrar,instanceof,bean,class,loader,aware,class,loader,class,loader,registry,instanceof,configurable,bean,factory,configurable,bean,factory,registry,get,bean,class,loader,resource,loader,get,class,loader,bean,class,loader,aware,registrar,set,bean,class,loader,class,loader,if,registrar,instanceof,bean,factory,aware,registry,instanceof,bean,factory,bean,factory,aware,registrar,set,bean,factory,bean,factory,registry
ConfigurationClassParser -> private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar);1362408075;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code registrar}.;private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar) {_		if (registrar instanceof Aware) {_			if (registrar instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) registrar).setResourceLoader(this.resourceLoader)__			}_			if (registrar instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) registrar).setBeanClassLoader(classLoader)__			}_			if (registrar instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) registrar).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,registrar;private,void,invoke,aware,methods,import,bean,definition,registrar,registrar,if,registrar,instanceof,aware,if,registrar,instanceof,resource,loader,aware,resource,loader,aware,registrar,set,resource,loader,this,resource,loader,if,registrar,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,registrar,set,bean,class,loader,class,loader,if,registrar,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,registrar,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar);1366717765;Invoke {@link ResourceLoaderAware}, {@link BeanClassLoaderAware} and_{@link BeanFactoryAware} contracts if implemented by the given {@code registrar}.;private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar) {_		if (registrar instanceof Aware) {_			if (registrar instanceof ResourceLoaderAware) {_				((ResourceLoaderAware) registrar).setResourceLoader(this.resourceLoader)__			}_			if (registrar instanceof BeanClassLoaderAware) {_				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?_						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :_						this.resourceLoader.getClassLoader())__				((BeanClassLoaderAware) registrar).setBeanClassLoader(classLoader)__			}_			if (registrar instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {_				((BeanFactoryAware) registrar).setBeanFactory((BeanFactory) this.registry)__			}_		}_	};invoke,link,resource,loader,aware,link,bean,class,loader,aware,and,link,bean,factory,aware,contracts,if,implemented,by,the,given,code,registrar;private,void,invoke,aware,methods,import,bean,definition,registrar,registrar,if,registrar,instanceof,aware,if,registrar,instanceof,resource,loader,aware,resource,loader,aware,registrar,set,resource,loader,this,resource,loader,if,registrar,instanceof,bean,class,loader,aware,class,loader,class,loader,this,registry,instanceof,configurable,bean,factory,configurable,bean,factory,this,registry,get,bean,class,loader,this,resource,loader,get,class,loader,bean,class,loader,aware,registrar,set,bean,class,loader,class,loader,if,registrar,instanceof,bean,factory,aware,this,registry,instanceof,bean,factory,bean,factory,aware,registrar,set,bean,factory,bean,factory,this,registry
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1375216602;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_		return new SourceClass(classType)__	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,catch,throwable,ex,return,as,source,class,class,type,get,name,return,new,source,class,class,type
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1377269365;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_		return new SourceClass(classType)__	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,catch,throwable,ex,return,as,source,class,class,type,get,name,return,new,source,class,class,type
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1377562322;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_		return new SourceClass(classType)__	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,catch,throwable,ex,return,as,source,class,class,type,get,name,return,new,source,class,class,type
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1377625191;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_		return new SourceClass(classType)__	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,catch,throwable,ex,return,as,source,class,class,type,get,name,return,new,source,class,class,type
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1377640854;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_		return new SourceClass(classType)__	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,catch,throwable,ex,return,as,source,class,class,type,get,name,return,new,source,class,class,type
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1381881109;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_		return new SourceClass(classType)__	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,catch,throwable,ex,return,as,source,class,class,type,get,name,return,new,source,class,class,type
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1382386279;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_		return new SourceClass(classType)__	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,catch,throwable,ex,return,as,source,class,class,type,get,name,return,new,source,class,class,type
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1382465750;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_		return new SourceClass(classType)__	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,catch,throwable,ex,return,as,source,class,class,type,get,name,return,new,source,class,class,type
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1384512601;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1385158940;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1385412762;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1385978370;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1393377752;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1394195941;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1397058189;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1398637994;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1398720297;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1400245582;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException;1402056098;Factory method to obtain a {@link SourceClass} from a {@link Class}.;public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {_		try {_			_			classType.getAnnotations()__			return new SourceClass(classType)__		}_		catch (Throwable ex) {_			_			return asSourceClass(classType.getName())__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,class;public,source,class,as,source,class,class,class,type,throws,ioexception,class,not,found,exception,try,class,type,get,annotations,return,new,source,class,class,type,catch,throwable,ex,return,as,source,class,class,type,get,name
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1347311780;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1347375001;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1351673950;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1351687206;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1351701017;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1352741263;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1354731125;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1356735495;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1357119239;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1362408075;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1366717765;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1367880232;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1368068203;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.beanNameGenerator = componentScanBeanNameGenerator__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,bean,name,generator,component,scan,bean,name,generator,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1368482696;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.beanNameGenerator = componentScanBeanNameGenerator__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,bean,name,generator,component,scan,bean,name,generator,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1368621032;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.beanNameGenerator = componentScanBeanNameGenerator__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,bean,name,generator,component,scan,bean,name,generator,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1368631197;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.beanNameGenerator = componentScanBeanNameGenerator__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,bean,name,generator,component,scan,bean,name,generator,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1377640854;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1381881109;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1382386279;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1382465750;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1384512601;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1385158940;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1385412762;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1385978370;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1393377752;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1394195941;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1397058189;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1398637994;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1398720297;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1400245582;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1402056098;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1405454692;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1407857001;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1408653788;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1408681275;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1408708479;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1408748821;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1409688471;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1409716050;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1409741991;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1410880110;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1411076915;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1411110630;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1411165756;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1413937661;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1414616928;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1426780215;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1427137082;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1433381203;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1434009363;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1434375974;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1451421608;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1452685588;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1453827605;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1456179950;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1464381249;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1467730834;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1468583965;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1468595845;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1468948866;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1469629308;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1469657173;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				resourceLoader, environment, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,resource,loader,environment,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1473796164;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1477860027;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1481292081;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1482521352;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1482524610;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1482746422;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1485175042;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1486719670;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1486994827;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1491319023;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1491903930;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1492434334;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1495868221;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1496263893;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1496837955;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1498780456;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1502974979;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1511268177;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1515777832;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1518772998;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1520858426;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1520974346;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1522360217;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1525267242;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1530174524;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1530174524;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1530190293;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1532091916;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1536317783;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1536753765;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1537204195;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1539159551;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1539161108;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1551093117;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory, 			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader, 			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry);1551113869;Create a new {@link ConfigurationClassParser} instance that will be used_to populate the set of configuration classes.;public ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,_			ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,_			BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) {__		this.metadataReaderFactory = metadataReaderFactory__		this.problemReporter = problemReporter__		this.environment = environment__		this.resourceLoader = resourceLoader__		this.registry = registry__		this.componentScanParser = new ComponentScanAnnotationParser(_				environment, resourceLoader, componentScanBeanNameGenerator, registry)__		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader)__	};create,a,new,link,configuration,class,parser,instance,that,will,be,used,to,populate,the,set,of,configuration,classes;public,configuration,class,parser,metadata,reader,factory,metadata,reader,factory,problem,reporter,problem,reporter,environment,environment,resource,loader,resource,loader,bean,name,generator,component,scan,bean,name,generator,bean,definition,registry,registry,this,metadata,reader,factory,metadata,reader,factory,this,problem,reporter,problem,reporter,this,environment,environment,this,resource,loader,resource,loader,this,registry,registry,this,component,scan,parser,new,component,scan,annotation,parser,environment,resource,loader,component,scan,bean,name,generator,registry,this,condition,evaluator,new,condition,evaluator,registry,environment,resource,loader
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) 			throws IOException;1372363092;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass)_			throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public SourceClass asSourceClass(ConfigurationClass configurationClass) 			throws IOException;1374264616;Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}.;public SourceClass asSourceClass(ConfigurationClass configurationClass)_			throws IOException {_		try {_			AnnotationMetadata metadata = configurationClass.getMetadata()__			if (metadata instanceof StandardAnnotationMetadata) {_				return asSourceClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass())__			}_			return asSourceClass(configurationClass.getMetadata().getClassName())__		}_		catch (ClassNotFoundException ex) {_			throw new IllegalStateException(ex)__		}_	};factory,method,to,obtain,a,link,source,class,from,a,link,configuration,class;public,source,class,as,source,class,configuration,class,configuration,class,throws,ioexception,try,annotation,metadata,metadata,configuration,class,get,metadata,if,metadata,instanceof,standard,annotation,metadata,return,as,source,class,standard,annotation,metadata,metadata,get,introspected,class,return,as,source,class,configuration,class,get,metadata,get,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,ex
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1328020251;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1329142650;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1329393628;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1329743944;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1329744111;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1347282850;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1347311780;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1347375001;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1351673950;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1351687206;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1351701017;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1352741263;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1354731125;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1356735495;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1357119239;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1362408075;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1366717765;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1367880232;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1368068203;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1368482696;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1368621032;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> public void parse(String className, String beanName) throws IOException;1368631197;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);public void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;public,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1366717765;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1367880232;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1368068203;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1368482696;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1368621032;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1368631197;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1372363092;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1374264616;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1375216602;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1377269365;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1377562322;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1377625191;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1377640854;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int nLocations = locations.length__		if (nLocations == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < nLocations_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (nLocations == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,n,locations,locations,length,if,n,locations,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,n,locations,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,n,locations,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1381881109;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int locationCount = locations.length__		if (locationCount == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < locationCount_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (locationCount == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (String location : locations) {_					ps.addPropertySource(new ResourcePropertySource(location, classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,location,count,locations,length,if,location,count,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,location,count,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,location,count,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,string,location,locations,ps,add,property,source,new,resource,property,source,location,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1382386279;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		int locationCount = locations.length__		if (locationCount == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (int i = 0_ i < locationCount_ i++) {_			locations[i] = this.environment.resolveRequiredPlaceholders(locations[i])__		}_		ClassLoader classLoader = this.resourceLoader.getClassLoader()__		if (!StringUtils.hasText(name)) {_			for (String location : locations) {_				this.propertySources.push(new ResourcePropertySource(location, classLoader))__			}_		}_		else {_			if (locationCount == 1) {_				this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader))__			}_			else {_				CompositePropertySource ps = new CompositePropertySource(name)__				for (int i = locations.length - 1_ i >= 0_ i--) {_					ps.addPropertySource(new ResourcePropertySource(locations[i], classLoader))__				}_				this.propertySources.push(ps)__			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,int,location,count,locations,length,if,location,count,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,int,i,0,i,location,count,i,locations,i,this,environment,resolve,required,placeholders,locations,i,class,loader,class,loader,this,resource,loader,get,class,loader,if,string,utils,has,text,name,for,string,location,locations,this,property,sources,push,new,resource,property,source,location,class,loader,else,if,location,count,1,this,property,sources,push,new,resource,property,source,name,locations,0,class,loader,else,composite,property,source,ps,new,composite,property,source,name,for,int,i,locations,length,1,i,0,i,ps,add,property,source,new,resource,property,source,locations,i,class,loader,this,property,sources,push,ps
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1382465750;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		int locationCount = locations.length__		if (locationCount == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			Resource resource = this.resourceLoader.getResource(_					this.environment.resolveRequiredPlaceholders(location))__			try {_				if (!StringUtils.hasText(name) || this.propertySources.containsKey(name)) {_					_					_					ResourcePropertySource ps = new ResourcePropertySource(resource)__					this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__				}_				else {_					this.propertySources.add(name, new ResourcePropertySource(name, resource))__				}_			}_			catch (FileNotFoundException ex) {_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,int,location,count,locations,length,if,location,count,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,resource,resource,this,resource,loader,get,resource,this,environment,resolve,required,placeholders,location,try,if,string,utils,has,text,name,this,property,sources,contains,key,name,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,else,this,property,sources,add,name,new,resource,property,source,name,resource,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1384512601;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		int locationCount = locations.length__		if (locationCount == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			Resource resource = this.resourceLoader.getResource(_					this.environment.resolveRequiredPlaceholders(location))__			try {_				if (!StringUtils.hasText(name) || this.propertySources.containsKey(name)) {_					_					_					ResourcePropertySource ps = new ResourcePropertySource(resource)__					this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__				}_				else {_					this.propertySources.add(name, new ResourcePropertySource(name, resource))__				}_			}_			catch (FileNotFoundException ex) {_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,int,location,count,locations,length,if,location,count,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,resource,resource,this,resource,loader,get,resource,this,environment,resolve,required,placeholders,location,try,if,string,utils,has,text,name,this,property,sources,contains,key,name,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,else,this,property,sources,add,name,new,resource,property,source,name,resource,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1385158940;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		int locationCount = locations.length__		if (locationCount == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			Resource resource = this.resourceLoader.getResource(_					this.environment.resolveRequiredPlaceholders(location))__			try {_				if (!StringUtils.hasText(name) || this.propertySources.containsKey(name)) {_					_					_					ResourcePropertySource ps = new ResourcePropertySource(resource)__					this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__				}_				else {_					this.propertySources.add(name, new ResourcePropertySource(name, resource))__				}_			}_			catch (FileNotFoundException ex) {_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,int,location,count,locations,length,if,location,count,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,resource,resource,this,resource,loader,get,resource,this,environment,resolve,required,placeholders,location,try,if,string,utils,has,text,name,this,property,sources,contains,key,name,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,else,this,property,sources,add,name,new,resource,property,source,name,resource,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1385412762;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		int locationCount = locations.length__		if (locationCount == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			Resource resource = this.resourceLoader.getResource(_					this.environment.resolveRequiredPlaceholders(location))__			try {_				if (!StringUtils.hasText(name) || this.propertySources.containsKey(name)) {_					_					_					ResourcePropertySource ps = new ResourcePropertySource(resource)__					this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__				}_				else {_					this.propertySources.add(name, new ResourcePropertySource(name, resource))__				}_			}_			catch (FileNotFoundException ex) {_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,int,location,count,locations,length,if,location,count,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,resource,resource,this,resource,loader,get,resource,this,environment,resolve,required,placeholders,location,try,if,string,utils,has,text,name,this,property,sources,contains,key,name,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,else,this,property,sources,add,name,new,resource,property,source,name,resource,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1385978370;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		int locationCount = locations.length__		if (locationCount == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			Resource resource = this.resourceLoader.getResource(_					this.environment.resolveRequiredPlaceholders(location))__			try {_				if (!StringUtils.hasText(name) || this.propertySources.containsKey(name)) {_					_					_					ResourcePropertySource ps = new ResourcePropertySource(resource)__					this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__				}_				else {_					this.propertySources.add(name, new ResourcePropertySource(name, resource))__				}_			}_			catch (FileNotFoundException ex) {_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,int,location,count,locations,length,if,location,count,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,resource,resource,this,resource,loader,get,resource,this,environment,resolve,required,placeholders,location,try,if,string,utils,has,text,name,this,property,sources,contains,key,name,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,else,this,property,sources,add,name,new,resource,property,source,name,resource,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1393377752;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		int locationCount = locations.length__		if (locationCount == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			Resource resource = this.resourceLoader.getResource(_					this.environment.resolveRequiredPlaceholders(location))__			try {_				if (!StringUtils.hasText(name) || this.propertySources.containsKey(name)) {_					_					_					ResourcePropertySource ps = new ResourcePropertySource(resource)__					this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__				}_				else {_					this.propertySources.add(name, new ResourcePropertySource(name, resource))__				}_			}_			catch (FileNotFoundException ex) {_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,int,location,count,locations,length,if,location,count,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,resource,resource,this,resource,loader,get,resource,this,environment,resolve,required,placeholders,location,try,if,string,utils,has,text,name,this,property,sources,contains,key,name,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,else,this,property,sources,add,name,new,resource,property,source,name,resource,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1394195941;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		int locationCount = locations.length__		if (locationCount == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			try {_				Resource resource = this.resourceLoader.getResource(_						this.environment.resolveRequiredPlaceholders(location))__				if (!StringUtils.hasText(name) || this.propertySources.containsKey(name)) {_					_					_					ResourcePropertySource ps = new ResourcePropertySource(resource)__					this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__				}_				else {_					this.propertySources.add(name, new ResourcePropertySource(name, resource))__				}_			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,int,location,count,locations,length,if,location,count,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,resource,resource,this,resource,loader,get,resource,this,environment,resolve,required,placeholders,location,if,string,utils,has,text,name,this,property,sources,contains,key,name,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,else,this,property,sources,add,name,new,resource,property,source,name,resource,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1397058189;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		if (locations.length == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			try {_				Resource resource = this.resourceLoader.getResource(_						this.environment.resolveRequiredPlaceholders(location))__				if (!StringUtils.hasText(name) || this.propertySources.containsKey(name)) {_					_					ResourcePropertySource ps = new ResourcePropertySource(resource)__					this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__				}_				else {_					this.propertySources.add(name, new ResourcePropertySource(name, resource))__				}_			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,if,locations,length,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,resource,resource,this,resource,loader,get,resource,this,environment,resolve,required,placeholders,location,if,string,utils,has,text,name,this,property,sources,contains,key,name,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,else,this,property,sources,add,name,new,resource,property,source,name,resource,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1398637994;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		if (locations.length == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			try {_				Resource resource = this.resourceLoader.getResource(_						this.environment.resolveRequiredPlaceholders(location))__				if (!StringUtils.hasText(name) || this.propertySources.containsKey(name)) {_					_					ResourcePropertySource ps = new ResourcePropertySource(resource)__					this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__				}_				else {_					this.propertySources.add(name, new ResourcePropertySource(name, resource))__				}_			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,if,locations,length,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,resource,resource,this,resource,loader,get,resource,this,environment,resolve,required,placeholders,location,if,string,utils,has,text,name,this,property,sources,contains,key,name,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,else,this,property,sources,add,name,new,resource,property,source,name,resource,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1398720297;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		if (locations.length == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource ps = new ResourcePropertySource(resource)__				this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,if,locations,length,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1400245582;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		if (locations.length == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource ps = new ResourcePropertySource(resource)__				this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,if,locations,length,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1402056098;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		if (locations.length == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource ps = new ResourcePropertySource(resource)__				this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,if,locations,length,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1405454692;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		if (locations.length == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource ps = new ResourcePropertySource(resource)__				this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,if,locations,length,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1407857001;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		if (locations.length == 0) {_			throw new IllegalArgumentException("At least one @PropertySource(value) location is required")__		}_		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource ps = new ResourcePropertySource(resource)__				this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,if,locations,length,0,throw,new,illegal,argument,exception,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,ps,new,resource,property,source,resource,this,property,sources,add,string,utils,has,text,name,name,ps,get,name,ps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1408681275;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				processPropertySourceLocation(name, location)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,process,property,source,location,name,location,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1408708479;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1408748821;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1409688471;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1409716050;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1409741991;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1410880110;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1411076915;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1411110630;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1411165756;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1413937661;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1414616928;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1426780215;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1427137082;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1433381203;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1434009363;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1434375974;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1451421608;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1452685588;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				ResourcePropertySource rps = (StringUtils.hasText(name) ?_						new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource))__				addPropertySource(rps)__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,resource,property,source,rps,string,utils,has,text,name,new,resource,property,source,name,resource,new,resource,property,source,resource,add,property,source,rps,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1453827605;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		String encoding = propertySource.getString("encoding")__		String[] locations = propertySource.getStringArray("value")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(createPropertySource(name, encoding, resource))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,string,encoding,property,source,get,string,encoding,string,locations,property,source,get,string,array,value,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,create,property,source,name,encoding,resource,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1456179950;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiate(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1464381249;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiate(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1467730834;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiate(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1468583965;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiate(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1468595845;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiate(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1468948866;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1469629308;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1469657173;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1473796164;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1477860027;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1481292081;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1482521352;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1482524610;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1482746422;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1485175042;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_			catch (FileNotFoundException ex) {_				_				if (!ignoreResourceNotFound) {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,ex,if,ignore,resource,not,found,throw,ex,catch,file,not,found,exception,ex,if,ignore,resource,not,found,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1486719670;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1486994827;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1491319023;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1491903930;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1492434334;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1495868221;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1496263893;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1496837955;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1498780456;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1502974979;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1511268177;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1515777832;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1518772998;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1520858426;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1520974346;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1522360217;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1525267242;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1530174524;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1530174524;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1530190293;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1532091916;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1536317783;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1536753765;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1537204195;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1539159551;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1539161108;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1551093117;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> private void processPropertySource(AnnotationAttributes propertySource) throws IOException;1551113869;Process the given <code>@PropertySource</code> annotation metadata._@param propertySource metadata for the <code>@PropertySource</code> annotation found_@throws IOException if loading a property source failed;private void processPropertySource(AnnotationAttributes propertySource) throws IOException {_		String name = propertySource.getString("name")__		if (!StringUtils.hasLength(name)) {_			name = null__		}_		String encoding = propertySource.getString("encoding")__		if (!StringUtils.hasLength(encoding)) {_			encoding = null__		}_		String[] locations = propertySource.getStringArray("value")__		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required")__		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound")___		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory")__		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?_				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass))___		for (String location : locations) {_			try {_				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location)__				Resource resource = this.resourceLoader.getResource(resolvedLocation)__				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)))__			}_			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {_				_				if (ignoreResourceNotFound) {_					if (logger.isInfoEnabled()) {_						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage())__					}_				}_				else {_					throw ex__				}_			}_		}_	};process,the,given,code,property,source,code,annotation,metadata,param,property,source,metadata,for,the,code,property,source,code,annotation,found,throws,ioexception,if,loading,a,property,source,failed;private,void,process,property,source,annotation,attributes,property,source,throws,ioexception,string,name,property,source,get,string,name,if,string,utils,has,length,name,name,null,string,encoding,property,source,get,string,encoding,if,string,utils,has,length,encoding,encoding,null,string,locations,property,source,get,string,array,value,assert,is,true,locations,length,0,at,least,one,property,source,value,location,is,required,boolean,ignore,resource,not,found,property,source,get,boolean,ignore,resource,not,found,class,extends,property,source,factory,factory,class,property,source,get,class,factory,property,source,factory,factory,factory,class,property,source,factory,class,bean,utils,instantiate,class,factory,class,for,string,location,locations,try,string,resolved,location,this,environment,resolve,required,placeholders,location,resource,resource,this,resource,loader,get,resource,resolved,location,add,property,source,factory,create,property,source,name,new,encoded,resource,resource,encoding,catch,illegal,argument,exception,file,not,found,exception,unknown,host,exception,ex,if,ignore,resource,not,found,if,logger,is,info,enabled,logger,info,properties,location,location,not,resolvable,ex,get,message,else,throw,ex
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1405454692;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1407857001;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1408653788;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1408681275;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1408708479;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1408748821;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1409688471;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1409716050;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1409741991;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1410880110;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1411076915;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1411110630;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1411165756;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1413937661;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1414616928;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1426780215;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1427137082;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1433381203;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1434009363;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1434375974;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1451421608;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1452685588;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1453827605;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1456179950;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1464381249;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<SourceClass>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,source,class,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1467730834;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1468583965;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1468595845;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1468948866;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1469629308;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1469657173;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1473796164;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1477860027;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1481292081;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1482521352;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1482524610;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1482746422;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1485175042;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException;1486719670;Factory method to obtain {@link SourceClass}s from class names.;public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException {_		List<SourceClass> annotatedClasses = new ArrayList<>()__		for (String className : classNames) {_			annotatedClasses.add(asSourceClass(className))__		}_		return annotatedClasses__	};factory,method,to,obtain,link,source,class,s,from,class,names;public,collection,source,class,as,source,classes,string,class,names,throws,ioexception,list,source,class,annotated,classes,new,array,list,for,string,class,name,class,names,annotated,classes,add,as,source,class,class,name,return,annotated,classes
ConfigurationClassParser -> private List<AnnotationAttributes> findAllAnnotationAttributes( 			Class<? extends Annotation> targetAnnotation, String annotatedClassName, 			boolean classValuesAsString) throws IOException;1329142650;Return a list of attribute maps for all declarations of the given annotation_on the given annotated class using the given MetadataReaderFactory to introspect_annotation metadata. Meta-annotations are ordered first in the list, and if the_target annotation is declared directly on the class, its map of attributes will be_ordered last in the list._@param targetAnnotation the annotation to search for, both locally and as a meta-annotation_@param annotatedClassName the class to inspect_@param classValuesAsString whether class attributes should be returned as strings;private List<AnnotationAttributes> findAllAnnotationAttributes(_			Class<? extends Annotation> targetAnnotation, String annotatedClassName,_			boolean classValuesAsString) throws IOException {__		List<AnnotationAttributes> allAttribs = new ArrayList<AnnotationAttributes>()___		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(annotatedClassName)__		AnnotationMetadata metadata = reader.getAnnotationMetadata()__		String targetAnnotationType = targetAnnotation.getName()___		for (String annotationType : metadata.getAnnotationTypes()) {_			if (annotationType.equals(targetAnnotationType)) {_				continue__			}_			AnnotationMetadata metaAnnotations =_					this.metadataReaderFactory.getMetadataReader(annotationType).getAnnotationMetadata()__			AnnotationAttributes targetAttribs =_					AnnotationAttributes.fromMap(metaAnnotations.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__			if (targetAttribs != null) {_				allAttribs.add(targetAttribs)__			}_		}__		AnnotationAttributes localAttribs =_				AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__		if (localAttribs != null) {_			allAttribs.add(localAttribs)__		}__		return allAttribs__	};return,a,list,of,attribute,maps,for,all,declarations,of,the,given,annotation,on,the,given,annotated,class,using,the,given,metadata,reader,factory,to,introspect,annotation,metadata,meta,annotations,are,ordered,first,in,the,list,and,if,the,target,annotation,is,declared,directly,on,the,class,its,map,of,attributes,will,be,ordered,last,in,the,list,param,target,annotation,the,annotation,to,search,for,both,locally,and,as,a,meta,annotation,param,annotated,class,name,the,class,to,inspect,param,class,values,as,string,whether,class,attributes,should,be,returned,as,strings;private,list,annotation,attributes,find,all,annotation,attributes,class,extends,annotation,target,annotation,string,annotated,class,name,boolean,class,values,as,string,throws,ioexception,list,annotation,attributes,all,attribs,new,array,list,annotation,attributes,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,annotated,class,name,annotation,metadata,metadata,reader,get,annotation,metadata,string,target,annotation,type,target,annotation,get,name,for,string,annotation,type,metadata,get,annotation,types,if,annotation,type,equals,target,annotation,type,continue,annotation,metadata,meta,annotations,this,metadata,reader,factory,get,metadata,reader,annotation,type,get,annotation,metadata,annotation,attributes,target,attribs,annotation,attributes,from,map,meta,annotations,get,annotation,attributes,target,annotation,type,class,values,as,string,if,target,attribs,null,all,attribs,add,target,attribs,annotation,attributes,local,attribs,annotation,attributes,from,map,metadata,get,annotation,attributes,target,annotation,type,class,values,as,string,if,local,attribs,null,all,attribs,add,local,attribs,return,all,attribs
ConfigurationClassParser -> private List<AnnotationAttributes> findAllAnnotationAttributes( 			Class<? extends Annotation> targetAnnotation, String annotatedClassName, 			boolean classValuesAsString) throws IOException;1329393628;Return a list of attribute maps for all declarations of the given annotation_on the given annotated class using the given MetadataReaderFactory to introspect_annotation metadata. Meta-annotations are ordered first in the list, and if the_target annotation is declared directly on the class, its map of attributes will be_ordered last in the list._@param targetAnnotation the annotation to search for, both locally and as a meta-annotation_@param annotatedClassName the class to inspect_@param classValuesAsString whether class attributes should be returned as strings;private List<AnnotationAttributes> findAllAnnotationAttributes(_			Class<? extends Annotation> targetAnnotation, String annotatedClassName,_			boolean classValuesAsString) throws IOException {__		List<AnnotationAttributes> allAttribs = new ArrayList<AnnotationAttributes>()___		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(annotatedClassName)__		AnnotationMetadata metadata = reader.getAnnotationMetadata()__		String targetAnnotationType = targetAnnotation.getName()___		for (String annotationType : metadata.getAnnotationTypes()) {_			if (annotationType.equals(targetAnnotationType)) {_				continue__			}_			AnnotationMetadata metaAnnotations =_					this.metadataReaderFactory.getMetadataReader(annotationType).getAnnotationMetadata()__			AnnotationAttributes targetAttribs =_					AnnotationAttributes.fromMap(metaAnnotations.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__			if (targetAttribs != null) {_				allAttribs.add(targetAttribs)__			}_		}__		AnnotationAttributes localAttribs =_				AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__		if (localAttribs != null) {_			allAttribs.add(localAttribs)__		}__		return allAttribs__	};return,a,list,of,attribute,maps,for,all,declarations,of,the,given,annotation,on,the,given,annotated,class,using,the,given,metadata,reader,factory,to,introspect,annotation,metadata,meta,annotations,are,ordered,first,in,the,list,and,if,the,target,annotation,is,declared,directly,on,the,class,its,map,of,attributes,will,be,ordered,last,in,the,list,param,target,annotation,the,annotation,to,search,for,both,locally,and,as,a,meta,annotation,param,annotated,class,name,the,class,to,inspect,param,class,values,as,string,whether,class,attributes,should,be,returned,as,strings;private,list,annotation,attributes,find,all,annotation,attributes,class,extends,annotation,target,annotation,string,annotated,class,name,boolean,class,values,as,string,throws,ioexception,list,annotation,attributes,all,attribs,new,array,list,annotation,attributes,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,annotated,class,name,annotation,metadata,metadata,reader,get,annotation,metadata,string,target,annotation,type,target,annotation,get,name,for,string,annotation,type,metadata,get,annotation,types,if,annotation,type,equals,target,annotation,type,continue,annotation,metadata,meta,annotations,this,metadata,reader,factory,get,metadata,reader,annotation,type,get,annotation,metadata,annotation,attributes,target,attribs,annotation,attributes,from,map,meta,annotations,get,annotation,attributes,target,annotation,type,class,values,as,string,if,target,attribs,null,all,attribs,add,target,attribs,annotation,attributes,local,attribs,annotation,attributes,from,map,metadata,get,annotation,attributes,target,annotation,type,class,values,as,string,if,local,attribs,null,all,attribs,add,local,attribs,return,all,attribs
ConfigurationClassParser -> private List<AnnotationAttributes> findAllAnnotationAttributes( 			Class<? extends Annotation> targetAnnotation, String annotatedClassName, 			boolean classValuesAsString) throws IOException;1329743944;Return a list of attribute maps for all declarations of the given annotation_on the given annotated class using the given MetadataReaderFactory to introspect_annotation metadata. Meta-annotations are ordered first in the list, and if the_target annotation is declared directly on the class, its map of attributes will be_ordered last in the list._@param targetAnnotation the annotation to search for, both locally and as a meta-annotation_@param annotatedClassName the class to inspect_@param classValuesAsString whether class attributes should be returned as strings;private List<AnnotationAttributes> findAllAnnotationAttributes(_			Class<? extends Annotation> targetAnnotation, String annotatedClassName,_			boolean classValuesAsString) throws IOException {__		List<AnnotationAttributes> allAttribs = new ArrayList<AnnotationAttributes>()___		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(annotatedClassName)__		AnnotationMetadata metadata = reader.getAnnotationMetadata()__		String targetAnnotationType = targetAnnotation.getName()___		for (String annotationType : metadata.getAnnotationTypes()) {_			if (annotationType.equals(targetAnnotationType)) {_				continue__			}_			AnnotationMetadata metaAnnotations =_					this.metadataReaderFactory.getMetadataReader(annotationType).getAnnotationMetadata()__			AnnotationAttributes targetAttribs =_					AnnotationAttributes.fromMap(metaAnnotations.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__			if (targetAttribs != null) {_				allAttribs.add(targetAttribs)__			}_		}__		AnnotationAttributes localAttribs =_				AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__		if (localAttribs != null) {_			allAttribs.add(localAttribs)__		}__		return allAttribs__	};return,a,list,of,attribute,maps,for,all,declarations,of,the,given,annotation,on,the,given,annotated,class,using,the,given,metadata,reader,factory,to,introspect,annotation,metadata,meta,annotations,are,ordered,first,in,the,list,and,if,the,target,annotation,is,declared,directly,on,the,class,its,map,of,attributes,will,be,ordered,last,in,the,list,param,target,annotation,the,annotation,to,search,for,both,locally,and,as,a,meta,annotation,param,annotated,class,name,the,class,to,inspect,param,class,values,as,string,whether,class,attributes,should,be,returned,as,strings;private,list,annotation,attributes,find,all,annotation,attributes,class,extends,annotation,target,annotation,string,annotated,class,name,boolean,class,values,as,string,throws,ioexception,list,annotation,attributes,all,attribs,new,array,list,annotation,attributes,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,annotated,class,name,annotation,metadata,metadata,reader,get,annotation,metadata,string,target,annotation,type,target,annotation,get,name,for,string,annotation,type,metadata,get,annotation,types,if,annotation,type,equals,target,annotation,type,continue,annotation,metadata,meta,annotations,this,metadata,reader,factory,get,metadata,reader,annotation,type,get,annotation,metadata,annotation,attributes,target,attribs,annotation,attributes,from,map,meta,annotations,get,annotation,attributes,target,annotation,type,class,values,as,string,if,target,attribs,null,all,attribs,add,target,attribs,annotation,attributes,local,attribs,annotation,attributes,from,map,metadata,get,annotation,attributes,target,annotation,type,class,values,as,string,if,local,attribs,null,all,attribs,add,local,attribs,return,all,attribs
ConfigurationClassParser -> private List<AnnotationAttributes> findAllAnnotationAttributes( 			Class<? extends Annotation> targetAnnotation, String annotatedClassName, 			boolean classValuesAsString) throws IOException;1329744111;Return a list of attribute maps for all declarations of the given annotation_on the given annotated class using the given MetadataReaderFactory to introspect_annotation metadata. Meta-annotations are ordered first in the list, and if the_target annotation is declared directly on the class, its map of attributes will be_ordered last in the list._@param targetAnnotation the annotation to search for, both locally and as a meta-annotation_@param annotatedClassName the class to inspect_@param classValuesAsString whether class attributes should be returned as strings;private List<AnnotationAttributes> findAllAnnotationAttributes(_			Class<? extends Annotation> targetAnnotation, String annotatedClassName,_			boolean classValuesAsString) throws IOException {__		List<AnnotationAttributes> allAttribs = new ArrayList<AnnotationAttributes>()___		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(annotatedClassName)__		AnnotationMetadata metadata = reader.getAnnotationMetadata()__		String targetAnnotationType = targetAnnotation.getName()___		for (String annotationType : metadata.getAnnotationTypes()) {_			if (annotationType.equals(targetAnnotationType)) {_				continue__			}_			AnnotationMetadata metaAnnotations =_					this.metadataReaderFactory.getMetadataReader(annotationType).getAnnotationMetadata()__			AnnotationAttributes targetAttribs =_					AnnotationAttributes.fromMap(metaAnnotations.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__			if (targetAttribs != null) {_				allAttribs.add(targetAttribs)__			}_		}__		AnnotationAttributes localAttribs =_				AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__		if (localAttribs != null) {_			allAttribs.add(localAttribs)__		}__		return allAttribs__	};return,a,list,of,attribute,maps,for,all,declarations,of,the,given,annotation,on,the,given,annotated,class,using,the,given,metadata,reader,factory,to,introspect,annotation,metadata,meta,annotations,are,ordered,first,in,the,list,and,if,the,target,annotation,is,declared,directly,on,the,class,its,map,of,attributes,will,be,ordered,last,in,the,list,param,target,annotation,the,annotation,to,search,for,both,locally,and,as,a,meta,annotation,param,annotated,class,name,the,class,to,inspect,param,class,values,as,string,whether,class,attributes,should,be,returned,as,strings;private,list,annotation,attributes,find,all,annotation,attributes,class,extends,annotation,target,annotation,string,annotated,class,name,boolean,class,values,as,string,throws,ioexception,list,annotation,attributes,all,attribs,new,array,list,annotation,attributes,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,annotated,class,name,annotation,metadata,metadata,reader,get,annotation,metadata,string,target,annotation,type,target,annotation,get,name,for,string,annotation,type,metadata,get,annotation,types,if,annotation,type,equals,target,annotation,type,continue,annotation,metadata,meta,annotations,this,metadata,reader,factory,get,metadata,reader,annotation,type,get,annotation,metadata,annotation,attributes,target,attribs,annotation,attributes,from,map,meta,annotations,get,annotation,attributes,target,annotation,type,class,values,as,string,if,target,attribs,null,all,attribs,add,target,attribs,annotation,attributes,local,attribs,annotation,attributes,from,map,metadata,get,annotation,attributes,target,annotation,type,class,values,as,string,if,local,attribs,null,all,attribs,add,local,attribs,return,all,attribs
ConfigurationClassParser -> private List<AnnotationAttributes> findAllAnnotationAttributes( 			Class<? extends Annotation> targetAnnotation, String annotatedClassName, 			boolean classValuesAsString) throws IOException;1347282850;Return a list of attribute maps for all declarations of the given annotation_on the given annotated class using the given MetadataReaderFactory to introspect_annotation metadata. Meta-annotations are ordered first in the list, and if the_target annotation is declared directly on the class, its map of attributes will be_ordered last in the list._@param targetAnnotation the annotation to search for, both locally and as a meta-annotation_@param annotatedClassName the class to inspect_@param classValuesAsString whether class attributes should be returned as strings;private List<AnnotationAttributes> findAllAnnotationAttributes(_			Class<? extends Annotation> targetAnnotation, String annotatedClassName,_			boolean classValuesAsString) throws IOException {__		List<AnnotationAttributes> allAttribs = new ArrayList<AnnotationAttributes>()___		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(annotatedClassName)__		AnnotationMetadata metadata = reader.getAnnotationMetadata()__		String targetAnnotationType = targetAnnotation.getName()___		for (String annotationType : metadata.getAnnotationTypes()) {_			if (annotationType.equals(targetAnnotationType)) {_				continue__			}_			AnnotationMetadata metaAnnotations =_					this.metadataReaderFactory.getMetadataReader(annotationType).getAnnotationMetadata()__			AnnotationAttributes targetAttribs =_					AnnotationAttributes.fromMap(metaAnnotations.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__			if (targetAttribs != null) {_				allAttribs.add(targetAttribs)__			}_		}__		AnnotationAttributes localAttribs =_				AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__		if (localAttribs != null) {_			allAttribs.add(localAttribs)__		}__		return allAttribs__	};return,a,list,of,attribute,maps,for,all,declarations,of,the,given,annotation,on,the,given,annotated,class,using,the,given,metadata,reader,factory,to,introspect,annotation,metadata,meta,annotations,are,ordered,first,in,the,list,and,if,the,target,annotation,is,declared,directly,on,the,class,its,map,of,attributes,will,be,ordered,last,in,the,list,param,target,annotation,the,annotation,to,search,for,both,locally,and,as,a,meta,annotation,param,annotated,class,name,the,class,to,inspect,param,class,values,as,string,whether,class,attributes,should,be,returned,as,strings;private,list,annotation,attributes,find,all,annotation,attributes,class,extends,annotation,target,annotation,string,annotated,class,name,boolean,class,values,as,string,throws,ioexception,list,annotation,attributes,all,attribs,new,array,list,annotation,attributes,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,annotated,class,name,annotation,metadata,metadata,reader,get,annotation,metadata,string,target,annotation,type,target,annotation,get,name,for,string,annotation,type,metadata,get,annotation,types,if,annotation,type,equals,target,annotation,type,continue,annotation,metadata,meta,annotations,this,metadata,reader,factory,get,metadata,reader,annotation,type,get,annotation,metadata,annotation,attributes,target,attribs,annotation,attributes,from,map,meta,annotations,get,annotation,attributes,target,annotation,type,class,values,as,string,if,target,attribs,null,all,attribs,add,target,attribs,annotation,attributes,local,attribs,annotation,attributes,from,map,metadata,get,annotation,attributes,target,annotation,type,class,values,as,string,if,local,attribs,null,all,attribs,add,local,attribs,return,all,attribs
ConfigurationClassParser -> private List<AnnotationAttributes> findAllAnnotationAttributes( 			Class<? extends Annotation> targetAnnotation, String annotatedClassName, 			boolean classValuesAsString) throws IOException;1347311780;Return a list of attribute maps for all declarations of the given annotation_on the given annotated class using the given MetadataReaderFactory to introspect_annotation metadata. Meta-annotations are ordered first in the list, and if the_target annotation is declared directly on the class, its map of attributes will be_ordered last in the list._@param targetAnnotation the annotation to search for, both locally and as a meta-annotation_@param annotatedClassName the class to inspect_@param classValuesAsString whether class attributes should be returned as strings;private List<AnnotationAttributes> findAllAnnotationAttributes(_			Class<? extends Annotation> targetAnnotation, String annotatedClassName,_			boolean classValuesAsString) throws IOException {__		List<AnnotationAttributes> allAttribs = new ArrayList<AnnotationAttributes>()___		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(annotatedClassName)__		AnnotationMetadata metadata = reader.getAnnotationMetadata()__		String targetAnnotationType = targetAnnotation.getName()___		for (String annotationType : metadata.getAnnotationTypes()) {_			if (annotationType.equals(targetAnnotationType)) {_				continue__			}_			AnnotationMetadata metaAnnotations =_					this.metadataReaderFactory.getMetadataReader(annotationType).getAnnotationMetadata()__			AnnotationAttributes targetAttribs =_					AnnotationAttributes.fromMap(metaAnnotations.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__			if (targetAttribs != null) {_				allAttribs.add(targetAttribs)__			}_		}__		AnnotationAttributes localAttribs =_				AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__		if (localAttribs != null) {_			allAttribs.add(localAttribs)__		}__		return allAttribs__	};return,a,list,of,attribute,maps,for,all,declarations,of,the,given,annotation,on,the,given,annotated,class,using,the,given,metadata,reader,factory,to,introspect,annotation,metadata,meta,annotations,are,ordered,first,in,the,list,and,if,the,target,annotation,is,declared,directly,on,the,class,its,map,of,attributes,will,be,ordered,last,in,the,list,param,target,annotation,the,annotation,to,search,for,both,locally,and,as,a,meta,annotation,param,annotated,class,name,the,class,to,inspect,param,class,values,as,string,whether,class,attributes,should,be,returned,as,strings;private,list,annotation,attributes,find,all,annotation,attributes,class,extends,annotation,target,annotation,string,annotated,class,name,boolean,class,values,as,string,throws,ioexception,list,annotation,attributes,all,attribs,new,array,list,annotation,attributes,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,annotated,class,name,annotation,metadata,metadata,reader,get,annotation,metadata,string,target,annotation,type,target,annotation,get,name,for,string,annotation,type,metadata,get,annotation,types,if,annotation,type,equals,target,annotation,type,continue,annotation,metadata,meta,annotations,this,metadata,reader,factory,get,metadata,reader,annotation,type,get,annotation,metadata,annotation,attributes,target,attribs,annotation,attributes,from,map,meta,annotations,get,annotation,attributes,target,annotation,type,class,values,as,string,if,target,attribs,null,all,attribs,add,target,attribs,annotation,attributes,local,attribs,annotation,attributes,from,map,metadata,get,annotation,attributes,target,annotation,type,class,values,as,string,if,local,attribs,null,all,attribs,add,local,attribs,return,all,attribs
ConfigurationClassParser -> private List<AnnotationAttributes> findAllAnnotationAttributes( 			Class<? extends Annotation> targetAnnotation, String annotatedClassName, 			boolean classValuesAsString) throws IOException;1347375001;Return a list of attribute maps for all declarations of the given annotation_on the given annotated class using the given MetadataReaderFactory to introspect_annotation metadata. Meta-annotations are ordered first in the list, and if the_target annotation is declared directly on the class, its map of attributes will be_ordered last in the list._@param targetAnnotation the annotation to search for, both locally and as a meta-annotation_@param annotatedClassName the class to inspect_@param classValuesAsString whether class attributes should be returned as strings;private List<AnnotationAttributes> findAllAnnotationAttributes(_			Class<? extends Annotation> targetAnnotation, String annotatedClassName,_			boolean classValuesAsString) throws IOException {__		List<AnnotationAttributes> allAttribs = new ArrayList<AnnotationAttributes>()___		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(annotatedClassName)__		AnnotationMetadata metadata = reader.getAnnotationMetadata()__		String targetAnnotationType = targetAnnotation.getName()___		for (String annotationType : metadata.getAnnotationTypes()) {_			if (annotationType.equals(targetAnnotationType)) {_				continue__			}_			AnnotationMetadata metaAnnotations =_					this.metadataReaderFactory.getMetadataReader(annotationType).getAnnotationMetadata()__			AnnotationAttributes targetAttribs =_					AnnotationAttributes.fromMap(metaAnnotations.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__			if (targetAttribs != null) {_				allAttribs.add(targetAttribs)__			}_		}__		AnnotationAttributes localAttribs =_				AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(targetAnnotationType, classValuesAsString))__		if (localAttribs != null) {_			allAttribs.add(localAttribs)__		}__		return allAttribs__	};return,a,list,of,attribute,maps,for,all,declarations,of,the,given,annotation,on,the,given,annotated,class,using,the,given,metadata,reader,factory,to,introspect,annotation,metadata,meta,annotations,are,ordered,first,in,the,list,and,if,the,target,annotation,is,declared,directly,on,the,class,its,map,of,attributes,will,be,ordered,last,in,the,list,param,target,annotation,the,annotation,to,search,for,both,locally,and,as,a,meta,annotation,param,annotated,class,name,the,class,to,inspect,param,class,values,as,string,whether,class,attributes,should,be,returned,as,strings;private,list,annotation,attributes,find,all,annotation,attributes,class,extends,annotation,target,annotation,string,annotated,class,name,boolean,class,values,as,string,throws,ioexception,list,annotation,attributes,all,attribs,new,array,list,annotation,attributes,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,annotated,class,name,annotation,metadata,metadata,reader,get,annotation,metadata,string,target,annotation,type,target,annotation,get,name,for,string,annotation,type,metadata,get,annotation,types,if,annotation,type,equals,target,annotation,type,continue,annotation,metadata,meta,annotations,this,metadata,reader,factory,get,metadata,reader,annotation,type,get,annotation,metadata,annotation,attributes,target,attribs,annotation,attributes,from,map,meta,annotations,get,annotation,attributes,target,annotation,type,class,values,as,string,if,target,attribs,null,all,attribs,add,target,attribs,annotation,attributes,local,attribs,annotation,attributes,from,map,metadata,get,annotation,attributes,target,annotation,type,class,values,as,string,if,local,attribs,null,all,attribs,add,local,attribs,return,all,attribs
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1372363092;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1374264616;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1375216602;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1377269365;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1377562322;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1377625191;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1377640854;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1381881109;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1382386279;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1382465750;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1384512601;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1385158940;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1385412762;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1385978370;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1393377752;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1394195941;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1397058189;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1398637994;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1398720297;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1400245582;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1402056098;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1405454692;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1407857001;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1408653788;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1408681275;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1408708479;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1408748821;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1409688471;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1409716050;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1409741991;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1410880110;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1411076915;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1411110630;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1411165756;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
ConfigurationClassParser -> protected final void parse(String className, String beanName) throws IOException;1413937661;Parse the specified {@link Configuration @Configuration} class._@param className the name of the class to parse_@param beanName may be null, but if populated represents the bean id_(assumes that this configuration class was configured via XML);protected final void parse(String className, String beanName) throws IOException {_		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className)__		processConfigurationClass(new ConfigurationClass(reader, beanName))__	};parse,the,specified,link,configuration,configuration,class,param,class,name,the,name,of,the,class,to,parse,param,bean,name,may,be,null,but,if,populated,represents,the,bean,id,assumes,that,this,configuration,class,was,configured,via,xml;protected,final,void,parse,string,class,name,string,bean,name,throws,ioexception,metadata,reader,reader,this,metadata,reader,factory,get,metadata,reader,class,name,process,configuration,class,new,configuration,class,reader,bean,name
