commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// Early cache initialization on startup @Override public void afterPropertiesSet() {     initializeCaches(). }
true;public;0;15;/**  * Initialize the static configuration of caches.  * <p>Triggered on startup through {@link #afterPropertiesSet()}.  * can also be called to re-initialize at runtime.  * @since 4.2.2  * @see #loadCaches()  */ ;/**  * Initialize the static configuration of caches.  * <p>Triggered on startup through {@link #afterPropertiesSet()}.  * can also be called to re-initialize at runtime.  * @since 4.2.2  * @see #loadCaches()  */ public void initializeCaches() {     Collection<? extends Cache> caches = loadCaches().     synchronized (this.cacheMap) {         this.cacheNames = Collections.emptySet().         this.cacheMap.clear().         Set<String> cacheNames = new LinkedHashSet<>(caches.size()).         for (Cache cache : caches) {             String name = cache.getName().             this.cacheMap.put(name, decorateCache(cache)).             cacheNames.add(name).         }         this.cacheNames = Collections.unmodifiableSet(cacheNames).     } }
true;protected,abstract;0;1;/**  * Load the initial caches for this cache manager.  * <p>Called by {@link #afterPropertiesSet()} on startup.  * The returned collection may be empty but must not be {@code null}.  */ ;/**  * Load the initial caches for this cache manager.  * <p>Called by {@link #afterPropertiesSet()} on startup.  * The returned collection may be empty but must not be {@code null}.  */ protected abstract Collection<? extends Cache> loadCaches().
false;public;1;23;;// Lazy cache initialization on access @Override @Nullable public Cache getCache(String name) {     Cache cache = this.cacheMap.get(name).     if (cache != null) {         return cache.     } else {         // Fully synchronize now for missing cache creation...         synchronized (this.cacheMap) {             cache = this.cacheMap.get(name).             if (cache == null) {                 cache = getMissingCache(name).                 if (cache != null) {                     cache = decorateCache(cache).                     this.cacheMap.put(name, cache).                     updateCacheNames(name).                 }             }             return cache.         }     } }
false;public;0;4;;@Override public Collection<String> getCacheNames() {     return this.cacheNames. }
true;protected,final;1;4;/**  * Check for a registered cache of the given name.  * In contrast to {@link #getCache(String)}, this method does not trigger  * the lazy creation of missing caches via {@link #getMissingCache(String)}.  * @param name the cache identifier (must not be {@code null})  * @return the associated Cache instance, or {@code null} if none found  * @since 4.1  * @see #getCache(String)  * @see #getMissingCache(String)  */ ;// Common cache initialization delegates for subclasses /**  * Check for a registered cache of the given name.  * In contrast to {@link #getCache(String)}, this method does not trigger  * the lazy creation of missing caches via {@link #getMissingCache(String)}.  * @param name the cache identifier (must not be {@code null})  * @return the associated Cache instance, or {@code null} if none found  * @since 4.1  * @see #getCache(String)  * @see #getMissingCache(String)  */ @Nullable protected final Cache lookupCache(String name) {     return this.cacheMap.get(name). }
true;protected,final;1;9;/**  * Dynamically register an additional Cache with this manager.  * @param cache the Cache to register  * @deprecated as of Spring 4.3, in favor of {@link #getMissingCache(String)}  */ ;/**  * Dynamically register an additional Cache with this manager.  * @param cache the Cache to register  * @deprecated as of Spring 4.3, in favor of {@link #getMissingCache(String)}  */ @Deprecated protected final void addCache(Cache cache) {     String name = cache.getName().     synchronized (this.cacheMap) {         if (this.cacheMap.put(name, decorateCache(cache)) == null) {             updateCacheNames(name).         }     } }
true;private;1;6;/**  * Update the exposed {@link #cacheNames} set with the given name.  * <p>This will always be called within a full {@link #cacheMap} lock  * and effectively behaves like a {@code CopyOnWriteArraySet} with  * preserved order but exposed as an unmodifiable reference.  * @param name the name of the cache to be added  */ ;/**  * Update the exposed {@link #cacheNames} set with the given name.  * <p>This will always be called within a full {@link #cacheMap} lock  * and effectively behaves like a {@code CopyOnWriteArraySet} with  * preserved order but exposed as an unmodifiable reference.  * @param name the name of the cache to be added  */ private void updateCacheNames(String name) {     Set<String> cacheNames = new LinkedHashSet<>(this.cacheNames.size() + 1).     cacheNames.addAll(this.cacheNames).     cacheNames.add(name).     this.cacheNames = Collections.unmodifiableSet(cacheNames). }
true;protected;1;3;/**  * Decorate the given Cache object if necessary.  * @param cache the Cache object to be added to this CacheManager  * @return the decorated Cache object to be used instead,  * or simply the passed-in Cache object by default  */ ;// Overridable template methods for cache initialization /**  * Decorate the given Cache object if necessary.  * @param cache the Cache object to be added to this CacheManager  * @return the decorated Cache object to be used instead,  * or simply the passed-in Cache object by default  */ protected Cache decorateCache(Cache cache) {     return cache. }
true;protected;1;4;/**  * Return a missing cache with the specified {@code name} or {@code null} if  * such cache does not exist or could not be created on the fly.  * <p>Some caches may be created at runtime if the native provider supports  * it. If a lookup by name does not yield any result, a subclass gets a chance  * to register such a cache at runtime. The returned cache will be automatically  * added to this instance.  * @param name the name of the cache to retrieve  * @return the missing cache or {@code null} if no such cache exists or could be  * created  * @since 4.1  * @see #getCache(String)  */ ;/**  * Return a missing cache with the specified {@code name} or {@code null} if  * such cache does not exist or could not be created on the fly.  * <p>Some caches may be created at runtime if the native provider supports  * it. If a lookup by name does not yield any result, a subclass gets a chance  * to register such a cache at runtime. The returned cache will be automatically  * added to this instance.  * @param name the name of the cache to retrieve  * @return the missing cache or {@code null} if no such cache exists or could be  * created  * @since 4.1  * @see #getCache(String)  */ @Nullable protected Cache getMissingCache(String name) {     return null. }
