commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected boolean matchClassName(String className) {     return declaringClass.equals(className). }
false;public;2;58;;public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {     ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader).     Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator").     boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass).     scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator : BeanUtils.instantiateClass(generatorClass)).     ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy").     if (scopedProxyMode != ScopedProxyMode.DEFAULT) {         scanner.setScopedProxyMode(scopedProxyMode).     } else {         Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver").         scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass)).     }     scanner.setResourcePattern(componentScan.getString("resourcePattern")).     for (AnnotationAttributes filter : componentScan.getAnnotationArray("includeFilters")) {         for (TypeFilter typeFilter : typeFiltersFor(filter)) {             scanner.addIncludeFilter(typeFilter).         }     }     for (AnnotationAttributes filter : componentScan.getAnnotationArray("excludeFilters")) {         for (TypeFilter typeFilter : typeFiltersFor(filter)) {             scanner.addExcludeFilter(typeFilter).         }     }     boolean lazyInit = componentScan.getBoolean("lazyInit").     if (lazyInit) {         scanner.getBeanDefinitionDefaults().setLazyInit(true).     }     Set<String> basePackages = new LinkedHashSet<>().     String[] basePackagesArray = componentScan.getStringArray("basePackages").     for (String pkg : basePackagesArray) {         String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg), ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS).         Collections.addAll(basePackages, tokenized).     }     for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {         basePackages.add(ClassUtils.getPackageName(clazz)).     }     if (basePackages.isEmpty()) {         basePackages.add(ClassUtils.getPackageName(declaringClass)).     }     scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {          @Override         protected boolean matchClassName(String className) {             return declaringClass.equals(className).         }     }).     return scanner.doScan(StringUtils.toStringArray(basePackages)). }
false;private;1;44;;private List<TypeFilter> typeFiltersFor(AnnotationAttributes filterAttributes) {     List<TypeFilter> typeFilters = new ArrayList<>().     FilterType filterType = filterAttributes.getEnum("type").     for (Class<?> filterClass : filterAttributes.getClassArray("classes")) {         switch(filterType) {             case ANNOTATION:                 Assert.isAssignable(Annotation.class, filterClass, "@ComponentScan ANNOTATION type filter requires an annotation type").                 @SuppressWarnings("unchecked")                 Class<Annotation> annotationType = (Class<Annotation>) filterClass.                 typeFilters.add(new AnnotationTypeFilter(annotationType)).                 break.             case ASSIGNABLE_TYPE:                 typeFilters.add(new AssignableTypeFilter(filterClass)).                 break.             case CUSTOM:                 Assert.isAssignable(TypeFilter.class, filterClass, "@ComponentScan CUSTOM type filter requires a TypeFilter implementation").                 TypeFilter filter = BeanUtils.instantiateClass(filterClass, TypeFilter.class).                 ParserStrategyUtils.invokeAwareMethods(filter, this.environment, this.resourceLoader, this.registry).                 typeFilters.add(filter).                 break.             default:                 throw new IllegalArgumentException("Filter type not supported with Class value: " + filterType).         }     }     for (String expression : filterAttributes.getStringArray("pattern")) {         switch(filterType) {             case ASPECTJ:                 typeFilters.add(new AspectJTypeFilter(expression, this.resourceLoader.getClassLoader())).                 break.             case REGEX:                 typeFilters.add(new RegexPatternTypeFilter(Pattern.compile(expression))).                 break.             default:                 throw new IllegalArgumentException("Filter type not supported with String pattern: " + filterType).         }     }     return typeFilters. }
