commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Class<?>[] getSpecificTargetClasses() {     return new Class<?>[] { Map.class }. }
false;public;3;4;;@Override public boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {     return (target instanceof Map && ((Map<?, ?>) target).containsKey(name)). }
false;public;3;10;;@Override public TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {     Assert.state(target instanceof Map, "Target must be of type Map").     Map<?, ?> map = (Map<?, ?>) target.     Object value = map.get(name).     if (value == null && !map.containsKey(name)) {         throw new MapAccessException(name).     }     return new TypedValue(value). }
false;public;3;4;;@Override public boolean canWrite(EvaluationContext context, @Nullable Object target, String name) throws AccessException {     return true. }
false;public;4;9;;@Override @SuppressWarnings("unchecked") public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) throws AccessException {     Assert.state(target instanceof Map, "Target must be a Map").     Map<Object, Object> map = (Map<Object, Object>) target.     map.put(name, newValue). }
false;public;0;4;;@Override public boolean isCompilable() {     return true. }
false;public;0;4;;@Override public Class<?> getPropertyType() {     return Object.class. }
false;public;3;12;;@Override public void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {     String descriptor = cf.lastDescriptor().     if (descriptor == null || !descriptor.equals("Ljava/util/Map")) {         if (descriptor == null) {             cf.loadTarget(mv).         }         CodeFlow.insertCheckCast(mv, "Ljava/util/Map").     }     mv.visitLdcInsn(propertyName).     mv.visitMethodInsn(INVOKEINTERFACE, "java/util/Map", "get", "(Ljava/lang/Object.)Ljava/lang/Object.", true). }
false;public;0;4;;@Override public String getMessage() {     return "Map does not contain a value for key '" + this.key + "'". }
