commented;modifiers;parameterAmount;loc;comment;code
true;public;4;9;/**  * Configure this aspect with the given error handler, key generator and cache resolver/manager  * suppliers, applying the corresponding default if a supplier is not resolvable.  * @since 5.1  */ ;/**  * Configure this aspect with the given error handler, key generator and cache resolver/manager  * suppliers, applying the corresponding default if a supplier is not resolvable.  * @since 5.1  */ public void configure(@Nullable Supplier<CacheErrorHandler> errorHandler, @Nullable Supplier<KeyGenerator> keyGenerator, @Nullable Supplier<CacheResolver> cacheResolver, @Nullable Supplier<CacheManager> cacheManager) {     this.errorHandler = new SingletonSupplier<>(errorHandler, SimpleCacheErrorHandler::new).     this.keyGenerator = new SingletonSupplier<>(keyGenerator, SimpleKeyGenerator::new).     this.cacheResolver = new SingletonSupplier<>(cacheResolver, () -> SimpleCacheResolver.of(SupplierUtils.resolve(cacheManager))). }
true;public;1;5;/**  * Set one or more cache operation sources which are used to find the cache  * attributes. If more than one source is provided, they will be aggregated  * using a {@link CompositeCacheOperationSource}.  * @see #setCacheOperationSource  */ ;/**  * Set one or more cache operation sources which are used to find the cache  * attributes. If more than one source is provided, they will be aggregated  * using a {@link CompositeCacheOperationSource}.  * @see #setCacheOperationSource  */ public void setCacheOperationSources(CacheOperationSource... cacheOperationSources) {     Assert.notEmpty(cacheOperationSources, "At least 1 CacheOperationSource needs to be specified").     this.cacheOperationSource = (cacheOperationSources.length > 1 ? new CompositeCacheOperationSource(cacheOperationSources) : cacheOperationSources[0]). }
true;public;1;3;/**  * Set the CacheOperationSource for this cache aspect.  * @since 5.1  * @see #setCacheOperationSources  */ ;/**  * Set the CacheOperationSource for this cache aspect.  * @since 5.1  * @see #setCacheOperationSources  */ public void setCacheOperationSource(@Nullable CacheOperationSource cacheOperationSource) {     this.cacheOperationSource = cacheOperationSource. }
true;public;0;4;/**  * Return the CacheOperationSource for this cache aspect.  */ ;/**  * Return the CacheOperationSource for this cache aspect.  */ @Nullable public CacheOperationSource getCacheOperationSource() {     return this.cacheOperationSource. }
true;public;1;3;/**  * Set the default {@link KeyGenerator} that this cache aspect should delegate to  * if no specific key generator has been set for the operation.  * <p>The default is a {@link SimpleKeyGenerator}.  */ ;/**  * Set the default {@link KeyGenerator} that this cache aspect should delegate to  * if no specific key generator has been set for the operation.  * <p>The default is a {@link SimpleKeyGenerator}.  */ public void setKeyGenerator(KeyGenerator keyGenerator) {     this.keyGenerator = SingletonSupplier.of(keyGenerator). }
true;public;0;3;/**  * Return the default {@link KeyGenerator} that this cache aspect delegates to.  */ ;/**  * Return the default {@link KeyGenerator} that this cache aspect delegates to.  */ public KeyGenerator getKeyGenerator() {     return this.keyGenerator.obtain(). }
true;public;1;3;/**  * Set the default {@link CacheResolver} that this cache aspect should delegate  * to if no specific cache resolver has been set for the operation.  * <p>The default resolver resolves the caches against their names and the  * default cache manager.  * @see #setCacheManager  * @see SimpleCacheResolver  */ ;/**  * Set the default {@link CacheResolver} that this cache aspect should delegate  * to if no specific cache resolver has been set for the operation.  * <p>The default resolver resolves the caches against their names and the  * default cache manager.  * @see #setCacheManager  * @see SimpleCacheResolver  */ public void setCacheResolver(@Nullable CacheResolver cacheResolver) {     this.cacheResolver = SingletonSupplier.ofNullable(cacheResolver). }
true;public;0;4;/**  * Return the default {@link CacheResolver} that this cache aspect delegates to.  */ ;/**  * Return the default {@link CacheResolver} that this cache aspect delegates to.  */ @Nullable public CacheResolver getCacheResolver() {     return SupplierUtils.resolve(this.cacheResolver). }
true;public;1;3;/**  * Set the {@link CacheManager} to use to create a default {@link CacheResolver}.  * Replace the current {@link CacheResolver}, if any.  * @see #setCacheResolver  * @see SimpleCacheResolver  */ ;/**  * Set the {@link CacheManager} to use to create a default {@link CacheResolver}.  * Replace the current {@link CacheResolver}, if any.  * @see #setCacheResolver  * @see SimpleCacheResolver  */ public void setCacheManager(CacheManager cacheManager) {     this.cacheResolver = SingletonSupplier.of(new SimpleCacheResolver(cacheManager)). }
true;public;1;4;/**  * Set the containing {@link BeanFactory} for {@link CacheManager} and other  * service lookups.  * @since 4.3  */ ;/**  * Set the containing {@link BeanFactory} for {@link CacheManager} and other  * service lookups.  * @since 4.3  */ @Override public void setBeanFactory(BeanFactory beanFactory) {     this.beanFactory = beanFactory. }
false;public;0;5;;@Override public void afterPropertiesSet() {     Assert.state(getCacheOperationSource() != null, "The 'cacheOperationSources' property is required: " + "If there are no cacheable methods, then don't use a cache aspect."). }
false;public;0;19;;@Override public void afterSingletonsInstantiated() {     if (getCacheResolver() == null) {         // Lazily initialize cache resolver via default cache manager...         Assert.state(this.beanFactory != null, "CacheResolver or BeanFactory must be set on cache aspect").         try {             setCacheManager(this.beanFactory.getBean(CacheManager.class)).         } catch (NoUniqueBeanDefinitionException ex) {             throw new IllegalStateException("No CacheResolver specified, and no unique bean of type " + "CacheManager found. Mark one as primary or declare a specific CacheManager to use.").         } catch (NoSuchBeanDefinitionException ex) {             throw new IllegalStateException("No CacheResolver specified, and no bean of type CacheManager found. " + "Register a CacheManager bean or remove the @EnableCaching annotation from your configuration.").         }     }     this.initialized = true. }
true;protected;2;4;/**  * Convenience method to return a String representation of this Method  * for use in logging. Can be overridden in subclasses to provide a  * different identifier for the given method.  * @param method the method we're interested in  * @param targetClass class the method is on  * @return log message identifying this method  * @see org.springframework.util.ClassUtils#getQualifiedMethodName  */ ;/**  * Convenience method to return a String representation of this Method  * for use in logging. Can be overridden in subclasses to provide a  * different identifier for the given method.  * @param method the method we're interested in  * @param targetClass class the method is on  * @return log message identifying this method  * @see org.springframework.util.ClassUtils#getQualifiedMethodName  */ protected String methodIdentification(Method method, Class<?> targetClass) {     Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass).     return ClassUtils.getQualifiedMethodName(specificMethod). }
false;protected;2;11;;protected Collection<? extends Cache> getCaches(CacheOperationInvocationContext<CacheOperation> context, CacheResolver cacheResolver) {     Collection<? extends Cache> caches = cacheResolver.resolveCaches(context).     if (caches.isEmpty()) {         throw new IllegalStateException("No cache could be resolved for '" + context.getOperation() + "' using resolver '" + cacheResolver + "'. At least one cache should be provided per cache operation.").     }     return caches. }
false;protected;5;6;;protected CacheOperationContext getOperationContext(CacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass) {     CacheOperationMetadata metadata = getCacheOperationMetadata(operation, method, targetClass).     return new CacheOperationContext(metadata, args, target). }
true;protected;3;31;/**  * Return the {@link CacheOperationMetadata} for the specified operation.  * <p>Resolve the {@link CacheResolver} and the {@link KeyGenerator} to be  * used for the operation.  * @param operation the operation  * @param method the method on which the operation is invoked  * @param targetClass the target type  * @return the resolved metadata for the operation  */ ;/**  * Return the {@link CacheOperationMetadata} for the specified operation.  * <p>Resolve the {@link CacheResolver} and the {@link KeyGenerator} to be  * used for the operation.  * @param operation the operation  * @param method the method on which the operation is invoked  * @param targetClass the target type  * @return the resolved metadata for the operation  */ protected CacheOperationMetadata getCacheOperationMetadata(CacheOperation operation, Method method, Class<?> targetClass) {     CacheOperationCacheKey cacheKey = new CacheOperationCacheKey(operation, method, targetClass).     CacheOperationMetadata metadata = this.metadataCache.get(cacheKey).     if (metadata == null) {         KeyGenerator operationKeyGenerator.         if (StringUtils.hasText(operation.getKeyGenerator())) {             operationKeyGenerator = getBean(operation.getKeyGenerator(), KeyGenerator.class).         } else {             operationKeyGenerator = getKeyGenerator().         }         CacheResolver operationCacheResolver.         if (StringUtils.hasText(operation.getCacheResolver())) {             operationCacheResolver = getBean(operation.getCacheResolver(), CacheResolver.class).         } else if (StringUtils.hasText(operation.getCacheManager())) {             CacheManager cacheManager = getBean(operation.getCacheManager(), CacheManager.class).             operationCacheResolver = new SimpleCacheResolver(cacheManager).         } else {             operationCacheResolver = getCacheResolver().             Assert.state(operationCacheResolver != null, "No CacheResolver/CacheManager set").         }         metadata = new CacheOperationMetadata(operation, method, targetClass, operationKeyGenerator, operationCacheResolver).         this.metadataCache.put(cacheKey, metadata).     }     return metadata. }
true;protected;2;7;/**  * Return a bean with the specified name and type. Used to resolve services that  * are referenced by name in a {@link CacheOperation}.  * @param beanName the name of the bean, as defined by the operation  * @param expectedType type for the bean  * @return the bean matching that name  * @throws org.springframework.beans.factory.NoSuchBeanDefinitionException if such bean does not exist  * @see CacheOperation#keyGenerator  * @see CacheOperation#cacheManager  * @see CacheOperation#cacheResolver  */ ;/**  * Return a bean with the specified name and type. Used to resolve services that  * are referenced by name in a {@link CacheOperation}.  * @param beanName the name of the bean, as defined by the operation  * @param expectedType type for the bean  * @return the bean matching that name  * @throws org.springframework.beans.factory.NoSuchBeanDefinitionException if such bean does not exist  * @see CacheOperation#keyGenerator  * @see CacheOperation#cacheManager  * @see CacheOperation#cacheResolver  */ protected <T> T getBean(String beanName, Class<T> expectedType) {     if (this.beanFactory == null) {         throw new IllegalStateException("BeanFactory must be set on cache aspect for " + expectedType.getSimpleName() + " retrieval").     }     return BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, expectedType, beanName). }
true;protected;0;4;/**  * Clear the cached metadata.  */ ;/**  * Clear the cached metadata.  */ protected void clearMetadataCache() {     this.metadataCache.clear().     this.evaluator.clear(). }
false;protected;4;17;;@Nullable protected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args) {     // Check whether aspect is enabled (to cope with cases where the AJ is pulled in automatically)     if (this.initialized) {         Class<?> targetClass = getTargetClass(target).         CacheOperationSource cacheOperationSource = getCacheOperationSource().         if (cacheOperationSource != null) {             Collection<CacheOperation> operations = cacheOperationSource.getCacheOperations(method, targetClass).             if (!CollectionUtils.isEmpty(operations)) {                 return execute(invoker, method, new CacheOperationContexts(operations, method, args, target, targetClass)).             }         }     }     return invoker.invoke(). }
true;protected;1;3;/**  * Execute the underlying operation (typically in case of cache miss) and return  * the result of the invocation. If an exception occurs it will be wrapped in  * a {@link CacheOperationInvoker.ThrowableWrapper}: the exception can be handled  * or modified but it <em>must</em> be wrapped in a  * {@link CacheOperationInvoker.ThrowableWrapper} as well.  * @param invoker the invoker handling the operation being cached  * @return the result of the invocation  * @see CacheOperationInvoker#invoke()  */ ;/**  * Execute the underlying operation (typically in case of cache miss) and return  * the result of the invocation. If an exception occurs it will be wrapped in  * a {@link CacheOperationInvoker.ThrowableWrapper}: the exception can be handled  * or modified but it <em>must</em> be wrapped in a  * {@link CacheOperationInvoker.ThrowableWrapper} as well.  * @param invoker the invoker handling the operation being cached  * @return the result of the invocation  * @see CacheOperationInvoker#invoke()  */ protected Object invokeOperation(CacheOperationInvoker invoker) {     return invoker.invoke(). }
false;private;1;3;;private Class<?> getTargetClass(Object target) {     return AopProxyUtils.ultimateTargetClass(target). }
false;private;3;65;;@Nullable private Object execute(final CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts) {     // Special handling of synchronized invocation     if (contexts.isSynchronized()) {         CacheOperationContext context = contexts.get(CacheableOperation.class).iterator().next().         if (isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) {             Object key = generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT).             Cache cache = context.getCaches().iterator().next().             try {                 return wrapCacheValue(method, cache.get(key, () -> unwrapReturnValue(invokeOperation(invoker)))).             } catch (Cache.ValueRetrievalException ex) {                 // can just make sure that one bubbles up the stack.                 throw (CacheOperationInvoker.ThrowableWrapper) ex.getCause().             }         } else {             // No caching required, only call the underlying method             return invokeOperation(invoker).         }     }     // Process any early evictions     processCacheEvicts(contexts.get(CacheEvictOperation.class), true, CacheOperationExpressionEvaluator.NO_RESULT).     // Check if we have a cached item matching the conditions     Cache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class)).     // Collect puts from any @Cacheable miss, if no cached item is found     List<CachePutRequest> cachePutRequests = new LinkedList<>().     if (cacheHit == null) {         collectPutRequests(contexts.get(CacheableOperation.class), CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests).     }     Object cacheValue.     Object returnValue.     if (cacheHit != null && !hasCachePut(contexts)) {         // If there are no put requests, just use the cache hit         cacheValue = cacheHit.get().         returnValue = wrapCacheValue(method, cacheValue).     } else {         // Invoke the method if we don't have a cache hit         returnValue = invokeOperation(invoker).         cacheValue = unwrapReturnValue(returnValue).     }     // Collect any explicit @CachePuts     collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests).     // Process any collected put requests, either from @CachePut or a @Cacheable miss     for (CachePutRequest cachePutRequest : cachePutRequests) {         cachePutRequest.apply(cacheValue).     }     // Process any late evictions     processCacheEvicts(contexts.get(CacheEvictOperation.class), false, cacheValue).     return returnValue. }
false;private;2;8;;@Nullable private Object wrapCacheValue(Method method, @Nullable Object cacheValue) {     if (method.getReturnType() == Optional.class && (cacheValue == null || cacheValue.getClass() != Optional.class)) {         return Optional.ofNullable(cacheValue).     }     return cacheValue. }
false;private;1;4;;@Nullable private Object unwrapReturnValue(Object returnValue) {     return ObjectUtils.unwrapOptional(returnValue). }
false;private;1;17;;private boolean hasCachePut(CacheOperationContexts contexts) {     // Evaluate the conditions *without* the result object because we don't have it yet...     Collection<CacheOperationContext> cachePutContexts = contexts.get(CachePutOperation.class).     Collection<CacheOperationContext> excluded = new ArrayList<>().     for (CacheOperationContext context : cachePutContexts) {         try {             if (!context.isConditionPassing(CacheOperationExpressionEvaluator.RESULT_UNAVAILABLE)) {                 excluded.add(context).             }         } catch (VariableNotAvailableException ex) {         // Ignoring failure due to missing result, consider the cache put has to proceed         }     }     // Check if all puts have been excluded by condition     return (cachePutContexts.size() != excluded.size()). }
false;private;3;10;;private void processCacheEvicts(Collection<CacheOperationContext> contexts, boolean beforeInvocation, @Nullable Object result) {     for (CacheOperationContext context : contexts) {         CacheEvictOperation operation = (CacheEvictOperation) context.metadata.operation.         if (beforeInvocation == operation.isBeforeInvocation() && isConditionPassing(context, result)) {             performCacheEvict(context, operation, result).         }     } }
false;private;3;18;;private void performCacheEvict(CacheOperationContext context, CacheEvictOperation operation, @Nullable Object result) {     Object key = null.     for (Cache cache : context.getCaches()) {         if (operation.isCacheWide()) {             logInvalidating(context, operation, null).             doClear(cache).         } else {             if (key == null) {                 key = generateKey(context, result).             }             logInvalidating(context, operation, key).             doEvict(cache, key).         }     } }
false;private;3;6;;private void logInvalidating(CacheOperationContext context, CacheEvictOperation operation, @Nullable Object key) {     if (logger.isTraceEnabled()) {         logger.trace("Invalidating " + (key != null ? "cache key [" + key + "]" : "entire cache") + " for operation " + operation + " on method " + context.metadata.method).     } }
true;private;1;19;/**  * Find a cached item only for {@link CacheableOperation} that passes the condition.  * @param contexts the cacheable operations  * @return a {@link Cache.ValueWrapper} holding the cached item,  * or {@code null} if none is found  */ ;/**  * Find a cached item only for {@link CacheableOperation} that passes the condition.  * @param contexts the cacheable operations  * @return a {@link Cache.ValueWrapper} holding the cached item,  * or {@code null} if none is found  */ @Nullable private Cache.ValueWrapper findCachedItem(Collection<CacheOperationContext> contexts) {     Object result = CacheOperationExpressionEvaluator.NO_RESULT.     for (CacheOperationContext context : contexts) {         if (isConditionPassing(context, result)) {             Object key = generateKey(context, result).             Cache.ValueWrapper cached = findInCaches(context, key).             if (cached != null) {                 return cached.             } else {                 if (logger.isTraceEnabled()) {                     logger.trace("No cache entry for key '" + key + "' in cache(s) " + context.getCacheNames()).                 }             }         }     }     return null. }
true;private;3;10;/**  * Collect the {@link CachePutRequest} for all {@link CacheOperation} using  * the specified result item.  * @param contexts the contexts to handle  * @param result the result item (never {@code null})  * @param putRequests the collection to update  */ ;/**  * Collect the {@link CachePutRequest} for all {@link CacheOperation} using  * the specified result item.  * @param contexts the contexts to handle  * @param result the result item (never {@code null})  * @param putRequests the collection to update  */ private void collectPutRequests(Collection<CacheOperationContext> contexts, @Nullable Object result, Collection<CachePutRequest> putRequests) {     for (CacheOperationContext context : contexts) {         if (isConditionPassing(context, result)) {             Object key = generateKey(context, result).             putRequests.add(new CachePutRequest(context, key)).         }     } }
false;private;2;13;;@Nullable private Cache.ValueWrapper findInCaches(CacheOperationContext context, Object key) {     for (Cache cache : context.getCaches()) {         Cache.ValueWrapper wrapper = doGet(cache, key).         if (wrapper != null) {             if (logger.isTraceEnabled()) {                 logger.trace("Cache entry for key '" + key + "' found in cache '" + cache.getName() + "'").             }             return wrapper.         }     }     return null. }
false;private;2;8;;private boolean isConditionPassing(CacheOperationContext context, @Nullable Object result) {     boolean passing = context.isConditionPassing(result).     if (!passing && logger.isTraceEnabled()) {         logger.trace("Cache condition failed on method " + context.metadata.method + " for operation " + context.metadata.operation).     }     return passing. }
false;private;2;11;;private Object generateKey(CacheOperationContext context, @Nullable Object result) {     Object key = context.generateKey(result).     if (key == null) {         throw new IllegalArgumentException("Null key returned for cache operation (maybe you are " + "using named params on classes without debug info?) " + context.metadata.operation).     }     if (logger.isTraceEnabled()) {         logger.trace("Computed cache key '" + key + "' for operation " + context.metadata.operation).     }     return key. }
false;public;1;4;;public Collection<CacheOperationContext> get(Class<? extends CacheOperation> operationClass) {     Collection<CacheOperationContext> result = this.contexts.get(operationClass).     return (result != null ? result : Collections.emptyList()). }
false;public;0;3;;public boolean isSynchronized() {     return this.sync. }
false;private;1;35;;private boolean determineSyncFlag(Method method) {     List<CacheOperationContext> cacheOperationContexts = this.contexts.get(CacheableOperation.class).     if (cacheOperationContexts == null) {         // no @Cacheable operation at all         return false.     }     boolean syncEnabled = false.     for (CacheOperationContext cacheOperationContext : cacheOperationContexts) {         if (((CacheableOperation) cacheOperationContext.getOperation()).isSync()) {             syncEnabled = true.             break.         }     }     if (syncEnabled) {         if (this.contexts.size() > 1) {             throw new IllegalStateException("@Cacheable(sync=true) cannot be combined with other cache operations on '" + method + "'").         }         if (cacheOperationContexts.size() > 1) {             throw new IllegalStateException("Only one @Cacheable(sync=true) entry is allowed on '" + method + "'").         }         CacheOperationContext cacheOperationContext = cacheOperationContexts.iterator().next().         CacheableOperation operation = (CacheableOperation) cacheOperationContext.getOperation().         if (cacheOperationContext.getCaches().size() > 1) {             throw new IllegalStateException("@Cacheable(sync=true) only allows a single cache on '" + operation + "'").         }         if (StringUtils.hasText(operation.getUnless())) {             throw new IllegalStateException("@Cacheable(sync=true) does not support unless attribute on '" + operation + "'").         }         return true.     }     return false. }
false;public;0;4;;@Override public CacheOperation getOperation() {     return this.metadata.operation. }
false;public;0;4;;@Override public Object getTarget() {     return this.target. }
false;public;0;4;;@Override public Method getMethod() {     return this.metadata.method. }
false;public;0;4;;@Override public Object[] getArgs() {     return this.args. }
false;private;2;10;;private Object[] extractArgs(Method method, Object[] args) {     if (!method.isVarArgs()) {         return args.     }     Object[] varArgs = ObjectUtils.toObjectArray(args[args.length - 1]).     Object[] combinedArgs = new Object[args.length - 1 + varArgs.length].     System.arraycopy(args, 0, combinedArgs, 0, args.length - 1).     System.arraycopy(varArgs, 0, combinedArgs, args.length - 1, varArgs.length).     return combinedArgs. }
false;protected;1;13;;protected boolean isConditionPassing(@Nullable Object result) {     if (this.conditionPassing == null) {         if (StringUtils.hasText(this.metadata.operation.getCondition())) {             EvaluationContext evaluationContext = createEvaluationContext(result).             this.conditionPassing = evaluator.condition(this.metadata.operation.getCondition(), this.metadata.methodKey, evaluationContext).         } else {             this.conditionPassing = true.         }     }     return this.conditionPassing. }
false;protected;1;14;;protected boolean canPutToCache(@Nullable Object value) {     String unless = "".     if (this.metadata.operation instanceof CacheableOperation) {         unless = ((CacheableOperation) this.metadata.operation).getUnless().     } else if (this.metadata.operation instanceof CachePutOperation) {         unless = ((CachePutOperation) this.metadata.operation).getUnless().     }     if (StringUtils.hasText(unless)) {         EvaluationContext evaluationContext = createEvaluationContext(value).         return !evaluator.unless(unless, this.metadata.methodKey, evaluationContext).     }     return true. }
true;protected;1;8;/**  * Compute the key for the given caching operation.  */ ;/**  * Compute the key for the given caching operation.  */ @Nullable protected Object generateKey(@Nullable Object result) {     if (StringUtils.hasText(this.metadata.operation.getKey())) {         EvaluationContext evaluationContext = createEvaluationContext(result).         return evaluator.key(this.metadata.operation.getKey(), this.metadata.methodKey, evaluationContext).     }     return this.metadata.keyGenerator.generate(this.target, this.metadata.method, this.args). }
false;private;1;4;;private EvaluationContext createEvaluationContext(@Nullable Object result) {     return evaluator.createEvaluationContext(this.caches, this.metadata.method, this.args, this.target, this.metadata.targetClass, this.metadata.targetMethod, result, beanFactory). }
false;protected;0;3;;protected Collection<? extends Cache> getCaches() {     return this.caches. }
false;protected;0;3;;protected Collection<String> getCacheNames() {     return this.cacheNames. }
false;private;1;7;;private Collection<String> createCacheNames(Collection<? extends Cache> caches) {     Collection<String> names = new ArrayList<>().     for (Cache cache : caches) {         names.add(cache.getName()).     }     return names. }
false;public;1;7;;public void apply(@Nullable Object result) {     if (this.context.canPutToCache(result)) {         for (Cache cache : this.context.getCaches()) {             doPut(cache, this.key, result).         }     } }
false;public;1;12;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof CacheOperationCacheKey)) {         return false.     }     CacheOperationCacheKey otherKey = (CacheOperationCacheKey) other.     return (this.cacheOperation.equals(otherKey.cacheOperation) && this.methodCacheKey.equals(otherKey.methodCacheKey)). }
false;public;0;4;;@Override public int hashCode() {     return (this.cacheOperation.hashCode() * 31 + this.methodCacheKey.hashCode()). }
false;public;0;4;;@Override public String toString() {     return this.cacheOperation + " on " + this.methodCacheKey. }
false;public;1;8;;@Override public int compareTo(CacheOperationCacheKey other) {     int result = this.cacheOperation.getName().compareTo(other.cacheOperation.getName()).     if (result == 0) {         result = this.methodCacheKey.compareTo(other.methodCacheKey).     }     return result. }
