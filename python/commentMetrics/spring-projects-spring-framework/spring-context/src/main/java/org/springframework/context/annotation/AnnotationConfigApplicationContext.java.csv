commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * Propagates the given custom {@code Environment} to the underlying  * {@link AnnotatedBeanDefinitionReader} and {@link ClassPathBeanDefinitionScanner}.  */ ;/**  * Propagates the given custom {@code Environment} to the underlying  * {@link AnnotatedBeanDefinitionReader} and {@link ClassPathBeanDefinitionScanner}.  */ @Override public void setEnvironment(ConfigurableEnvironment environment) {     super.setEnvironment(environment).     this.reader.setEnvironment(environment).     this.scanner.setEnvironment(environment). }
true;public;1;6;/**  * Provide a custom {@link BeanNameGenerator} for use with {@link AnnotatedBeanDefinitionReader}  * and/or {@link ClassPathBeanDefinitionScanner}, if any.  * <p>Default is {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}.  * <p>Any call to this method must occur prior to calls to {@link #register(Class...)}  * and/or {@link #scan(String...)}.  * @see AnnotatedBeanDefinitionReader#setBeanNameGenerator  * @see ClassPathBeanDefinitionScanner#setBeanNameGenerator  */ ;/**  * Provide a custom {@link BeanNameGenerator} for use with {@link AnnotatedBeanDefinitionReader}  * and/or {@link ClassPathBeanDefinitionScanner}, if any.  * <p>Default is {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}.  * <p>Any call to this method must occur prior to calls to {@link #register(Class...)}  * and/or {@link #scan(String...)}.  * @see AnnotatedBeanDefinitionReader#setBeanNameGenerator  * @see ClassPathBeanDefinitionScanner#setBeanNameGenerator  */ public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {     this.reader.setBeanNameGenerator(beanNameGenerator).     this.scanner.setBeanNameGenerator(beanNameGenerator).     getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator). }
true;public;1;4;/**  * Set the {@link ScopeMetadataResolver} to use for detected bean classes.  * <p>The default is an {@link AnnotationScopeMetadataResolver}.  * <p>Any call to this method must occur prior to calls to {@link #register(Class...)}  * and/or {@link #scan(String...)}.  */ ;/**  * Set the {@link ScopeMetadataResolver} to use for detected bean classes.  * <p>The default is an {@link AnnotationScopeMetadataResolver}.  * <p>Any call to this method must occur prior to calls to {@link #register(Class...)}  * and/or {@link #scan(String...)}.  */ public void setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver) {     this.reader.setScopeMetadataResolver(scopeMetadataResolver).     this.scanner.setScopeMetadataResolver(scopeMetadataResolver). }
true;public;1;4;/**  * Register one or more annotated classes to be processed.  * <p>Note that {@link #refresh()} must be called in order for the context  * to fully process the new classes.  * @param annotatedClasses one or more annotated classes,  * e.g. {@link Configuration @Configuration} classes  * @see #scan(String...)  * @see #refresh()  */ ;// --------------------------------------------------------------------- // Implementation of AnnotationConfigRegistry // --------------------------------------------------------------------- /**  * Register one or more annotated classes to be processed.  * <p>Note that {@link #refresh()} must be called in order for the context  * to fully process the new classes.  * @param annotatedClasses one or more annotated classes,  * e.g. {@link Configuration @Configuration} classes  * @see #scan(String...)  * @see #refresh()  */ public void register(Class<?>... annotatedClasses) {     Assert.notEmpty(annotatedClasses, "At least one annotated class must be specified").     this.reader.register(annotatedClasses). }
true;public;1;4;/**  * Perform a scan within the specified base packages.  * <p>Note that {@link #refresh()} must be called in order for the context  * to fully process the new classes.  * @param basePackages the packages to check for annotated classes  * @see #register(Class...)  * @see #refresh()  */ ;/**  * Perform a scan within the specified base packages.  * <p>Note that {@link #refresh()} must be called in order for the context  * to fully process the new classes.  * @param basePackages the packages to check for annotated classes  * @see #register(Class...)  * @see #refresh()  */ public void scan(String... basePackages) {     Assert.notEmpty(basePackages, "At least one base package must be specified").     this.scanner.scan(basePackages). }
true;public;2;3;/**  * Register a bean from the given bean class, deriving its metadata from  * class-declared annotations, and optionally providing explicit constructor  * arguments for consideration in the autowiring process.  * <p>The bean name will be generated according to annotated component rules.  * @param annotatedClass the class of the bean  * @param constructorArguments argument values to be fed into Spring's  * constructor resolution algorithm, resolving either all arguments or just  * specific ones, with the rest to be resolved through regular autowiring  * (may be {@code null} or empty)  * @since 5.0  */ ;// --------------------------------------------------------------------- // Convenient methods for registering individual beans // --------------------------------------------------------------------- /**  * Register a bean from the given bean class, deriving its metadata from  * class-declared annotations, and optionally providing explicit constructor  * arguments for consideration in the autowiring process.  * <p>The bean name will be generated according to annotated component rules.  * @param annotatedClass the class of the bean  * @param constructorArguments argument values to be fed into Spring's  * constructor resolution algorithm, resolving either all arguments or just  * specific ones, with the rest to be resolved through regular autowiring  * (may be {@code null} or empty)  * @since 5.0  */ public <T> void registerBean(Class<T> annotatedClass, Object... constructorArguments) {     registerBean(null, annotatedClass, constructorArguments). }
true;public;3;8;/**  * Register a bean from the given bean class, deriving its metadata from  * class-declared annotations, and optionally providing explicit constructor  * arguments for consideration in the autowiring process.  * @param beanName the name of the bean (may be {@code null})  * @param annotatedClass the class of the bean  * @param constructorArguments argument values to be fed into Spring's  * constructor resolution algorithm, resolving either all arguments or just  * specific ones, with the rest to be resolved through regular autowiring  * (may be {@code null} or empty)  * @since 5.0  */ ;/**  * Register a bean from the given bean class, deriving its metadata from  * class-declared annotations, and optionally providing explicit constructor  * arguments for consideration in the autowiring process.  * @param beanName the name of the bean (may be {@code null})  * @param annotatedClass the class of the bean  * @param constructorArguments argument values to be fed into Spring's  * constructor resolution algorithm, resolving either all arguments or just  * specific ones, with the rest to be resolved through regular autowiring  * (may be {@code null} or empty)  * @since 5.0  */ public <T> void registerBean(@Nullable String beanName, Class<T> annotatedClass, Object... constructorArguments) {     this.reader.doRegisterBean(annotatedClass, null, beanName, null, bd -> {         for (Object arg : constructorArguments) {             bd.getConstructorArgumentValues().addGenericArgumentValue(arg).         }     }). }
false;public;4;6;;@Override public <T> void registerBean(@Nullable String beanName, Class<T> beanClass, @Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {     this.reader.doRegisterBean(beanClass, supplier, beanName, null, customizers). }
