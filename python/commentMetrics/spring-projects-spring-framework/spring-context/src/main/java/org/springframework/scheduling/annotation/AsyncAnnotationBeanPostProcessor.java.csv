commented;modifiers;parameterAmount;loc;comment;code
true;public;2;6;/**  * Configure this post-processor with the given executor and exception handler suppliers,  * applying the corresponding default if a supplier is not resolvable.  * @since 5.1  */ ;/**  * Configure this post-processor with the given executor and exception handler suppliers,  * applying the corresponding default if a supplier is not resolvable.  * @since 5.1  */ public void configure(@Nullable Supplier<Executor> executor, @Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler) {     this.executor = executor.     this.exceptionHandler = exceptionHandler. }
true;public;1;3;/**  * Set the {@link Executor} to use when invoking methods asynchronously.  * <p>If not specified, default executor resolution will apply: searching for a  * unique {@link TaskExecutor} bean in the context, or for an {@link Executor}  * bean named "taskExecutor" otherwise. If neither of the two is resolvable,  * a local default executor will be created within the interceptor.  * @see AnnotationAsyncExecutionInterceptor#getDefaultExecutor(BeanFactory)  * @see #DEFAULT_TASK_EXECUTOR_BEAN_NAME  */ ;/**  * Set the {@link Executor} to use when invoking methods asynchronously.  * <p>If not specified, default executor resolution will apply: searching for a  * unique {@link TaskExecutor} bean in the context, or for an {@link Executor}  * bean named "taskExecutor" otherwise. If neither of the two is resolvable,  * a local default executor will be created within the interceptor.  * @see AnnotationAsyncExecutionInterceptor#getDefaultExecutor(BeanFactory)  * @see #DEFAULT_TASK_EXECUTOR_BEAN_NAME  */ public void setExecutor(Executor executor) {     this.executor = SingletonSupplier.of(executor). }
true;public;1;3;/**  * Set the {@link AsyncUncaughtExceptionHandler} to use to handle uncaught  * exceptions thrown by asynchronous method executions.  * @since 4.1  */ ;/**  * Set the {@link AsyncUncaughtExceptionHandler} to use to handle uncaught  * exceptions thrown by asynchronous method executions.  * @since 4.1  */ public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler) {     this.exceptionHandler = SingletonSupplier.of(exceptionHandler). }
true;public;1;4;/**  * Set the 'async' annotation type to be detected at either class or method  * level. By default, both the {@link Async} annotation and the EJB 3.1  * {@code javax.ejb.Asynchronous} annotation will be detected.  * <p>This setter property exists so that developers can provide their own  * (non-Spring-specific) annotation type to indicate that a method (or all  * methods of a given class) should be invoked asynchronously.  * @param asyncAnnotationType the desired annotation type  */ ;/**  * Set the 'async' annotation type to be detected at either class or method  * level. By default, both the {@link Async} annotation and the EJB 3.1  * {@code javax.ejb.Asynchronous} annotation will be detected.  * <p>This setter property exists so that developers can provide their own  * (non-Spring-specific) annotation type to indicate that a method (or all  * methods of a given class) should be invoked asynchronously.  * @param asyncAnnotationType the desired annotation type  */ public void setAsyncAnnotationType(Class<? extends Annotation> asyncAnnotationType) {     Assert.notNull(asyncAnnotationType, "'asyncAnnotationType' must not be null").     this.asyncAnnotationType = asyncAnnotationType. }
false;public;1;11;;@Override public void setBeanFactory(BeanFactory beanFactory) {     super.setBeanFactory(beanFactory).     AsyncAnnotationAdvisor advisor = new AsyncAnnotationAdvisor(this.executor, this.exceptionHandler).     if (this.asyncAnnotationType != null) {         advisor.setAsyncAnnotationType(this.asyncAnnotationType).     }     advisor.setBeanFactory(beanFactory).     this.advisor = advisor. }
