commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the pattern to use to format date values.  * @param pattern the format pattern  */ ;/**  * Set the pattern to use to format date values.  * @param pattern the format pattern  */ public void setPattern(String pattern) {     this.pattern = pattern. }
true;public;1;3;/**  * Set the ISO format used to format date values.  * @param iso the ISO format  */ ;/**  * Set the ISO format used to format date values.  * @param iso the ISO format  */ public void setIso(ISO iso) {     this.iso = iso. }
true;public;1;3;/**  * Set the style to use for date types.  */ ;/**  * Set the style to use for date types.  */ public void setDateStyle(FormatStyle dateStyle) {     this.dateStyle = dateStyle. }
true;public;1;3;/**  * Set the style to use for time types.  */ ;/**  * Set the style to use for time types.  */ public void setTimeStyle(FormatStyle timeStyle) {     this.timeStyle = timeStyle. }
true;public;1;4;/**  * Set the style to use for date and time types.  */ ;/**  * Set the style to use for date and time types.  */ public void setDateTimeStyle(FormatStyle dateTimeStyle) {     this.dateStyle = dateTimeStyle.     this.timeStyle = dateTimeStyle. }
true;public;1;5;/**  * Set the two characters to use to format date values, in Joda-Time style.  * <p>The first character is used for the date style. the second is for  * the time style. Supported characters are:  * <ul>  * <li>'S' = Small</li>  * <li>'M' = Medium</li>  * <li>'L' = Long</li>  * <li>'F' = Full</li>  * <li>'-' = Omitted</li>  * </ul>  * <p>This method mimics the styles supported by Joda-Time. Note that  * JSR-310 natively favors {@link java.time.format.FormatStyle} as used for  * {@link #setDateStyle}, {@link #setTimeStyle} and {@link #setDateTimeStyle}.  * @param style two characters from the set {"S", "M", "L", "F", "-"}  */ ;/**  * Set the two characters to use to format date values, in Joda-Time style.  * <p>The first character is used for the date style. the second is for  * the time style. Supported characters are:  * <ul>  * <li>'S' = Small</li>  * <li>'M' = Medium</li>  * <li>'L' = Long</li>  * <li>'F' = Full</li>  * <li>'-' = Omitted</li>  * </ul>  * <p>This method mimics the styles supported by Joda-Time. Note that  * JSR-310 natively favors {@link java.time.format.FormatStyle} as used for  * {@link #setDateStyle}, {@link #setTimeStyle} and {@link #setDateTimeStyle}.  * @param style two characters from the set {"S", "M", "L", "F", "-"}  */ public void setStylePattern(String style) {     Assert.isTrue(style.length() == 2, "Style pattern must consist of two characters").     this.dateStyle = convertStyleCharacter(style.charAt(0)).     this.timeStyle = convertStyleCharacter(style.charAt(1)). }
false;private;1;11;;@Nullable private FormatStyle convertStyleCharacter(char c) {     switch(c) {         case 'S':             return FormatStyle.SHORT.         case 'M':             return FormatStyle.MEDIUM.         case 'L':             return FormatStyle.LONG.         case 'F':             return FormatStyle.FULL.         case '-':             return null.         default:             throw new IllegalArgumentException("Invalid style character '" + c + "'").     } }
true;public;1;3;/**  * Set the {@code TimeZone} to normalize the date values into, if any.  * @param timeZone the time zone  */ ;/**  * Set the {@code TimeZone} to normalize the date values into, if any.  * @param timeZone the time zone  */ public void setTimeZone(TimeZone timeZone) {     this.timeZone = timeZone. }
true;public;0;3;/**  * Create a new {@code DateTimeFormatter} using this factory.  * <p>If no specific pattern or style has been defined,  * {@link FormatStyle#MEDIUM medium date time format} will be used.  * @return a new date time formatter  * @see #createDateTimeFormatter(DateTimeFormatter)  */ ;/**  * Create a new {@code DateTimeFormatter} using this factory.  * <p>If no specific pattern or style has been defined,  * {@link FormatStyle#MEDIUM medium date time format} will be used.  * @return a new date time formatter  * @see #createDateTimeFormatter(DateTimeFormatter)  */ public DateTimeFormatter createDateTimeFormatter() {     return createDateTimeFormatter(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)). }
true;public;1;39;/**  * Create a new {@code DateTimeFormatter} using this factory.  * <p>If no specific pattern or style has been defined,  * the supplied {@code fallbackFormatter} will be used.  * @param fallbackFormatter the fall-back formatter to use  * when no specific factory properties have been set  * @return a new date time formatter  */ ;/**  * Create a new {@code DateTimeFormatter} using this factory.  * <p>If no specific pattern or style has been defined,  * the supplied {@code fallbackFormatter} will be used.  * @param fallbackFormatter the fall-back formatter to use  * when no specific factory properties have been set  * @return a new date time formatter  */ public DateTimeFormatter createDateTimeFormatter(DateTimeFormatter fallbackFormatter) {     DateTimeFormatter dateTimeFormatter = null.     if (StringUtils.hasLength(this.pattern)) {         // Using strict parsing to align with Joda-Time and standard DateFormat behavior:         // otherwise, an overflow like e.g. Feb 29 for a non-leap-year wouldn't get rejected.         // However, with strict parsing, a year digit needs to be specified as 'u'...         String patternToUse = StringUtils.replace(this.pattern, "yy", "uu").         dateTimeFormatter = DateTimeFormatter.ofPattern(patternToUse).withResolverStyle(ResolverStyle.STRICT).     } else if (this.iso != null && this.iso != ISO.NONE) {         switch(this.iso) {             case DATE:                 dateTimeFormatter = DateTimeFormatter.ISO_DATE.                 break.             case TIME:                 dateTimeFormatter = DateTimeFormatter.ISO_TIME.                 break.             case DATE_TIME:                 dateTimeFormatter = DateTimeFormatter.ISO_DATE_TIME.                 break.             default:                 throw new IllegalStateException("Unsupported ISO format: " + this.iso).         }     } else if (this.dateStyle != null && this.timeStyle != null) {         dateTimeFormatter = DateTimeFormatter.ofLocalizedDateTime(this.dateStyle, this.timeStyle).     } else if (this.dateStyle != null) {         dateTimeFormatter = DateTimeFormatter.ofLocalizedDate(this.dateStyle).     } else if (this.timeStyle != null) {         dateTimeFormatter = DateTimeFormatter.ofLocalizedTime(this.timeStyle).     }     if (dateTimeFormatter != null && this.timeZone != null) {         dateTimeFormatter = dateTimeFormatter.withZone(this.timeZone.toZoneId()).     }     return (dateTimeFormatter != null ? dateTimeFormatter : fallbackFormatter). }
