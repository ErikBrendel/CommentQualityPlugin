commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.beanClassLoader = classLoader. }
false;public;0;4;;@Override public String getScriptSourceLocator() {     return this.scriptSourceLocator. }
false;public;0;5;;@Override @Nullable public Class<?>[] getScriptInterfaces() {     return this.scriptInterfaces. }
true;public;0;4;/**  * BeanShell scripts do require a config interface.  */ ;/**  * BeanShell scripts do require a config interface.  */ @Override public boolean requiresConfigInterface() {     return true. }
true;public;2;58;/**  * Load and parse the BeanShell script via {@link BshScriptUtils}.  * @see BshScriptUtils#createBshObject(String, Class[], ClassLoader)  */ ;/**  * Load and parse the BeanShell script via {@link BshScriptUtils}.  * @see BshScriptUtils#createBshObject(String, Class[], ClassLoader)  */ @Override @Nullable public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces) throws IOException, ScriptCompilationException {     Class<?> clazz.     try {         synchronized (this.scriptClassMonitor) {             boolean requiresScriptEvaluation = (this.wasModifiedForTypeCheck && this.scriptClass == null).             this.wasModifiedForTypeCheck = false.             if (scriptSource.isModified() || requiresScriptEvaluation) {                 // New script content: Let's check whether it evaluates to a Class.                 Object result = BshScriptUtils.evaluateBshScript(scriptSource.getScriptAsString(), actualInterfaces, this.beanClassLoader).                 if (result instanceof Class) {                     // A Class: We'll cache the Class here and create an instance                     // outside of the synchronized block.                     this.scriptClass = (Class<?>) result.                 } else {                     // already evaluated object.                     return result.                 }             }             clazz = this.scriptClass.         }     } catch (EvalError ex) {         this.scriptClass = null.         throw new ScriptCompilationException(scriptSource, ex).     }     if (clazz != null) {         // A Class: We need to create an instance for every call.         try {             return ReflectionUtils.accessibleConstructor(clazz).newInstance().         } catch (Throwable ex) {             throw new ScriptCompilationException(scriptSource, "Could not instantiate script class: " + clazz.getName(), ex).         }     } else {         // Not a Class: We need to evaluate the script for every call.         try {             return BshScriptUtils.createBshObject(scriptSource.getScriptAsString(), actualInterfaces, this.beanClassLoader).         } catch (EvalError ex) {             throw new ScriptCompilationException(scriptSource, ex).         }     } }
false;public;1;21;;@Override @Nullable public Class<?> getScriptedObjectType(ScriptSource scriptSource) throws IOException, ScriptCompilationException {     synchronized (this.scriptClassMonitor) {         try {             if (scriptSource.isModified()) {                 // New script content: Let's check whether it evaluates to a Class.                 this.wasModifiedForTypeCheck = true.                 this.scriptClass = BshScriptUtils.determineBshObjectType(scriptSource.getScriptAsString(), this.beanClassLoader).             }             return this.scriptClass.         } catch (EvalError ex) {             this.scriptClass = null.             throw new ScriptCompilationException(scriptSource, ex).         }     } }
false;public;1;6;;@Override public boolean requiresScriptedObjectRefresh(ScriptSource scriptSource) {     synchronized (this.scriptClassMonitor) {         return (scriptSource.isModified() || this.wasModifiedForTypeCheck).     } }
false;public;0;4;;@Override public String toString() {     return "BshScriptFactory: script source locator [" + this.scriptSourceLocator + "]". }
