commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void setNestedPath(@Nullable String nestedPath) {     doSetNestedPath(nestedPath).     this.nestedPathStack.clear(). }
false;public;0;4;;@Override public String getNestedPath() {     return this.nestedPath. }
false;public;1;5;;@Override public void pushNestedPath(String subPath) {     this.nestedPathStack.push(getNestedPath()).     doSetNestedPath(getNestedPath() + subPath). }
false;public;0;10;;@Override public void popNestedPath() throws IllegalStateException {     try {         String formerNestedPath = this.nestedPathStack.pop().         doSetNestedPath(formerNestedPath).     } catch (NoSuchElementException ex) {         throw new IllegalStateException("Cannot pop nested path: no nested path on stack").     } }
true;protected;1;10;/**  * Actually set the nested path.  * Delegated to by setNestedPath and pushNestedPath.  */ ;/**  * Actually set the nested path.  * Delegated to by setNestedPath and pushNestedPath.  */ protected void doSetNestedPath(@Nullable String nestedPath) {     if (nestedPath == null) {         nestedPath = "".     }     nestedPath = canonicalFieldName(nestedPath).     if (nestedPath.length() > 0 && !nestedPath.endsWith(Errors.NESTED_PATH_SEPARATOR)) {         nestedPath += Errors.NESTED_PATH_SEPARATOR.     }     this.nestedPath = nestedPath. }
true;protected;1;10;/**  * Transform the given field into its full path,  * regarding the nested path of this instance.  */ ;/**  * Transform the given field into its full path,  * regarding the nested path of this instance.  */ protected String fixedField(@Nullable String field) {     if (StringUtils.hasLength(field)) {         return getNestedPath() + canonicalFieldName(field).     } else {         String path = getNestedPath().         return (path.endsWith(Errors.NESTED_PATH_SEPARATOR) ? path.substring(0, path.length() - NESTED_PATH_SEPARATOR.length()) : path).     } }
true;protected;1;3;/**  * Determine the canonical field name for the given field.  * <p>The default implementation simply returns the field name as-is.  * @param field the original field name  * @return the canonical field name  */ ;/**  * Determine the canonical field name for the given field.  * <p>The default implementation simply returns the field name as-is.  * @param field the original field name  * @return the canonical field name  */ protected String canonicalFieldName(String field) {     return field. }
false;public;1;4;;@Override public void reject(String errorCode) {     reject(errorCode, null, null). }
false;public;2;4;;@Override public void reject(String errorCode, String defaultMessage) {     reject(errorCode, null, defaultMessage). }
false;public;2;4;;@Override public void rejectValue(@Nullable String field, String errorCode) {     rejectValue(field, errorCode, null, null). }
false;public;3;4;;@Override public void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {     rejectValue(field, errorCode, null, defaultMessage). }
false;public;0;4;;@Override public boolean hasErrors() {     return !getAllErrors().isEmpty(). }
false;public;0;4;;@Override public int getErrorCount() {     return getAllErrors().size(). }
false;public;0;7;;@Override public List<ObjectError> getAllErrors() {     List<ObjectError> result = new LinkedList<>().     result.addAll(getGlobalErrors()).     result.addAll(getFieldErrors()).     return Collections.unmodifiableList(result). }
false;public;0;4;;@Override public boolean hasGlobalErrors() {     return (getGlobalErrorCount() > 0). }
false;public;0;4;;@Override public int getGlobalErrorCount() {     return getGlobalErrors().size(). }
false;public;0;6;;@Override @Nullable public ObjectError getGlobalError() {     List<ObjectError> globalErrors = getGlobalErrors().     return (!globalErrors.isEmpty() ? globalErrors.get(0) : null). }
false;public;0;4;;@Override public boolean hasFieldErrors() {     return (getFieldErrorCount() > 0). }
false;public;0;4;;@Override public int getFieldErrorCount() {     return getFieldErrors().size(). }
false;public;0;6;;@Override @Nullable public FieldError getFieldError() {     List<FieldError> fieldErrors = getFieldErrors().     return (!fieldErrors.isEmpty() ? fieldErrors.get(0) : null). }
false;public;1;4;;@Override public boolean hasFieldErrors(String field) {     return (getFieldErrorCount(field) > 0). }
false;public;1;4;;@Override public int getFieldErrorCount(String field) {     return getFieldErrors(field).size(). }
false;public;1;12;;@Override public List<FieldError> getFieldErrors(String field) {     List<FieldError> fieldErrors = getFieldErrors().     List<FieldError> result = new LinkedList<>().     String fixedField = fixedField(field).     for (FieldError error : fieldErrors) {         if (isMatchingFieldError(fixedField, error)) {             result.add(error).         }     }     return Collections.unmodifiableList(result). }
false;public;1;6;;@Override @Nullable public FieldError getFieldError(String field) {     List<FieldError> fieldErrors = getFieldErrors(field).     return (!fieldErrors.isEmpty() ? fieldErrors.get(0) : null). }
false;public;1;6;;@Override @Nullable public Class<?> getFieldType(String field) {     Object value = getFieldValue(field).     return (value != null ? value.getClass() : null). }
true;protected;2;9;/**  * Check whether the given FieldError matches the given field.  * @param field the field that we are looking up FieldErrors for  * @param fieldError the candidate FieldError  * @return whether the FieldError matches the given field  */ ;/**  * Check whether the given FieldError matches the given field.  * @param field the field that we are looking up FieldErrors for  * @param fieldError the candidate FieldError  * @return whether the FieldError matches the given field  */ protected boolean isMatchingFieldError(String field, FieldError fieldError) {     if (field.equals(fieldError.getField())) {         return true.     }     // Optimization: use charAt and regionMatches instead of endsWith and startsWith (SPR-11304)     int endIndex = field.length() - 1.     return (endIndex >= 0 && field.charAt(endIndex) == '*' && (endIndex == 0 || field.regionMatches(0, fieldError.getField(), 0, endIndex))). }
false;public;0;9;;@Override public String toString() {     StringBuilder sb = new StringBuilder(getClass().getName()).     sb.append(": ").append(getErrorCount()).append(" errors").     for (ObjectError error : getAllErrors()) {         sb.append('\n').append(error).     }     return sb.toString(). }
