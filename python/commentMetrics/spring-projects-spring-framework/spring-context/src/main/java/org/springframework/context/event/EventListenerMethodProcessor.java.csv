commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void setApplicationContext(ApplicationContext applicationContext) {     Assert.isTrue(applicationContext instanceof ConfigurableApplicationContext, "ApplicationContext does not implement ConfigurableApplicationContext").     this.applicationContext = (ConfigurableApplicationContext) applicationContext. }
false;public;1;9;;@Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {     this.beanFactory = beanFactory.     Map<String, EventListenerFactory> beans = beanFactory.getBeansOfType(EventListenerFactory.class, false, false).     List<EventListenerFactory> factories = new ArrayList<>(beans.values()).     AnnotationAwareOrderComparator.sort(factories).     this.eventListenerFactories = factories. }
false;public;0;44;;@Override public void afterSingletonsInstantiated() {     ConfigurableListableBeanFactory beanFactory = this.beanFactory.     Assert.state(this.beanFactory != null, "No ConfigurableListableBeanFactory set").     String[] beanNames = beanFactory.getBeanNamesForType(Object.class).     for (String beanName : beanNames) {         if (!ScopedProxyUtils.isScopedTarget(beanName)) {             Class<?> type = null.             try {                 type = AutoProxyUtils.determineTargetClass(beanFactory, beanName).             } catch (Throwable ex) {                 // An unresolvable bean type, probably from a lazy bean - let's ignore it.                 if (logger.isDebugEnabled()) {                     logger.debug("Could not resolve target class for bean with name '" + beanName + "'", ex).                 }             }             if (type != null) {                 if (ScopedObject.class.isAssignableFrom(type)) {                     try {                         Class<?> targetClass = AutoProxyUtils.determineTargetClass(beanFactory, ScopedProxyUtils.getTargetBeanName(beanName)).                         if (targetClass != null) {                             type = targetClass.                         }                     } catch (Throwable ex) {                         // An invalid scoped proxy arrangement - let's ignore it.                         if (logger.isDebugEnabled()) {                             logger.debug("Could not resolve target bean for scoped proxy '" + beanName + "'", ex).                         }                     }                 }                 try {                     processBean(beanName, type).                 } catch (Throwable ex) {                     throw new BeanInitializationException("Failed to process @EventListener " + "annotation on bean with name '" + beanName + "'", ex).                 }             }         }     } }
false;private;2;47;;private void processBean(final String beanName, final Class<?> targetType) {     if (!this.nonAnnotatedClasses.contains(targetType) && !isSpringContainerClass(targetType)) {         Map<Method, EventListener> annotatedMethods = null.         try {             annotatedMethods = MethodIntrospector.selectMethods(targetType, (MethodIntrospector.MetadataLookup<EventListener>) method -> AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class)).         } catch (Throwable ex) {             // An unresolvable type in a method signature, probably from a lazy bean - let's ignore it.             if (logger.isDebugEnabled()) {                 logger.debug("Could not resolve methods for bean with name '" + beanName + "'", ex).             }         }         if (CollectionUtils.isEmpty(annotatedMethods)) {             this.nonAnnotatedClasses.add(targetType).             if (logger.isTraceEnabled()) {                 logger.trace("No @EventListener annotations found on bean class: " + targetType.getName()).             }         } else {             // Non-empty set of methods             ConfigurableApplicationContext context = this.applicationContext.             Assert.state(context != null, "No ApplicationContext set").             List<EventListenerFactory> factories = this.eventListenerFactories.             Assert.state(factories != null, "EventListenerFactory List not initialized").             for (Method method : annotatedMethods.keySet()) {                 for (EventListenerFactory factory : factories) {                     if (factory.supportsMethod(method)) {                         Method methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName)).                         ApplicationListener<?> applicationListener = factory.createApplicationListener(beanName, targetType, methodToUse).                         if (applicationListener instanceof ApplicationListenerMethodAdapter) {                             ((ApplicationListenerMethodAdapter) applicationListener).init(context, this.evaluator).                         }                         context.addApplicationListener(applicationListener).                         break.                     }                 }             }             if (logger.isDebugEnabled()) {                 logger.debug(annotatedMethods.size() + " @EventListener methods processed on bean '" + beanName + "': " + annotatedMethods).             }         }     } }
true;private,static;1;4;/**  * Determine whether the given class is an {@code org.springframework}  * bean class that is not annotated as a user or test {@link Component}...  * which indicates that there is no {@link EventListener} to be found there.  * @since 5.1  */ ;/**  * Determine whether the given class is an {@code org.springframework}  * bean class that is not annotated as a user or test {@link Component}...  * which indicates that there is no {@link EventListener} to be found there.  * @since 5.1  */ private static boolean isSpringContainerClass(Class<?> clazz) {     return (clazz.getName().startsWith("org.springframework.") && !AnnotatedElementUtils.isAnnotated(ClassUtils.getUserClass(clazz), Component.class)). }
