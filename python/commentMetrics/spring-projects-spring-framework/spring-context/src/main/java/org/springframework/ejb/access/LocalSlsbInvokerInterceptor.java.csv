commented;modifiers;parameterAmount;loc;comment;code
true;public;1;42;/**  * This implementation "creates" a new EJB instance for each invocation.  * Can be overridden for custom invocation strategies.  * <p>Alternatively, override {@link #getSessionBeanInstance} and  * {@link #releaseSessionBeanInstance} to change EJB instance creation,  * for example to hold a single shared EJB instance.  */ ;/**  * This implementation "creates" a new EJB instance for each invocation.  * Can be overridden for custom invocation strategies.  * <p>Alternatively, override {@link #getSessionBeanInstance} and  * {@link #releaseSessionBeanInstance} to change EJB instance creation,  * for example to hold a single shared EJB instance.  */ @Override @Nullable public Object invokeInContext(MethodInvocation invocation) throws Throwable {     Object ejb = null.     try {         ejb = getSessionBeanInstance().         Method method = invocation.getMethod().         if (method.getDeclaringClass().isInstance(ejb)) {             // directly implemented             return method.invoke(ejb, invocation.getArguments()).         } else {             // not directly implemented             Method ejbMethod = ejb.getClass().getMethod(method.getName(), method.getParameterTypes()).             return ejbMethod.invoke(ejb, invocation.getArguments()).         }     } catch (InvocationTargetException ex) {         Throwable targetEx = ex.getTargetException().         if (logger.isDebugEnabled()) {             logger.debug("Method of local EJB [" + getJndiName() + "] threw exception", targetEx).         }         if (targetEx instanceof CreateException) {             throw new EjbAccessException("Could not create local EJB [" + getJndiName() + "]", targetEx).         } else {             throw targetEx.         }     } catch (NamingException ex) {         throw new EjbAccessException("Failed to locate local EJB [" + getJndiName() + "]", ex).     } catch (IllegalAccessException ex) {         throw new EjbAccessException("Could not access method [" + invocation.getMethod().getName() + "] of local EJB [" + getJndiName() + "]", ex).     } finally {         if (ejb instanceof EJBLocalObject) {             releaseSessionBeanInstance((EJBLocalObject) ejb).         }     } }
true;protected;1;12;/**  * Check for EJB3-style home object that serves as EJB component directly.  */ ;/**  * Check for EJB3-style home object that serves as EJB component directly.  */ @Override protected Method getCreateMethod(Object home) throws EjbAccessException {     if (this.homeAsComponent) {         return null.     }     if (!(home instanceof EJBLocalHome)) {         // An EJB3 Session Bean...         this.homeAsComponent = true.         return null.     }     return super.getCreateMethod(home). }
true;protected;0;3;/**  * Return an EJB instance to delegate the call to.  * Default implementation delegates to newSessionBeanInstance.  * @throws NamingException if thrown by JNDI  * @throws InvocationTargetException if thrown by the create method  * @see #newSessionBeanInstance  */ ;/**  * Return an EJB instance to delegate the call to.  * Default implementation delegates to newSessionBeanInstance.  * @throws NamingException if thrown by JNDI  * @throws InvocationTargetException if thrown by the create method  * @see #newSessionBeanInstance  */ protected Object getSessionBeanInstance() throws NamingException, InvocationTargetException {     return newSessionBeanInstance(). }
true;protected;1;3;/**  * Release the given EJB instance.  * Default implementation delegates to removeSessionBeanInstance.  * @param ejb the EJB instance to release  * @see #removeSessionBeanInstance  */ ;/**  * Release the given EJB instance.  * Default implementation delegates to removeSessionBeanInstance.  * @param ejb the EJB instance to release  * @see #removeSessionBeanInstance  */ protected void releaseSessionBeanInstance(EJBLocalObject ejb) {     removeSessionBeanInstance(ejb). }
true;protected;0;10;/**  * Return a new instance of the stateless session bean.  * Can be overridden to change the algorithm.  * @throws NamingException if thrown by JNDI  * @throws InvocationTargetException if thrown by the create method  * @see #create  */ ;/**  * Return a new instance of the stateless session bean.  * Can be overridden to change the algorithm.  * @throws NamingException if thrown by JNDI  * @throws InvocationTargetException if thrown by the create method  * @see #create  */ protected Object newSessionBeanInstance() throws NamingException, InvocationTargetException {     if (logger.isDebugEnabled()) {         logger.debug("Trying to create reference to local EJB").     }     Object ejbInstance = create().     if (logger.isDebugEnabled()) {         logger.debug("Obtained reference to local EJB: " + ejbInstance).     }     return ejbInstance. }
true;protected;1;10;/**  * Remove the given EJB instance.  * @param ejb the EJB instance to remove  * @see javax.ejb.EJBLocalObject#remove()  */ ;/**  * Remove the given EJB instance.  * @param ejb the EJB instance to remove  * @see javax.ejb.EJBLocalObject#remove()  */ protected void removeSessionBeanInstance(@Nullable EJBLocalObject ejb) {     if (ejb != null && !this.homeAsComponent) {         try {             ejb.remove().         } catch (Throwable ex) {             logger.warn("Could not invoke 'remove' on local EJB proxy", ex).         }     } }
