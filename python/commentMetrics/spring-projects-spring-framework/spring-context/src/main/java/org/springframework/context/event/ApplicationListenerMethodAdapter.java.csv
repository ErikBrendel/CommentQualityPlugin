commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;24;;private static List<ResolvableType> resolveDeclaredEventTypes(Method method, @Nullable EventListener ann) {     int count = method.getParameterCount().     if (count > 1) {         throw new IllegalStateException("Maximum one parameter is allowed for event listener method: " + method).     }     if (ann != null) {         Class<?>[] classes = ann.classes().         if (classes.length > 0) {             List<ResolvableType> types = new ArrayList<>(classes.length).             for (Class<?> eventType : classes) {                 types.add(ResolvableType.forClass(eventType)).             }             return types.         }     }     if (count == 0) {         throw new IllegalStateException("Event parameter is mandatory for event listener method: " + method).     }     return Collections.singletonList(ResolvableType.forMethodParameter(method, 0)). }
false;private,static;1;4;;private static int resolveOrder(Method method) {     Order ann = AnnotatedElementUtils.findMergedAnnotation(method, Order.class).     return (ann != null ? ann.value() : 0). }
true;;2;4;/**  * Initialize this instance.  */ ;/**  * Initialize this instance.  */ void init(ApplicationContext applicationContext, EventExpressionEvaluator evaluator) {     this.applicationContext = applicationContext.     this.evaluator = evaluator. }
false;public;1;4;;@Override public void onApplicationEvent(ApplicationEvent event) {     processEvent(event). }
false;public;1;15;;@Override public boolean supportsEventType(ResolvableType eventType) {     for (ResolvableType declaredEventType : this.declaredEventTypes) {         if (declaredEventType.isAssignableFrom(eventType)) {             return true.         }         if (PayloadApplicationEvent.class.isAssignableFrom(eventType.toClass())) {             ResolvableType payloadType = eventType.as(PayloadApplicationEvent.class).getGeneric().             if (declaredEventType.isAssignableFrom(payloadType)) {                 return true.             }         }     }     return eventType.hasUnresolvableGenerics(). }
false;public;1;4;;@Override public boolean supportsSourceType(@Nullable Class<?> sourceType) {     return true. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
true;public;1;12;/**  * Process the specified {@link ApplicationEvent}, checking if the condition  * match and handling non-null result, if any.  */ ;/**  * Process the specified {@link ApplicationEvent}, checking if the condition  * match and handling non-null result, if any.  */ public void processEvent(ApplicationEvent event) {     Object[] args = resolveArguments(event).     if (shouldHandle(event, args)) {         Object result = doInvoke(args).         if (result != null) {             handleResult(result).         } else {             logger.trace("No result object given - no result to handle").         }     } }
true;protected;1;19;/**  * Resolve the method arguments to use for the specified {@link ApplicationEvent}.  * <p>These arguments will be used to invoke the method handled by this instance.  * Can return {@code null} to indicate that no suitable arguments could be resolved  * and therefore the method should not be invoked at all for the specified event.  */ ;/**  * Resolve the method arguments to use for the specified {@link ApplicationEvent}.  * <p>These arguments will be used to invoke the method handled by this instance.  * Can return {@code null} to indicate that no suitable arguments could be resolved  * and therefore the method should not be invoked at all for the specified event.  */ @Nullable protected Object[] resolveArguments(ApplicationEvent event) {     ResolvableType declaredEventType = getResolvableType(event).     if (declaredEventType == null) {         return null.     }     if (this.method.getParameterCount() == 0) {         return new Object[0].     }     Class<?> declaredEventClass = declaredEventType.toClass().     if (!ApplicationEvent.class.isAssignableFrom(declaredEventClass) && event instanceof PayloadApplicationEvent) {         Object payload = ((PayloadApplicationEvent) event).getPayload().         if (declaredEventClass.isInstance(payload)) {             return new Object[] { payload }.         }     }     return new Object[] { event }. }
false;protected;1;17;;protected void handleResult(Object result) {     if (result.getClass().isArray()) {         Object[] events = ObjectUtils.toObjectArray(result).         for (Object event : events) {             publishEvent(event).         }     } else if (result instanceof Collection<?>) {         Collection<?> events = (Collection<?>) result.         for (Object event : events) {             publishEvent(event).         }     } else {         publishEvent(result).     } }
false;private;1;6;;private void publishEvent(@Nullable Object event) {     if (event != null) {         Assert.notNull(this.applicationContext, "ApplicationContext must not be null").         this.applicationContext.publishEvent(event).     } }
false;private;2;12;;private boolean shouldHandle(ApplicationEvent event, @Nullable Object[] args) {     if (args == null) {         return false.     }     String condition = getCondition().     if (StringUtils.hasText(condition)) {         Assert.notNull(this.evaluator, "EventExpressionEvaluator must not be null").         return this.evaluator.condition(condition, event, this.targetMethod, this.methodKey, args, this.applicationContext).     }     return true. }
true;protected;1;26;/**  * Invoke the event listener method with the given argument values.  */ ;/**  * Invoke the event listener method with the given argument values.  */ @Nullable protected Object doInvoke(Object... args) {     Object bean = getTargetBean().     ReflectionUtils.makeAccessible(this.method).     try {         return this.method.invoke(bean, args).     } catch (IllegalArgumentException ex) {         assertTargetBean(this.method, bean, args).         throw new IllegalStateException(getInvocationErrorMessage(bean, ex.getMessage(), args), ex).     } catch (IllegalAccessException ex) {         throw new IllegalStateException(getInvocationErrorMessage(bean, ex.getMessage(), args), ex).     } catch (InvocationTargetException ex) {         // Throw underlying exception         Throwable targetException = ex.getTargetException().         if (targetException instanceof RuntimeException) {             throw (RuntimeException) targetException.         } else {             String msg = getInvocationErrorMessage(bean, "Failed to invoke event listener method", args).             throw new UndeclaredThrowableException(targetException, msg).         }     } }
true;protected;0;4;/**  * Return the target bean instance to use.  */ ;/**  * Return the target bean instance to use.  */ protected Object getTargetBean() {     Assert.notNull(this.applicationContext, "ApplicationContext must no be null").     return this.applicationContext.getBean(this.beanName). }
true;protected;0;4;/**  * Return the condition to use.  * <p>Matches the {@code condition} attribute of the {@link EventListener}  * annotation or any matching attribute on a composed annotation that  * is meta-annotated with {@code @EventListener}.  */ ;/**  * Return the condition to use.  * <p>Matches the {@code condition} attribute of the {@link EventListener}  * annotation or any matching attribute on a composed annotation that  * is meta-annotated with {@code @EventListener}.  */ @Nullable protected String getCondition() {     return this.condition. }
true;protected;2;7;/**  * Add additional details such as the bean type and method signature to  * the given error message.  * @param message error message to append the HandlerMethod details to  */ ;/**  * Add additional details such as the bean type and method signature to  * the given error message.  * @param message error message to append the HandlerMethod details to  */ protected String getDetailedErrorMessage(Object bean, String message) {     StringBuilder sb = new StringBuilder(message).append("\n").     sb.append("HandlerMethod details: \n").     sb.append("Bean [").append(bean.getClass().getName()).append("]\n").     sb.append("Method [").append(this.method.toGenericString()).append("]\n").     return sb.toString(). }
true;private;3;11;/**  * Assert that the target bean class is an instance of the class where the given  * method is declared. In some cases the actual bean instance at event-  * processing time may be a JDK dynamic proxy (lazy initialization, prototype  * beans, and others). Event listener beans that require proxying should prefer  * class-based proxy mechanisms.  */ ;/**  * Assert that the target bean class is an instance of the class where the given  * method is declared. In some cases the actual bean instance at event-  * processing time may be a JDK dynamic proxy (lazy initialization, prototype  * beans, and others). Event listener beans that require proxying should prefer  * class-based proxy mechanisms.  */ private void assertTargetBean(Method method, Object targetBean, Object[] args) {     Class<?> methodDeclaringClass = method.getDeclaringClass().     Class<?> targetBeanClass = targetBean.getClass().     if (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {         String msg = "The event listener method class '" + methodDeclaringClass.getName() + "' is not an instance of the actual bean class '" + targetBeanClass.getName() + "'. If the bean requires proxying " + "(e.g. due to @Transactional), please use class-based proxying.".         throw new IllegalStateException(getInvocationErrorMessage(targetBean, msg, args)).     } }
false;private;3;15;;private String getInvocationErrorMessage(Object bean, String message, Object[] resolvedArgs) {     StringBuilder sb = new StringBuilder(getDetailedErrorMessage(bean, message)).     sb.append("Resolved arguments: \n").     for (int i = 0. i < resolvedArgs.length. i++) {         sb.append("[").append(i).append("] ").         if (resolvedArgs[i] == null) {             sb.append("[null] \n").         } else {             sb.append("[type=").append(resolvedArgs[i].getClass().getName()).append("] ").             sb.append("[value=").append(resolvedArgs[i]).append("]\n").         }     }     return sb.toString(). }
false;private;1;22;;@Nullable private ResolvableType getResolvableType(ApplicationEvent event) {     ResolvableType payloadType = null.     if (event instanceof PayloadApplicationEvent) {         PayloadApplicationEvent<?> payloadEvent = (PayloadApplicationEvent<?>) event.         ResolvableType eventType = payloadEvent.getResolvableType().         if (eventType != null) {             payloadType = eventType.as(PayloadApplicationEvent.class).getGeneric().         }     }     for (ResolvableType declaredEventType : this.declaredEventTypes) {         Class<?> eventClass = declaredEventType.toClass().         if (!ApplicationEvent.class.isAssignableFrom(eventClass) && payloadType != null && declaredEventType.isAssignableFrom(payloadType)) {             return declaredEventType.         }         if (eventClass.isInstance(event)) {             return declaredEventType.         }     }     return null. }
false;public;0;4;;@Override public String toString() {     return this.method.toGenericString(). }
