commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the host of the registry for the exported RMI service,  * i.e. {@code rmi://HOST:port/name}  * <p>Default is localhost.  */ ;/**  * Set the host of the registry for the exported RMI service,  * i.e. {@code rmi://HOST:port/name}  * <p>Default is localhost.  */ public void setHost(String host) {     this.host = host. }
true;public;0;3;/**  * Return the host of the registry for the exported RMI service.  */ ;/**  * Return the host of the registry for the exported RMI service.  */ public String getHost() {     return this.host. }
true;public;1;3;/**  * Set the port of the registry for the exported RMI service,  * i.e. {@code rmi://host:PORT/name}  * <p>Default is {@code Registry.REGISTRY_PORT} (1099).  */ ;/**  * Set the port of the registry for the exported RMI service,  * i.e. {@code rmi://host:PORT/name}  * <p>Default is {@code Registry.REGISTRY_PORT} (1099).  */ public void setPort(int port) {     this.port = port. }
true;public;0;3;/**  * Return the port of the registry for the exported RMI service.  */ ;/**  * Return the port of the registry for the exported RMI service.  */ public int getPort() {     return this.port. }
true;public;1;3;/**  * Set a custom RMI client socket factory to use for the RMI registry.  * <p>If the given object also implements {@code java.rmi.server.RMIServerSocketFactory},  * it will automatically be registered as server socket factory too.  * @see #setServerSocketFactory  * @see java.rmi.server.RMIClientSocketFactory  * @see java.rmi.server.RMIServerSocketFactory  * @see java.rmi.registry.LocateRegistry#getRegistry(String, int, java.rmi.server.RMIClientSocketFactory)  */ ;/**  * Set a custom RMI client socket factory to use for the RMI registry.  * <p>If the given object also implements {@code java.rmi.server.RMIServerSocketFactory},  * it will automatically be registered as server socket factory too.  * @see #setServerSocketFactory  * @see java.rmi.server.RMIClientSocketFactory  * @see java.rmi.server.RMIServerSocketFactory  * @see java.rmi.registry.LocateRegistry#getRegistry(String, int, java.rmi.server.RMIClientSocketFactory)  */ public void setClientSocketFactory(RMIClientSocketFactory clientSocketFactory) {     this.clientSocketFactory = clientSocketFactory. }
true;public;1;3;/**  * Set a custom RMI server socket factory to use for the RMI registry.  * <p>Only needs to be specified when the client socket factory does not  * implement {@code java.rmi.server.RMIServerSocketFactory} already.  * @see #setClientSocketFactory  * @see java.rmi.server.RMIClientSocketFactory  * @see java.rmi.server.RMIServerSocketFactory  * @see java.rmi.registry.LocateRegistry#createRegistry(int, RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)  */ ;/**  * Set a custom RMI server socket factory to use for the RMI registry.  * <p>Only needs to be specified when the client socket factory does not  * implement {@code java.rmi.server.RMIServerSocketFactory} already.  * @see #setClientSocketFactory  * @see java.rmi.server.RMIClientSocketFactory  * @see java.rmi.server.RMIServerSocketFactory  * @see java.rmi.registry.LocateRegistry#createRegistry(int, RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)  */ public void setServerSocketFactory(RMIServerSocketFactory serverSocketFactory) {     this.serverSocketFactory = serverSocketFactory. }
true;public;1;3;/**  * Set whether to always create the registry in-process,  * not attempting to locate an existing registry at the specified port.  * <p>Default is "false". Switch this flag to "true" in order to avoid  * the overhead of locating an existing registry when you always  * intend to create a new registry in any case.  */ ;/**  * Set whether to always create the registry in-process,  * not attempting to locate an existing registry at the specified port.  * <p>Default is "false". Switch this flag to "true" in order to avoid  * the overhead of locating an existing registry when you always  * intend to create a new registry in any case.  */ public void setAlwaysCreate(boolean alwaysCreate) {     this.alwaysCreate = alwaysCreate. }
false;public;0;15;;@Override public void afterPropertiesSet() throws Exception {     // Check socket factories for registry.     if (this.clientSocketFactory instanceof RMIServerSocketFactory) {         this.serverSocketFactory = (RMIServerSocketFactory) this.clientSocketFactory.     }     if ((this.clientSocketFactory != null && this.serverSocketFactory == null) || (this.clientSocketFactory == null && this.serverSocketFactory != null)) {         throw new IllegalArgumentException("Both RMIClientSocketFactory and RMIServerSocketFactory or none required").     }     // Fetch RMI registry to expose.     this.registry = getRegistry(this.host, this.port, this.clientSocketFactory, this.serverSocketFactory). }
true;protected;4;18;/**  * Locate or create the RMI registry.  * @param registryHost the registry host to use (if this is specified,  * no implicit creation of a RMI registry will happen)  * @param registryPort the registry port to use  * @param clientSocketFactory the RMI client socket factory for the registry (if any)  * @param serverSocketFactory the RMI server socket factory for the registry (if any)  * @return the RMI registry  * @throws java.rmi.RemoteException if the registry couldn't be located or created  */ ;/**  * Locate or create the RMI registry.  * @param registryHost the registry host to use (if this is specified,  * no implicit creation of a RMI registry will happen)  * @param registryPort the registry port to use  * @param clientSocketFactory the RMI client socket factory for the registry (if any)  * @param serverSocketFactory the RMI server socket factory for the registry (if any)  * @return the RMI registry  * @throws java.rmi.RemoteException if the registry couldn't be located or created  */ protected Registry getRegistry(String registryHost, int registryPort, @Nullable RMIClientSocketFactory clientSocketFactory, @Nullable RMIServerSocketFactory serverSocketFactory) throws RemoteException {     if (registryHost != null) {         // Host explicitly specified: only lookup possible.         if (logger.isDebugEnabled()) {             logger.debug("Looking for RMI registry at port '" + registryPort + "' of host [" + registryHost + "]").         }         Registry reg = LocateRegistry.getRegistry(registryHost, registryPort, clientSocketFactory).         testRegistry(reg).         return reg.     } else {         return getRegistry(registryPort, clientSocketFactory, serverSocketFactory).     } }
true;protected;3;34;/**  * Locate or create the RMI registry.  * @param registryPort the registry port to use  * @param clientSocketFactory the RMI client socket factory for the registry (if any)  * @param serverSocketFactory the RMI server socket factory for the registry (if any)  * @return the RMI registry  * @throws RemoteException if the registry couldn't be located or created  */ ;/**  * Locate or create the RMI registry.  * @param registryPort the registry port to use  * @param clientSocketFactory the RMI client socket factory for the registry (if any)  * @param serverSocketFactory the RMI server socket factory for the registry (if any)  * @return the RMI registry  * @throws RemoteException if the registry couldn't be located or created  */ protected Registry getRegistry(int registryPort, @Nullable RMIClientSocketFactory clientSocketFactory, @Nullable RMIServerSocketFactory serverSocketFactory) throws RemoteException {     if (clientSocketFactory != null) {         if (this.alwaysCreate) {             logger.debug("Creating new RMI registry").             this.created = true.             return LocateRegistry.createRegistry(registryPort, clientSocketFactory, serverSocketFactory).         }         if (logger.isDebugEnabled()) {             logger.debug("Looking for RMI registry at port '" + registryPort + "', using custom socket factory").         }         synchronized (LocateRegistry.class) {             try {                 // Retrieve existing registry.                 Registry reg = LocateRegistry.getRegistry(null, registryPort, clientSocketFactory).                 testRegistry(reg).                 return reg.             } catch (RemoteException ex) {                 logger.trace("RMI registry access threw exception", ex).                 logger.debug("Could not detect RMI registry - creating new one").                 // Assume no registry found -> create new one.                 this.created = true.                 return LocateRegistry.createRegistry(registryPort, clientSocketFactory, serverSocketFactory).             }         }     } else {         return getRegistry(registryPort).     } }
true;protected;1;25;/**  * Locate or create the RMI registry.  * @param registryPort the registry port to use  * @return the RMI registry  * @throws RemoteException if the registry couldn't be located or created  */ ;/**  * Locate or create the RMI registry.  * @param registryPort the registry port to use  * @return the RMI registry  * @throws RemoteException if the registry couldn't be located or created  */ protected Registry getRegistry(int registryPort) throws RemoteException {     if (this.alwaysCreate) {         logger.debug("Creating new RMI registry").         this.created = true.         return LocateRegistry.createRegistry(registryPort).     }     if (logger.isDebugEnabled()) {         logger.debug("Looking for RMI registry at port '" + registryPort + "'").     }     synchronized (LocateRegistry.class) {         try {             // Retrieve existing registry.             Registry reg = LocateRegistry.getRegistry(registryPort).             testRegistry(reg).             return reg.         } catch (RemoteException ex) {             logger.trace("RMI registry access threw exception", ex).             logger.debug("Could not detect RMI registry - creating new one").             // Assume no registry found -> create new one.             this.created = true.             return LocateRegistry.createRegistry(registryPort).         }     } }
true;protected;1;3;/**  * Test the given RMI registry, calling some operation on it to  * check whether it is still active.  * <p>Default implementation calls {@code Registry.list()}.  * @param registry the RMI registry to test  * @throws RemoteException if thrown by registry methods  * @see java.rmi.registry.Registry#list()  */ ;/**  * Test the given RMI registry, calling some operation on it to  * check whether it is still active.  * <p>Default implementation calls {@code Registry.list()}.  * @param registry the RMI registry to test  * @throws RemoteException if thrown by registry methods  * @see java.rmi.registry.Registry#list()  */ protected void testRegistry(Registry registry) throws RemoteException {     registry.list(). }
false;public;0;4;;@Override public Registry getObject() throws Exception {     return this.registry. }
false;public;0;4;;@Override public Class<? extends Registry> getObjectType() {     return (this.registry != null ? this.registry.getClass() : Registry.class). }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
true;public;0;7;/**  * Unexport the RMI registry on bean factory shutdown,  * provided that this bean actually created a registry.  */ ;/**  * Unexport the RMI registry on bean factory shutdown,  * provided that this bean actually created a registry.  */ @Override public void destroy() throws RemoteException {     if (this.created) {         logger.debug("Unexporting RMI registry").         UnicastRemoteObject.unexportObject(this.registry, true).     } }
