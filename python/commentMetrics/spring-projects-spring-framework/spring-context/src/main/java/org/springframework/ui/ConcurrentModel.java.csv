commented;modifiers;parameterAmount;loc;comment;code
false;public;2;9;;@Override public Object put(String key, Object value) {     if (value != null) {         return super.put(key, value).     } else {         return remove(key).     } }
false;public;1;6;;@Override public void putAll(Map<? extends String, ?> map) {     for (Map.Entry<? extends String, ?> entry : map.entrySet()) {         put(entry.getKey(), entry.getValue()).     } }
true;public;2;5;/**  * Add the supplied attribute under the supplied name.  * @param attributeName the name of the model attribute (never {@code null})  * @param attributeValue the model attribute value (ignored if {@code null},  * just removing an existing entry if any)  */ ;/**  * Add the supplied attribute under the supplied name.  * @param attributeName the name of the model attribute (never {@code null})  * @param attributeValue the model attribute value (ignored if {@code null},  * just removing an existing entry if any)  */ public ConcurrentModel addAttribute(String attributeName, @Nullable Object attributeValue) {     Assert.notNull(attributeName, "Model attribute name must not be null").     put(attributeName, attributeValue).     return this. }
true;public;1;7;/**  * Add the supplied attribute to this {@code Map} using a  * {@link org.springframework.core.Conventions#getVariableName generated name}.  * <p><i>Note: Empty {@link Collection Collections} are not added to  * the model when using this method because we cannot correctly determine  * the true convention name. View code should check for {@code null} rather  * than for empty collections as is already done by JSTL tags.</i>  * @param attributeValue the model attribute value (never {@code null})  */ ;/**  * Add the supplied attribute to this {@code Map} using a  * {@link org.springframework.core.Conventions#getVariableName generated name}.  * <p><i>Note: Empty {@link Collection Collections} are not added to  * the model when using this method because we cannot correctly determine  * the true convention name. View code should check for {@code null} rather  * than for empty collections as is already done by JSTL tags.</i>  * @param attributeValue the model attribute value (never {@code null})  */ public ConcurrentModel addAttribute(Object attributeValue) {     Assert.notNull(attributeValue, "Model attribute value must not be null").     if (attributeValue instanceof Collection && ((Collection<?>) attributeValue).isEmpty()) {         return this.     }     return addAttribute(Conventions.getVariableName(attributeValue), attributeValue). }
true;public;1;8;/**  * Copy all attributes in the supplied {@code Collection} into this  * {@code Map}, using attribute name generation for each element.  * @see #addAttribute(Object)  */ ;/**  * Copy all attributes in the supplied {@code Collection} into this  * {@code Map}, using attribute name generation for each element.  * @see #addAttribute(Object)  */ public ConcurrentModel addAllAttributes(@Nullable Collection<?> attributeValues) {     if (attributeValues != null) {         for (Object attributeValue : attributeValues) {             addAttribute(attributeValue).         }     }     return this. }
true;public;1;6;/**  * Copy all attributes in the supplied {@code Map} into this {@code Map}.  * @see #addAttribute(String, Object)  */ ;/**  * Copy all attributes in the supplied {@code Map} into this {@code Map}.  * @see #addAttribute(String, Object)  */ public ConcurrentModel addAllAttributes(@Nullable Map<String, ?> attributes) {     if (attributes != null) {         putAll(attributes).     }     return this. }
true;public;1;10;/**  * Copy all attributes in the supplied {@code Map} into this {@code Map},  * with existing objects of the same name taking precedence (i.e. not getting  * replaced).  */ ;/**  * Copy all attributes in the supplied {@code Map} into this {@code Map},  * with existing objects of the same name taking precedence (i.e. not getting  * replaced).  */ public ConcurrentModel mergeAttributes(@Nullable Map<String, ?> attributes) {     if (attributes != null) {         attributes.forEach((key, value) -> {             if (!containsKey(key)) {                 put(key, value).             }         }).     }     return this. }
true;public;1;3;/**  * Does this model contain an attribute of the given name?  * @param attributeName the name of the model attribute (never {@code null})  * @return whether this model contains a corresponding attribute  */ ;/**  * Does this model contain an attribute of the given name?  * @param attributeName the name of the model attribute (never {@code null})  * @return whether this model contains a corresponding attribute  */ public boolean containsAttribute(String attributeName) {     return containsKey(attributeName). }
false;public;1;5;;@Override @Nullable public Object getAttribute(String attributeName) {     return get(attributeName). }
false;public;0;4;;@Override public Map<String, Object> asMap() {     return this. }
