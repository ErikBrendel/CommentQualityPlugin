commented;modifiers;parameterAmount;loc;comment;code
true;public;1;11;/**  * Set the array of interfaces to use for creating the management info.  * These interfaces will be used for a bean if no entry corresponding to  * that bean is found in the {@code interfaceMappings} property.  * @param managedInterfaces an array of classes indicating the interfaces to use.  * Each entry <strong>MUST</strong> be an interface.  * @see #setInterfaceMappings  */ ;/**  * Set the array of interfaces to use for creating the management info.  * These interfaces will be used for a bean if no entry corresponding to  * that bean is found in the {@code interfaceMappings} property.  * @param managedInterfaces an array of classes indicating the interfaces to use.  * Each entry <strong>MUST</strong> be an interface.  * @see #setInterfaceMappings  */ public void setManagedInterfaces(@Nullable Class<?>... managedInterfaces) {     if (managedInterfaces != null) {         for (Class<?> ifc : managedInterfaces) {             if (!ifc.isInterface()) {                 throw new IllegalArgumentException("Management interface [" + ifc.getName() + "] is not an interface").             }         }     }     this.managedInterfaces = managedInterfaces. }
true;public;1;3;/**  * Set the mappings of bean keys to a comma-separated list of interface names.  * <p>The property key should match the bean key and the property value should match  * the list of interface names. When searching for interfaces for a bean, Spring  * will check these mappings first.  * @param mappings the mappings of bean keys to interface names  */ ;/**  * Set the mappings of bean keys to a comma-separated list of interface names.  * <p>The property key should match the bean key and the property value should match  * the list of interface names. When searching for interfaces for a bean, Spring  * will check these mappings first.  * @param mappings the mappings of bean keys to interface names  */ public void setInterfaceMappings(@Nullable Properties mappings) {     this.interfaceMappings = mappings. }
false;public;1;4;;@Override public void setBeanClassLoader(@Nullable ClassLoader beanClassLoader) {     this.beanClassLoader = beanClassLoader. }
false;public;0;6;;@Override public void afterPropertiesSet() {     if (this.interfaceMappings != null) {         this.resolvedInterfaceMappings = resolveInterfaceMappings(this.interfaceMappings).     } }
true;private;1;10;/**  * Resolve the given interface mappings, turning class names into Class objects.  * @param mappings the specified interface mappings  * @return the resolved interface mappings (with Class objects as values)  */ ;/**  * Resolve the given interface mappings, turning class names into Class objects.  * @param mappings the specified interface mappings  * @return the resolved interface mappings (with Class objects as values)  */ private Map<String, Class<?>[]> resolveInterfaceMappings(Properties mappings) {     Map<String, Class<?>[]> resolvedMappings = new HashMap<>(mappings.size()).     for (Enumeration<?> en = mappings.propertyNames(). en.hasMoreElements(). ) {         String beanKey = (String) en.nextElement().         String[] classNames = StringUtils.commaDelimitedListToStringArray(mappings.getProperty(beanKey)).         Class<?>[] classes = resolveClassNames(classNames, beanKey).         resolvedMappings.put(beanKey, classes).     }     return resolvedMappings. }
true;private;2;12;/**  * Resolve the given class names into Class objects.  * @param classNames the class names to resolve  * @param beanKey the bean key that the class names are associated with  * @return the resolved Class  */ ;/**  * Resolve the given class names into Class objects.  * @param classNames the class names to resolve  * @param beanKey the bean key that the class names are associated with  * @return the resolved Class  */ private Class<?>[] resolveClassNames(String[] classNames, String beanKey) {     Class<?>[] classes = new Class<?>[classNames.length].     for (int x = 0. x < classes.length. x++) {         Class<?> cls = ClassUtils.resolveClassName(classNames[x].trim(), this.beanClassLoader).         if (!cls.isInterface()) {             throw new IllegalArgumentException("Class [" + classNames[x] + "] mapped to bean key [" + beanKey + "] is no interface").         }         classes[x] = cls.     }     return classes. }
true;protected;2;4;/**  * Check to see if the {@code Method} is declared in  * one of the configured interfaces and that it is public.  * @param method the accessor {@code Method}.  * @param beanKey the key associated with the MBean in the  * {@code beans} {@code Map}.  * @return {@code true} if the {@code Method} is declared in one of the  * configured interfaces, otherwise {@code false}.  */ ;/**  * Check to see if the {@code Method} is declared in  * one of the configured interfaces and that it is public.  * @param method the accessor {@code Method}.  * @param beanKey the key associated with the MBean in the  * {@code beans} {@code Map}.  * @return {@code true} if the {@code Method} is declared in one of the  * configured interfaces, otherwise {@code false}.  */ @Override protected boolean includeReadAttribute(Method method, String beanKey) {     return isPublicInInterface(method, beanKey). }
true;protected;2;4;/**  * Check to see if the {@code Method} is declared in  * one of the configured interfaces and that it is public.  * @param method the mutator {@code Method}.  * @param beanKey the key associated with the MBean in the  * {@code beans} {@code Map}.  * @return {@code true} if the {@code Method} is declared in one of the  * configured interfaces, otherwise {@code false}.  */ ;/**  * Check to see if the {@code Method} is declared in  * one of the configured interfaces and that it is public.  * @param method the mutator {@code Method}.  * @param beanKey the key associated with the MBean in the  * {@code beans} {@code Map}.  * @return {@code true} if the {@code Method} is declared in one of the  * configured interfaces, otherwise {@code false}.  */ @Override protected boolean includeWriteAttribute(Method method, String beanKey) {     return isPublicInInterface(method, beanKey). }
true;protected;2;4;/**  * Check to see if the {@code Method} is declared in  * one of the configured interfaces and that it is public.  * @param method the operation {@code Method}.  * @param beanKey the key associated with the MBean in the  * {@code beans} {@code Map}.  * @return {@code true} if the {@code Method} is declared in one of the  * configured interfaces, otherwise {@code false}.  */ ;/**  * Check to see if the {@code Method} is declared in  * one of the configured interfaces and that it is public.  * @param method the operation {@code Method}.  * @param beanKey the key associated with the MBean in the  * {@code beans} {@code Map}.  * @return {@code true} if the {@code Method} is declared in one of the  * configured interfaces, otherwise {@code false}.  */ @Override protected boolean includeOperation(Method method, String beanKey) {     return isPublicInInterface(method, beanKey). }
true;private;2;3;/**  * Check to see if the {@code Method} is both public and declared in  * one of the configured interfaces.  * @param method the {@code Method} to check.  * @param beanKey the key associated with the MBean in the beans map  * @return {@code true} if the {@code Method} is declared in one of the  * configured interfaces and is public, otherwise {@code false}.  */ ;/**  * Check to see if the {@code Method} is both public and declared in  * one of the configured interfaces.  * @param method the {@code Method} to check.  * @param beanKey the key associated with the MBean in the beans map  * @return {@code true} if the {@code Method} is declared in one of the  * configured interfaces and is public, otherwise {@code false}.  */ private boolean isPublicInInterface(Method method, String beanKey) {     return ((method.getModifiers() & Modifier.PUBLIC) > 0) && isDeclaredInInterface(method, beanKey). }
true;private;2;25;/**  * Checks to see if the given method is declared in a managed  * interface for the given bean.  */ ;/**  * Checks to see if the given method is declared in a managed  * interface for the given bean.  */ private boolean isDeclaredInInterface(Method method, String beanKey) {     Class<?>[] ifaces = null.     if (this.resolvedInterfaceMappings != null) {         ifaces = this.resolvedInterfaceMappings.get(beanKey).     }     if (ifaces == null) {         ifaces = this.managedInterfaces.         if (ifaces == null) {             ifaces = ClassUtils.getAllInterfacesForClass(method.getDeclaringClass()).         }     }     for (Class<?> ifc : ifaces) {         for (Method ifcMethod : ifc.getMethods()) {             if (ifcMethod.getName().equals(method.getName()) && Arrays.equals(ifcMethod.getParameterTypes(), method.getParameterTypes())) {                 return true.             }         }     }     return false. }
