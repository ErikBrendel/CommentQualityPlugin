commented;modifiers;parameterAmount;loc;comment;code
true;public;1;7;/**  * Set the ScheduledExecutorService's pool size.  * Default is 1.  * <p><b>This setting can be modified at runtime, for example through JMX.</b>  */ ;/**  * Set the ScheduledExecutorService's pool size.  * Default is 1.  * <p><b>This setting can be modified at runtime, for example through JMX.</b>  */ public void setPoolSize(int poolSize) {     Assert.isTrue(poolSize > 0, "'poolSize' must be 1 or higher").     this.poolSize = poolSize.     if (this.scheduledExecutor instanceof ScheduledThreadPoolExecutor) {         ((ScheduledThreadPoolExecutor) this.scheduledExecutor).setCorePoolSize(poolSize).     } }
true;public;1;9;/**  * Set the remove-on-cancel mode on {@link ScheduledThreadPoolExecutor}.  * <p>Default is {@code false}. If set to {@code true}, the target executor will be  * switched into remove-on-cancel mode (if possible, with a soft fallback otherwise).  * <p><b>This setting can be modified at runtime, for example through JMX.</b>  */ ;/**  * Set the remove-on-cancel mode on {@link ScheduledThreadPoolExecutor}.  * <p>Default is {@code false}. If set to {@code true}, the target executor will be  * switched into remove-on-cancel mode (if possible, with a soft fallback otherwise).  * <p><b>This setting can be modified at runtime, for example through JMX.</b>  */ public void setRemoveOnCancelPolicy(boolean removeOnCancelPolicy) {     this.removeOnCancelPolicy = removeOnCancelPolicy.     if (this.scheduledExecutor instanceof ScheduledThreadPoolExecutor) {         ((ScheduledThreadPoolExecutor) this.scheduledExecutor).setRemoveOnCancelPolicy(removeOnCancelPolicy).     } else if (removeOnCancelPolicy && this.scheduledExecutor != null) {         logger.debug("Could not apply remove-on-cancel policy - not a ScheduledThreadPoolExecutor").     } }
true;public;1;3;/**  * Set a custom {@link ErrorHandler} strategy.  */ ;/**  * Set a custom {@link ErrorHandler} strategy.  */ public void setErrorHandler(ErrorHandler errorHandler) {     this.errorHandler = errorHandler. }
false;protected;2;17;;@Override protected ExecutorService initializeExecutor(ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {     this.scheduledExecutor = createExecutor(this.poolSize, threadFactory, rejectedExecutionHandler).     if (this.removeOnCancelPolicy) {         if (this.scheduledExecutor instanceof ScheduledThreadPoolExecutor) {             ((ScheduledThreadPoolExecutor) this.scheduledExecutor).setRemoveOnCancelPolicy(true).         } else {             logger.debug("Could not apply remove-on-cancel policy - not a ScheduledThreadPoolExecutor").         }     }     return this.scheduledExecutor. }
true;protected;3;5;/**  * Create a new {@link ScheduledExecutorService} instance.  * <p>The default implementation creates a {@link ScheduledThreadPoolExecutor}.  * Can be overridden in subclasses to provide custom {@link ScheduledExecutorService} instances.  * @param poolSize the specified pool size  * @param threadFactory the ThreadFactory to use  * @param rejectedExecutionHandler the RejectedExecutionHandler to use  * @return a new ScheduledExecutorService instance  * @see #afterPropertiesSet()  * @see java.util.concurrent.ScheduledThreadPoolExecutor  */ ;/**  * Create a new {@link ScheduledExecutorService} instance.  * <p>The default implementation creates a {@link ScheduledThreadPoolExecutor}.  * Can be overridden in subclasses to provide custom {@link ScheduledExecutorService} instances.  * @param poolSize the specified pool size  * @param threadFactory the ThreadFactory to use  * @param rejectedExecutionHandler the RejectedExecutionHandler to use  * @return a new ScheduledExecutorService instance  * @see #afterPropertiesSet()  * @see java.util.concurrent.ScheduledThreadPoolExecutor  */ protected ScheduledExecutorService createExecutor(int poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {     return new ScheduledThreadPoolExecutor(poolSize, threadFactory, rejectedExecutionHandler). }
true;public;0;4;/**  * Return the underlying ScheduledExecutorService for native access.  * @return the underlying ScheduledExecutorService (never {@code null})  * @throws IllegalStateException if the ThreadPoolTaskScheduler hasn't been initialized yet  */ ;/**  * Return the underlying ScheduledExecutorService for native access.  * @return the underlying ScheduledExecutorService (never {@code null})  * @throws IllegalStateException if the ThreadPoolTaskScheduler hasn't been initialized yet  */ public ScheduledExecutorService getScheduledExecutor() throws IllegalStateException {     Assert.state(this.scheduledExecutor != null, "ThreadPoolTaskScheduler not initialized").     return this.scheduledExecutor. }
true;public;0;5;/**  * Return the underlying ScheduledThreadPoolExecutor, if available.  * @return the underlying ScheduledExecutorService (never {@code null})  * @throws IllegalStateException if the ThreadPoolTaskScheduler hasn't been initialized yet  * or if the underlying ScheduledExecutorService isn't a ScheduledThreadPoolExecutor  * @see #getScheduledExecutor()  */ ;/**  * Return the underlying ScheduledThreadPoolExecutor, if available.  * @return the underlying ScheduledExecutorService (never {@code null})  * @throws IllegalStateException if the ThreadPoolTaskScheduler hasn't been initialized yet  * or if the underlying ScheduledExecutorService isn't a ScheduledThreadPoolExecutor  * @see #getScheduledExecutor()  */ public ScheduledThreadPoolExecutor getScheduledThreadPoolExecutor() throws IllegalStateException {     Assert.state(this.scheduledExecutor instanceof ScheduledThreadPoolExecutor, "No ScheduledThreadPoolExecutor available").     return (ScheduledThreadPoolExecutor) this.scheduledExecutor. }
true;public;0;7;/**  * Return the current pool size.  * <p>Requires an underlying {@link ScheduledThreadPoolExecutor}.  * @see #getScheduledThreadPoolExecutor()  * @see java.util.concurrent.ScheduledThreadPoolExecutor#getPoolSize()  */ ;/**  * Return the current pool size.  * <p>Requires an underlying {@link ScheduledThreadPoolExecutor}.  * @see #getScheduledThreadPoolExecutor()  * @see java.util.concurrent.ScheduledThreadPoolExecutor#getPoolSize()  */ public int getPoolSize() {     if (this.scheduledExecutor == null) {         // Not initialized yet: assume initial pool size.         return this.poolSize.     }     return getScheduledThreadPoolExecutor().getPoolSize(). }
true;public;0;7;/**  * Return the current setting for the remove-on-cancel mode.  * <p>Requires an underlying {@link ScheduledThreadPoolExecutor}.  */ ;/**  * Return the current setting for the remove-on-cancel mode.  * <p>Requires an underlying {@link ScheduledThreadPoolExecutor}.  */ public boolean isRemoveOnCancelPolicy() {     if (this.scheduledExecutor == null) {         // Not initialized yet: return our setting for the time being.         return this.removeOnCancelPolicy.     }     return getScheduledThreadPoolExecutor().getRemoveOnCancelPolicy(). }
true;public;0;7;/**  * Return the number of currently active threads.  * <p>Requires an underlying {@link ScheduledThreadPoolExecutor}.  * @see #getScheduledThreadPoolExecutor()  * @see java.util.concurrent.ScheduledThreadPoolExecutor#getActiveCount()  */ ;/**  * Return the number of currently active threads.  * <p>Requires an underlying {@link ScheduledThreadPoolExecutor}.  * @see #getScheduledThreadPoolExecutor()  * @see java.util.concurrent.ScheduledThreadPoolExecutor#getActiveCount()  */ public int getActiveCount() {     if (this.scheduledExecutor == null) {         // Not initialized yet: assume no active threads.         return 0.     }     return getScheduledThreadPoolExecutor().getActiveCount(). }
false;public;1;10;;// SchedulingTaskExecutor implementation @Override public void execute(Runnable task) {     Executor executor = getScheduledExecutor().     try {         executor.execute(errorHandlingTask(task, false)).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + executor + "] did not accept task: " + task, ex).     } }
false;public;2;4;;@Override public void execute(Runnable task, long startTimeout) {     execute(task). }
false;public;1;10;;@Override public Future<?> submit(Runnable task) {     ExecutorService executor = getScheduledExecutor().     try {         return executor.submit(errorHandlingTask(task, false)).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + executor + "] did not accept task: " + task, ex).     } }
false;public;1;15;;@Override public <T> Future<T> submit(Callable<T> task) {     ExecutorService executor = getScheduledExecutor().     try {         Callable<T> taskToUse = task.         ErrorHandler errorHandler = this.errorHandler.         if (errorHandler != null) {             taskToUse = new DelegatingErrorHandlingCallable<>(task, errorHandler).         }         return executor.submit(taskToUse).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + executor + "] did not accept task: " + task, ex).     } }
false;public;1;12;;@Override public ListenableFuture<?> submitListenable(Runnable task) {     ExecutorService executor = getScheduledExecutor().     try {         ListenableFutureTask<Object> listenableFuture = new ListenableFutureTask<>(task, null).         executeAndTrack(executor, listenableFuture).         return listenableFuture.     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + executor + "] did not accept task: " + task, ex).     } }
false;public;1;12;;@Override public <T> ListenableFuture<T> submitListenable(Callable<T> task) {     ExecutorService executor = getScheduledExecutor().     try {         ListenableFutureTask<T> listenableFuture = new ListenableFutureTask<>(task).         executeAndTrack(executor, listenableFuture).         return listenableFuture.     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + executor + "] did not accept task: " + task, ex).     } }
false;private;2;6;;private void executeAndTrack(ExecutorService executor, ListenableFutureTask<?> listenableFuture) {     Future<?> scheduledFuture = executor.submit(errorHandlingTask(listenableFuture, false)).     this.listenableFutureMap.put(scheduledFuture, listenableFuture).     listenableFuture.addCallback(result -> this.listenableFutureMap.remove(scheduledFuture), ex -> this.listenableFutureMap.remove(scheduledFuture)). }
false;protected;1;9;;@Override protected void cancelRemainingTask(Runnable task) {     super.cancelRemainingTask(task).     // Cancel associated user-level ListenableFuture handle as well     ListenableFuture<?> listenableFuture = this.listenableFutureMap.get(task).     if (listenableFuture != null) {         listenableFuture.cancel(true).     } }
false;public;2;15;;// TaskScheduler implementation @Override @Nullable public ScheduledFuture<?> schedule(Runnable task, Trigger trigger) {     ScheduledExecutorService executor = getScheduledExecutor().     try {         ErrorHandler errorHandler = this.errorHandler.         if (errorHandler == null) {             errorHandler = TaskUtils.getDefaultErrorHandler(true).         }         return new ReschedulingRunnable(task, trigger, executor, errorHandler).schedule().     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + executor + "] did not accept task: " + task, ex).     } }
false;public;2;11;;@Override public ScheduledFuture<?> schedule(Runnable task, Date startTime) {     ScheduledExecutorService executor = getScheduledExecutor().     long initialDelay = startTime.getTime() - System.currentTimeMillis().     try {         return executor.schedule(errorHandlingTask(task, false), initialDelay, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + executor + "] did not accept task: " + task, ex).     } }
false;public;3;11;;@Override public ScheduledFuture<?> scheduleAtFixedRate(Runnable task, Date startTime, long period) {     ScheduledExecutorService executor = getScheduledExecutor().     long initialDelay = startTime.getTime() - System.currentTimeMillis().     try {         return executor.scheduleAtFixedRate(errorHandlingTask(task, true), initialDelay, period, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + executor + "] did not accept task: " + task, ex).     } }
false;public;2;10;;@Override public ScheduledFuture<?> scheduleAtFixedRate(Runnable task, long period) {     ScheduledExecutorService executor = getScheduledExecutor().     try {         return executor.scheduleAtFixedRate(errorHandlingTask(task, true), 0, period, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + executor + "] did not accept task: " + task, ex).     } }
false;public;3;11;;@Override public ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, Date startTime, long delay) {     ScheduledExecutorService executor = getScheduledExecutor().     long initialDelay = startTime.getTime() - System.currentTimeMillis().     try {         return executor.scheduleWithFixedDelay(errorHandlingTask(task, true), initialDelay, delay, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + executor + "] did not accept task: " + task, ex).     } }
false;public;2;10;;@Override public ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, long delay) {     ScheduledExecutorService executor = getScheduledExecutor().     try {         return executor.scheduleWithFixedDelay(errorHandlingTask(task, true), 0, delay, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + executor + "] did not accept task: " + task, ex).     } }
false;private;2;3;;private Runnable errorHandlingTask(Runnable task, boolean isRepeatingTask) {     return TaskUtils.decorateTaskWithErrorHandler(task, this.errorHandler, isRepeatingTask). }
false;public;0;11;;@Override @Nullable public V call() throws Exception {     try {         return this.delegate.call().     } catch (Throwable ex) {         this.errorHandler.handleError(ex).         return null.     } }
