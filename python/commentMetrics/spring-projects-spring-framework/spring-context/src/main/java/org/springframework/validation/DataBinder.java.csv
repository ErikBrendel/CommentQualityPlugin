commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Return the wrapped target object.  */ ;/**  * Return the wrapped target object.  */ @Nullable public Object getTarget() {     return this.target. }
true;public;0;3;/**  * Return the name of the bound object.  */ ;/**  * Return the name of the bound object.  */ public String getObjectName() {     return this.objectName. }
true;public;1;5;/**  * Set whether this binder should attempt to "auto-grow" a nested path that contains a null value.  * <p>If "true", a null path location will be populated with a default object value and traversed  * instead of resulting in an exception. This flag also enables auto-growth of collection elements  * when accessing an out-of-bounds index.  * <p>Default is "true" on a standard DataBinder. Note that since Spring 4.1 this feature is supported  * for bean property access (DataBinder's default mode) and field access.  * @see #initBeanPropertyAccess()  * @see org.springframework.beans.BeanWrapper#setAutoGrowNestedPaths  */ ;/**  * Set whether this binder should attempt to "auto-grow" a nested path that contains a null value.  * <p>If "true", a null path location will be populated with a default object value and traversed  * instead of resulting in an exception. This flag also enables auto-growth of collection elements  * when accessing an out-of-bounds index.  * <p>Default is "true" on a standard DataBinder. Note that since Spring 4.1 this feature is supported  * for bean property access (DataBinder's default mode) and field access.  * @see #initBeanPropertyAccess()  * @see org.springframework.beans.BeanWrapper#setAutoGrowNestedPaths  */ public void setAutoGrowNestedPaths(boolean autoGrowNestedPaths) {     Assert.state(this.bindingResult == null, "DataBinder is already initialized - call setAutoGrowNestedPaths before other configuration methods").     this.autoGrowNestedPaths = autoGrowNestedPaths. }
true;public;0;3;/**  * Return whether "auto-growing" of nested paths has been activated.  */ ;/**  * Return whether "auto-growing" of nested paths has been activated.  */ public boolean isAutoGrowNestedPaths() {     return this.autoGrowNestedPaths. }
true;public;1;5;/**  * Specify the limit for array and collection auto-growing.  * <p>Default is 256, preventing OutOfMemoryErrors in case of large indexes.  * Raise this limit if your auto-growing needs are unusually high.  * @see #initBeanPropertyAccess()  * @see org.springframework.beans.BeanWrapper#setAutoGrowCollectionLimit  */ ;/**  * Specify the limit for array and collection auto-growing.  * <p>Default is 256, preventing OutOfMemoryErrors in case of large indexes.  * Raise this limit if your auto-growing needs are unusually high.  * @see #initBeanPropertyAccess()  * @see org.springframework.beans.BeanWrapper#setAutoGrowCollectionLimit  */ public void setAutoGrowCollectionLimit(int autoGrowCollectionLimit) {     Assert.state(this.bindingResult == null, "DataBinder is already initialized - call setAutoGrowCollectionLimit before other configuration methods").     this.autoGrowCollectionLimit = autoGrowCollectionLimit. }
true;public;0;3;/**  * Return the current limit for array and collection auto-growing.  */ ;/**  * Return the current limit for array and collection auto-growing.  */ public int getAutoGrowCollectionLimit() {     return this.autoGrowCollectionLimit. }
true;public;0;5;/**  * Initialize standard JavaBean property access for this DataBinder.  * <p>This is the default. an explicit call just leads to eager initialization.  * @see #initDirectFieldAccess()  * @see #createBeanPropertyBindingResult()  */ ;/**  * Initialize standard JavaBean property access for this DataBinder.  * <p>This is the default. an explicit call just leads to eager initialization.  * @see #initDirectFieldAccess()  * @see #createBeanPropertyBindingResult()  */ public void initBeanPropertyAccess() {     Assert.state(this.bindingResult == null, "DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods").     this.bindingResult = createBeanPropertyBindingResult(). }
true;protected;0;13;/**  * Create the {@link AbstractPropertyBindingResult} instance using standard  * JavaBean property access.  * @since 4.2.1  */ ;/**  * Create the {@link AbstractPropertyBindingResult} instance using standard  * JavaBean property access.  * @since 4.2.1  */ protected AbstractPropertyBindingResult createBeanPropertyBindingResult() {     BeanPropertyBindingResult result = new BeanPropertyBindingResult(getTarget(), getObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit()).     if (this.conversionService != null) {         result.initConversion(this.conversionService).     }     if (this.messageCodesResolver != null) {         result.setMessageCodesResolver(this.messageCodesResolver).     }     return result. }
true;public;0;5;/**  * Initialize direct field access for this DataBinder,  * as alternative to the default bean property access.  * @see #initBeanPropertyAccess()  * @see #createDirectFieldBindingResult()  */ ;/**  * Initialize direct field access for this DataBinder,  * as alternative to the default bean property access.  * @see #initBeanPropertyAccess()  * @see #createDirectFieldBindingResult()  */ public void initDirectFieldAccess() {     Assert.state(this.bindingResult == null, "DataBinder is already initialized - call initDirectFieldAccess before other configuration methods").     this.bindingResult = createDirectFieldBindingResult(). }
true;protected;0;13;/**  * Create the {@link AbstractPropertyBindingResult} instance using direct  * field access.  * @since 4.2.1  */ ;/**  * Create the {@link AbstractPropertyBindingResult} instance using direct  * field access.  * @since 4.2.1  */ protected AbstractPropertyBindingResult createDirectFieldBindingResult() {     DirectFieldBindingResult result = new DirectFieldBindingResult(getTarget(), getObjectName(), isAutoGrowNestedPaths()).     if (this.conversionService != null) {         result.initConversion(this.conversionService).     }     if (this.messageCodesResolver != null) {         result.setMessageCodesResolver(this.messageCodesResolver).     }     return result. }
true;protected;0;6;/**  * Return the internal BindingResult held by this DataBinder,  * as an AbstractPropertyBindingResult.  */ ;/**  * Return the internal BindingResult held by this DataBinder,  * as an AbstractPropertyBindingResult.  */ protected AbstractPropertyBindingResult getInternalBindingResult() {     if (this.bindingResult == null) {         initBeanPropertyAccess().     }     return this.bindingResult. }
true;protected;0;3;/**  * Return the underlying PropertyAccessor of this binder's BindingResult.  */ ;/**  * Return the underlying PropertyAccessor of this binder's BindingResult.  */ protected ConfigurablePropertyAccessor getPropertyAccessor() {     return getInternalBindingResult().getPropertyAccessor(). }
true;protected;0;9;/**  * Return this binder's underlying SimpleTypeConverter.  */ ;/**  * Return this binder's underlying SimpleTypeConverter.  */ protected SimpleTypeConverter getSimpleTypeConverter() {     if (this.typeConverter == null) {         this.typeConverter = new SimpleTypeConverter().         if (this.conversionService != null) {             this.typeConverter.setConversionService(this.conversionService).         }     }     return this.typeConverter. }
true;protected;0;8;/**  * Return the underlying TypeConverter of this binder's BindingResult.  */ ;/**  * Return the underlying TypeConverter of this binder's BindingResult.  */ protected PropertyEditorRegistry getPropertyEditorRegistry() {     if (getTarget() != null) {         return getInternalBindingResult().getPropertyAccessor().     } else {         return getSimpleTypeConverter().     } }
true;protected;0;8;/**  * Return the underlying TypeConverter of this binder's BindingResult.  */ ;/**  * Return the underlying TypeConverter of this binder's BindingResult.  */ protected TypeConverter getTypeConverter() {     if (getTarget() != null) {         return getInternalBindingResult().getPropertyAccessor().     } else {         return getSimpleTypeConverter().     } }
true;public;0;3;/**  * Return the BindingResult instance created by this DataBinder.  * This allows for convenient access to the binding results after  * a bind operation.  * @return the BindingResult instance, to be treated as BindingResult  * or as Errors instance (Errors is a super-interface of BindingResult)  * @see Errors  * @see #bind  */ ;/**  * Return the BindingResult instance created by this DataBinder.  * This allows for convenient access to the binding results after  * a bind operation.  * @return the BindingResult instance, to be treated as BindingResult  * or as Errors instance (Errors is a super-interface of BindingResult)  * @see Errors  * @see #bind  */ public BindingResult getBindingResult() {     return getInternalBindingResult(). }
true;public;1;3;/**  * Set whether to ignore unknown fields, that is, whether to ignore bind  * parameters that do not have corresponding fields in the target object.  * <p>Default is "true". Turn this off to enforce that all bind parameters  * must have a matching field in the target object.  * <p>Note that this setting only applies to <i>binding</i> operations  * on this DataBinder, not to <i>retrieving</i> values via its  * {@link #getBindingResult() BindingResult}.  * @see #bind  */ ;/**  * Set whether to ignore unknown fields, that is, whether to ignore bind  * parameters that do not have corresponding fields in the target object.  * <p>Default is "true". Turn this off to enforce that all bind parameters  * must have a matching field in the target object.  * <p>Note that this setting only applies to <i>binding</i> operations  * on this DataBinder, not to <i>retrieving</i> values via its  * {@link #getBindingResult() BindingResult}.  * @see #bind  */ public void setIgnoreUnknownFields(boolean ignoreUnknownFields) {     this.ignoreUnknownFields = ignoreUnknownFields. }
true;public;0;3;/**  * Return whether to ignore unknown fields when binding.  */ ;/**  * Return whether to ignore unknown fields when binding.  */ public boolean isIgnoreUnknownFields() {     return this.ignoreUnknownFields. }
true;public;1;3;/**  * Set whether to ignore invalid fields, that is, whether to ignore bind  * parameters that have corresponding fields in the target object which are  * not accessible (for example because of null values in the nested path).  * <p>Default is "false". Turn this on to ignore bind parameters for  * nested objects in non-existing parts of the target object graph.  * <p>Note that this setting only applies to <i>binding</i> operations  * on this DataBinder, not to <i>retrieving</i> values via its  * {@link #getBindingResult() BindingResult}.  * @see #bind  */ ;/**  * Set whether to ignore invalid fields, that is, whether to ignore bind  * parameters that have corresponding fields in the target object which are  * not accessible (for example because of null values in the nested path).  * <p>Default is "false". Turn this on to ignore bind parameters for  * nested objects in non-existing parts of the target object graph.  * <p>Note that this setting only applies to <i>binding</i> operations  * on this DataBinder, not to <i>retrieving</i> values via its  * {@link #getBindingResult() BindingResult}.  * @see #bind  */ public void setIgnoreInvalidFields(boolean ignoreInvalidFields) {     this.ignoreInvalidFields = ignoreInvalidFields. }
true;public;0;3;/**  * Return whether to ignore invalid fields when binding.  */ ;/**  * Return whether to ignore invalid fields when binding.  */ public boolean isIgnoreInvalidFields() {     return this.ignoreInvalidFields. }
true;public;1;3;/**  * Register fields that should be allowed for binding. Default is all  * fields. Restrict this for example to avoid unwanted modifications  * by malicious users when binding HTTP request parameters.  * <p>Supports "xxx*", "*xxx" and "*xxx*" patterns. More sophisticated matching  * can be implemented by overriding the {@code isAllowed} method.  * <p>Alternatively, specify a list of <i>disallowed</i> fields.  * @param allowedFields array of field names  * @see #setDisallowedFields  * @see #isAllowed(String)  */ ;/**  * Register fields that should be allowed for binding. Default is all  * fields. Restrict this for example to avoid unwanted modifications  * by malicious users when binding HTTP request parameters.  * <p>Supports "xxx*", "*xxx" and "*xxx*" patterns. More sophisticated matching  * can be implemented by overriding the {@code isAllowed} method.  * <p>Alternatively, specify a list of <i>disallowed</i> fields.  * @param allowedFields array of field names  * @see #setDisallowedFields  * @see #isAllowed(String)  */ public void setAllowedFields(@Nullable String... allowedFields) {     this.allowedFields = PropertyAccessorUtils.canonicalPropertyNames(allowedFields). }
true;public;0;4;/**  * Return the fields that should be allowed for binding.  * @return array of field names  */ ;/**  * Return the fields that should be allowed for binding.  * @return array of field names  */ @Nullable public String[] getAllowedFields() {     return this.allowedFields. }
true;public;1;3;/**  * Register fields that should <i>not</i> be allowed for binding. Default is none.  * Mark fields as disallowed for example to avoid unwanted modifications  * by malicious users when binding HTTP request parameters.  * <p>Supports "xxx*", "*xxx" and "*xxx*" patterns. More sophisticated matching  * can be implemented by overriding the {@code isAllowed} method.  * <p>Alternatively, specify a list of <i>allowed</i> fields.  * @param disallowedFields array of field names  * @see #setAllowedFields  * @see #isAllowed(String)  */ ;/**  * Register fields that should <i>not</i> be allowed for binding. Default is none.  * Mark fields as disallowed for example to avoid unwanted modifications  * by malicious users when binding HTTP request parameters.  * <p>Supports "xxx*", "*xxx" and "*xxx*" patterns. More sophisticated matching  * can be implemented by overriding the {@code isAllowed} method.  * <p>Alternatively, specify a list of <i>allowed</i> fields.  * @param disallowedFields array of field names  * @see #setAllowedFields  * @see #isAllowed(String)  */ public void setDisallowedFields(@Nullable String... disallowedFields) {     this.disallowedFields = PropertyAccessorUtils.canonicalPropertyNames(disallowedFields). }
true;public;0;4;/**  * Return the fields that should <i>not</i> be allowed for binding.  * @return array of field names  */ ;/**  * Return the fields that should <i>not</i> be allowed for binding.  * @return array of field names  */ @Nullable public String[] getDisallowedFields() {     return this.disallowedFields. }
true;public;1;7;/**  * Register fields that are required for each binding process.  * <p>If one of the specified fields is not contained in the list of  * incoming property values, a corresponding "missing field" error  * will be created, with error code "required" (by the default  * binding error processor).  * @param requiredFields array of field names  * @see #setBindingErrorProcessor  * @see DefaultBindingErrorProcessor#MISSING_FIELD_ERROR_CODE  */ ;/**  * Register fields that are required for each binding process.  * <p>If one of the specified fields is not contained in the list of  * incoming property values, a corresponding "missing field" error  * will be created, with error code "required" (by the default  * binding error processor).  * @param requiredFields array of field names  * @see #setBindingErrorProcessor  * @see DefaultBindingErrorProcessor#MISSING_FIELD_ERROR_CODE  */ public void setRequiredFields(@Nullable String... requiredFields) {     this.requiredFields = PropertyAccessorUtils.canonicalPropertyNames(requiredFields).     if (logger.isDebugEnabled()) {         logger.debug("DataBinder requires binding of required fields [" + StringUtils.arrayToCommaDelimitedString(requiredFields) + "]").     } }
true;public;0;4;/**  * Return the fields that are required for each binding process.  * @return array of field names  */ ;/**  * Return the fields that are required for each binding process.  * @return array of field names  */ @Nullable public String[] getRequiredFields() {     return this.requiredFields. }
true;public;1;7;/**  * Set the strategy to use for resolving errors into message codes.  * Applies the given strategy to the underlying errors holder.  * <p>Default is a DefaultMessageCodesResolver.  * @see BeanPropertyBindingResult#setMessageCodesResolver  * @see DefaultMessageCodesResolver  */ ;/**  * Set the strategy to use for resolving errors into message codes.  * Applies the given strategy to the underlying errors holder.  * <p>Default is a DefaultMessageCodesResolver.  * @see BeanPropertyBindingResult#setMessageCodesResolver  * @see DefaultMessageCodesResolver  */ public void setMessageCodesResolver(@Nullable MessageCodesResolver messageCodesResolver) {     Assert.state(this.messageCodesResolver == null, "DataBinder is already initialized with MessageCodesResolver").     this.messageCodesResolver = messageCodesResolver.     if (this.bindingResult != null && messageCodesResolver != null) {         this.bindingResult.setMessageCodesResolver(messageCodesResolver).     } }
true;public;1;4;/**  * Set the strategy to use for processing binding errors, that is,  * required field errors and {@code PropertyAccessException}s.  * <p>Default is a DefaultBindingErrorProcessor.  * @see DefaultBindingErrorProcessor  */ ;/**  * Set the strategy to use for processing binding errors, that is,  * required field errors and {@code PropertyAccessException}s.  * <p>Default is a DefaultBindingErrorProcessor.  * @see DefaultBindingErrorProcessor  */ public void setBindingErrorProcessor(BindingErrorProcessor bindingErrorProcessor) {     Assert.notNull(bindingErrorProcessor, "BindingErrorProcessor must not be null").     this.bindingErrorProcessor = bindingErrorProcessor. }
true;public;0;3;/**  * Return the strategy for processing binding errors.  */ ;/**  * Return the strategy for processing binding errors.  */ public BindingErrorProcessor getBindingErrorProcessor() {     return this.bindingErrorProcessor. }
true;public;1;7;/**  * Set the Validator to apply after each binding step.  * @see #addValidators(Validator...)  * @see #replaceValidators(Validator...)  */ ;/**  * Set the Validator to apply after each binding step.  * @see #addValidators(Validator...)  * @see #replaceValidators(Validator...)  */ public void setValidator(@Nullable Validator validator) {     assertValidators(validator).     this.validators.clear().     if (validator != null) {         this.validators.add(validator).     } }
false;private;1;8;;private void assertValidators(Validator... validators) {     Object target = getTarget().     for (Validator validator : validators) {         if (validator != null && (target != null && !validator.supports(target.getClass()))) {             throw new IllegalStateException("Invalid target for Validator [" + validator + "]: " + target).         }     } }
true;public;1;4;/**  * Add Validators to apply after each binding step.  * @see #setValidator(Validator)  * @see #replaceValidators(Validator...)  */ ;/**  * Add Validators to apply after each binding step.  * @see #setValidator(Validator)  * @see #replaceValidators(Validator...)  */ public void addValidators(Validator... validators) {     assertValidators(validators).     this.validators.addAll(Arrays.asList(validators)). }
true;public;1;5;/**  * Replace the Validators to apply after each binding step.  * @see #setValidator(Validator)  * @see #addValidators(Validator...)  */ ;/**  * Replace the Validators to apply after each binding step.  * @see #setValidator(Validator)  * @see #addValidators(Validator...)  */ public void replaceValidators(Validator... validators) {     assertValidators(validators).     this.validators.clear().     this.validators.addAll(Arrays.asList(validators)). }
true;public;0;4;/**  * Return the primary Validator to apply after each binding step, if any.  */ ;/**  * Return the primary Validator to apply after each binding step, if any.  */ @Nullable public Validator getValidator() {     return (!this.validators.isEmpty() ? this.validators.get(0) : null). }
true;public;0;3;/**  * Return the Validators to apply after data binding.  */ ;/**  * Return the Validators to apply after data binding.  */ public List<Validator> getValidators() {     return Collections.unmodifiableList(this.validators). }
true;public;1;7;/**  * Specify a Spring 3.0 ConversionService to use for converting  * property values, as an alternative to JavaBeans PropertyEditors.  */ ;// --------------------------------------------------------------------- // Implementation of PropertyEditorRegistry/TypeConverter interface // --------------------------------------------------------------------- /**  * Specify a Spring 3.0 ConversionService to use for converting  * property values, as an alternative to JavaBeans PropertyEditors.  */ public void setConversionService(@Nullable ConversionService conversionService) {     Assert.state(this.conversionService == null, "DataBinder is already initialized with ConversionService").     this.conversionService = conversionService.     if (this.bindingResult != null && conversionService != null) {         this.bindingResult.initConversion(conversionService).     } }
true;public;0;4;/**  * Return the associated ConversionService, if any.  */ ;/**  * Return the associated ConversionService, if any.  */ @Nullable public ConversionService getConversionService() {     return this.conversionService. }
true;public;1;4;/**  * Add a custom formatter, applying it to all fields matching the  * {@link Formatter}-declared type.  * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.  * @param formatter the formatter to add, generically declared for a specific type  * @since 4.2  * @see #registerCustomEditor(Class, PropertyEditor)  */ ;/**  * Add a custom formatter, applying it to all fields matching the  * {@link Formatter}-declared type.  * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.  * @param formatter the formatter to add, generically declared for a specific type  * @since 4.2  * @see #registerCustomEditor(Class, PropertyEditor)  */ public void addCustomFormatter(Formatter<?> formatter) {     FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter).     getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter). }
true;public;2;12;/**  * Add a custom formatter for the field type specified in {@link Formatter} class,  * applying it to the specified fields only, if any, or otherwise to all fields.  * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.  * @param formatter the formatter to add, generically declared for a specific type  * @param fields the fields to apply the formatter to, or none if to be applied to all  * @since 4.2  * @see #registerCustomEditor(Class, String, PropertyEditor)  */ ;/**  * Add a custom formatter for the field type specified in {@link Formatter} class,  * applying it to the specified fields only, if any, or otherwise to all fields.  * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.  * @param formatter the formatter to add, generically declared for a specific type  * @param fields the fields to apply the formatter to, or none if to be applied to all  * @since 4.2  * @see #registerCustomEditor(Class, String, PropertyEditor)  */ public void addCustomFormatter(Formatter<?> formatter, String... fields) {     FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter).     Class<?> fieldType = adapter.getFieldType().     if (ObjectUtils.isEmpty(fields)) {         getPropertyEditorRegistry().registerCustomEditor(fieldType, adapter).     } else {         for (String field : fields) {             getPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter).         }     } }
true;public;2;11;/**  * Add a custom formatter, applying it to the specified field types only, if any,  * or otherwise to all fields matching the {@link Formatter}-declared type.  * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.  * @param formatter the formatter to add (does not need to generically declare a  * field type if field types are explicitly specified as parameters)  * @param fieldTypes the field types to apply the formatter to, or none if to be  * derived from the given {@link Formatter} implementation class  * @since 4.2  * @see #registerCustomEditor(Class, PropertyEditor)  */ ;/**  * Add a custom formatter, applying it to the specified field types only, if any,  * or otherwise to all fields matching the {@link Formatter}-declared type.  * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.  * @param formatter the formatter to add (does not need to generically declare a  * field type if field types are explicitly specified as parameters)  * @param fieldTypes the field types to apply the formatter to, or none if to be  * derived from the given {@link Formatter} implementation class  * @since 4.2  * @see #registerCustomEditor(Class, PropertyEditor)  */ public void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes) {     FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter).     if (ObjectUtils.isEmpty(fieldTypes)) {         getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter).     } else {         for (Class<?> fieldType : fieldTypes) {             getPropertyEditorRegistry().registerCustomEditor(fieldType, adapter).         }     } }
false;public;2;4;;@Override public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {     getPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor). }
false;public;3;4;;@Override public void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor) {     getPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor). }
false;public;2;5;;@Override @Nullable public PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath) {     return getPropertyEditorRegistry().findCustomEditor(requiredType, propertyPath). }
false;public;2;5;;@Override @Nullable public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {     return getTypeConverter().convertIfNecessary(value, requiredType). }
false;public;3;7;;@Override @Nullable public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable MethodParameter methodParam) throws TypeMismatchException {     return getTypeConverter().convertIfNecessary(value, requiredType, methodParam). }
false;public;3;7;;@Override @Nullable public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field) throws TypeMismatchException {     return getTypeConverter().convertIfNecessary(value, requiredType, field). }
false;public;3;7;;@Nullable @Override public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {     return getTypeConverter().convertIfNecessary(value, requiredType, typeDescriptor). }
true;public;1;5;/**  * Bind the given property values to this binder's target.  * <p>This call can create field errors, representing basic binding  * errors like a required field (code "required"), or type mismatch  * between value and bean property (code "typeMismatch").  * <p>Note that the given PropertyValues should be a throwaway instance:  * For efficiency, it will be modified to just contain allowed fields if it  * implements the MutablePropertyValues interface. else, an internal mutable  * copy will be created for this purpose. Pass in a copy of the PropertyValues  * if you want your original instance to stay unmodified in any case.  * @param pvs property values to bind  * @see #doBind(org.springframework.beans.MutablePropertyValues)  */ ;/**  * Bind the given property values to this binder's target.  * <p>This call can create field errors, representing basic binding  * errors like a required field (code "required"), or type mismatch  * between value and bean property (code "typeMismatch").  * <p>Note that the given PropertyValues should be a throwaway instance:  * For efficiency, it will be modified to just contain allowed fields if it  * implements the MutablePropertyValues interface. else, an internal mutable  * copy will be created for this purpose. Pass in a copy of the PropertyValues  * if you want your original instance to stay unmodified in any case.  * @param pvs property values to bind  * @see #doBind(org.springframework.beans.MutablePropertyValues)  */ public void bind(PropertyValues pvs) {     MutablePropertyValues mpvs = (pvs instanceof MutablePropertyValues ? (MutablePropertyValues) pvs : new MutablePropertyValues(pvs)).     doBind(mpvs). }
true;protected;1;5;/**  * Actual implementation of the binding process, working with the  * passed-in MutablePropertyValues instance.  * @param mpvs the property values to bind,  * as MutablePropertyValues instance  * @see #checkAllowedFields  * @see #checkRequiredFields  * @see #applyPropertyValues  */ ;/**  * Actual implementation of the binding process, working with the  * passed-in MutablePropertyValues instance.  * @param mpvs the property values to bind,  * as MutablePropertyValues instance  * @see #checkAllowedFields  * @see #checkRequiredFields  * @see #applyPropertyValues  */ protected void doBind(MutablePropertyValues mpvs) {     checkAllowedFields(mpvs).     checkRequiredFields(mpvs).     applyPropertyValues(mpvs). }
true;protected;1;14;/**  * Check the given property values against the allowed fields,  * removing values for fields that are not allowed.  * @param mpvs the property values to be bound (can be modified)  * @see #getAllowedFields  * @see #isAllowed(String)  */ ;/**  * Check the given property values against the allowed fields,  * removing values for fields that are not allowed.  * @param mpvs the property values to be bound (can be modified)  * @see #getAllowedFields  * @see #isAllowed(String)  */ protected void checkAllowedFields(MutablePropertyValues mpvs) {     PropertyValue[] pvs = mpvs.getPropertyValues().     for (PropertyValue pv : pvs) {         String field = PropertyAccessorUtils.canonicalPropertyName(pv.getName()).         if (!isAllowed(field)) {             mpvs.removePropertyValue(pv).             getBindingResult().recordSuppressedField(field).             if (logger.isDebugEnabled()) {                 logger.debug("Field [" + field + "] has been removed from PropertyValues " + "and will not be bound, because it has not been found in the list of allowed fields").             }         }     } }
true;protected;1;6;/**  * Return if the given field is allowed for binding.  * Invoked for each passed-in property value.  * <p>The default implementation checks for "xxx*", "*xxx" and "*xxx*" matches,  * as well as direct equality, in the specified lists of allowed fields and  * disallowed fields. A field matching a disallowed pattern will not be accepted  * even if it also happens to match a pattern in the allowed list.  * <p>Can be overridden in subclasses.  * @param field the field to check  * @return if the field is allowed  * @see #setAllowedFields  * @see #setDisallowedFields  * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)  */ ;/**  * Return if the given field is allowed for binding.  * Invoked for each passed-in property value.  * <p>The default implementation checks for "xxx*", "*xxx" and "*xxx*" matches,  * as well as direct equality, in the specified lists of allowed fields and  * disallowed fields. A field matching a disallowed pattern will not be accepted  * even if it also happens to match a pattern in the allowed list.  * <p>Can be overridden in subclasses.  * @param field the field to check  * @return if the field is allowed  * @see #setAllowedFields  * @see #setDisallowedFields  * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)  */ protected boolean isAllowed(String field) {     String[] allowed = getAllowedFields().     String[] disallowed = getDisallowedFields().     return ((ObjectUtils.isEmpty(allowed) || PatternMatchUtils.simpleMatch(allowed, field)) && (ObjectUtils.isEmpty(disallowed) || !PatternMatchUtils.simpleMatch(disallowed, field))). }
true;protected;1;34;/**  * Check the given property values against the required fields,  * generating missing field errors where appropriate.  * @param mpvs the property values to be bound (can be modified)  * @see #getRequiredFields  * @see #getBindingErrorProcessor  * @see BindingErrorProcessor#processMissingFieldError  */ ;/**  * Check the given property values against the required fields,  * generating missing field errors where appropriate.  * @param mpvs the property values to be bound (can be modified)  * @see #getRequiredFields  * @see #getBindingErrorProcessor  * @see BindingErrorProcessor#processMissingFieldError  */ protected void checkRequiredFields(MutablePropertyValues mpvs) {     String[] requiredFields = getRequiredFields().     if (!ObjectUtils.isEmpty(requiredFields)) {         Map<String, PropertyValue> propertyValues = new HashMap<>().         PropertyValue[] pvs = mpvs.getPropertyValues().         for (PropertyValue pv : pvs) {             String canonicalName = PropertyAccessorUtils.canonicalPropertyName(pv.getName()).             propertyValues.put(canonicalName, pv).         }         for (String field : requiredFields) {             PropertyValue pv = propertyValues.get(field).             boolean empty = (pv == null || pv.getValue() == null).             if (!empty) {                 if (pv.getValue() instanceof String) {                     empty = !StringUtils.hasText((String) pv.getValue()).                 } else if (pv.getValue() instanceof String[]) {                     String[] values = (String[]) pv.getValue().                     empty = (values.length == 0 || !StringUtils.hasText(values[0])).                 }             }             if (empty) {                 // Use bind error processor to create FieldError.                 getBindingErrorProcessor().processMissingFieldError(field, getInternalBindingResult()).                 // It has already caused a field error with a rejected value.                 if (pv != null) {                     mpvs.removePropertyValue(pv).                     propertyValues.remove(field).                 }             }         }     } }
true;protected;1;12;/**  * Apply given property values to the target object.  * <p>Default implementation applies all of the supplied property  * values as bean property values. By default, unknown fields will  * be ignored.  * @param mpvs the property values to be bound (can be modified)  * @see #getTarget  * @see #getPropertyAccessor  * @see #isIgnoreUnknownFields  * @see #getBindingErrorProcessor  * @see BindingErrorProcessor#processPropertyAccessException  */ ;/**  * Apply given property values to the target object.  * <p>Default implementation applies all of the supplied property  * values as bean property values. By default, unknown fields will  * be ignored.  * @param mpvs the property values to be bound (can be modified)  * @see #getTarget  * @see #getPropertyAccessor  * @see #isIgnoreUnknownFields  * @see #getBindingErrorProcessor  * @see BindingErrorProcessor#processPropertyAccessException  */ protected void applyPropertyValues(MutablePropertyValues mpvs) {     try {         // Bind request parameters onto target object.         getPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields()).     } catch (PropertyBatchUpdateException ex) {         // Use bind error processor to create FieldErrors.         for (PropertyAccessException pae : ex.getPropertyAccessExceptions()) {             getBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult()).         }     } }
true;public;0;9;/**  * Invoke the specified Validators, if any.  * @see #setValidator(Validator)  * @see #getBindingResult()  */ ;/**  * Invoke the specified Validators, if any.  * @see #setValidator(Validator)  * @see #getBindingResult()  */ public void validate() {     Object target = getTarget().     Assert.state(target != null, "No target to validate").     BindingResult bindingResult = getBindingResult().     // Call each validator with the same binding result     for (Validator validator : getValidators()) {         validator.validate(target, bindingResult).     } }
true;public;1;14;/**  * Invoke the specified Validators, if any, with the given validation hints.  * <p>Note: Validation hints may get ignored by the actual target Validator.  * @param validationHints one or more hint objects to be passed to a {@link SmartValidator}  * @since 3.1  * @see #setValidator(Validator)  * @see SmartValidator#validate(Object, Errors, Object...)  */ ;/**  * Invoke the specified Validators, if any, with the given validation hints.  * <p>Note: Validation hints may get ignored by the actual target Validator.  * @param validationHints one or more hint objects to be passed to a {@link SmartValidator}  * @since 3.1  * @see #setValidator(Validator)  * @see SmartValidator#validate(Object, Errors, Object...)  */ public void validate(Object... validationHints) {     Object target = getTarget().     Assert.state(target != null, "No target to validate").     BindingResult bindingResult = getBindingResult().     // Call each validator with the same binding result     for (Validator validator : getValidators()) {         if (!ObjectUtils.isEmpty(validationHints) && validator instanceof SmartValidator) {             ((SmartValidator) validator).validate(target, bindingResult, validationHints).         } else if (validator != null) {             validator.validate(target, bindingResult).         }     } }
true;public;0;6;/**  * Close this DataBinder, which may result in throwing  * a BindException if it encountered any errors.  * @return the model Map, containing target object and Errors instance  * @throws BindException if there were any errors in the bind operation  * @see BindingResult#getModel()  */ ;/**  * Close this DataBinder, which may result in throwing  * a BindException if it encountered any errors.  * @return the model Map, containing target object and Errors instance  * @throws BindException if there were any errors in the bind operation  * @see BindingResult#getModel()  */ public Map<?, ?> close() throws BindException {     if (getBindingResult().hasErrors()) {         throw new BindException(getBindingResult()).     }     return getBindingResult().getModel(). }
