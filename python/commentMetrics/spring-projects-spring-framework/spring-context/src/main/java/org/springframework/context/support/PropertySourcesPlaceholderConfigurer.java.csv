commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Customize the set of {@link PropertySources} to be used by this configurer.  * <p>Setting this property indicates that environment property sources and  * local properties should be ignored.  * @see #postProcessBeanFactory  */ ;/**  * Customize the set of {@link PropertySources} to be used by this configurer.  * <p>Setting this property indicates that environment property sources and  * local properties should be ignored.  * @see #postProcessBeanFactory  */ public void setPropertySources(PropertySources propertySources) {     this.propertySources = new MutablePropertySources(propertySources). }
true;public;1;4;/**  * {@code PropertySources} from the given {@link Environment}  * will be searched when replacing ${...} placeholders.  * @see #setPropertySources  * @see #postProcessBeanFactory  */ ;/**  * {@code PropertySources} from the given {@link Environment}  * will be searched when replacing ${...} placeholders.  * @see #setPropertySources  * @see #postProcessBeanFactory  */ @Override public void setEnvironment(Environment environment) {     this.environment = environment. }
false;public;1;5;;@Override @Nullable public String getProperty(String key) {     return this.source.getProperty(key). }
true;public;1;33;/**  * Processing occurs by replacing ${...} placeholders in bean definitions by resolving each  * against this configurer's set of {@link PropertySources}, which includes:  * <ul>  * <li>all {@linkplain org.springframework.core.env.ConfigurableEnvironment#getPropertySources  * environment property sources}, if an {@code Environment} {@linkplain #setEnvironment is present}  * <li>{@linkplain #mergeProperties merged local properties}, if {@linkplain #setLocation any}  * {@linkplain #setLocations have} {@linkplain #setProperties been}  * {@linkplain #setPropertiesArray specified}  * <li>any property sources set by calling {@link #setPropertySources}  * </ul>  * <p>If {@link #setPropertySources} is called, <strong>environment and local properties will be  * ignored</strong>. This method is designed to give the user fine-grained control over property  * sources, and once set, the configurer makes no assumptions about adding additional sources.  */ ;/**  * Processing occurs by replacing ${...} placeholders in bean definitions by resolving each  * against this configurer's set of {@link PropertySources}, which includes:  * <ul>  * <li>all {@linkplain org.springframework.core.env.ConfigurableEnvironment#getPropertySources  * environment property sources}, if an {@code Environment} {@linkplain #setEnvironment is present}  * <li>{@linkplain #mergeProperties merged local properties}, if {@linkplain #setLocation any}  * {@linkplain #setLocations have} {@linkplain #setProperties been}  * {@linkplain #setPropertiesArray specified}  * <li>any property sources set by calling {@link #setPropertySources}  * </ul>  * <p>If {@link #setPropertySources} is called, <strong>environment and local properties will be  * ignored</strong>. This method is designed to give the user fine-grained control over property  * sources, and once set, the configurer makes no assumptions about adding additional sources.  */ @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {     if (this.propertySources == null) {         this.propertySources = new MutablePropertySources().         if (this.environment != null) {             this.propertySources.addLast(new PropertySource<Environment>(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, this.environment) {                  @Override                 @Nullable                 public String getProperty(String key) {                     return this.source.getProperty(key).                 }             }).         }         try {             PropertySource<?> localPropertySource = new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties()).             if (this.localOverride) {                 this.propertySources.addFirst(localPropertySource).             } else {                 this.propertySources.addLast(localPropertySource).             }         } catch (IOException ex) {             throw new BeanInitializationException("Could not load properties", ex).         }     }     processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources)).     this.appliedPropertySources = this.propertySources. }
true;protected;2;19;/**  * Visit each bean definition in the given bean factory and attempt to replace ${...} property  * placeholders with values from the given properties.  */ ;/**  * Visit each bean definition in the given bean factory and attempt to replace ${...} property  * placeholders with values from the given properties.  */ protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, final ConfigurablePropertyResolver propertyResolver) throws BeansException {     propertyResolver.setPlaceholderPrefix(this.placeholderPrefix).     propertyResolver.setPlaceholderSuffix(this.placeholderSuffix).     propertyResolver.setValueSeparator(this.valueSeparator).     StringValueResolver valueResolver = strVal -> {         String resolved = (this.ignoreUnresolvablePlaceholders ? propertyResolver.resolvePlaceholders(strVal) : propertyResolver.resolveRequiredPlaceholders(strVal)).         if (this.trimValues) {             resolved = resolved.trim().         }         return (resolved.equals(this.nullValue) ? null : resolved).     }.     doProcessProperties(beanFactoryToProcess, valueResolver). }
true;protected;2;6;/**  * Implemented for compatibility with  * {@link org.springframework.beans.factory.config.PlaceholderConfigurerSupport}.  * @deprecated in favor of  * {@link #processProperties(ConfigurableListableBeanFactory, ConfigurablePropertyResolver)}  * @throws UnsupportedOperationException in this implementation  */ ;/**  * Implemented for compatibility with  * {@link org.springframework.beans.factory.config.PlaceholderConfigurerSupport}.  * @deprecated in favor of  * {@link #processProperties(ConfigurableListableBeanFactory, ConfigurablePropertyResolver)}  * @throws UnsupportedOperationException in this implementation  */ @Override @Deprecated protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props) {     throw new UnsupportedOperationException("Call processProperties(ConfigurableListableBeanFactory, ConfigurablePropertyResolver) instead"). }
true;public;0;4;/**  * Return the property sources that were actually applied during  * {@link #postProcessBeanFactory(ConfigurableListableBeanFactory) post-processing}.  * @return the property sources that were applied  * @throws IllegalStateException if the property sources have not yet been applied  * @since 4.0  */ ;/**  * Return the property sources that were actually applied during  * {@link #postProcessBeanFactory(ConfigurableListableBeanFactory) post-processing}.  * @return the property sources that were applied  * @throws IllegalStateException if the property sources have not yet been applied  * @since 4.0  */ public PropertySources getAppliedPropertySources() throws IllegalStateException {     Assert.state(this.appliedPropertySources != null, "PropertySources have not yet been applied").     return this.appliedPropertySources. }
