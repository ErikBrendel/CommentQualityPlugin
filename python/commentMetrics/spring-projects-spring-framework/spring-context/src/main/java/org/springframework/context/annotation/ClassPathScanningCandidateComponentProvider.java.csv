commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the resource pattern to use when scanning the classpath.  * This value will be appended to each base package name.  * @see #findCandidateComponents(String)  * @see #DEFAULT_RESOURCE_PATTERN  */ ;/**  * Set the resource pattern to use when scanning the classpath.  * This value will be appended to each base package name.  * @see #findCandidateComponents(String)  * @see #DEFAULT_RESOURCE_PATTERN  */ public void setResourcePattern(String resourcePattern) {     Assert.notNull(resourcePattern, "'resourcePattern' must not be null").     this.resourcePattern = resourcePattern. }
true;public;1;3;/**  * Add an include type filter to the <i>end</i> of the inclusion list.  */ ;/**  * Add an include type filter to the <i>end</i> of the inclusion list.  */ public void addIncludeFilter(TypeFilter includeFilter) {     this.includeFilters.add(includeFilter). }
true;public;1;3;/**  * Add an exclude type filter to the <i>front</i> of the exclusion list.  */ ;/**  * Add an exclude type filter to the <i>front</i> of the exclusion list.  */ public void addExcludeFilter(TypeFilter excludeFilter) {     this.excludeFilters.add(0, excludeFilter). }
true;public;1;7;/**  * Reset the configured type filters.  * @param useDefaultFilters whether to re-register the default filters for  * the {@link Component @Component}, {@link Repository @Repository},  * {@link Service @Service}, and {@link Controller @Controller}  * stereotype annotations  * @see #registerDefaultFilters()  */ ;/**  * Reset the configured type filters.  * @param useDefaultFilters whether to re-register the default filters for  * the {@link Component @Component}, {@link Repository @Repository},  * {@link Service @Service}, and {@link Controller @Controller}  * stereotype annotations  * @see #registerDefaultFilters()  */ public void resetFilters(boolean useDefaultFilters) {     this.includeFilters.clear().     this.excludeFilters.clear().     if (useDefaultFilters) {         registerDefaultFilters().     } }
true;protected;0;21;/**  * Register the default filter for {@link Component @Component}.  * <p>This will implicitly register all annotations that have the  * {@link Component @Component} meta-annotation including the  * {@link Repository @Repository}, {@link Service @Service}, and  * {@link Controller @Controller} stereotype annotations.  * <p>Also supports Java EE 6's {@link javax.annotation.ManagedBean} and  * JSR-330's {@link javax.inject.Named} annotations, if available.  */ ;/**  * Register the default filter for {@link Component @Component}.  * <p>This will implicitly register all annotations that have the  * {@link Component @Component} meta-annotation including the  * {@link Repository @Repository}, {@link Service @Service}, and  * {@link Controller @Controller} stereotype annotations.  * <p>Also supports Java EE 6's {@link javax.annotation.ManagedBean} and  * JSR-330's {@link javax.inject.Named} annotations, if available.  */ @SuppressWarnings("unchecked") protected void registerDefaultFilters() {     this.includeFilters.add(new AnnotationTypeFilter(Component.class)).     ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader().     try {         this.includeFilters.add(new AnnotationTypeFilter(((Class<? extends Annotation>) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false)).         logger.trace("JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning").     } catch (ClassNotFoundException ex) {     // JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.     }     try {         this.includeFilters.add(new AnnotationTypeFilter(((Class<? extends Annotation>) ClassUtils.forName("javax.inject.Named", cl)), false)).         logger.trace("JSR-330 'javax.inject.Named' annotation found and supported for component scanning").     } catch (ClassNotFoundException ex) {     // JSR-330 API not available - simply skip.     } }
true;public;1;5;/**  * Set the Environment to use when resolving placeholders and evaluating  * {@link Conditional @Conditional}-annotated component classes.  * <p>The default is a {@link StandardEnvironment}.  * @param environment the Environment to use  */ ;/**  * Set the Environment to use when resolving placeholders and evaluating  * {@link Conditional @Conditional}-annotated component classes.  * <p>The default is a {@link StandardEnvironment}.  * @param environment the Environment to use  */ public void setEnvironment(Environment environment) {     Assert.notNull(environment, "Environment must not be null").     this.environment = environment.     this.conditionEvaluator = null. }
false;public,final;0;7;;@Override public final Environment getEnvironment() {     if (this.environment == null) {         this.environment = new StandardEnvironment().     }     return this.environment. }
true;protected;0;4;/**  * Return the {@link BeanDefinitionRegistry} used by this scanner, if any.  */ ;/**  * Return the {@link BeanDefinitionRegistry} used by this scanner, if any.  */ @Nullable protected BeanDefinitionRegistry getRegistry() {     return null. }
true;public;1;6;/**  * Set the {@link ResourceLoader} to use for resource locations.  * This will typically be a {@link ResourcePatternResolver} implementation.  * <p>Default is a {@code PathMatchingResourcePatternResolver}, also capable of  * resource pattern resolving through the {@code ResourcePatternResolver} interface.  * @see org.springframework.core.io.support.ResourcePatternResolver  * @see org.springframework.core.io.support.PathMatchingResourcePatternResolver  */ ;/**  * Set the {@link ResourceLoader} to use for resource locations.  * This will typically be a {@link ResourcePatternResolver} implementation.  * <p>Default is a {@code PathMatchingResourcePatternResolver}, also capable of  * resource pattern resolving through the {@code ResourcePatternResolver} interface.  * @see org.springframework.core.io.support.ResourcePatternResolver  * @see org.springframework.core.io.support.PathMatchingResourcePatternResolver  */ @Override public void setResourceLoader(@Nullable ResourceLoader resourceLoader) {     this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader).     this.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader).     this.componentsIndex = CandidateComponentsIndexLoader.loadIndex(this.resourcePatternResolver.getClassLoader()). }
true;public,final;0;3;/**  * Return the ResourceLoader that this component provider uses.  */ ;/**  * Return the ResourceLoader that this component provider uses.  */ public final ResourceLoader getResourceLoader() {     return getResourcePatternResolver(). }
false;private;0;6;;private ResourcePatternResolver getResourcePatternResolver() {     if (this.resourcePatternResolver == null) {         this.resourcePatternResolver = new PathMatchingResourcePatternResolver().     }     return this.resourcePatternResolver. }
true;public;1;3;/**  * Set the {@link MetadataReaderFactory} to use.  * <p>Default is a {@link CachingMetadataReaderFactory} for the specified  * {@linkplain #setResourceLoader resource loader}.  * <p>Call this setter method <i>after</i> {@link #setResourceLoader} in order  * for the given MetadataReaderFactory to override the default factory.  */ ;/**  * Set the {@link MetadataReaderFactory} to use.  * <p>Default is a {@link CachingMetadataReaderFactory} for the specified  * {@linkplain #setResourceLoader resource loader}.  * <p>Call this setter method <i>after</i> {@link #setResourceLoader} in order  * for the given MetadataReaderFactory to override the default factory.  */ public void setMetadataReaderFactory(MetadataReaderFactory metadataReaderFactory) {     this.metadataReaderFactory = metadataReaderFactory. }
true;public,final;0;6;/**  * Return the MetadataReaderFactory used by this component provider.  */ ;/**  * Return the MetadataReaderFactory used by this component provider.  */ public final MetadataReaderFactory getMetadataReaderFactory() {     if (this.metadataReaderFactory == null) {         this.metadataReaderFactory = new CachingMetadataReaderFactory().     }     return this.metadataReaderFactory. }
true;public;1;8;/**  * Scan the class path for candidate components.  * @param basePackage the package to check for annotated classes  * @return a corresponding Set of autodetected bean definitions  */ ;/**  * Scan the class path for candidate components.  * @param basePackage the package to check for annotated classes  * @return a corresponding Set of autodetected bean definitions  */ public Set<BeanDefinition> findCandidateComponents(String basePackage) {     if (this.componentsIndex != null && indexSupportsIncludeFilters()) {         return addCandidateComponentsFromIndex(this.componentsIndex, basePackage).     } else {         return scanCandidateComponents(basePackage).     } }
true;private;0;8;/**  * Determine if the index can be used by this instance.  * @return {@code true} if the index is available and the configuration of this  * instance is supported by it, {@code false} otherwise  * @since 5.0  */ ;/**  * Determine if the index can be used by this instance.  * @return {@code true} if the index is available and the configuration of this  * instance is supported by it, {@code false} otherwise  * @since 5.0  */ private boolean indexSupportsIncludeFilters() {     for (TypeFilter includeFilter : this.includeFilters) {         if (!indexSupportsIncludeFilter(includeFilter)) {             return false.         }     }     return true. }
true;private;1;12;/**  * Determine if the specified include {@link TypeFilter} is supported by the index.  * @param filter the filter to check  * @return whether the index supports this include filter  * @since 5.0  * @see #extractStereotype(TypeFilter)  */ ;/**  * Determine if the specified include {@link TypeFilter} is supported by the index.  * @param filter the filter to check  * @return whether the index supports this include filter  * @since 5.0  * @see #extractStereotype(TypeFilter)  */ private boolean indexSupportsIncludeFilter(TypeFilter filter) {     if (filter instanceof AnnotationTypeFilter) {         Class<? extends Annotation> annotation = ((AnnotationTypeFilter) filter).getAnnotationType().         return (AnnotationUtils.isAnnotationDeclaredLocally(Indexed.class, annotation) || annotation.getName().startsWith("javax.")).     }     if (filter instanceof AssignableTypeFilter) {         Class<?> target = ((AssignableTypeFilter) filter).getTargetType().         return AnnotationUtils.isAnnotationDeclaredLocally(Indexed.class, target).     }     return false. }
true;private;1;10;/**  * Extract the stereotype to use for the specified compatible filter.  * @param filter the filter to handle  * @return the stereotype in the index matching this filter  * @since 5.0  * @see #indexSupportsIncludeFilter(TypeFilter)  */ ;/**  * Extract the stereotype to use for the specified compatible filter.  * @param filter the filter to handle  * @return the stereotype in the index matching this filter  * @since 5.0  * @see #indexSupportsIncludeFilter(TypeFilter)  */ @Nullable private String extractStereotype(TypeFilter filter) {     if (filter instanceof AnnotationTypeFilter) {         return ((AnnotationTypeFilter) filter).getAnnotationType().getName().     }     if (filter instanceof AssignableTypeFilter) {         return ((AssignableTypeFilter) filter).getTargetType().getName().     }     return null. }
false;private;2;42;;private Set<BeanDefinition> addCandidateComponentsFromIndex(CandidateComponentsIndex index, String basePackage) {     Set<BeanDefinition> candidates = new LinkedHashSet<>().     try {         Set<String> types = new HashSet<>().         for (TypeFilter filter : this.includeFilters) {             String stereotype = extractStereotype(filter).             if (stereotype == null) {                 throw new IllegalArgumentException("Failed to extract stereotype from " + filter).             }             types.addAll(index.getCandidateTypes(basePackage, stereotype)).         }         boolean traceEnabled = logger.isTraceEnabled().         boolean debugEnabled = logger.isDebugEnabled().         for (String type : types) {             MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(type).             if (isCandidateComponent(metadataReader)) {                 AnnotatedGenericBeanDefinition sbd = new AnnotatedGenericBeanDefinition(metadataReader.getAnnotationMetadata()).                 if (isCandidateComponent(sbd)) {                     if (debugEnabled) {                         logger.debug("Using candidate component class from index: " + type).                     }                     candidates.add(sbd).                 } else {                     if (debugEnabled) {                         logger.debug("Ignored because not a concrete top-level class: " + type).                     }                 }             } else {                 if (traceEnabled) {                     logger.trace("Ignored because matching an exclude filter: " + type).                 }             }         }     } catch (IOException ex) {         throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex).     }     return candidates. }
false;private;1;54;;private Set<BeanDefinition> scanCandidateComponents(String basePackage) {     Set<BeanDefinition> candidates = new LinkedHashSet<>().     try {         String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern.         Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath).         boolean traceEnabled = logger.isTraceEnabled().         boolean debugEnabled = logger.isDebugEnabled().         for (Resource resource : resources) {             if (traceEnabled) {                 logger.trace("Scanning " + resource).             }             if (resource.isReadable()) {                 try {                     MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource).                     if (isCandidateComponent(metadataReader)) {                         ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader).                         sbd.setResource(resource).                         sbd.setSource(resource).                         if (isCandidateComponent(sbd)) {                             if (debugEnabled) {                                 logger.debug("Identified candidate component class: " + resource).                             }                             candidates.add(sbd).                         } else {                             if (debugEnabled) {                                 logger.debug("Ignored because not a concrete top-level class: " + resource).                             }                         }                     } else {                         if (traceEnabled) {                             logger.trace("Ignored because not matching any filter: " + resource).                         }                     }                 } catch (Throwable ex) {                     throw new BeanDefinitionStoreException("Failed to read candidate component class: " + resource, ex).                 }             } else {                 if (traceEnabled) {                     logger.trace("Ignored because not readable: " + resource).                 }             }         }     } catch (IOException ex) {         throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex).     }     return candidates. }
true;protected;1;3;/**  * Resolve the specified base package into a pattern specification for  * the package search path.  * <p>The default implementation resolves placeholders against system properties,  * and converts a "."-based package path to a "/"-based resource path.  * @param basePackage the base package as specified by the user  * @return the pattern specification to be used for package searching  */ ;/**  * Resolve the specified base package into a pattern specification for  * the package search path.  * <p>The default implementation resolves placeholders against system properties,  * and converts a "."-based package path to a "/"-based resource path.  * @param basePackage the base package as specified by the user  * @return the pattern specification to be used for package searching  */ protected String resolveBasePackage(String basePackage) {     return ClassUtils.convertClassNameToResourcePath(getEnvironment().resolveRequiredPlaceholders(basePackage)). }
true;protected;1;13;/**  * Determine whether the given class does not match any exclude filter  * and does match at least one include filter.  * @param metadataReader the ASM ClassReader for the class  * @return whether the class qualifies as a candidate component  */ ;/**  * Determine whether the given class does not match any exclude filter  * and does match at least one include filter.  * @param metadataReader the ASM ClassReader for the class  * @return whether the class qualifies as a candidate component  */ protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {     for (TypeFilter tf : this.excludeFilters) {         if (tf.match(metadataReader, getMetadataReaderFactory())) {             return false.         }     }     for (TypeFilter tf : this.includeFilters) {         if (tf.match(metadataReader, getMetadataReaderFactory())) {             return isConditionMatch(metadataReader).         }     }     return false. }
true;private;1;7;/**  * Determine whether the given class is a candidate component based on any  * {@code @Conditional} annotations.  * @param metadataReader the ASM ClassReader for the class  * @return whether the class qualifies as a candidate component  */ ;/**  * Determine whether the given class is a candidate component based on any  * {@code @Conditional} annotations.  * @param metadataReader the ASM ClassReader for the class  * @return whether the class qualifies as a candidate component  */ private boolean isConditionMatch(MetadataReader metadataReader) {     if (this.conditionEvaluator == null) {         this.conditionEvaluator = new ConditionEvaluator(getRegistry(), this.environment, this.resourcePatternResolver).     }     return !this.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata()). }
true;protected;1;5;/**  * Determine whether the given bean definition qualifies as candidate.  * <p>The default implementation checks whether the class is not an interface  * and not dependent on an enclosing class.  * <p>Can be overridden in subclasses.  * @param beanDefinition the bean definition to check  * @return whether the bean definition qualifies as a candidate component  */ ;/**  * Determine whether the given bean definition qualifies as candidate.  * <p>The default implementation checks whether the class is not an interface  * and not dependent on an enclosing class.  * <p>Can be overridden in subclasses.  * @param beanDefinition the bean definition to check  * @return whether the bean definition qualifies as a candidate component  */ protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {     AnnotationMetadata metadata = beanDefinition.getMetadata().     return (metadata.isIndependent() && (metadata.isConcrete() || (metadata.isAbstract() && metadata.hasAnnotatedMethods(Lookup.class.getName())))). }
true;public;0;7;/**  * Clear the local metadata cache, if any, removing all cached class metadata.  */ ;/**  * Clear the local metadata cache, if any, removing all cached class metadata.  */ public void clearCache() {     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {         // Clear cache in externally provided MetadataReaderFactory. this is a no-op         // for a shared cache since it'll be cleared by the ApplicationContext.         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache().     } }
