commented;modifiers;parameterAmount;loc;comment;code
true;public;2;10;/**  * Return the candidate types that are associated with the specified stereotype.  * @param basePackage the package to check for candidates  * @param stereotype the stereotype to use  * @return the candidate types associated with the specified {@code stereotype}  * or an empty set if none has been found for the specified {@code basePackage}  */ ;/**  * Return the candidate types that are associated with the specified stereotype.  * @param basePackage the package to check for candidates  * @param stereotype the stereotype to use  * @return the candidate types associated with the specified {@code stereotype}  * or an empty set if none has been found for the specified {@code basePackage}  */ public Set<String> getCandidateTypes(String basePackage, String stereotype) {     List<Entry> candidates = this.index.get(stereotype).     if (candidates != null) {         return candidates.parallelStream().filter(t -> t.match(basePackage)).map(t -> t.type).collect(Collectors.toSet()).     }     return Collections.emptySet(). }
false;private,static;1;12;;private static MultiValueMap<String, Entry> parseIndex(List<Properties> content) {     MultiValueMap<String, Entry> index = new LinkedMultiValueMap<>().     for (Properties entry : content) {         entry.forEach((type, values) -> {             String[] stereotypes = ((String) values).split(",").             for (String stereotype : stereotypes) {                 index.add(stereotype, new Entry((String) type)).             }         }).     }     return index. }
false;public;1;8;;public boolean match(String basePackage) {     if (pathMatcher.isPattern(basePackage)) {         return pathMatcher.match(basePackage, this.packageName).     } else {         return this.type.startsWith(basePackage).     } }
