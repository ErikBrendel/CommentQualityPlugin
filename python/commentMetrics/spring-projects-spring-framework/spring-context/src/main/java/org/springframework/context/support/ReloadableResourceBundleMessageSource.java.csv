# id;timestamp;commentText;codeText;commentWords;codeWords
ReloadableResourceBundleMessageSource -> public void setBasename(String basename);1328020251;Set a single basename, following the basic ResourceBundle convention of_not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._@param basename the single basename_@see #setBasenames_@see org.springframework.core.io.ResourceEditor_@see java.util.ResourceBundle;public void setBasename(String basename) {_		setBasenames(new String[] {basename})__	};set,a,single,basename,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,param,basename,the,single,basename,see,set,basenames,see,org,springframework,core,io,resource,editor,see,java,util,resource,bundle;public,void,set,basename,string,basename,set,basenames,new,string,basename
ReloadableResourceBundleMessageSource -> public void setBasename(String basename);1329142650;Set a single basename, following the basic ResourceBundle convention of_not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._@param basename the single basename_@see #setBasenames_@see org.springframework.core.io.ResourceEditor_@see java.util.ResourceBundle;public void setBasename(String basename) {_		setBasenames(basename)__	};set,a,single,basename,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,param,basename,the,single,basename,see,set,basenames,see,org,springframework,core,io,resource,editor,see,java,util,resource,bundle;public,void,set,basename,string,basename,set,basenames,basename
ReloadableResourceBundleMessageSource -> public void setBasename(String basename);1348671314;Set a single basename, following the basic ResourceBundle convention of_not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._@param basename the single basename_@see #setBasenames_@see org.springframework.core.io.ResourceEditor_@see java.util.ResourceBundle;public void setBasename(String basename) {_		setBasenames(basename)__	};set,a,single,basename,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,param,basename,the,single,basename,see,set,basenames,see,org,springframework,core,io,resource,editor,see,java,util,resource,bundle;public,void,set,basename,string,basename,set,basenames,basename
ReloadableResourceBundleMessageSource -> public void setBasename(String basename);1356735495;Set a single basename, following the basic ResourceBundle convention of_not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._@param basename the single basename_@see #setBasenames_@see org.springframework.core.io.ResourceEditor_@see java.util.ResourceBundle;public void setBasename(String basename) {_		setBasenames(basename)__	};set,a,single,basename,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,param,basename,the,single,basename,see,set,basenames,see,org,springframework,core,io,resource,editor,see,java,util,resource,bundle;public,void,set,basename,string,basename,set,basenames,basename
ReloadableResourceBundleMessageSource -> public void setBasename(String basename);1357119239;Set a single basename, following the basic ResourceBundle convention of_not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._@param basename the single basename_@see #setBasenames_@see org.springframework.core.io.ResourceEditor_@see java.util.ResourceBundle;public void setBasename(String basename) {_		setBasenames(basename)__	};set,a,single,basename,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,param,basename,the,single,basename,see,set,basenames,see,org,springframework,core,io,resource,editor,see,java,util,resource,bundle;public,void,set,basename,string,basename,set,basenames,basename
ReloadableResourceBundleMessageSource -> public void setBasename(String basename);1368482696;Set a single basename, following the basic ResourceBundle convention of_not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._@param basename the single basename_@see #setBasenames_@see org.springframework.core.io.ResourceEditor_@see java.util.ResourceBundle;public void setBasename(String basename) {_		setBasenames(basename)__	};set,a,single,basename,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,param,basename,the,single,basename,see,set,basenames,see,org,springframework,core,io,resource,editor,see,java,util,resource,bundle;public,void,set,basename,string,basename,set,basenames,basename
ReloadableResourceBundleMessageSource -> public void setBasename(String basename);1385412762;Set a single basename, following the basic ResourceBundle convention of_not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._@param basename the single basename_@see #setBasenames_@see org.springframework.core.io.ResourceEditor_@see java.util.ResourceBundle;public void setBasename(String basename) {_		setBasenames(basename)__	};set,a,single,basename,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,param,basename,the,single,basename,see,set,basenames,see,org,springframework,core,io,resource,editor,see,java,util,resource,bundle;public,void,set,basename,string,basename,set,basenames,basename
ReloadableResourceBundleMessageSource -> public void setBasename(String basename);1408623868;Set a single basename, following the basic ResourceBundle convention of_not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._@param basename the single basename_@see #setBasenames_@see org.springframework.core.io.ResourceEditor_@see java.util.ResourceBundle;public void setBasename(String basename) {_		setBasenames(basename)__	};set,a,single,basename,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,param,basename,the,single,basename,see,set,basenames,see,org,springframework,core,io,resource,editor,see,java,util,resource,bundle;public,void,set,basename,string,basename,set,basenames,basename
ReloadableResourceBundleMessageSource -> public void setBasename(String basename);1410958822;Set a single basename, following the basic ResourceBundle convention of_not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._@param basename the single basename_@see #setBasenames_@see org.springframework.core.io.ResourceEditor_@see java.util.ResourceBundle;public void setBasename(String basename) {_		setBasenames(basename)__	};set,a,single,basename,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,param,basename,the,single,basename,see,set,basenames,see,org,springframework,core,io,resource,editor,see,java,util,resource,bundle;public,void,set,basename,string,basename,set,basenames,basename
ReloadableResourceBundleMessageSource -> public void setBasename(String basename);1425660337;Set a single basename, following the basic ResourceBundle convention of_not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._@param basename the single basename_@see #setBasenames_@see org.springframework.core.io.ResourceEditor_@see java.util.ResourceBundle;public void setBasename(String basename) {_		setBasenames(basename)__	};set,a,single,basename,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,param,basename,the,single,basename,see,set,basenames,see,org,springframework,core,io,resource,editor,see,java,util,resource,bundle;public,void,set,basename,string,basename,set,basenames,basename
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1328020251;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1329142650;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1348671314;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1356735495;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1357119239;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1368482696;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1385412762;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1408623868;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1410958822;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1425660337;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1454612260;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1454617957;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1467730834;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1478179664;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1495868221;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1496259743;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1496837955;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1498780456;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1502974979;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1515532822;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1516393837;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1518167602;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected String resolveCodeWithoutArguments(String code, Locale locale);1530174524;Resolves the given message code as key in the retrieved bundle files,_returning the value found in the bundle as-is (without MessageFormat parsing).;@Override_	protected String resolveCodeWithoutArguments(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			String result = propHolder.getProperty(code)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					String result = propHolder.getProperty(code)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,returning,the,value,found,in,the,bundle,as,is,without,message,format,parsing;override,protected,string,resolve,code,without,arguments,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,string,result,prop,holder,get,property,code,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,string,result,prop,holder,get,property,code,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1328020251;Refresh the PropertiesHolder for the given bundle filename._The holder can be <code>null</code> if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (this.cacheMillis < 0) ? -1 : System.currentTimeMillis()___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (this.cacheMillis >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(_								resource + " could not be resolved in the file system - assuming that is hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,code,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,this,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,this,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,is,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1329142650;Refresh the PropertiesHolder for the given bundle filename._The holder can be <code>null</code> if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (this.cacheMillis < 0) ? -1 : System.currentTimeMillis()___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (this.cacheMillis >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(_								resource + " could not be resolved in the file system - assuming that is hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,code,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,this,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,this,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,is,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1348671314;Refresh the PropertiesHolder for the given bundle filename._The holder can be <code>null</code> if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (this.cacheMillis < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (this.cacheMillis >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(_								resource + " could not be resolved in the file system - assuming that is hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,code,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,this,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,this,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,is,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1356735495;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (this.cacheMillis < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (this.cacheMillis >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(_								resource + " could not be resolved in the file system - assuming that is hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,this,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,this,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,is,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1357119239;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (this.cacheMillis < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (this.cacheMillis >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(_								resource + " could not be resolved in the file system - assuming that is hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,this,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,this,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,is,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1368482696;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (this.cacheMillis < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (this.cacheMillis >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(_								resource + " could not be resolved in the file system - assuming that is hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,this,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,this,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,is,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1385412762;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (this.cacheMillis < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (this.cacheMillis >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(_								resource + " could not be resolved in the file system - assuming that is hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,this,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,this,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,is,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1408623868;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (this.cacheMillis < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (this.cacheMillis >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,this,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,this,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1410958822;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (this.cacheMillis < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (this.cacheMillis >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,this,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,this,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1425660337;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (this.cacheMillis < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (this.cacheMillis >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,this,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,this,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1454612260;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1454617957;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1467730834;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder);1478179664;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1328020251;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		synchronized (this.cachedFilenames) {_			Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__			if (localeMap != null) {_				List<String> filenames = localeMap.get(locale)__				if (filenames != null) {_					return filenames__				}_			}_			List<String> filenames = new ArrayList<String>(7)__			filenames.addAll(calculateFilenamesForLocale(basename, locale))__			if (this.fallbackToSystemLocale && !locale.equals(Locale.getDefault())) {_				List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__				for (String fallbackFilename : fallbackFilenames) {_					if (!filenames.contains(fallbackFilename)) {_						_						filenames.add(fallbackFilename)__					}_				}_			}_			filenames.add(basename)__			if (localeMap != null) {_				localeMap.put(locale, filenames)__			}_			else {_				localeMap = new HashMap<Locale, List<String>>()__				localeMap.put(locale, filenames)__				this.cachedFilenames.put(basename, localeMap)__			}_			return filenames__		}_	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,synchronized,this,cached,filenames,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,this,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,put,locale,filenames,else,locale,map,new,hash,map,locale,list,string,locale,map,put,locale,filenames,this,cached,filenames,put,basename,locale,map,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1329142650;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		synchronized (this.cachedFilenames) {_			Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__			if (localeMap != null) {_				List<String> filenames = localeMap.get(locale)__				if (filenames != null) {_					return filenames__				}_			}_			List<String> filenames = new ArrayList<String>(7)__			filenames.addAll(calculateFilenamesForLocale(basename, locale))__			if (this.fallbackToSystemLocale && !locale.equals(Locale.getDefault())) {_				List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__				for (String fallbackFilename : fallbackFilenames) {_					if (!filenames.contains(fallbackFilename)) {_						_						filenames.add(fallbackFilename)__					}_				}_			}_			filenames.add(basename)__			if (localeMap != null) {_				localeMap.put(locale, filenames)__			}_			else {_				localeMap = new HashMap<Locale, List<String>>()__				localeMap.put(locale, filenames)__				this.cachedFilenames.put(basename, localeMap)__			}_			return filenames__		}_	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,synchronized,this,cached,filenames,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,this,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,put,locale,filenames,else,locale,map,new,hash,map,locale,list,string,locale,map,put,locale,filenames,this,cached,filenames,put,basename,locale,map,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1348671314;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		synchronized (this.cachedFilenames) {_			Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__			if (localeMap != null) {_				List<String> filenames = localeMap.get(locale)__				if (filenames != null) {_					return filenames__				}_			}_			List<String> filenames = new ArrayList<String>(7)__			filenames.addAll(calculateFilenamesForLocale(basename, locale))__			if (this.fallbackToSystemLocale && !locale.equals(Locale.getDefault())) {_				List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__				for (String fallbackFilename : fallbackFilenames) {_					if (!filenames.contains(fallbackFilename)) {_						_						filenames.add(fallbackFilename)__					}_				}_			}_			filenames.add(basename)__			if (localeMap != null) {_				localeMap.put(locale, filenames)__			}_			else {_				localeMap = new HashMap<Locale, List<String>>()__				localeMap.put(locale, filenames)__				this.cachedFilenames.put(basename, localeMap)__			}_			return filenames__		}_	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,synchronized,this,cached,filenames,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,this,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,put,locale,filenames,else,locale,map,new,hash,map,locale,list,string,locale,map,put,locale,filenames,this,cached,filenames,put,basename,locale,map,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1356735495;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		synchronized (this.cachedFilenames) {_			Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__			if (localeMap != null) {_				List<String> filenames = localeMap.get(locale)__				if (filenames != null) {_					return filenames__				}_			}_			List<String> filenames = new ArrayList<String>(7)__			filenames.addAll(calculateFilenamesForLocale(basename, locale))__			if (this.fallbackToSystemLocale && !locale.equals(Locale.getDefault())) {_				List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__				for (String fallbackFilename : fallbackFilenames) {_					if (!filenames.contains(fallbackFilename)) {_						_						filenames.add(fallbackFilename)__					}_				}_			}_			filenames.add(basename)__			if (localeMap != null) {_				localeMap.put(locale, filenames)__			}_			else {_				localeMap = new HashMap<Locale, List<String>>()__				localeMap.put(locale, filenames)__				this.cachedFilenames.put(basename, localeMap)__			}_			return filenames__		}_	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,synchronized,this,cached,filenames,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,this,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,put,locale,filenames,else,locale,map,new,hash,map,locale,list,string,locale,map,put,locale,filenames,this,cached,filenames,put,basename,locale,map,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1357119239;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		synchronized (this.cachedFilenames) {_			Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__			if (localeMap != null) {_				List<String> filenames = localeMap.get(locale)__				if (filenames != null) {_					return filenames__				}_			}_			List<String> filenames = new ArrayList<String>(7)__			filenames.addAll(calculateFilenamesForLocale(basename, locale))__			if (this.fallbackToSystemLocale && !locale.equals(Locale.getDefault())) {_				List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__				for (String fallbackFilename : fallbackFilenames) {_					if (!filenames.contains(fallbackFilename)) {_						_						filenames.add(fallbackFilename)__					}_				}_			}_			filenames.add(basename)__			if (localeMap != null) {_				localeMap.put(locale, filenames)__			}_			else {_				localeMap = new HashMap<Locale, List<String>>()__				localeMap.put(locale, filenames)__				this.cachedFilenames.put(basename, localeMap)__			}_			return filenames__		}_	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,synchronized,this,cached,filenames,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,this,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,put,locale,filenames,else,locale,map,new,hash,map,locale,list,string,locale,map,put,locale,filenames,this,cached,filenames,put,basename,locale,map,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1368482696;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		synchronized (this.cachedFilenames) {_			Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__			if (localeMap != null) {_				List<String> filenames = localeMap.get(locale)__				if (filenames != null) {_					return filenames__				}_			}_			List<String> filenames = new ArrayList<String>(7)__			filenames.addAll(calculateFilenamesForLocale(basename, locale))__			if (this.fallbackToSystemLocale && !locale.equals(Locale.getDefault())) {_				List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__				for (String fallbackFilename : fallbackFilenames) {_					if (!filenames.contains(fallbackFilename)) {_						_						filenames.add(fallbackFilename)__					}_				}_			}_			filenames.add(basename)__			if (localeMap != null) {_				localeMap.put(locale, filenames)__			}_			else {_				localeMap = new HashMap<Locale, List<String>>()__				localeMap.put(locale, filenames)__				this.cachedFilenames.put(basename, localeMap)__			}_			return filenames__		}_	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,synchronized,this,cached,filenames,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,this,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,put,locale,filenames,else,locale,map,new,hash,map,locale,list,string,locale,map,put,locale,filenames,this,cached,filenames,put,basename,locale,map,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1385412762;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		synchronized (this.cachedFilenames) {_			Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__			if (localeMap != null) {_				List<String> filenames = localeMap.get(locale)__				if (filenames != null) {_					return filenames__				}_			}_			List<String> filenames = new ArrayList<String>(7)__			filenames.addAll(calculateFilenamesForLocale(basename, locale))__			if (this.fallbackToSystemLocale && !locale.equals(Locale.getDefault())) {_				List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__				for (String fallbackFilename : fallbackFilenames) {_					if (!filenames.contains(fallbackFilename)) {_						_						filenames.add(fallbackFilename)__					}_				}_			}_			filenames.add(basename)__			if (localeMap != null) {_				localeMap.put(locale, filenames)__			}_			else {_				localeMap = new HashMap<Locale, List<String>>()__				localeMap.put(locale, filenames)__				this.cachedFilenames.put(basename, localeMap)__			}_			return filenames__		}_	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,synchronized,this,cached,filenames,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,this,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,put,locale,filenames,else,locale,map,new,hash,map,locale,list,string,locale,map,put,locale,filenames,this,cached,filenames,put,basename,locale,map,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1408623868;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<String>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (this.fallbackToSystemLocale && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<Locale, List<String>>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,this,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,locale,list,string,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1410958822;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<String>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (this.fallbackToSystemLocale && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<Locale, List<String>>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,this,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,locale,list,string,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1425660337;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<String>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (this.fallbackToSystemLocale && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<Locale, List<String>>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,this,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,locale,list,string,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1454612260;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<String>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<Locale, List<String>>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,locale,list,string,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1454617957;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<String>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<Locale, List<String>>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,string,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,locale,list,string,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1467730834;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1478179664;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1495868221;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1496259743;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1496837955;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1498780456;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1502974979;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1515532822;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1516393837;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1518167602;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> protected List<String> calculateAllFilenames(String basename, Locale locale);1530174524;Calculate all filenames for the given bundle basename and Locale._Will calculate filenames for the given Locale, the system Locale_(if applicable), and the default file._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check_@see #setFallbackToSystemLocale_@see #calculateFilenamesForLocale;protected List<String> calculateAllFilenames(String basename, Locale locale) {_		Map<Locale, List<String>> localeMap = this.cachedFilenames.get(basename)__		if (localeMap != null) {_			List<String> filenames = localeMap.get(locale)__			if (filenames != null) {_				return filenames__			}_		}_		List<String> filenames = new ArrayList<>(7)__		filenames.addAll(calculateFilenamesForLocale(basename, locale))__		if (isFallbackToSystemLocale() && !locale.equals(Locale.getDefault())) {_			List<String> fallbackFilenames = calculateFilenamesForLocale(basename, Locale.getDefault())__			for (String fallbackFilename : fallbackFilenames) {_				if (!filenames.contains(fallbackFilename)) {_					_					filenames.add(fallbackFilename)__				}_			}_		}_		filenames.add(basename)__		if (localeMap == null) {_			localeMap = new ConcurrentHashMap<>()__			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap)__			if (existing != null) {_				localeMap = existing__			}_		}_		localeMap.put(locale, filenames)__		return filenames__	};calculate,all,filenames,for,the,given,bundle,basename,and,locale,will,calculate,filenames,for,the,given,locale,the,system,locale,if,applicable,and,the,default,file,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check,see,set,fallback,to,system,locale,see,calculate,filenames,for,locale;protected,list,string,calculate,all,filenames,string,basename,locale,locale,map,locale,list,string,locale,map,this,cached,filenames,get,basename,if,locale,map,null,list,string,filenames,locale,map,get,locale,if,filenames,null,return,filenames,list,string,filenames,new,array,list,7,filenames,add,all,calculate,filenames,for,locale,basename,locale,if,is,fallback,to,system,locale,locale,equals,locale,get,default,list,string,fallback,filenames,calculate,filenames,for,locale,basename,locale,get,default,for,string,fallback,filename,fallback,filenames,if,filenames,contains,fallback,filename,filenames,add,fallback,filename,filenames,add,basename,if,locale,map,null,locale,map,new,concurrent,hash,map,map,locale,list,string,existing,this,cached,filenames,put,if,absent,basename,locale,map,if,existing,null,locale,map,existing,locale,map,put,locale,filenames,return,filenames
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister);1496837955;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,nullable,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister);1498780456;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,nullable,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister);1502974979;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,nullable,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister);1515532822;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,nullable,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister);1516393837;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,nullable,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister);1518167602;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,nullable,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister);1530174524;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,nullable,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(@Nullable ResourceLoader resourceLoader);1496259743;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(@Nullable ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,nullable,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(@Nullable ResourceLoader resourceLoader);1496837955;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(@Nullable ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,nullable,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(@Nullable ResourceLoader resourceLoader);1498780456;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(@Nullable ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,nullable,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(@Nullable ResourceLoader resourceLoader);1502974979;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(@Nullable ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,nullable,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(@Nullable ResourceLoader resourceLoader);1515532822;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(@Nullable ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,nullable,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(@Nullable ResourceLoader resourceLoader);1516393837;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(@Nullable ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,nullable,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(@Nullable ResourceLoader resourceLoader);1518167602;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(@Nullable ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,nullable,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(@Nullable ResourceLoader resourceLoader);1530174524;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(@Nullable ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,nullable,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	@Nullable 	protected MessageFormat resolveCode(String code, Locale locale);1502974979;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	@Nullable_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,nullable,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	@Nullable 	protected MessageFormat resolveCode(String code, Locale locale);1515532822;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	@Nullable_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,nullable,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	@Nullable 	protected MessageFormat resolveCode(String code, Locale locale);1516393837;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	@Nullable_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,nullable,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	@Nullable 	protected MessageFormat resolveCode(String code, Locale locale);1518167602;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	@Nullable_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,nullable,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	@Nullable 	protected MessageFormat resolveCode(String code, Locale locale);1530174524;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	@Nullable_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,nullable,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1328020251;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific appendices: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,appendices,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1329142650;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific appendices: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,appendices,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1348671314;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific appendices: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,appendices,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1356735495;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific appendices: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,appendices,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1357119239;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific appendices: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,appendices,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1368482696;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific appendices: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,appendices,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1385412762;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific appendices: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,appendices,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1408623868;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific appendices: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,appendices,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1410958822;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific appendices: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,appendices,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1425660337;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific appendices: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,appendices,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1454612260;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific appendices: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,appendices,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1454617957;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1467730834;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1478179664;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1495868221;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1496259743;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1496837955;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1498780456;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1502974979;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1515532822;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1516393837;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1518167602;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFileEncodings(Properties fileEncodings);1530174524;Set per-file charsets to use for parsing properties files._<p>Only applies to classic properties files, not to XML files._@param fileEncodings a Properties with filenames as keys and charset_names as values. Filenames have to match the basename syntax,_with optional locale-specific components: e.g. "WEB-INF/messages"_or "WEB-INF/messages_en"._@see #setBasenames_@see org.springframework.util.PropertiesPersister#load;public void setFileEncodings(Properties fileEncodings) {_		this.fileEncodings = fileEncodings__	};set,per,file,charsets,to,use,for,parsing,properties,files,p,only,applies,to,classic,properties,files,not,to,xml,files,param,file,encodings,a,properties,with,filenames,as,keys,and,charset,names,as,values,filenames,have,to,match,the,basename,syntax,with,optional,locale,specific,components,e,g,web,inf,messages,or,web,inf,see,set,basenames,see,org,springframework,util,properties,persister,load;public,void,set,file,encodings,properties,file,encodings,this,file,encodings,file,encodings
ReloadableResourceBundleMessageSource -> public void setFallbackToSystemLocale(boolean fallbackToSystemLocale);1328020251;Set whether to fall back to the system Locale if no files for a specific_Locale have been found. Default is "true"_ if this is turned off, the only_fallback will be the default file (e.g. "messages.properties" for_basename "messages")._<p>Falling back to the system Locale is the default behavior of_<code>java.util.ResourceBundle</code>. However, this is often not_desirable in an application server environment, where the system Locale_is not relevant to the application at all: Set this flag to "false"_in such a scenario.;public void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {_		this.fallbackToSystemLocale = fallbackToSystemLocale__	};set,whether,to,fall,back,to,the,system,locale,if,no,files,for,a,specific,locale,have,been,found,default,is,true,if,this,is,turned,off,the,only,fallback,will,be,the,default,file,e,g,messages,properties,for,basename,messages,p,falling,back,to,the,system,locale,is,the,default,behavior,of,code,java,util,resource,bundle,code,however,this,is,often,not,desirable,in,an,application,server,environment,where,the,system,locale,is,not,relevant,to,the,application,at,all,set,this,flag,to,false,in,such,a,scenario;public,void,set,fallback,to,system,locale,boolean,fallback,to,system,locale,this,fallback,to,system,locale,fallback,to,system,locale
ReloadableResourceBundleMessageSource -> public void setFallbackToSystemLocale(boolean fallbackToSystemLocale);1329142650;Set whether to fall back to the system Locale if no files for a specific_Locale have been found. Default is "true"_ if this is turned off, the only_fallback will be the default file (e.g. "messages.properties" for_basename "messages")._<p>Falling back to the system Locale is the default behavior of_<code>java.util.ResourceBundle</code>. However, this is often not_desirable in an application server environment, where the system Locale_is not relevant to the application at all: Set this flag to "false"_in such a scenario.;public void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {_		this.fallbackToSystemLocale = fallbackToSystemLocale__	};set,whether,to,fall,back,to,the,system,locale,if,no,files,for,a,specific,locale,have,been,found,default,is,true,if,this,is,turned,off,the,only,fallback,will,be,the,default,file,e,g,messages,properties,for,basename,messages,p,falling,back,to,the,system,locale,is,the,default,behavior,of,code,java,util,resource,bundle,code,however,this,is,often,not,desirable,in,an,application,server,environment,where,the,system,locale,is,not,relevant,to,the,application,at,all,set,this,flag,to,false,in,such,a,scenario;public,void,set,fallback,to,system,locale,boolean,fallback,to,system,locale,this,fallback,to,system,locale,fallback,to,system,locale
ReloadableResourceBundleMessageSource -> public void setFallbackToSystemLocale(boolean fallbackToSystemLocale);1348671314;Set whether to fall back to the system Locale if no files for a specific_Locale have been found. Default is "true"_ if this is turned off, the only_fallback will be the default file (e.g. "messages.properties" for_basename "messages")._<p>Falling back to the system Locale is the default behavior of_<code>java.util.ResourceBundle</code>. However, this is often not desirable_in an application server environment, where the system Locale is not relevant_to the application at all: Set this flag to "false" in such a scenario.;public void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {_		this.fallbackToSystemLocale = fallbackToSystemLocale__	};set,whether,to,fall,back,to,the,system,locale,if,no,files,for,a,specific,locale,have,been,found,default,is,true,if,this,is,turned,off,the,only,fallback,will,be,the,default,file,e,g,messages,properties,for,basename,messages,p,falling,back,to,the,system,locale,is,the,default,behavior,of,code,java,util,resource,bundle,code,however,this,is,often,not,desirable,in,an,application,server,environment,where,the,system,locale,is,not,relevant,to,the,application,at,all,set,this,flag,to,false,in,such,a,scenario;public,void,set,fallback,to,system,locale,boolean,fallback,to,system,locale,this,fallback,to,system,locale,fallback,to,system,locale
ReloadableResourceBundleMessageSource -> public void setFallbackToSystemLocale(boolean fallbackToSystemLocale);1356735495;Set whether to fall back to the system Locale if no files for a specific_Locale have been found. Default is "true"_ if this is turned off, the only_fallback will be the default file (e.g. "messages.properties" for_basename "messages")._<p>Falling back to the system Locale is the default behavior of_{@code java.util.ResourceBundle}. However, this is often not desirable_in an application server environment, where the system Locale is not relevant_to the application at all: Set this flag to "false" in such a scenario.;public void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {_		this.fallbackToSystemLocale = fallbackToSystemLocale__	};set,whether,to,fall,back,to,the,system,locale,if,no,files,for,a,specific,locale,have,been,found,default,is,true,if,this,is,turned,off,the,only,fallback,will,be,the,default,file,e,g,messages,properties,for,basename,messages,p,falling,back,to,the,system,locale,is,the,default,behavior,of,code,java,util,resource,bundle,however,this,is,often,not,desirable,in,an,application,server,environment,where,the,system,locale,is,not,relevant,to,the,application,at,all,set,this,flag,to,false,in,such,a,scenario;public,void,set,fallback,to,system,locale,boolean,fallback,to,system,locale,this,fallback,to,system,locale,fallback,to,system,locale
ReloadableResourceBundleMessageSource -> public void setFallbackToSystemLocale(boolean fallbackToSystemLocale);1357119239;Set whether to fall back to the system Locale if no files for a specific_Locale have been found. Default is "true"_ if this is turned off, the only_fallback will be the default file (e.g. "messages.properties" for_basename "messages")._<p>Falling back to the system Locale is the default behavior of_{@code java.util.ResourceBundle}. However, this is often not desirable_in an application server environment, where the system Locale is not relevant_to the application at all: Set this flag to "false" in such a scenario.;public void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {_		this.fallbackToSystemLocale = fallbackToSystemLocale__	};set,whether,to,fall,back,to,the,system,locale,if,no,files,for,a,specific,locale,have,been,found,default,is,true,if,this,is,turned,off,the,only,fallback,will,be,the,default,file,e,g,messages,properties,for,basename,messages,p,falling,back,to,the,system,locale,is,the,default,behavior,of,code,java,util,resource,bundle,however,this,is,often,not,desirable,in,an,application,server,environment,where,the,system,locale,is,not,relevant,to,the,application,at,all,set,this,flag,to,false,in,such,a,scenario;public,void,set,fallback,to,system,locale,boolean,fallback,to,system,locale,this,fallback,to,system,locale,fallback,to,system,locale
ReloadableResourceBundleMessageSource -> public void setFallbackToSystemLocale(boolean fallbackToSystemLocale);1368482696;Set whether to fall back to the system Locale if no files for a specific_Locale have been found. Default is "true"_ if this is turned off, the only_fallback will be the default file (e.g. "messages.properties" for_basename "messages")._<p>Falling back to the system Locale is the default behavior of_{@code java.util.ResourceBundle}. However, this is often not desirable_in an application server environment, where the system Locale is not relevant_to the application at all: Set this flag to "false" in such a scenario.;public void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {_		this.fallbackToSystemLocale = fallbackToSystemLocale__	};set,whether,to,fall,back,to,the,system,locale,if,no,files,for,a,specific,locale,have,been,found,default,is,true,if,this,is,turned,off,the,only,fallback,will,be,the,default,file,e,g,messages,properties,for,basename,messages,p,falling,back,to,the,system,locale,is,the,default,behavior,of,code,java,util,resource,bundle,however,this,is,often,not,desirable,in,an,application,server,environment,where,the,system,locale,is,not,relevant,to,the,application,at,all,set,this,flag,to,false,in,such,a,scenario;public,void,set,fallback,to,system,locale,boolean,fallback,to,system,locale,this,fallback,to,system,locale,fallback,to,system,locale
ReloadableResourceBundleMessageSource -> public void setFallbackToSystemLocale(boolean fallbackToSystemLocale);1385412762;Set whether to fall back to the system Locale if no files for a specific_Locale have been found. Default is "true"_ if this is turned off, the only_fallback will be the default file (e.g. "messages.properties" for_basename "messages")._<p>Falling back to the system Locale is the default behavior of_{@code java.util.ResourceBundle}. However, this is often not desirable_in an application server environment, where the system Locale is not relevant_to the application at all: Set this flag to "false" in such a scenario.;public void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {_		this.fallbackToSystemLocale = fallbackToSystemLocale__	};set,whether,to,fall,back,to,the,system,locale,if,no,files,for,a,specific,locale,have,been,found,default,is,true,if,this,is,turned,off,the,only,fallback,will,be,the,default,file,e,g,messages,properties,for,basename,messages,p,falling,back,to,the,system,locale,is,the,default,behavior,of,code,java,util,resource,bundle,however,this,is,often,not,desirable,in,an,application,server,environment,where,the,system,locale,is,not,relevant,to,the,application,at,all,set,this,flag,to,false,in,such,a,scenario;public,void,set,fallback,to,system,locale,boolean,fallback,to,system,locale,this,fallback,to,system,locale,fallback,to,system,locale
ReloadableResourceBundleMessageSource -> public void setFallbackToSystemLocale(boolean fallbackToSystemLocale);1408623868;Set whether to fall back to the system Locale if no files for a specific_Locale have been found. Default is "true"_ if this is turned off, the only_fallback will be the default file (e.g. "messages.properties" for_basename "messages")._<p>Falling back to the system Locale is the default behavior of_{@code java.util.ResourceBundle}. However, this is often not desirable_in an application server environment, where the system Locale is not relevant_to the application at all: Set this flag to "false" in such a scenario.;public void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {_		this.fallbackToSystemLocale = fallbackToSystemLocale__	};set,whether,to,fall,back,to,the,system,locale,if,no,files,for,a,specific,locale,have,been,found,default,is,true,if,this,is,turned,off,the,only,fallback,will,be,the,default,file,e,g,messages,properties,for,basename,messages,p,falling,back,to,the,system,locale,is,the,default,behavior,of,code,java,util,resource,bundle,however,this,is,often,not,desirable,in,an,application,server,environment,where,the,system,locale,is,not,relevant,to,the,application,at,all,set,this,flag,to,false,in,such,a,scenario;public,void,set,fallback,to,system,locale,boolean,fallback,to,system,locale,this,fallback,to,system,locale,fallback,to,system,locale
ReloadableResourceBundleMessageSource -> public void setFallbackToSystemLocale(boolean fallbackToSystemLocale);1410958822;Set whether to fall back to the system Locale if no files for a specific_Locale have been found. Default is "true"_ if this is turned off, the only_fallback will be the default file (e.g. "messages.properties" for_basename "messages")._<p>Falling back to the system Locale is the default behavior of_{@code java.util.ResourceBundle}. However, this is often not desirable_in an application server environment, where the system Locale is not relevant_to the application at all: Set this flag to "false" in such a scenario.;public void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {_		this.fallbackToSystemLocale = fallbackToSystemLocale__	};set,whether,to,fall,back,to,the,system,locale,if,no,files,for,a,specific,locale,have,been,found,default,is,true,if,this,is,turned,off,the,only,fallback,will,be,the,default,file,e,g,messages,properties,for,basename,messages,p,falling,back,to,the,system,locale,is,the,default,behavior,of,code,java,util,resource,bundle,however,this,is,often,not,desirable,in,an,application,server,environment,where,the,system,locale,is,not,relevant,to,the,application,at,all,set,this,flag,to,false,in,such,a,scenario;public,void,set,fallback,to,system,locale,boolean,fallback,to,system,locale,this,fallback,to,system,locale,fallback,to,system,locale
ReloadableResourceBundleMessageSource -> public void setFallbackToSystemLocale(boolean fallbackToSystemLocale);1425660337;Set whether to fall back to the system Locale if no files for a specific_Locale have been found. Default is "true"_ if this is turned off, the only_fallback will be the default file (e.g. "messages.properties" for_basename "messages")._<p>Falling back to the system Locale is the default behavior of_{@code java.util.ResourceBundle}. However, this is often not desirable_in an application server environment, where the system Locale is not relevant_to the application at all: Set this flag to "false" in such a scenario.;public void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {_		this.fallbackToSystemLocale = fallbackToSystemLocale__	};set,whether,to,fall,back,to,the,system,locale,if,no,files,for,a,specific,locale,have,been,found,default,is,true,if,this,is,turned,off,the,only,fallback,will,be,the,default,file,e,g,messages,properties,for,basename,messages,p,falling,back,to,the,system,locale,is,the,default,behavior,of,code,java,util,resource,bundle,however,this,is,often,not,desirable,in,an,application,server,environment,where,the,system,locale,is,not,relevant,to,the,application,at,all,set,this,flag,to,false,in,such,a,scenario;public,void,set,fallback,to,system,locale,boolean,fallback,to,system,locale,this,fallback,to,system,locale,fallback,to,system,locale
ReloadableResourceBundleMessageSource -> public void setResourceLoader(ResourceLoader resourceLoader);1328020251;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> public void setResourceLoader(ResourceLoader resourceLoader);1329142650;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> public void setResourceLoader(ResourceLoader resourceLoader);1348671314;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> public void setResourceLoader(ResourceLoader resourceLoader);1357119239;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1328020251;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = new Properties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = this.defaultEncoding__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,this,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1329142650;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = new Properties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = this.defaultEncoding__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,this,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1348671314;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = new Properties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = this.defaultEncoding__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,this,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1356735495;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = new Properties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = this.defaultEncoding__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,this,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1357119239;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = new Properties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = this.defaultEncoding__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,this,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1368482696;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = new Properties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = this.defaultEncoding__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,this,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1385412762;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = new Properties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = this.defaultEncoding__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,this,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1408623868;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = new Properties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = this.defaultEncoding__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,this,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1410958822;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = new Properties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = this.defaultEncoding__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,this,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1425660337;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = this.defaultEncoding__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,this,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1454612260;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1454617957;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1467730834;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1478179664;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1495868221;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1496259743;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			if (resource.getFilename().endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,if,resource,get,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1496837955;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			String resourceFilename = resource.getFilename()__			if (resourceFilename != null && resourceFilename.endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,string,resource,filename,resource,get,filename,if,resource,filename,null,resource,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1498780456;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			String resourceFilename = resource.getFilename()__			if (resourceFilename != null && resourceFilename.endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,string,resource,filename,resource,get,filename,if,resource,filename,null,resource,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1502974979;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			String resourceFilename = resource.getFilename()__			if (resourceFilename != null && resourceFilename.endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,string,resource,filename,resource,get,filename,if,resource,filename,null,resource,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1515532822;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			String resourceFilename = resource.getFilename()__			if (resourceFilename != null && resourceFilename.endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,string,resource,filename,resource,get,filename,if,resource,filename,null,resource,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1516393837;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		InputStream is = resource.getInputStream()__		Properties props = newProperties()__		try {_			String resourceFilename = resource.getFilename()__			if (resourceFilename != null && resourceFilename.endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_		finally {_			is.close()__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,input,stream,is,resource,get,input,stream,properties,props,new,properties,try,string,resource,filename,resource,get,filename,if,resource,filename,null,resource,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props,finally,is,close
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1518167602;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		Properties props = newProperties()__		try (InputStream is = resource.getInputStream()) {_			String resourceFilename = resource.getFilename()__			if (resourceFilename != null && resourceFilename.endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,properties,props,new,properties,try,input,stream,is,resource,get,input,stream,string,resource,filename,resource,get,filename,if,resource,filename,null,resource,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props
ReloadableResourceBundleMessageSource -> protected Properties loadProperties(Resource resource, String filename) throws IOException;1530174524;Load the properties from the given resource._@param resource the resource to load from_@param filename the original bundle filename (basename + Locale)_@return the populated Properties instance_@throws IOException if properties loading failed;protected Properties loadProperties(Resource resource, String filename) throws IOException {_		Properties props = newProperties()__		try (InputStream is = resource.getInputStream()) {_			String resourceFilename = resource.getFilename()__			if (resourceFilename != null && resourceFilename.endsWith(XML_SUFFIX)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Loading properties [" + resource.getFilename() + "]")__				}_				this.propertiesPersister.loadFromXml(props, is)__			}_			else {_				String encoding = null__				if (this.fileEncodings != null) {_					encoding = this.fileEncodings.getProperty(filename)__				}_				if (encoding == null) {_					encoding = getDefaultEncoding()__				}_				if (encoding != null) {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "] with encoding '" + encoding + "'")__					}_					this.propertiesPersister.load(props, new InputStreamReader(is, encoding))__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Loading properties [" + resource.getFilename() + "]")__					}_					this.propertiesPersister.load(props, is)__				}_			}_			return props__		}_	};load,the,properties,from,the,given,resource,param,resource,the,resource,to,load,from,param,filename,the,original,bundle,filename,basename,locale,return,the,populated,properties,instance,throws,ioexception,if,properties,loading,failed;protected,properties,load,properties,resource,resource,string,filename,throws,ioexception,properties,props,new,properties,try,input,stream,is,resource,get,input,stream,string,resource,filename,resource,get,filename,if,resource,filename,null,resource,filename,ends,with,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,from,xml,props,is,else,string,encoding,null,if,this,file,encodings,null,encoding,this,file,encodings,get,property,filename,if,encoding,null,encoding,get,default,encoding,if,encoding,null,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,with,encoding,encoding,this,properties,persister,load,props,new,input,stream,reader,is,encoding,else,if,logger,is,debug,enabled,logger,debug,loading,properties,resource,get,filename,this,properties,persister,load,props,is,return,props
ReloadableResourceBundleMessageSource -> public void setDefaultEncoding(String defaultEncoding);1328020251;Set the default charset to use for parsing properties files._Used if no file-specific charset is specified for a file._<p>Default is none, using the <code>java.util.Properties</code>_default encoding._<p>Only applies to classic properties files, not to XML files._@param defaultEncoding the default charset_@see #setFileEncodings_@see org.springframework.util.PropertiesPersister#load;public void setDefaultEncoding(String defaultEncoding) {_		this.defaultEncoding = defaultEncoding__	};set,the,default,charset,to,use,for,parsing,properties,files,used,if,no,file,specific,charset,is,specified,for,a,file,p,default,is,none,using,the,code,java,util,properties,code,default,encoding,p,only,applies,to,classic,properties,files,not,to,xml,files,param,default,encoding,the,default,charset,see,set,file,encodings,see,org,springframework,util,properties,persister,load;public,void,set,default,encoding,string,default,encoding,this,default,encoding,default,encoding
ReloadableResourceBundleMessageSource -> public void setDefaultEncoding(String defaultEncoding);1329142650;Set the default charset to use for parsing properties files._Used if no file-specific charset is specified for a file._<p>Default is none, using the <code>java.util.Properties</code>_default encoding._<p>Only applies to classic properties files, not to XML files._@param defaultEncoding the default charset_@see #setFileEncodings_@see org.springframework.util.PropertiesPersister#load;public void setDefaultEncoding(String defaultEncoding) {_		this.defaultEncoding = defaultEncoding__	};set,the,default,charset,to,use,for,parsing,properties,files,used,if,no,file,specific,charset,is,specified,for,a,file,p,default,is,none,using,the,code,java,util,properties,code,default,encoding,p,only,applies,to,classic,properties,files,not,to,xml,files,param,default,encoding,the,default,charset,see,set,file,encodings,see,org,springframework,util,properties,persister,load;public,void,set,default,encoding,string,default,encoding,this,default,encoding,default,encoding
ReloadableResourceBundleMessageSource -> public void setDefaultEncoding(String defaultEncoding);1348671314;Set the default charset to use for parsing properties files._Used if no file-specific charset is specified for a file._<p>Default is none, using the <code>java.util.Properties</code>_default encoding: ISO-8859-1._<p>Only applies to classic properties files, not to XML files._@param defaultEncoding the default charset_@see #setFileEncodings_@see org.springframework.util.PropertiesPersister#load;public void setDefaultEncoding(String defaultEncoding) {_		this.defaultEncoding = defaultEncoding__	};set,the,default,charset,to,use,for,parsing,properties,files,used,if,no,file,specific,charset,is,specified,for,a,file,p,default,is,none,using,the,code,java,util,properties,code,default,encoding,iso,8859,1,p,only,applies,to,classic,properties,files,not,to,xml,files,param,default,encoding,the,default,charset,see,set,file,encodings,see,org,springframework,util,properties,persister,load;public,void,set,default,encoding,string,default,encoding,this,default,encoding,default,encoding
ReloadableResourceBundleMessageSource -> public void setDefaultEncoding(String defaultEncoding);1356735495;Set the default charset to use for parsing properties files._Used if no file-specific charset is specified for a file._<p>Default is none, using the {@code java.util.Properties}_default encoding: ISO-8859-1._<p>Only applies to classic properties files, not to XML files._@param defaultEncoding the default charset_@see #setFileEncodings_@see org.springframework.util.PropertiesPersister#load;public void setDefaultEncoding(String defaultEncoding) {_		this.defaultEncoding = defaultEncoding__	};set,the,default,charset,to,use,for,parsing,properties,files,used,if,no,file,specific,charset,is,specified,for,a,file,p,default,is,none,using,the,code,java,util,properties,default,encoding,iso,8859,1,p,only,applies,to,classic,properties,files,not,to,xml,files,param,default,encoding,the,default,charset,see,set,file,encodings,see,org,springframework,util,properties,persister,load;public,void,set,default,encoding,string,default,encoding,this,default,encoding,default,encoding
ReloadableResourceBundleMessageSource -> public void setDefaultEncoding(String defaultEncoding);1357119239;Set the default charset to use for parsing properties files._Used if no file-specific charset is specified for a file._<p>Default is none, using the {@code java.util.Properties}_default encoding: ISO-8859-1._<p>Only applies to classic properties files, not to XML files._@param defaultEncoding the default charset_@see #setFileEncodings_@see org.springframework.util.PropertiesPersister#load;public void setDefaultEncoding(String defaultEncoding) {_		this.defaultEncoding = defaultEncoding__	};set,the,default,charset,to,use,for,parsing,properties,files,used,if,no,file,specific,charset,is,specified,for,a,file,p,default,is,none,using,the,code,java,util,properties,default,encoding,iso,8859,1,p,only,applies,to,classic,properties,files,not,to,xml,files,param,default,encoding,the,default,charset,see,set,file,encodings,see,org,springframework,util,properties,persister,load;public,void,set,default,encoding,string,default,encoding,this,default,encoding,default,encoding
ReloadableResourceBundleMessageSource -> public void setDefaultEncoding(String defaultEncoding);1368482696;Set the default charset to use for parsing properties files._Used if no file-specific charset is specified for a file._<p>Default is none, using the {@code java.util.Properties}_default encoding: ISO-8859-1._<p>Only applies to classic properties files, not to XML files._@param defaultEncoding the default charset_@see #setFileEncodings_@see org.springframework.util.PropertiesPersister#load;public void setDefaultEncoding(String defaultEncoding) {_		this.defaultEncoding = defaultEncoding__	};set,the,default,charset,to,use,for,parsing,properties,files,used,if,no,file,specific,charset,is,specified,for,a,file,p,default,is,none,using,the,code,java,util,properties,default,encoding,iso,8859,1,p,only,applies,to,classic,properties,files,not,to,xml,files,param,default,encoding,the,default,charset,see,set,file,encodings,see,org,springframework,util,properties,persister,load;public,void,set,default,encoding,string,default,encoding,this,default,encoding,default,encoding
ReloadableResourceBundleMessageSource -> public void setDefaultEncoding(String defaultEncoding);1385412762;Set the default charset to use for parsing properties files._Used if no file-specific charset is specified for a file._<p>Default is none, using the {@code java.util.Properties}_default encoding: ISO-8859-1._<p>Only applies to classic properties files, not to XML files._@param defaultEncoding the default charset_@see #setFileEncodings_@see org.springframework.util.PropertiesPersister#load;public void setDefaultEncoding(String defaultEncoding) {_		this.defaultEncoding = defaultEncoding__	};set,the,default,charset,to,use,for,parsing,properties,files,used,if,no,file,specific,charset,is,specified,for,a,file,p,default,is,none,using,the,code,java,util,properties,default,encoding,iso,8859,1,p,only,applies,to,classic,properties,files,not,to,xml,files,param,default,encoding,the,default,charset,see,set,file,encodings,see,org,springframework,util,properties,persister,load;public,void,set,default,encoding,string,default,encoding,this,default,encoding,default,encoding
ReloadableResourceBundleMessageSource -> public void setDefaultEncoding(String defaultEncoding);1408623868;Set the default charset to use for parsing properties files._Used if no file-specific charset is specified for a file._<p>Default is none, using the {@code java.util.Properties}_default encoding: ISO-8859-1._<p>Only applies to classic properties files, not to XML files._@param defaultEncoding the default charset_@see #setFileEncodings_@see org.springframework.util.PropertiesPersister#load;public void setDefaultEncoding(String defaultEncoding) {_		this.defaultEncoding = defaultEncoding__	};set,the,default,charset,to,use,for,parsing,properties,files,used,if,no,file,specific,charset,is,specified,for,a,file,p,default,is,none,using,the,code,java,util,properties,default,encoding,iso,8859,1,p,only,applies,to,classic,properties,files,not,to,xml,files,param,default,encoding,the,default,charset,see,set,file,encodings,see,org,springframework,util,properties,persister,load;public,void,set,default,encoding,string,default,encoding,this,default,encoding,default,encoding
ReloadableResourceBundleMessageSource -> public void setDefaultEncoding(String defaultEncoding);1410958822;Set the default charset to use for parsing properties files._Used if no file-specific charset is specified for a file._<p>Default is none, using the {@code java.util.Properties}_default encoding: ISO-8859-1._<p>Only applies to classic properties files, not to XML files._@param defaultEncoding the default charset_@see #setFileEncodings_@see org.springframework.util.PropertiesPersister#load;public void setDefaultEncoding(String defaultEncoding) {_		this.defaultEncoding = defaultEncoding__	};set,the,default,charset,to,use,for,parsing,properties,files,used,if,no,file,specific,charset,is,specified,for,a,file,p,default,is,none,using,the,code,java,util,properties,default,encoding,iso,8859,1,p,only,applies,to,classic,properties,files,not,to,xml,files,param,default,encoding,the,default,charset,see,set,file,encodings,see,org,springframework,util,properties,persister,load;public,void,set,default,encoding,string,default,encoding,this,default,encoding,default,encoding
ReloadableResourceBundleMessageSource -> public void setDefaultEncoding(String defaultEncoding);1425660337;Set the default charset to use for parsing properties files._Used if no file-specific charset is specified for a file._<p>Default is none, using the {@code java.util.Properties}_default encoding: ISO-8859-1._<p>Only applies to classic properties files, not to XML files._@param defaultEncoding the default charset_@see #setFileEncodings_@see org.springframework.util.PropertiesPersister#load;public void setDefaultEncoding(String defaultEncoding) {_		this.defaultEncoding = defaultEncoding__	};set,the,default,charset,to,use,for,parsing,properties,files,used,if,no,file,specific,charset,is,specified,for,a,file,p,default,is,none,using,the,code,java,util,properties,default,encoding,iso,8859,1,p,only,applies,to,classic,properties,files,not,to,xml,files,param,default,encoding,the,default,charset,see,set,file,encodings,see,org,springframework,util,properties,persister,load;public,void,set,default,encoding,string,default,encoding,this,default,encoding,default,encoding
ReloadableResourceBundleMessageSource -> public void setCacheSeconds(int cacheSeconds);1328020251;Set the number of seconds to cache loaded properties files._<ul>_<li>Default is "-1", indicating to cache forever (just like_<code>java.util.ResourceBundle</code>)._<li>A positive number will cache loaded properties files for the given_number of seconds. This is essentially the interval between refresh checks._Note that a refresh attempt will first check the last-modified timestamp_of the file before actually reloading it_ so if files don't change, this_interval can be set rather low, as refresh attempts will not actually reload._<li>A value of "0" will check the last-modified timestamp of the file on_every message access. <b>Do not use this in a production environment!</b>_</ul>;public void setCacheSeconds(int cacheSeconds) {_		this.cacheMillis = (cacheSeconds * 1000)__	};set,the,number,of,seconds,to,cache,loaded,properties,files,ul,li,default,is,1,indicating,to,cache,forever,just,like,code,java,util,resource,bundle,code,li,a,positive,number,will,cache,loaded,properties,files,for,the,given,number,of,seconds,this,is,essentially,the,interval,between,refresh,checks,note,that,a,refresh,attempt,will,first,check,the,last,modified,timestamp,of,the,file,before,actually,reloading,it,so,if,files,don,t,change,this,interval,can,be,set,rather,low,as,refresh,attempts,will,not,actually,reload,li,a,value,of,0,will,check,the,last,modified,timestamp,of,the,file,on,every,message,access,b,do,not,use,this,in,a,production,environment,b,ul;public,void,set,cache,seconds,int,cache,seconds,this,cache,millis,cache,seconds,1000
ReloadableResourceBundleMessageSource -> public void setCacheSeconds(int cacheSeconds);1329142650;Set the number of seconds to cache loaded properties files._<ul>_<li>Default is "-1", indicating to cache forever (just like_<code>java.util.ResourceBundle</code>)._<li>A positive number will cache loaded properties files for the given_number of seconds. This is essentially the interval between refresh checks._Note that a refresh attempt will first check the last-modified timestamp_of the file before actually reloading it_ so if files don't change, this_interval can be set rather low, as refresh attempts will not actually reload._<li>A value of "0" will check the last-modified timestamp of the file on_every message access. <b>Do not use this in a production environment!</b>_</ul>;public void setCacheSeconds(int cacheSeconds) {_		this.cacheMillis = (cacheSeconds * 1000)__	};set,the,number,of,seconds,to,cache,loaded,properties,files,ul,li,default,is,1,indicating,to,cache,forever,just,like,code,java,util,resource,bundle,code,li,a,positive,number,will,cache,loaded,properties,files,for,the,given,number,of,seconds,this,is,essentially,the,interval,between,refresh,checks,note,that,a,refresh,attempt,will,first,check,the,last,modified,timestamp,of,the,file,before,actually,reloading,it,so,if,files,don,t,change,this,interval,can,be,set,rather,low,as,refresh,attempts,will,not,actually,reload,li,a,value,of,0,will,check,the,last,modified,timestamp,of,the,file,on,every,message,access,b,do,not,use,this,in,a,production,environment,b,ul;public,void,set,cache,seconds,int,cache,seconds,this,cache,millis,cache,seconds,1000
ReloadableResourceBundleMessageSource -> public void setCacheSeconds(int cacheSeconds);1348671314;Set the number of seconds to cache loaded properties files._<ul>_<li>Default is "-1", indicating to cache forever (just like_<code>java.util.ResourceBundle</code>)._<li>A positive number will cache loaded properties files for the given_number of seconds. This is essentially the interval between refresh checks._Note that a refresh attempt will first check the last-modified timestamp_of the file before actually reloading it_ so if files don't change, this_interval can be set rather low, as refresh attempts will not actually reload._<li>A value of "0" will check the last-modified timestamp of the file on_every message access. <b>Do not use this in a production environment!</b>_</ul>;public void setCacheSeconds(int cacheSeconds) {_		this.cacheMillis = (cacheSeconds * 1000)__	};set,the,number,of,seconds,to,cache,loaded,properties,files,ul,li,default,is,1,indicating,to,cache,forever,just,like,code,java,util,resource,bundle,code,li,a,positive,number,will,cache,loaded,properties,files,for,the,given,number,of,seconds,this,is,essentially,the,interval,between,refresh,checks,note,that,a,refresh,attempt,will,first,check,the,last,modified,timestamp,of,the,file,before,actually,reloading,it,so,if,files,don,t,change,this,interval,can,be,set,rather,low,as,refresh,attempts,will,not,actually,reload,li,a,value,of,0,will,check,the,last,modified,timestamp,of,the,file,on,every,message,access,b,do,not,use,this,in,a,production,environment,b,ul;public,void,set,cache,seconds,int,cache,seconds,this,cache,millis,cache,seconds,1000
ReloadableResourceBundleMessageSource -> public void setCacheSeconds(int cacheSeconds);1356735495;Set the number of seconds to cache loaded properties files._<ul>_<li>Default is "-1", indicating to cache forever (just like_{@code java.util.ResourceBundle})._<li>A positive number will cache loaded properties files for the given_number of seconds. This is essentially the interval between refresh checks._Note that a refresh attempt will first check the last-modified timestamp_of the file before actually reloading it_ so if files don't change, this_interval can be set rather low, as refresh attempts will not actually reload._<li>A value of "0" will check the last-modified timestamp of the file on_every message access. <b>Do not use this in a production environment!</b>_</ul>;public void setCacheSeconds(int cacheSeconds) {_		this.cacheMillis = (cacheSeconds * 1000)__	};set,the,number,of,seconds,to,cache,loaded,properties,files,ul,li,default,is,1,indicating,to,cache,forever,just,like,code,java,util,resource,bundle,li,a,positive,number,will,cache,loaded,properties,files,for,the,given,number,of,seconds,this,is,essentially,the,interval,between,refresh,checks,note,that,a,refresh,attempt,will,first,check,the,last,modified,timestamp,of,the,file,before,actually,reloading,it,so,if,files,don,t,change,this,interval,can,be,set,rather,low,as,refresh,attempts,will,not,actually,reload,li,a,value,of,0,will,check,the,last,modified,timestamp,of,the,file,on,every,message,access,b,do,not,use,this,in,a,production,environment,b,ul;public,void,set,cache,seconds,int,cache,seconds,this,cache,millis,cache,seconds,1000
ReloadableResourceBundleMessageSource -> public void setCacheSeconds(int cacheSeconds);1357119239;Set the number of seconds to cache loaded properties files._<ul>_<li>Default is "-1", indicating to cache forever (just like_{@code java.util.ResourceBundle})._<li>A positive number will cache loaded properties files for the given_number of seconds. This is essentially the interval between refresh checks._Note that a refresh attempt will first check the last-modified timestamp_of the file before actually reloading it_ so if files don't change, this_interval can be set rather low, as refresh attempts will not actually reload._<li>A value of "0" will check the last-modified timestamp of the file on_every message access. <b>Do not use this in a production environment!</b>_</ul>;public void setCacheSeconds(int cacheSeconds) {_		this.cacheMillis = (cacheSeconds * 1000)__	};set,the,number,of,seconds,to,cache,loaded,properties,files,ul,li,default,is,1,indicating,to,cache,forever,just,like,code,java,util,resource,bundle,li,a,positive,number,will,cache,loaded,properties,files,for,the,given,number,of,seconds,this,is,essentially,the,interval,between,refresh,checks,note,that,a,refresh,attempt,will,first,check,the,last,modified,timestamp,of,the,file,before,actually,reloading,it,so,if,files,don,t,change,this,interval,can,be,set,rather,low,as,refresh,attempts,will,not,actually,reload,li,a,value,of,0,will,check,the,last,modified,timestamp,of,the,file,on,every,message,access,b,do,not,use,this,in,a,production,environment,b,ul;public,void,set,cache,seconds,int,cache,seconds,this,cache,millis,cache,seconds,1000
ReloadableResourceBundleMessageSource -> public void setCacheSeconds(int cacheSeconds);1368482696;Set the number of seconds to cache loaded properties files._<ul>_<li>Default is "-1", indicating to cache forever (just like_{@code java.util.ResourceBundle})._<li>A positive number will cache loaded properties files for the given_number of seconds. This is essentially the interval between refresh checks._Note that a refresh attempt will first check the last-modified timestamp_of the file before actually reloading it_ so if files don't change, this_interval can be set rather low, as refresh attempts will not actually reload._<li>A value of "0" will check the last-modified timestamp of the file on_every message access. <b>Do not use this in a production environment!</b>_</ul>;public void setCacheSeconds(int cacheSeconds) {_		this.cacheMillis = (cacheSeconds * 1000)__	};set,the,number,of,seconds,to,cache,loaded,properties,files,ul,li,default,is,1,indicating,to,cache,forever,just,like,code,java,util,resource,bundle,li,a,positive,number,will,cache,loaded,properties,files,for,the,given,number,of,seconds,this,is,essentially,the,interval,between,refresh,checks,note,that,a,refresh,attempt,will,first,check,the,last,modified,timestamp,of,the,file,before,actually,reloading,it,so,if,files,don,t,change,this,interval,can,be,set,rather,low,as,refresh,attempts,will,not,actually,reload,li,a,value,of,0,will,check,the,last,modified,timestamp,of,the,file,on,every,message,access,b,do,not,use,this,in,a,production,environment,b,ul;public,void,set,cache,seconds,int,cache,seconds,this,cache,millis,cache,seconds,1000
ReloadableResourceBundleMessageSource -> public void setCacheSeconds(int cacheSeconds);1385412762;Set the number of seconds to cache loaded properties files._<ul>_<li>Default is "-1", indicating to cache forever (just like_{@code java.util.ResourceBundle})._<li>A positive number will cache loaded properties files for the given_number of seconds. This is essentially the interval between refresh checks._Note that a refresh attempt will first check the last-modified timestamp_of the file before actually reloading it_ so if files don't change, this_interval can be set rather low, as refresh attempts will not actually reload._<li>A value of "0" will check the last-modified timestamp of the file on_every message access. <b>Do not use this in a production environment!</b>_</ul>;public void setCacheSeconds(int cacheSeconds) {_		this.cacheMillis = (cacheSeconds * 1000)__	};set,the,number,of,seconds,to,cache,loaded,properties,files,ul,li,default,is,1,indicating,to,cache,forever,just,like,code,java,util,resource,bundle,li,a,positive,number,will,cache,loaded,properties,files,for,the,given,number,of,seconds,this,is,essentially,the,interval,between,refresh,checks,note,that,a,refresh,attempt,will,first,check,the,last,modified,timestamp,of,the,file,before,actually,reloading,it,so,if,files,don,t,change,this,interval,can,be,set,rather,low,as,refresh,attempts,will,not,actually,reload,li,a,value,of,0,will,check,the,last,modified,timestamp,of,the,file,on,every,message,access,b,do,not,use,this,in,a,production,environment,b,ul;public,void,set,cache,seconds,int,cache,seconds,this,cache,millis,cache,seconds,1000
ReloadableResourceBundleMessageSource -> public void setCacheSeconds(int cacheSeconds);1408623868;Set the number of seconds to cache loaded properties files._<ul>_<li>Default is "-1", indicating to cache forever (just like_{@code java.util.ResourceBundle})._<li>A positive number will cache loaded properties files for the given_number of seconds. This is essentially the interval between refresh checks._Note that a refresh attempt will first check the last-modified timestamp_of the file before actually reloading it_ so if files don't change, this_interval can be set rather low, as refresh attempts will not actually reload._<li>A value of "0" will check the last-modified timestamp of the file on_every message access. <b>Do not use this in a production environment!</b>_</ul>;public void setCacheSeconds(int cacheSeconds) {_		this.cacheMillis = (cacheSeconds * 1000)__	};set,the,number,of,seconds,to,cache,loaded,properties,files,ul,li,default,is,1,indicating,to,cache,forever,just,like,code,java,util,resource,bundle,li,a,positive,number,will,cache,loaded,properties,files,for,the,given,number,of,seconds,this,is,essentially,the,interval,between,refresh,checks,note,that,a,refresh,attempt,will,first,check,the,last,modified,timestamp,of,the,file,before,actually,reloading,it,so,if,files,don,t,change,this,interval,can,be,set,rather,low,as,refresh,attempts,will,not,actually,reload,li,a,value,of,0,will,check,the,last,modified,timestamp,of,the,file,on,every,message,access,b,do,not,use,this,in,a,production,environment,b,ul;public,void,set,cache,seconds,int,cache,seconds,this,cache,millis,cache,seconds,1000
ReloadableResourceBundleMessageSource -> public void setCacheSeconds(int cacheSeconds);1410958822;Set the number of seconds to cache loaded properties files._<ul>_<li>Default is "-1", indicating to cache forever (just like_{@code java.util.ResourceBundle})._<li>A positive number will cache loaded properties files for the given_number of seconds. This is essentially the interval between refresh checks._Note that a refresh attempt will first check the last-modified timestamp_of the file before actually reloading it_ so if files don't change, this_interval can be set rather low, as refresh attempts will not actually reload._<li>A value of "0" will check the last-modified timestamp of the file on_every message access. <b>Do not use this in a production environment!</b>_</ul>;public void setCacheSeconds(int cacheSeconds) {_		this.cacheMillis = (cacheSeconds * 1000)__	};set,the,number,of,seconds,to,cache,loaded,properties,files,ul,li,default,is,1,indicating,to,cache,forever,just,like,code,java,util,resource,bundle,li,a,positive,number,will,cache,loaded,properties,files,for,the,given,number,of,seconds,this,is,essentially,the,interval,between,refresh,checks,note,that,a,refresh,attempt,will,first,check,the,last,modified,timestamp,of,the,file,before,actually,reloading,it,so,if,files,don,t,change,this,interval,can,be,set,rather,low,as,refresh,attempts,will,not,actually,reload,li,a,value,of,0,will,check,the,last,modified,timestamp,of,the,file,on,every,message,access,b,do,not,use,this,in,a,production,environment,b,ul;public,void,set,cache,seconds,int,cache,seconds,this,cache,millis,cache,seconds,1000
ReloadableResourceBundleMessageSource -> public void setCacheSeconds(int cacheSeconds);1425660337;Set the number of seconds to cache loaded properties files._<ul>_<li>Default is "-1", indicating to cache forever (just like_{@code java.util.ResourceBundle})._<li>A positive number will cache loaded properties files for the given_number of seconds. This is essentially the interval between refresh checks._Note that a refresh attempt will first check the last-modified timestamp_of the file before actually reloading it_ so if files don't change, this_interval can be set rather low, as refresh attempts will not actually reload._<li>A value of "0" will check the last-modified timestamp of the file on_every message access. <b>Do not use this in a production environment!</b>_</ul>;public void setCacheSeconds(int cacheSeconds) {_		this.cacheMillis = (cacheSeconds * 1000)__	};set,the,number,of,seconds,to,cache,loaded,properties,files,ul,li,default,is,1,indicating,to,cache,forever,just,like,code,java,util,resource,bundle,li,a,positive,number,will,cache,loaded,properties,files,for,the,given,number,of,seconds,this,is,essentially,the,interval,between,refresh,checks,note,that,a,refresh,attempt,will,first,check,the,last,modified,timestamp,of,the,file,before,actually,reloading,it,so,if,files,don,t,change,this,interval,can,be,set,rather,low,as,refresh,attempts,will,not,actually,reload,li,a,value,of,0,will,check,the,last,modified,timestamp,of,the,file,on,every,message,access,b,do,not,use,this,in,a,production,environment,b,ul;public,void,set,cache,seconds,int,cache,seconds,this,cache,millis,cache,seconds,1000
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(ResourceLoader resourceLoader);1356735495;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(ResourceLoader resourceLoader);1368482696;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(ResourceLoader resourceLoader);1385412762;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(ResourceLoader resourceLoader);1408623868;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(ResourceLoader resourceLoader);1410958822;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(ResourceLoader resourceLoader);1425660337;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(ResourceLoader resourceLoader);1454612260;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(ResourceLoader resourceLoader);1454617957;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(ResourceLoader resourceLoader);1467730834;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(ResourceLoader resourceLoader);1478179664;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	public void setResourceLoader(ResourceLoader resourceLoader);1495868221;Set the ResourceLoader to use for loading bundle properties files._<p>The default is a DefaultResourceLoader. Will get overridden by the_ApplicationContext if running in a context, as it implements the_ResourceLoaderAware interface. Can be manually overridden when_running outside of an ApplicationContext._@see org.springframework.core.io.DefaultResourceLoader_@see org.springframework.context.ResourceLoaderAware;@Override_	public void setResourceLoader(ResourceLoader resourceLoader) {_		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader())__	};set,the,resource,loader,to,use,for,loading,bundle,properties,files,p,the,default,is,a,default,resource,loader,will,get,overridden,by,the,application,context,if,running,in,a,context,as,it,implements,the,resource,loader,aware,interface,can,be,manually,overridden,when,running,outside,of,an,application,context,see,org,springframework,core,io,default,resource,loader,see,org,springframework,context,resource,loader,aware;override,public,void,set,resource,loader,resource,loader,resource,loader,this,resource,loader,resource,loader,null,resource,loader,new,default,resource,loader
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1328020251;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1329142650;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1348671314;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1356735495;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1357119239;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1368482696;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1385412762;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1408623868;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1410958822;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1425660337;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (this.cacheMillis < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : this.basenames) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,this,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,this,basenames,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1454612260;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1454617957;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1467730834;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1478179664;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1495868221;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1496259743;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1496837955;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> @Override 	protected MessageFormat resolveCode(String code, Locale locale);1498780456;Resolves the given message code as key in the retrieved bundle files,_using a cached MessageFormat instance per message code.;@Override_	protected MessageFormat resolveCode(String code, Locale locale) {_		if (getCacheMillis() < 0) {_			PropertiesHolder propHolder = getMergedProperties(locale)__			MessageFormat result = propHolder.getMessageFormat(code, locale)__			if (result != null) {_				return result__			}_		}_		else {_			for (String basename : getBasenameSet()) {_				List<String> filenames = calculateAllFilenames(basename, locale)__				for (String filename : filenames) {_					PropertiesHolder propHolder = getProperties(filename)__					MessageFormat result = propHolder.getMessageFormat(code, locale)__					if (result != null) {_						return result__					}_				}_			}_		}_		return null__	};resolves,the,given,message,code,as,key,in,the,retrieved,bundle,files,using,a,cached,message,format,instance,per,message,code;override,protected,message,format,resolve,code,string,code,locale,locale,if,get,cache,millis,0,properties,holder,prop,holder,get,merged,properties,locale,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,else,for,string,basename,get,basename,set,list,string,filenames,calculate,all,filenames,basename,locale,for,string,filename,filenames,properties,holder,prop,holder,get,properties,filename,message,format,result,prop,holder,get,message,format,code,locale,if,result,null,return,result,return,null
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1328020251;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1329142650;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1348671314;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1356735495;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1357119239;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1368482696;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1385412762;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1408623868;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1410958822;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1425660337;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1454612260;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1454617957;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1467730834;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1478179664;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1495868221;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setPropertiesPersister(PropertiesPersister propertiesPersister);1496259743;Set the PropertiesPersister to use for parsing properties files._<p>The default is a DefaultPropertiesPersister._@see org.springframework.util.DefaultPropertiesPersister;public void setPropertiesPersister(PropertiesPersister propertiesPersister) {_		this.propertiesPersister =_				(propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister())__	};set,the,properties,persister,to,use,for,parsing,properties,files,p,the,default,is,a,default,properties,persister,see,org,springframework,util,default,properties,persister;public,void,set,properties,persister,properties,persister,properties,persister,this,properties,persister,properties,persister,null,properties,persister,new,default,properties,persister
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1408623868;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": This behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1410958822;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": This behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1425660337;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": This behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1454612260;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": This behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1454617957;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1467730834;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1478179664;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1495868221;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1496259743;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1496837955;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1498780456;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1502974979;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1515532822;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1516393837;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1518167602;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> public void setConcurrentRefresh(boolean concurrentRefresh);1530174524;Specify whether to allow for concurrent refresh behavior, i.e. one thread_locked in a refresh attempt for a specific cached properties file whereas_other threads keep returning the old properties for the time being, until_the refresh attempt has completed._<p>Default is "true": this behavior is new as of Spring Framework 4.1,_minimizing contention between threads. If you prefer the old behavior,_i.e. to fully block on refresh, switch this flag to "false"._@since 4.1_@see #setCacheSeconds;public void setConcurrentRefresh(boolean concurrentRefresh) {_		this.concurrentRefresh = concurrentRefresh__	};specify,whether,to,allow,for,concurrent,refresh,behavior,i,e,one,thread,locked,in,a,refresh,attempt,for,a,specific,cached,properties,file,whereas,other,threads,keep,returning,the,old,properties,for,the,time,being,until,the,refresh,attempt,has,completed,p,default,is,true,this,behavior,is,new,as,of,spring,framework,4,1,minimizing,contention,between,threads,if,you,prefer,the,old,behavior,i,e,to,fully,block,on,refresh,switch,this,flag,to,false,since,4,1,see,set,cache,seconds;public,void,set,concurrent,refresh,boolean,concurrent,refresh,this,concurrent,refresh,concurrent,refresh
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1328020251;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		synchronized (this.cachedProperties) {_			PropertiesHolder propHolder = this.cachedProperties.get(filename)__			if (propHolder != null &&_					(propHolder.getRefreshTimestamp() < 0 ||_					 propHolder.getRefreshTimestamp() > System.currentTimeMillis() - this.cacheMillis)) {_				_				return propHolder__			}_			return refreshProperties(filename, propHolder)__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,synchronized,this,cached,properties,properties,holder,prop,holder,this,cached,properties,get,filename,if,prop,holder,null,prop,holder,get,refresh,timestamp,0,prop,holder,get,refresh,timestamp,system,current,time,millis,this,cache,millis,return,prop,holder,return,refresh,properties,filename,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1329142650;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		synchronized (this.cachedProperties) {_			PropertiesHolder propHolder = this.cachedProperties.get(filename)__			if (propHolder != null &&_					(propHolder.getRefreshTimestamp() < 0 ||_					 propHolder.getRefreshTimestamp() > System.currentTimeMillis() - this.cacheMillis)) {_				_				return propHolder__			}_			return refreshProperties(filename, propHolder)__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,synchronized,this,cached,properties,properties,holder,prop,holder,this,cached,properties,get,filename,if,prop,holder,null,prop,holder,get,refresh,timestamp,0,prop,holder,get,refresh,timestamp,system,current,time,millis,this,cache,millis,return,prop,holder,return,refresh,properties,filename,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1348671314;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		synchronized (this.cachedProperties) {_			PropertiesHolder propHolder = this.cachedProperties.get(filename)__			if (propHolder != null &&_					(propHolder.getRefreshTimestamp() < 0 ||_					 propHolder.getRefreshTimestamp() > System.currentTimeMillis() - this.cacheMillis)) {_				_				return propHolder__			}_			return refreshProperties(filename, propHolder)__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,synchronized,this,cached,properties,properties,holder,prop,holder,this,cached,properties,get,filename,if,prop,holder,null,prop,holder,get,refresh,timestamp,0,prop,holder,get,refresh,timestamp,system,current,time,millis,this,cache,millis,return,prop,holder,return,refresh,properties,filename,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1356735495;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		synchronized (this.cachedProperties) {_			PropertiesHolder propHolder = this.cachedProperties.get(filename)__			if (propHolder != null &&_					(propHolder.getRefreshTimestamp() < 0 ||_					 propHolder.getRefreshTimestamp() > System.currentTimeMillis() - this.cacheMillis)) {_				_				return propHolder__			}_			return refreshProperties(filename, propHolder)__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,synchronized,this,cached,properties,properties,holder,prop,holder,this,cached,properties,get,filename,if,prop,holder,null,prop,holder,get,refresh,timestamp,0,prop,holder,get,refresh,timestamp,system,current,time,millis,this,cache,millis,return,prop,holder,return,refresh,properties,filename,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1357119239;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		synchronized (this.cachedProperties) {_			PropertiesHolder propHolder = this.cachedProperties.get(filename)__			if (propHolder != null &&_					(propHolder.getRefreshTimestamp() < 0 ||_					 propHolder.getRefreshTimestamp() > System.currentTimeMillis() - this.cacheMillis)) {_				_				return propHolder__			}_			return refreshProperties(filename, propHolder)__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,synchronized,this,cached,properties,properties,holder,prop,holder,this,cached,properties,get,filename,if,prop,holder,null,prop,holder,get,refresh,timestamp,0,prop,holder,get,refresh,timestamp,system,current,time,millis,this,cache,millis,return,prop,holder,return,refresh,properties,filename,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1368482696;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		synchronized (this.cachedProperties) {_			PropertiesHolder propHolder = this.cachedProperties.get(filename)__			if (propHolder != null &&_					(propHolder.getRefreshTimestamp() < 0 ||_					 propHolder.getRefreshTimestamp() > System.currentTimeMillis() - this.cacheMillis)) {_				_				return propHolder__			}_			return refreshProperties(filename, propHolder)__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,synchronized,this,cached,properties,properties,holder,prop,holder,this,cached,properties,get,filename,if,prop,holder,null,prop,holder,get,refresh,timestamp,0,prop,holder,get,refresh,timestamp,system,current,time,millis,this,cache,millis,return,prop,holder,return,refresh,properties,filename,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1385412762;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		synchronized (this.cachedProperties) {_			PropertiesHolder propHolder = this.cachedProperties.get(filename)__			if (propHolder != null &&_					(propHolder.getRefreshTimestamp() < 0 ||_					 propHolder.getRefreshTimestamp() > System.currentTimeMillis() - this.cacheMillis)) {_				_				return propHolder__			}_			return refreshProperties(filename, propHolder)__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,synchronized,this,cached,properties,properties,holder,prop,holder,this,cached,properties,get,filename,if,prop,holder,null,prop,holder,get,refresh,timestamp,0,prop,holder,get,refresh,timestamp,system,current,time,millis,this,cache,millis,return,prop,holder,return,refresh,properties,filename,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1408623868;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -1___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp < 0 || originalTimestamp > System.currentTimeMillis() - this.cacheMillis) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,1,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,0,original,timestamp,system,current,time,millis,this,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1410958822;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - this.cacheMillis) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,this,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1425660337;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - this.cacheMillis) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,this,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1454612260;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1454617957;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1467730834;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1478179664;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1495868221;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1496259743;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1496837955;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1498780456;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1502974979;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1515532822;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1516393837;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1518167602;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getProperties(String filename);1530174524;Get a PropertiesHolder for the given filename, either from the_cache or freshly loaded._@param filename the bundle filename (basename + Locale)_@return the current PropertiesHolder for the bundle;protected PropertiesHolder getProperties(String filename) {_		PropertiesHolder propHolder = this.cachedProperties.get(filename)__		long originalTimestamp = -2___		if (propHolder != null) {_			originalTimestamp = propHolder.getRefreshTimestamp()__			if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {_				_				return propHolder__			}_		}_		else {_			propHolder = new PropertiesHolder()__			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder)__			if (existingHolder != null) {_				propHolder = existingHolder__			}_		}__		_		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {_			_			if (!propHolder.refreshLock.tryLock()) {_				_				_				return propHolder__			}_		}_		else {_			propHolder.refreshLock.lock()__		}_		try {_			PropertiesHolder existingHolder = this.cachedProperties.get(filename)__			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {_				return existingHolder__			}_			return refreshProperties(filename, propHolder)__		}_		finally {_			propHolder.refreshLock.unlock()__		}_	};get,a,properties,holder,for,the,given,filename,either,from,the,cache,or,freshly,loaded,param,filename,the,bundle,filename,basename,locale,return,the,current,properties,holder,for,the,bundle;protected,properties,holder,get,properties,string,filename,properties,holder,prop,holder,this,cached,properties,get,filename,long,original,timestamp,2,if,prop,holder,null,original,timestamp,prop,holder,get,refresh,timestamp,if,original,timestamp,1,original,timestamp,system,current,time,millis,get,cache,millis,return,prop,holder,else,prop,holder,new,properties,holder,properties,holder,existing,holder,this,cached,properties,put,if,absent,filename,prop,holder,if,existing,holder,null,prop,holder,existing,holder,if,this,concurrent,refresh,prop,holder,get,refresh,timestamp,0,if,prop,holder,refresh,lock,try,lock,return,prop,holder,else,prop,holder,refresh,lock,lock,try,properties,holder,existing,holder,this,cached,properties,get,filename,if,existing,holder,null,existing,holder,get,refresh,timestamp,original,timestamp,return,existing,holder,return,refresh,properties,filename,prop,holder,finally,prop,holder,refresh,lock,unlock
ReloadableResourceBundleMessageSource -> public void clearCache();1328020251;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		synchronized (this.cachedProperties) {_			this.cachedProperties.clear()__		}_		synchronized (this.cachedMergedProperties) {_			this.cachedMergedProperties.clear()__		}_	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,synchronized,this,cached,properties,this,cached,properties,clear,synchronized,this,cached,merged,properties,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1329142650;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		synchronized (this.cachedProperties) {_			this.cachedProperties.clear()__		}_		synchronized (this.cachedMergedProperties) {_			this.cachedMergedProperties.clear()__		}_	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,synchronized,this,cached,properties,this,cached,properties,clear,synchronized,this,cached,merged,properties,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1348671314;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		synchronized (this.cachedProperties) {_			this.cachedProperties.clear()__		}_		synchronized (this.cachedMergedProperties) {_			this.cachedMergedProperties.clear()__		}_	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,synchronized,this,cached,properties,this,cached,properties,clear,synchronized,this,cached,merged,properties,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1356735495;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		synchronized (this.cachedProperties) {_			this.cachedProperties.clear()__		}_		synchronized (this.cachedMergedProperties) {_			this.cachedMergedProperties.clear()__		}_	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,synchronized,this,cached,properties,this,cached,properties,clear,synchronized,this,cached,merged,properties,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1357119239;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		synchronized (this.cachedProperties) {_			this.cachedProperties.clear()__		}_		synchronized (this.cachedMergedProperties) {_			this.cachedMergedProperties.clear()__		}_	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,synchronized,this,cached,properties,this,cached,properties,clear,synchronized,this,cached,merged,properties,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1368482696;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		synchronized (this.cachedProperties) {_			this.cachedProperties.clear()__		}_		synchronized (this.cachedMergedProperties) {_			this.cachedMergedProperties.clear()__		}_	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,synchronized,this,cached,properties,this,cached,properties,clear,synchronized,this,cached,merged,properties,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1385412762;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		synchronized (this.cachedProperties) {_			this.cachedProperties.clear()__		}_		synchronized (this.cachedMergedProperties) {_			this.cachedMergedProperties.clear()__		}_	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,synchronized,this,cached,properties,this,cached,properties,clear,synchronized,this,cached,merged,properties,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1408623868;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1410958822;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1425660337;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1454612260;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1454617957;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1467730834;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1478179664;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1495868221;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1496259743;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1496837955;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1498780456;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1502974979;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1515532822;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1516393837;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1518167602;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> public void clearCache();1530174524;Clear the resource bundle cache._Subsequent resolve calls will lead to reloading of the properties files.;public void clearCache() {_		logger.debug("Clearing entire resource bundle cache")__		this.cachedProperties.clear()__		this.cachedMergedProperties.clear()__	};clear,the,resource,bundle,cache,subsequent,resolve,calls,will,lead,to,reloading,of,the,properties,files;public,void,clear,cache,logger,debug,clearing,entire,resource,bundle,cache,this,cached,properties,clear,this,cached,merged,properties,clear
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1328020251;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1329142650;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1348671314;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1356735495;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1357119239;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1368482696;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1385412762;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1408623868;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1410958822;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1425660337;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1454612260;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1454617957;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<String>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,string,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1467730834;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1478179664;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1495868221;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1496259743;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1496837955;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1498780456;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1502974979;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1515532822;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1516393837;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1518167602;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> protected List<String> calculateFilenamesForLocale(String basename, Locale locale);1530174524;Calculate the filenames for the given bundle basename and Locale,_appending language code, country code, and variant code._E.g.: basename "messages", Locale "de_AT_oo" -> "messages_de_AT_OO",_"messages_de_AT", "messages_de"._<p>Follows the rules defined by {@link java.util.Locale#toString()}._@param basename the basename of the bundle_@param locale the locale_@return the List of filenames to check;protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {_		List<String> result = new ArrayList<>(3)__		String language = locale.getLanguage()__		String country = locale.getCountry()__		String variant = locale.getVariant()__		StringBuilder temp = new StringBuilder(basename)___		temp.append('_')__		if (language.length() > 0) {_			temp.append(language)__			result.add(0, temp.toString())__		}__		temp.append('_')__		if (country.length() > 0) {_			temp.append(country)__			result.add(0, temp.toString())__		}__		if (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {_			temp.append('_').append(variant)__			result.add(0, temp.toString())__		}__		return result__	};calculate,the,filenames,for,the,given,bundle,basename,and,locale,appending,language,code,country,code,and,variant,code,e,g,basename,messages,locale,p,follows,the,rules,defined,by,link,java,util,locale,to,string,param,basename,the,basename,of,the,bundle,param,locale,the,locale,return,the,list,of,filenames,to,check;protected,list,string,calculate,filenames,for,locale,string,basename,locale,locale,list,string,result,new,array,list,3,string,language,locale,get,language,string,country,locale,get,country,string,variant,locale,get,variant,string,builder,temp,new,string,builder,basename,temp,append,if,language,length,0,temp,append,language,result,add,0,temp,to,string,temp,append,if,country,length,0,temp,append,country,result,add,0,temp,to,string,if,variant,length,0,language,length,0,country,length,0,temp,append,append,variant,result,add,0,temp,to,string,return,result
ReloadableResourceBundleMessageSource -> public void setBasenames(String... basenames);1329142650;Set an array of basenames, each following the basic ResourceBundle convention_of not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._<p>The associated resource bundles will be checked sequentially when resolving_a message code. Note that message definitions in a <i>previous</i> resource_bundle will override ones in a later bundle, due to the sequential lookup._@param basenames an array of basenames_@see #setBasename_@see java.util.ResourceBundle;public void setBasenames(String... basenames) {_		if (basenames != null) {_			this.basenames = new String[basenames.length]__			for (int i = 0_ i < basenames.length_ i++) {_				String basename = basenames[i]__				Assert.hasText(basename, "Basename must not be empty")__				this.basenames[i] = basename.trim()__			}_		}_		else {_			this.basenames = new String[0]__		}_	};set,an,array,of,basenames,each,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,p,the,associated,resource,bundles,will,be,checked,sequentially,when,resolving,a,message,code,note,that,message,definitions,in,a,i,previous,i,resource,bundle,will,override,ones,in,a,later,bundle,due,to,the,sequential,lookup,param,basenames,an,array,of,basenames,see,set,basename,see,java,util,resource,bundle;public,void,set,basenames,string,basenames,if,basenames,null,this,basenames,new,string,basenames,length,for,int,i,0,i,basenames,length,i,string,basename,basenames,i,assert,has,text,basename,basename,must,not,be,empty,this,basenames,i,basename,trim,else,this,basenames,new,string,0
ReloadableResourceBundleMessageSource -> public void setBasenames(String... basenames);1348671314;Set an array of basenames, each following the basic ResourceBundle convention_of not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._<p>The associated resource bundles will be checked sequentially when resolving_a message code. Note that message definitions in a <i>previous</i> resource_bundle will override ones in a later bundle, due to the sequential lookup._@param basenames an array of basenames_@see #setBasename_@see java.util.ResourceBundle;public void setBasenames(String... basenames) {_		if (basenames != null) {_			this.basenames = new String[basenames.length]__			for (int i = 0_ i < basenames.length_ i++) {_				String basename = basenames[i]__				Assert.hasText(basename, "Basename must not be empty")__				this.basenames[i] = basename.trim()__			}_		}_		else {_			this.basenames = new String[0]__		}_	};set,an,array,of,basenames,each,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,p,the,associated,resource,bundles,will,be,checked,sequentially,when,resolving,a,message,code,note,that,message,definitions,in,a,i,previous,i,resource,bundle,will,override,ones,in,a,later,bundle,due,to,the,sequential,lookup,param,basenames,an,array,of,basenames,see,set,basename,see,java,util,resource,bundle;public,void,set,basenames,string,basenames,if,basenames,null,this,basenames,new,string,basenames,length,for,int,i,0,i,basenames,length,i,string,basename,basenames,i,assert,has,text,basename,basename,must,not,be,empty,this,basenames,i,basename,trim,else,this,basenames,new,string,0
ReloadableResourceBundleMessageSource -> public void setBasenames(String... basenames);1356735495;Set an array of basenames, each following the basic ResourceBundle convention_of not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._<p>The associated resource bundles will be checked sequentially when resolving_a message code. Note that message definitions in a <i>previous</i> resource_bundle will override ones in a later bundle, due to the sequential lookup._@param basenames an array of basenames_@see #setBasename_@see java.util.ResourceBundle;public void setBasenames(String... basenames) {_		if (basenames != null) {_			this.basenames = new String[basenames.length]__			for (int i = 0_ i < basenames.length_ i++) {_				String basename = basenames[i]__				Assert.hasText(basename, "Basename must not be empty")__				this.basenames[i] = basename.trim()__			}_		}_		else {_			this.basenames = new String[0]__		}_	};set,an,array,of,basenames,each,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,p,the,associated,resource,bundles,will,be,checked,sequentially,when,resolving,a,message,code,note,that,message,definitions,in,a,i,previous,i,resource,bundle,will,override,ones,in,a,later,bundle,due,to,the,sequential,lookup,param,basenames,an,array,of,basenames,see,set,basename,see,java,util,resource,bundle;public,void,set,basenames,string,basenames,if,basenames,null,this,basenames,new,string,basenames,length,for,int,i,0,i,basenames,length,i,string,basename,basenames,i,assert,has,text,basename,basename,must,not,be,empty,this,basenames,i,basename,trim,else,this,basenames,new,string,0
ReloadableResourceBundleMessageSource -> public void setBasenames(String... basenames);1357119239;Set an array of basenames, each following the basic ResourceBundle convention_of not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._<p>The associated resource bundles will be checked sequentially when resolving_a message code. Note that message definitions in a <i>previous</i> resource_bundle will override ones in a later bundle, due to the sequential lookup._@param basenames an array of basenames_@see #setBasename_@see java.util.ResourceBundle;public void setBasenames(String... basenames) {_		if (basenames != null) {_			this.basenames = new String[basenames.length]__			for (int i = 0_ i < basenames.length_ i++) {_				String basename = basenames[i]__				Assert.hasText(basename, "Basename must not be empty")__				this.basenames[i] = basename.trim()__			}_		}_		else {_			this.basenames = new String[0]__		}_	};set,an,array,of,basenames,each,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,p,the,associated,resource,bundles,will,be,checked,sequentially,when,resolving,a,message,code,note,that,message,definitions,in,a,i,previous,i,resource,bundle,will,override,ones,in,a,later,bundle,due,to,the,sequential,lookup,param,basenames,an,array,of,basenames,see,set,basename,see,java,util,resource,bundle;public,void,set,basenames,string,basenames,if,basenames,null,this,basenames,new,string,basenames,length,for,int,i,0,i,basenames,length,i,string,basename,basenames,i,assert,has,text,basename,basename,must,not,be,empty,this,basenames,i,basename,trim,else,this,basenames,new,string,0
ReloadableResourceBundleMessageSource -> public void setBasenames(String... basenames);1368482696;Set an array of basenames, each following the basic ResourceBundle convention_of not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._<p>The associated resource bundles will be checked sequentially when resolving_a message code. Note that message definitions in a <i>previous</i> resource_bundle will override ones in a later bundle, due to the sequential lookup._@param basenames an array of basenames_@see #setBasename_@see java.util.ResourceBundle;public void setBasenames(String... basenames) {_		if (basenames != null) {_			this.basenames = new String[basenames.length]__			for (int i = 0_ i < basenames.length_ i++) {_				String basename = basenames[i]__				Assert.hasText(basename, "Basename must not be empty")__				this.basenames[i] = basename.trim()__			}_		}_		else {_			this.basenames = new String[0]__		}_	};set,an,array,of,basenames,each,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,p,the,associated,resource,bundles,will,be,checked,sequentially,when,resolving,a,message,code,note,that,message,definitions,in,a,i,previous,i,resource,bundle,will,override,ones,in,a,later,bundle,due,to,the,sequential,lookup,param,basenames,an,array,of,basenames,see,set,basename,see,java,util,resource,bundle;public,void,set,basenames,string,basenames,if,basenames,null,this,basenames,new,string,basenames,length,for,int,i,0,i,basenames,length,i,string,basename,basenames,i,assert,has,text,basename,basename,must,not,be,empty,this,basenames,i,basename,trim,else,this,basenames,new,string,0
ReloadableResourceBundleMessageSource -> public void setBasenames(String... basenames);1385412762;Set an array of basenames, each following the basic ResourceBundle convention_of not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._<p>The associated resource bundles will be checked sequentially when resolving_a message code. Note that message definitions in a <i>previous</i> resource_bundle will override ones in a later bundle, due to the sequential lookup._@param basenames an array of basenames_@see #setBasename_@see java.util.ResourceBundle;public void setBasenames(String... basenames) {_		if (basenames != null) {_			this.basenames = new String[basenames.length]__			for (int i = 0_ i < basenames.length_ i++) {_				String basename = basenames[i]__				Assert.hasText(basename, "Basename must not be empty")__				this.basenames[i] = basename.trim()__			}_		}_		else {_			this.basenames = new String[0]__		}_	};set,an,array,of,basenames,each,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,p,the,associated,resource,bundles,will,be,checked,sequentially,when,resolving,a,message,code,note,that,message,definitions,in,a,i,previous,i,resource,bundle,will,override,ones,in,a,later,bundle,due,to,the,sequential,lookup,param,basenames,an,array,of,basenames,see,set,basename,see,java,util,resource,bundle;public,void,set,basenames,string,basenames,if,basenames,null,this,basenames,new,string,basenames,length,for,int,i,0,i,basenames,length,i,string,basename,basenames,i,assert,has,text,basename,basename,must,not,be,empty,this,basenames,i,basename,trim,else,this,basenames,new,string,0
ReloadableResourceBundleMessageSource -> public void setBasenames(String... basenames);1408623868;Set an array of basenames, each following the basic ResourceBundle convention_of not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._<p>The associated resource bundles will be checked sequentially when resolving_a message code. Note that message definitions in a <i>previous</i> resource_bundle will override ones in a later bundle, due to the sequential lookup._@param basenames an array of basenames_@see #setBasename_@see java.util.ResourceBundle;public void setBasenames(String... basenames) {_		if (basenames != null) {_			this.basenames = new String[basenames.length]__			for (int i = 0_ i < basenames.length_ i++) {_				String basename = basenames[i]__				Assert.hasText(basename, "Basename must not be empty")__				this.basenames[i] = basename.trim()__			}_		}_		else {_			this.basenames = new String[0]__		}_	};set,an,array,of,basenames,each,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,p,the,associated,resource,bundles,will,be,checked,sequentially,when,resolving,a,message,code,note,that,message,definitions,in,a,i,previous,i,resource,bundle,will,override,ones,in,a,later,bundle,due,to,the,sequential,lookup,param,basenames,an,array,of,basenames,see,set,basename,see,java,util,resource,bundle;public,void,set,basenames,string,basenames,if,basenames,null,this,basenames,new,string,basenames,length,for,int,i,0,i,basenames,length,i,string,basename,basenames,i,assert,has,text,basename,basename,must,not,be,empty,this,basenames,i,basename,trim,else,this,basenames,new,string,0
ReloadableResourceBundleMessageSource -> public void setBasenames(String... basenames);1410958822;Set an array of basenames, each following the basic ResourceBundle convention_of not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._<p>The associated resource bundles will be checked sequentially when resolving_a message code. Note that message definitions in a <i>previous</i> resource_bundle will override ones in a later bundle, due to the sequential lookup._@param basenames an array of basenames_@see #setBasename_@see java.util.ResourceBundle;public void setBasenames(String... basenames) {_		if (basenames != null) {_			this.basenames = new String[basenames.length]__			for (int i = 0_ i < basenames.length_ i++) {_				String basename = basenames[i]__				Assert.hasText(basename, "Basename must not be empty")__				this.basenames[i] = basename.trim()__			}_		}_		else {_			this.basenames = new String[0]__		}_	};set,an,array,of,basenames,each,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,p,the,associated,resource,bundles,will,be,checked,sequentially,when,resolving,a,message,code,note,that,message,definitions,in,a,i,previous,i,resource,bundle,will,override,ones,in,a,later,bundle,due,to,the,sequential,lookup,param,basenames,an,array,of,basenames,see,set,basename,see,java,util,resource,bundle;public,void,set,basenames,string,basenames,if,basenames,null,this,basenames,new,string,basenames,length,for,int,i,0,i,basenames,length,i,string,basename,basenames,i,assert,has,text,basename,basename,must,not,be,empty,this,basenames,i,basename,trim,else,this,basenames,new,string,0
ReloadableResourceBundleMessageSource -> public void setBasenames(String... basenames);1425660337;Set an array of basenames, each following the basic ResourceBundle convention_of not specifying file extension or language codes, but in contrast to_{@link ResourceBundleMessageSource} referring to a Spring resource location:_e.g. "WEB-INF/messages" for "WEB-INF/messages.properties",_"WEB-INF/messages_en.properties", etc._<p>XML properties files are also supported: .g. "WEB-INF/messages" will find_and load "WEB-INF/messages.xml", "WEB-INF/messages_en.xml", etc as well._<p>The associated resource bundles will be checked sequentially when resolving_a message code. Note that message definitions in a <i>previous</i> resource_bundle will override ones in a later bundle, due to the sequential lookup._@param basenames an array of basenames_@see #setBasename_@see java.util.ResourceBundle;public void setBasenames(String... basenames) {_		if (basenames != null) {_			this.basenames = new String[basenames.length]__			for (int i = 0_ i < basenames.length_ i++) {_				String basename = basenames[i]__				Assert.hasText(basename, "Basename must not be empty")__				this.basenames[i] = basename.trim()__			}_		}_		else {_			this.basenames = new String[0]__		}_	};set,an,array,of,basenames,each,following,the,basic,resource,bundle,convention,of,not,specifying,file,extension,or,language,codes,but,in,contrast,to,link,resource,bundle,message,source,referring,to,a,spring,resource,location,e,g,web,inf,messages,for,web,inf,messages,properties,web,inf,properties,etc,p,xml,properties,files,are,also,supported,g,web,inf,messages,will,find,and,load,web,inf,messages,xml,web,inf,xml,etc,as,well,p,the,associated,resource,bundles,will,be,checked,sequentially,when,resolving,a,message,code,note,that,message,definitions,in,a,i,previous,i,resource,bundle,will,override,ones,in,a,later,bundle,due,to,the,sequential,lookup,param,basenames,an,array,of,basenames,see,set,basename,see,java,util,resource,bundle;public,void,set,basenames,string,basenames,if,basenames,null,this,basenames,new,string,basenames,length,for,int,i,0,i,basenames,length,i,string,basename,basenames,i,assert,has,text,basename,basename,must,not,be,empty,this,basenames,i,basename,trim,else,this,basenames,new,string,0
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder);1495868221;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,nullable,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder);1496259743;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,nullable,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder);1496837955;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,nullable,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder);1498780456;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,nullable,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder);1502974979;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,nullable,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder);1515532822;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,nullable,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder);1516393837;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,nullable,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder);1518167602;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,nullable,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder);1530174524;Refresh the PropertiesHolder for the given bundle filename._The holder can be {@code null} if not cached before, or a timed-out cache entry_(potentially getting re-validated against the current last-modified timestamp)._@param filename the bundle filename (basename + Locale)_@param propHolder the current PropertiesHolder for the bundle;protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {_		long refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis())___		Resource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX)__		if (!resource.exists()) {_			resource = this.resourceLoader.getResource(filename + XML_SUFFIX)__		}__		if (resource.exists()) {_			long fileTimestamp = -1__			if (getCacheMillis() >= 0) {_				_				try {_					fileTimestamp = resource.lastModified()__					if (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {_						if (logger.isDebugEnabled()) {_							logger.debug("Re-caching properties for filename [" + filename + "] - file hasn't been modified")__						}_						propHolder.setRefreshTimestamp(refreshTimestamp)__						return propHolder__					}_				}_				catch (IOException ex) {_					_					if (logger.isDebugEnabled()) {_						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex)__					}_					fileTimestamp = -1__				}_			}_			try {_				Properties props = loadProperties(resource, filename)__				propHolder = new PropertiesHolder(props, fileTimestamp)__			}_			catch (IOException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Could not parse properties file [" + resource.getFilename() + "]", ex)__				}_				_				propHolder = new PropertiesHolder()__			}_		}__		else {_			_			if (logger.isDebugEnabled()) {_				logger.debug("No properties file found for [" + filename + "] - neither plain properties nor XML")__			}_			_			propHolder = new PropertiesHolder()__		}__		propHolder.setRefreshTimestamp(refreshTimestamp)__		this.cachedProperties.put(filename, propHolder)__		return propHolder__	};refresh,the,properties,holder,for,the,given,bundle,filename,the,holder,can,be,code,null,if,not,cached,before,or,a,timed,out,cache,entry,potentially,getting,re,validated,against,the,current,last,modified,timestamp,param,filename,the,bundle,filename,basename,locale,param,prop,holder,the,current,properties,holder,for,the,bundle;protected,properties,holder,refresh,properties,string,filename,nullable,properties,holder,prop,holder,long,refresh,timestamp,get,cache,millis,0,1,system,current,time,millis,resource,resource,this,resource,loader,get,resource,filename,if,resource,exists,resource,this,resource,loader,get,resource,filename,if,resource,exists,long,file,timestamp,1,if,get,cache,millis,0,try,file,timestamp,resource,last,modified,if,prop,holder,null,prop,holder,get,file,timestamp,file,timestamp,if,logger,is,debug,enabled,logger,debug,re,caching,properties,for,filename,filename,file,hasn,t,been,modified,prop,holder,set,refresh,timestamp,refresh,timestamp,return,prop,holder,catch,ioexception,ex,if,logger,is,debug,enabled,logger,debug,resource,could,not,be,resolved,in,the,file,system,assuming,that,it,hasn,t,changed,ex,file,timestamp,1,try,properties,props,load,properties,resource,filename,prop,holder,new,properties,holder,props,file,timestamp,catch,ioexception,ex,if,logger,is,warn,enabled,logger,warn,could,not,parse,properties,file,resource,get,filename,ex,prop,holder,new,properties,holder,else,if,logger,is,debug,enabled,logger,debug,no,properties,file,found,for,filename,neither,plain,properties,nor,xml,prop,holder,new,properties,holder,prop,holder,set,refresh,timestamp,refresh,timestamp,this,cached,properties,put,filename,prop,holder,return,prop,holder
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1425660337;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1454612260;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1454617957;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1467730834;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1478179664;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1495868221;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1496259743;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1496837955;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1498780456;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1502974979;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1515532822;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1516393837;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1518167602;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected Properties newProperties();1530174524;Template method for creating a plain new {@link Properties} instance._The default implementation simply calls {@link Properties#Properties()}._<p>Allows for returning a custom {@link Properties} extension in subclasses._Overriding methods should just instantiate a custom {@link Properties} subclass,_with no further initialization or population to be performed at that point._@return a plain Properties instance_@since 4.2;protected Properties newProperties() {_		return new Properties()__	};template,method,for,creating,a,plain,new,link,properties,instance,the,default,implementation,simply,calls,link,properties,properties,p,allows,for,returning,a,custom,link,properties,extension,in,subclasses,overriding,methods,should,just,instantiate,a,custom,link,properties,subclass,with,no,further,initialization,or,population,to,be,performed,at,that,point,return,a,plain,properties,instance,since,4,2;protected,properties,new,properties,return,new,properties
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1328020251;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		synchronized (this.cachedMergedProperties) {_			PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__			if (mergedHolder != null) {_				return mergedHolder__			}_			Properties mergedProps = new Properties()__			mergedHolder = new PropertiesHolder(mergedProps, -1)__			for (int i = this.basenames.length - 1_ i >= 0_ i--) {_				List filenames = calculateAllFilenames(this.basenames[i], locale)__				for (int j = filenames.size() - 1_ j >= 0_ j--) {_					String filename = (String) filenames.get(j)__					PropertiesHolder propHolder = getProperties(filename)__					if (propHolder.getProperties() != null) {_						mergedProps.putAll(propHolder.getProperties())__					}_				}_			}_			this.cachedMergedProperties.put(locale, mergedHolder)__			return mergedHolder__		}_	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,synchronized,this,cached,merged,properties,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,for,int,i,this,basenames,length,1,i,0,i,list,filenames,calculate,all,filenames,this,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,string,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,this,cached,merged,properties,put,locale,merged,holder,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1329142650;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		synchronized (this.cachedMergedProperties) {_			PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__			if (mergedHolder != null) {_				return mergedHolder__			}_			Properties mergedProps = new Properties()__			mergedHolder = new PropertiesHolder(mergedProps, -1)__			for (int i = this.basenames.length - 1_ i >= 0_ i--) {_				List filenames = calculateAllFilenames(this.basenames[i], locale)__				for (int j = filenames.size() - 1_ j >= 0_ j--) {_					String filename = (String) filenames.get(j)__					PropertiesHolder propHolder = getProperties(filename)__					if (propHolder.getProperties() != null) {_						mergedProps.putAll(propHolder.getProperties())__					}_				}_			}_			this.cachedMergedProperties.put(locale, mergedHolder)__			return mergedHolder__		}_	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,synchronized,this,cached,merged,properties,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,for,int,i,this,basenames,length,1,i,0,i,list,filenames,calculate,all,filenames,this,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,string,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,this,cached,merged,properties,put,locale,merged,holder,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1348671314;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		synchronized (this.cachedMergedProperties) {_			PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__			if (mergedHolder != null) {_				return mergedHolder__			}_			Properties mergedProps = new Properties()__			mergedHolder = new PropertiesHolder(mergedProps, -1)__			for (int i = this.basenames.length - 1_ i >= 0_ i--) {_				List filenames = calculateAllFilenames(this.basenames[i], locale)__				for (int j = filenames.size() - 1_ j >= 0_ j--) {_					String filename = (String) filenames.get(j)__					PropertiesHolder propHolder = getProperties(filename)__					if (propHolder.getProperties() != null) {_						mergedProps.putAll(propHolder.getProperties())__					}_				}_			}_			this.cachedMergedProperties.put(locale, mergedHolder)__			return mergedHolder__		}_	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,synchronized,this,cached,merged,properties,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,for,int,i,this,basenames,length,1,i,0,i,list,filenames,calculate,all,filenames,this,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,string,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,this,cached,merged,properties,put,locale,merged,holder,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1356735495;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		synchronized (this.cachedMergedProperties) {_			PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__			if (mergedHolder != null) {_				return mergedHolder__			}_			Properties mergedProps = new Properties()__			mergedHolder = new PropertiesHolder(mergedProps, -1)__			for (int i = this.basenames.length - 1_ i >= 0_ i--) {_				List filenames = calculateAllFilenames(this.basenames[i], locale)__				for (int j = filenames.size() - 1_ j >= 0_ j--) {_					String filename = (String) filenames.get(j)__					PropertiesHolder propHolder = getProperties(filename)__					if (propHolder.getProperties() != null) {_						mergedProps.putAll(propHolder.getProperties())__					}_				}_			}_			this.cachedMergedProperties.put(locale, mergedHolder)__			return mergedHolder__		}_	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,synchronized,this,cached,merged,properties,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,for,int,i,this,basenames,length,1,i,0,i,list,filenames,calculate,all,filenames,this,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,string,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,this,cached,merged,properties,put,locale,merged,holder,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1357119239;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		synchronized (this.cachedMergedProperties) {_			PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__			if (mergedHolder != null) {_				return mergedHolder__			}_			Properties mergedProps = new Properties()__			mergedHolder = new PropertiesHolder(mergedProps, -1)__			for (int i = this.basenames.length - 1_ i >= 0_ i--) {_				List filenames = calculateAllFilenames(this.basenames[i], locale)__				for (int j = filenames.size() - 1_ j >= 0_ j--) {_					String filename = (String) filenames.get(j)__					PropertiesHolder propHolder = getProperties(filename)__					if (propHolder.getProperties() != null) {_						mergedProps.putAll(propHolder.getProperties())__					}_				}_			}_			this.cachedMergedProperties.put(locale, mergedHolder)__			return mergedHolder__		}_	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,synchronized,this,cached,merged,properties,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,for,int,i,this,basenames,length,1,i,0,i,list,filenames,calculate,all,filenames,this,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,string,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,this,cached,merged,properties,put,locale,merged,holder,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1368482696;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		synchronized (this.cachedMergedProperties) {_			PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__			if (mergedHolder != null) {_				return mergedHolder__			}_			Properties mergedProps = new Properties()__			mergedHolder = new PropertiesHolder(mergedProps, -1)__			for (int i = this.basenames.length - 1_ i >= 0_ i--) {_				List filenames = calculateAllFilenames(this.basenames[i], locale)__				for (int j = filenames.size() - 1_ j >= 0_ j--) {_					String filename = (String) filenames.get(j)__					PropertiesHolder propHolder = getProperties(filename)__					if (propHolder.getProperties() != null) {_						mergedProps.putAll(propHolder.getProperties())__					}_				}_			}_			this.cachedMergedProperties.put(locale, mergedHolder)__			return mergedHolder__		}_	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,synchronized,this,cached,merged,properties,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,for,int,i,this,basenames,length,1,i,0,i,list,filenames,calculate,all,filenames,this,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,string,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,this,cached,merged,properties,put,locale,merged,holder,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1385412762;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		synchronized (this.cachedMergedProperties) {_			PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__			if (mergedHolder != null) {_				return mergedHolder__			}_			Properties mergedProps = new Properties()__			mergedHolder = new PropertiesHolder(mergedProps, -1)__			for (int i = this.basenames.length - 1_ i >= 0_ i--) {_				List<String> filenames = calculateAllFilenames(this.basenames[i], locale)__				for (int j = filenames.size() - 1_ j >= 0_ j--) {_					String filename = filenames.get(j)__					PropertiesHolder propHolder = getProperties(filename)__					if (propHolder.getProperties() != null) {_						mergedProps.putAll(propHolder.getProperties())__					}_				}_			}_			this.cachedMergedProperties.put(locale, mergedHolder)__			return mergedHolder__		}_	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,synchronized,this,cached,merged,properties,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,for,int,i,this,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,this,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,this,cached,merged,properties,put,locale,merged,holder,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1408623868;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = new Properties()__		mergedHolder = new PropertiesHolder(mergedProps, -1)__		for (int i = this.basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(this.basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__				}_			}_		}_		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,for,int,i,this,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,this,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1410958822;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = new Properties()__		mergedHolder = new PropertiesHolder(mergedProps, -1)__		for (int i = this.basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(this.basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__				}_			}_		}_		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,for,int,i,this,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,this,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1425660337;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		mergedHolder = new PropertiesHolder(mergedProps, -1)__		for (int i = this.basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(this.basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__				}_			}_		}_		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,for,int,i,this,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,this,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1454612260;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		mergedHolder = new PropertiesHolder(mergedProps, -1)__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__				}_			}_		}_		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1454617957;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		mergedHolder = new PropertiesHolder(mergedProps, -1)__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__				}_			}_		}_		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1467730834;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		mergedHolder = new PropertiesHolder(mergedProps, -1)__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__				}_			}_		}_		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,merged,holder,new,properties,holder,merged,props,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1478179664;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		long latestTimestamp = -1__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__					if (propHolder.getFileTimestamp() > latestTimestamp) {_						latestTimestamp = propHolder.getFileTimestamp()__					}_				}_			}_		}_		mergedHolder = new PropertiesHolder(mergedProps, latestTimestamp)__		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,long,latest,timestamp,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,if,prop,holder,get,file,timestamp,latest,timestamp,latest,timestamp,prop,holder,get,file,timestamp,merged,holder,new,properties,holder,merged,props,latest,timestamp,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1495868221;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		long latestTimestamp = -1__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__					if (propHolder.getFileTimestamp() > latestTimestamp) {_						latestTimestamp = propHolder.getFileTimestamp()__					}_				}_			}_		}_		mergedHolder = new PropertiesHolder(mergedProps, latestTimestamp)__		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,long,latest,timestamp,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,if,prop,holder,get,file,timestamp,latest,timestamp,latest,timestamp,prop,holder,get,file,timestamp,merged,holder,new,properties,holder,merged,props,latest,timestamp,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1496259743;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		long latestTimestamp = -1__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__					if (propHolder.getFileTimestamp() > latestTimestamp) {_						latestTimestamp = propHolder.getFileTimestamp()__					}_				}_			}_		}_		mergedHolder = new PropertiesHolder(mergedProps, latestTimestamp)__		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,long,latest,timestamp,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,if,prop,holder,get,file,timestamp,latest,timestamp,latest,timestamp,prop,holder,get,file,timestamp,merged,holder,new,properties,holder,merged,props,latest,timestamp,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1496837955;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		long latestTimestamp = -1__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__					if (propHolder.getFileTimestamp() > latestTimestamp) {_						latestTimestamp = propHolder.getFileTimestamp()__					}_				}_			}_		}_		mergedHolder = new PropertiesHolder(mergedProps, latestTimestamp)__		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,long,latest,timestamp,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,if,prop,holder,get,file,timestamp,latest,timestamp,latest,timestamp,prop,holder,get,file,timestamp,merged,holder,new,properties,holder,merged,props,latest,timestamp,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1498780456;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		long latestTimestamp = -1__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__					if (propHolder.getFileTimestamp() > latestTimestamp) {_						latestTimestamp = propHolder.getFileTimestamp()__					}_				}_			}_		}_		mergedHolder = new PropertiesHolder(mergedProps, latestTimestamp)__		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,long,latest,timestamp,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,if,prop,holder,get,file,timestamp,latest,timestamp,latest,timestamp,prop,holder,get,file,timestamp,merged,holder,new,properties,holder,merged,props,latest,timestamp,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1502974979;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		long latestTimestamp = -1__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__					if (propHolder.getFileTimestamp() > latestTimestamp) {_						latestTimestamp = propHolder.getFileTimestamp()__					}_				}_			}_		}_		mergedHolder = new PropertiesHolder(mergedProps, latestTimestamp)__		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,long,latest,timestamp,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,if,prop,holder,get,file,timestamp,latest,timestamp,latest,timestamp,prop,holder,get,file,timestamp,merged,holder,new,properties,holder,merged,props,latest,timestamp,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1515532822;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		long latestTimestamp = -1__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__					if (propHolder.getFileTimestamp() > latestTimestamp) {_						latestTimestamp = propHolder.getFileTimestamp()__					}_				}_			}_		}_		mergedHolder = new PropertiesHolder(mergedProps, latestTimestamp)__		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,long,latest,timestamp,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,if,prop,holder,get,file,timestamp,latest,timestamp,latest,timestamp,prop,holder,get,file,timestamp,merged,holder,new,properties,holder,merged,props,latest,timestamp,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1516393837;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		long latestTimestamp = -1__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__					if (propHolder.getFileTimestamp() > latestTimestamp) {_						latestTimestamp = propHolder.getFileTimestamp()__					}_				}_			}_		}_		mergedHolder = new PropertiesHolder(mergedProps, latestTimestamp)__		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,long,latest,timestamp,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,if,prop,holder,get,file,timestamp,latest,timestamp,latest,timestamp,prop,holder,get,file,timestamp,merged,holder,new,properties,holder,merged,props,latest,timestamp,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1518167602;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		long latestTimestamp = -1__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__					if (propHolder.getFileTimestamp() > latestTimestamp) {_						latestTimestamp = propHolder.getFileTimestamp()__					}_				}_			}_		}_		mergedHolder = new PropertiesHolder(mergedProps, latestTimestamp)__		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,long,latest,timestamp,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,if,prop,holder,get,file,timestamp,latest,timestamp,latest,timestamp,prop,holder,get,file,timestamp,merged,holder,new,properties,holder,merged,props,latest,timestamp,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> protected PropertiesHolder getMergedProperties(Locale locale);1530174524;Get a PropertiesHolder that contains the actually visible properties_for a Locale, after merging all specified resource bundles._Either fetches the holder from the cache or freshly loads it._<p>Only used when caching resource bundle contents forever, i.e._with cacheSeconds < 0. Therefore, merged properties are always_cached forever.;protected PropertiesHolder getMergedProperties(Locale locale) {_		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale)__		if (mergedHolder != null) {_			return mergedHolder__		}_		Properties mergedProps = newProperties()__		long latestTimestamp = -1__		String[] basenames = StringUtils.toStringArray(getBasenameSet())__		for (int i = basenames.length - 1_ i >= 0_ i--) {_			List<String> filenames = calculateAllFilenames(basenames[i], locale)__			for (int j = filenames.size() - 1_ j >= 0_ j--) {_				String filename = filenames.get(j)__				PropertiesHolder propHolder = getProperties(filename)__				if (propHolder.getProperties() != null) {_					mergedProps.putAll(propHolder.getProperties())__					if (propHolder.getFileTimestamp() > latestTimestamp) {_						latestTimestamp = propHolder.getFileTimestamp()__					}_				}_			}_		}_		mergedHolder = new PropertiesHolder(mergedProps, latestTimestamp)__		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder)__		if (existing != null) {_			mergedHolder = existing__		}_		return mergedHolder__	};get,a,properties,holder,that,contains,the,actually,visible,properties,for,a,locale,after,merging,all,specified,resource,bundles,either,fetches,the,holder,from,the,cache,or,freshly,loads,it,p,only,used,when,caching,resource,bundle,contents,forever,i,e,with,cache,seconds,0,therefore,merged,properties,are,always,cached,forever;protected,properties,holder,get,merged,properties,locale,locale,properties,holder,merged,holder,this,cached,merged,properties,get,locale,if,merged,holder,null,return,merged,holder,properties,merged,props,new,properties,long,latest,timestamp,1,string,basenames,string,utils,to,string,array,get,basename,set,for,int,i,basenames,length,1,i,0,i,list,string,filenames,calculate,all,filenames,basenames,i,locale,for,int,j,filenames,size,1,j,0,j,string,filename,filenames,get,j,properties,holder,prop,holder,get,properties,filename,if,prop,holder,get,properties,null,merged,props,put,all,prop,holder,get,properties,if,prop,holder,get,file,timestamp,latest,timestamp,latest,timestamp,prop,holder,get,file,timestamp,merged,holder,new,properties,holder,merged,props,latest,timestamp,properties,holder,existing,this,cached,merged,properties,put,if,absent,locale,merged,holder,if,existing,null,merged,holder,existing,return,merged,holder
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1328020251;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1329142650;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1348671314;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1356735495;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1357119239;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1368482696;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1385412762;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1408623868;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1410958822;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1425660337;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1454612260;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1454617957;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1467730834;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1478179664;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1495868221;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1496259743;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1496837955;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1498780456;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1502974979;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1515532822;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1516393837;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1518167602;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
ReloadableResourceBundleMessageSource -> public void clearCacheIncludingAncestors();1530174524;Clear the resource bundle caches of this MessageSource and all its ancestors._@see #clearCache;public void clearCacheIncludingAncestors() {_		clearCache()__		if (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {_			((ReloadableResourceBundleMessageSource) getParentMessageSource()).clearCacheIncludingAncestors()__		}_	};clear,the,resource,bundle,caches,of,this,message,source,and,all,its,ancestors,see,clear,cache;public,void,clear,cache,including,ancestors,clear,cache,if,get,parent,message,source,instanceof,reloadable,resource,bundle,message,source,reloadable,resource,bundle,message,source,get,parent,message,source,clear,cache,including,ancestors
