# id;timestamp;commentText;codeText;commentWords;codeWords
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1356735495;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object.__@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (this.beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean('&'+beanName) && factoryContainsBean(beanName)) {_				Object factoryBean = this.beanFactory.getBean('&'+beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanName)__				}_			}__			boolean factoryIsCaller = beanMethod.equals(SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod())__			boolean factoryAlreadyContainsSingleton = this.beanFactory.containsSingleton(beanName)__			if (factoryIsCaller && !factoryAlreadyContainsSingleton) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return this.beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,this,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,name,factory,contains,bean,bean,name,object,factory,bean,this,bean,factory,get,bean,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,name,boolean,factory,is,caller,bean,method,equals,simple,instantiation,strategy,get,currently,invoked,factory,method,boolean,factory,already,contains,singleton,this,bean,factory,contains,singleton,bean,name,if,factory,is,caller,factory,already,contains,singleton,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,this,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,false,return,this,bean,factory,get,bean,bean,name,finally,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1368482696;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod) && !beanFactory.containsSingleton(beanName)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,bean,factory,contains,singleton,bean,name,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1372363092;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod) && !beanFactory.containsSingleton(beanName)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,bean,factory,contains,singleton,bean,name,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1385159394;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod) && !beanFactory.containsSingleton(beanName)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,bean,factory,contains,singleton,bean,name,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1385412762;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod) && !beanFactory.containsSingleton(beanName)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,bean,factory,contains,singleton,bean,name,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1386019951;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod) && !beanFactory.containsSingleton(beanName)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,bean,factory,contains,singleton,bean,name,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1391714711;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod) && !beanFactory.containsSingleton(beanName)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,bean,factory,contains,singleton,bean,name,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1391904536;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod) && !beanFactory.containsSingleton(beanName)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,bean,factory,contains,singleton,bean,name,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1409688815;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1416668785;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return (!ObjectUtils.isEmpty(beanMethodArgs) ?_							beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,object,utils,is,empty,bean,method,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1417457791;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return (!ObjectUtils.isEmpty(beanMethodArgs) ?_							beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,object,utils,is,empty,bean,method,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1417525010;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return (!ObjectUtils.isEmpty(beanMethodArgs) ?_							beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,object,utils,is,empty,bean,method,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1417981938;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return (!ObjectUtils.isEmpty(beanMethodArgs) ?_							beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,object,utils,is,empty,bean,method,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1429130993;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return (!ObjectUtils.isEmpty(beanMethodArgs) ?_							beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,object,utils,is,empty,bean,method,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1429133871;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ?_							beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))__					if (beanInstance != null && !beanMethod.getReturnType().isInstance(beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,object,bean,instance,object,utils,is,empty,bean,method,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,bean,method,get,return,type,is,instance,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1429201126;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ?_							beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,object,bean,instance,object,utils,is,empty,bean,method,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1432125256;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ?_							beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,object,bean,instance,object,utils,is,empty,bean,method,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1433455782;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ?_							beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,object,bean,instance,object,utils,is,empty,bean,method,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1434484897;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ?_							beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,object,bean,instance,object,utils,is,empty,bean,method,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1448383082;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ?_							beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,object,bean,instance,object,utils,is,empty,bean,method,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1455886852;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs)__					if (useArgs && beanFactory.isSingleton(beanName)) {_						_						_						_						for (Object arg : beanMethodArgs) {_							if (arg == null) {_								useArgs = false__								break__							}_						}_					}_					Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :_							beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,boolean,use,args,object,utils,is,empty,bean,method,args,if,use,args,bean,factory,is,singleton,bean,name,for,object,arg,bean,method,args,if,arg,null,use,args,false,break,object,bean,instance,use,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1458754760;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs)__					if (useArgs && beanFactory.isSingleton(beanName)) {_						_						_						_						for (Object arg : beanMethodArgs) {_							if (arg == null) {_								useArgs = false__								break__							}_						}_					}_					Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :_							beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,boolean,use,args,object,utils,is,empty,bean,method,args,if,use,args,bean,factory,is,singleton,bean,name,for,object,arg,bean,method,args,if,arg,null,use,args,false,break,object,bean,instance,use,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1462195145;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs)__					if (useArgs && beanFactory.isSingleton(beanName)) {_						_						_						_						for (Object arg : beanMethodArgs) {_							if (arg == null) {_								useArgs = false__								break__							}_						}_					}_					Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :_							beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,boolean,use,args,object,utils,is,empty,bean,method,args,if,use,args,bean,factory,is,singleton,bean,name,for,object,arg,bean,method,args,if,arg,null,use,args,false,break,object,bean,instance,use,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1467808333;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs)__					if (useArgs && beanFactory.isSingleton(beanName)) {_						_						_						_						for (Object arg : beanMethodArgs) {_							if (arg == null) {_								useArgs = false__								break__							}_						}_					}_					Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :_							beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,boolean,use,args,object,utils,is,empty,bean,method,args,if,use,args,bean,factory,is,singleton,bean,name,for,object,arg,bean,method,args,if,arg,null,use,args,false,break,object,bean,instance,use,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1467846264;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs)__					if (useArgs && beanFactory.isSingleton(beanName)) {_						_						_						_						for (Object arg : beanMethodArgs) {_							if (arg == null) {_								useArgs = false__								break__							}_						}_					}_					Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :_							beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,boolean,use,args,object,utils,is,empty,bean,method,args,if,use,args,bean,factory,is,singleton,bean,name,for,object,arg,bean,method,args,if,arg,null,use,args,false,break,object,bean,instance,use,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1468948866;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs)__					if (useArgs && beanFactory.isSingleton(beanName)) {_						_						_						_						for (Object arg : beanMethodArgs) {_							if (arg == null) {_								useArgs = false__								break__							}_						}_					}_					Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :_							beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,boolean,use,args,object,utils,is,empty,bean,method,args,if,use,args,bean,factory,is,singleton,bean,name,for,object,arg,bean,method,args,if,arg,null,use,args,false,break,object,bean,instance,use,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1482232576;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs)__					if (useArgs && beanFactory.isSingleton(beanName)) {_						_						_						_						for (Object arg : beanMethodArgs) {_							if (arg == null) {_								useArgs = false__								break__							}_						}_					}_					Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :_							beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,boolean,use,args,object,utils,is,empty,bean,method,args,if,use,args,bean,factory,is,singleton,bean,name,for,object,arg,bean,method,args,if,arg,null,use,args,false,break,object,bean,instance,use,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1483047480;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs)__					if (useArgs && beanFactory.isSingleton(beanName)) {_						_						_						_						for (Object arg : beanMethodArgs) {_							if (arg == null) {_								useArgs = false__								break__							}_						}_					}_					Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :_							beanFactory.getBean(beanName))__					if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {_						String msg = String.format("@Bean method %s.%s called as a bean reference " +_									"for type [%s] but overridden by non-compatible bean instance of type [%s].",_									beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),_									beanMethod.getReturnType().getName(), beanInstance.getClass().getName())__						try {_							BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)__							msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()__						}_						catch (NoSuchBeanDefinitionException ex) {_							_						}_						throw new IllegalStateException(msg)__					}_					Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__					if (currentlyInvoked != null) {_						String outerBeanName = BeanAnnotationHelper.determineBeanNameFor(currentlyInvoked)__						beanFactory.registerDependentBean(beanName, outerBeanName)__					}_					return beanInstance__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,boolean,use,args,object,utils,is,empty,bean,method,args,if,use,args,bean,factory,is,singleton,bean,name,for,object,arg,bean,method,args,if,arg,null,use,args,false,break,object,bean,instance,use,args,bean,factory,get,bean,bean,name,bean,method,args,bean,factory,get,bean,bean,name,if,bean,instance,null,class,utils,is,assignable,value,bean,method,get,return,type,bean,instance,string,msg,string,format,bean,method,s,s,called,as,a,bean,reference,for,type,s,but,overridden,by,non,compatible,bean,instance,of,type,s,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,bean,method,get,return,type,get,name,bean,instance,get,class,get,name,try,bean,definition,bean,definition,bean,factory,get,merged,bean,definition,bean,name,msg,overriding,bean,of,same,name,declared,in,bean,definition,get,resource,description,catch,no,such,bean,definition,exception,ex,throw,new,illegal,state,exception,msg,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,if,currently,invoked,null,string,outer,bean,name,bean,annotation,helper,determine,bean,name,for,currently,invoked,bean,factory,register,dependent,bean,bean,name,outer,bean,name,return,bean,instance,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1487773924;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return obtainBeanInstanceFromFactory(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,obtain,bean,instance,from,factory,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1488891103;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return obtainBeanInstanceFromFactory(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,obtain,bean,instance,from,factory,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1495868221;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return obtainBeanInstanceFromFactory(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,obtain,bean,instance,from,factory,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1496263893;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return obtainBeanInstanceFromFactory(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,obtain,bean,instance,from,factory,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1496837955;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return obtainBeanInstanceFromFactory(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,obtain,bean,instance,from,factory,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1498780456;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return obtainBeanInstanceFromFactory(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,obtain,bean,instance,from,factory,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader);1523443675;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(configSuperClass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,config,super,class,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,config,super,class,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader);1530174524;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(configSuperClass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,config,super,class,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,config,super,class,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader);1532091916;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(configSuperClass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,config,super,class,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,config,super,class,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader);1532706365;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(configSuperClass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,config,super,class,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,config,super,class,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader);1533116608;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(configSuperClass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,config,super,class,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,config,super,class,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader);1533598532;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(configSuperClass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,config,super,class,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,config,super,class,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader);1542899558;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(configSuperClass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,config,super,class,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,config,super,class,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory);1328020251;Creates a new {@link ConfigurationClassEnhancer} instance.;public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory) {_		Assert.notNull(beanFactory, "BeanFactory must not be null")___		this.callbackInstances.add(new BeanMethodInterceptor(beanFactory))__		this.callbackInstances.add(new DisposableBeanMethodInterceptor())__		this.callbackInstances.add(NoOp.INSTANCE)___		for (Callback callback : this.callbackInstances) {_			this.callbackTypes.add(callback.getClass())__		}__		_		_		callbackFilter = new CallbackFilter() {_			public int accept(Method candidateMethod) {_				if (BeanAnnotationHelper.isBeanAnnotated(candidateMethod)) {_					return 0__				}_				if (DisposableBeanMethodInterceptor.isDestroyMethod(candidateMethod)) {_					return 1__				}_				return 2__			}_		}__	};creates,a,new,link,configuration,class,enhancer,instance;public,configuration,class,enhancer,configurable,bean,factory,bean,factory,assert,not,null,bean,factory,bean,factory,must,not,be,null,this,callback,instances,add,new,bean,method,interceptor,bean,factory,this,callback,instances,add,new,disposable,bean,method,interceptor,this,callback,instances,add,no,op,instance,for,callback,callback,this,callback,instances,this,callback,types,add,callback,get,class,callback,filter,new,callback,filter,public,int,accept,method,candidate,method,if,bean,annotation,helper,is,bean,annotated,candidate,method,return,0,if,disposable,bean,method,interceptor,is,destroy,method,candidate,method,return,1,return,2
ConfigurationClassEnhancer -> public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory);1344552803;Creates a new {@link ConfigurationClassEnhancer} instance.;public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory) {_		Assert.notNull(beanFactory, "BeanFactory must not be null")___		this.callbackInstances.add(new BeanMethodInterceptor(beanFactory))__		this.callbackInstances.add(new DisposableBeanMethodInterceptor())__		this.callbackInstances.add(NoOp.INSTANCE)___		for (Callback callback : this.callbackInstances) {_			this.callbackTypes.add(callback.getClass())__		}__		_		_		callbackFilter = new CallbackFilter() {_			public int accept(Method candidateMethod) {_				if (BeanAnnotationHelper.isBeanAnnotated(candidateMethod)) {_					return 0__				}_				if (DisposableBeanMethodInterceptor.isDestroyMethod(candidateMethod)) {_					return 1__				}_				return 2__			}_		}__	};creates,a,new,link,configuration,class,enhancer,instance;public,configuration,class,enhancer,configurable,bean,factory,bean,factory,assert,not,null,bean,factory,bean,factory,must,not,be,null,this,callback,instances,add,new,bean,method,interceptor,bean,factory,this,callback,instances,add,new,disposable,bean,method,interceptor,this,callback,instances,add,no,op,instance,for,callback,callback,this,callback,instances,this,callback,types,add,callback,get,class,callback,filter,new,callback,filter,public,int,accept,method,candidate,method,if,bean,annotation,helper,is,bean,annotated,candidate,method,return,0,if,disposable,bean,method,interceptor,is,destroy,method,candidate,method,return,1,return,2
ConfigurationClassEnhancer -> public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory);1350071785;Creates a new {@link ConfigurationClassEnhancer} instance.;public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory) {_		Assert.notNull(beanFactory, "BeanFactory must not be null")__		_		this.callbackInstances = new Callback[] {_				new BeanMethodInterceptor(beanFactory),_				DISPOSABLE_BEAN_METHOD_INTERCEPTOR,_				NoOp.INSTANCE }__	};creates,a,new,link,configuration,class,enhancer,instance;public,configuration,class,enhancer,configurable,bean,factory,bean,factory,assert,not,null,bean,factory,bean,factory,must,not,be,null,this,callback,instances,new,callback,new,bean,method,interceptor,bean,factory,no,op,instance
ConfigurationClassEnhancer -> public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory);1352418897;Creates a new {@link ConfigurationClassEnhancer} instance.;public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory) {_		Assert.notNull(beanFactory, "BeanFactory must not be null")__		_		this.callbackInstances = new Callback[] {_				new BeanMethodInterceptor(beanFactory),_				DISPOSABLE_BEAN_METHOD_INTERCEPTOR,_				NoOp.INSTANCE }__	};creates,a,new,link,configuration,class,enhancer,instance;public,configuration,class,enhancer,configurable,bean,factory,bean,factory,assert,not,null,bean,factory,bean,factory,must,not,be,null,this,callback,instances,new,callback,new,bean,method,interceptor,bean,factory,no,op,instance
ConfigurationClassEnhancer -> public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory);1356735495;Creates a new {@link ConfigurationClassEnhancer} instance.;public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory) {_		Assert.notNull(beanFactory, "BeanFactory must not be null")__		_		this.callbackInstances = new Callback[] {_				new BeanMethodInterceptor(beanFactory),_				DISPOSABLE_BEAN_METHOD_INTERCEPTOR,_				NoOp.INSTANCE }__	};creates,a,new,link,configuration,class,enhancer,instance;public,configuration,class,enhancer,configurable,bean,factory,bean,factory,assert,not,null,bean,factory,bean,factory,must,not,be,null,this,callback,instances,new,callback,new,bean,method,interceptor,bean,factory,no,op,instance
ConfigurationClassEnhancer -> public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory);1357119239;Creates a new {@link ConfigurationClassEnhancer} instance.;public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory) {_		Assert.notNull(beanFactory, "BeanFactory must not be null")__		_		this.callbackInstances = new Callback[] {_				new BeanMethodInterceptor(beanFactory),_				DISPOSABLE_BEAN_METHOD_INTERCEPTOR,_				NoOp.INSTANCE }__	};creates,a,new,link,configuration,class,enhancer,instance;public,configuration,class,enhancer,configurable,bean,factory,bean,factory,assert,not,null,bean,factory,bean,factory,must,not,be,null,this,callback,instances,new,callback,new,bean,method,interceptor,bean,factory,no,op,instance
ConfigurationClassEnhancer -> public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory);1362408075;Creates a new {@link ConfigurationClassEnhancer} instance.;public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory) {_		Assert.notNull(beanFactory, "BeanFactory must not be null")__		_		this.callbackInstances = new Callback[]_				{new BeanMethodInterceptor(beanFactory), DISPOSABLE_BEAN_METHOD_INTERCEPTOR, NoOp.INSTANCE}__	};creates,a,new,link,configuration,class,enhancer,instance;public,configuration,class,enhancer,configurable,bean,factory,bean,factory,assert,not,null,bean,factory,bean,factory,must,not,be,null,this,callback,instances,new,callback,new,bean,method,interceptor,bean,factory,no,op,instance
ConfigurationClassEnhancer -> public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory);1363208506;Creates a new {@link ConfigurationClassEnhancer} instance.;public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory) {_		Assert.notNull(beanFactory, "BeanFactory must not be null")__		_		this.callbackInstances = new Callback[]_				{new BeanMethodInterceptor(beanFactory), DISPOSABLE_BEAN_METHOD_INTERCEPTOR, NoOp.INSTANCE}__	};creates,a,new,link,configuration,class,enhancer,instance;public,configuration,class,enhancer,configurable,bean,factory,bean,factory,assert,not,null,bean,factory,bean,factory,must,not,be,null,this,callback,instances,new,callback,new,bean,method,interceptor,bean,factory,no,op,instance
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName);1434484897;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallbackType(MethodInterceptor.class)___			_			_			Class<?> fbClass = enhancer.createClass()__			Object fbProxy = null___			if (objenesis.isWorthTrying()) {_				try {_					fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache())__				}_				catch (ObjenesisException ex) {_					logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"falling back to regular construction", ex)__				}_			}__			if (fbProxy == null) {_				try {_					fbProxy = fbClass.newInstance()__				}_				catch (Exception ex) {_					throw new IllegalStateException("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"and regular FactoryBean instantiation via default constructor fails as well", ex)__				}_			}__			((Factory) fbProxy).setCallback(0, new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})___			return fbProxy__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,type,method,interceptor,class,class,fb,class,enhancer,create,class,object,fb,proxy,null,if,objenesis,is,worth,trying,try,fb,proxy,objenesis,new,instance,fb,class,enhancer,get,use,cache,catch,objenesis,exception,ex,logger,debug,unable,to,instantiate,enhanced,factory,bean,using,objenesis,falling,back,to,regular,construction,ex,if,fb,proxy,null,try,fb,proxy,fb,class,new,instance,catch,exception,ex,throw,new,illegal,state,exception,unable,to,instantiate,enhanced,factory,bean,using,objenesis,and,regular,factory,bean,instantiation,via,default,constructor,fails,as,well,ex,factory,fb,proxy,set,callback,0,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,fb,proxy
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName);1448383082;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallbackType(MethodInterceptor.class)___			_			_			Class<?> fbClass = enhancer.createClass()__			Object fbProxy = null___			if (objenesis.isWorthTrying()) {_				try {_					fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache())__				}_				catch (ObjenesisException ex) {_					logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"falling back to regular construction", ex)__				}_			}__			if (fbProxy == null) {_				try {_					fbProxy = fbClass.newInstance()__				}_				catch (Exception ex) {_					throw new IllegalStateException("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"and regular FactoryBean instantiation via default constructor fails as well", ex)__				}_			}__			((Factory) fbProxy).setCallback(0, new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})___			return fbProxy__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,type,method,interceptor,class,class,fb,class,enhancer,create,class,object,fb,proxy,null,if,objenesis,is,worth,trying,try,fb,proxy,objenesis,new,instance,fb,class,enhancer,get,use,cache,catch,objenesis,exception,ex,logger,debug,unable,to,instantiate,enhanced,factory,bean,using,objenesis,falling,back,to,regular,construction,ex,if,fb,proxy,null,try,fb,proxy,fb,class,new,instance,catch,exception,ex,throw,new,illegal,state,exception,unable,to,instantiate,enhanced,factory,bean,using,objenesis,and,regular,factory,bean,instantiation,via,default,constructor,fails,as,well,ex,factory,fb,proxy,set,callback,0,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,fb,proxy
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName);1455886852;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallbackType(MethodInterceptor.class)___			_			_			Class<?> fbClass = enhancer.createClass()__			Object fbProxy = null___			if (objenesis.isWorthTrying()) {_				try {_					fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache())__				}_				catch (ObjenesisException ex) {_					logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"falling back to regular construction", ex)__				}_			}__			if (fbProxy == null) {_				try {_					fbProxy = fbClass.newInstance()__				}_				catch (Exception ex) {_					throw new IllegalStateException("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"and regular FactoryBean instantiation via default constructor fails as well", ex)__				}_			}__			((Factory) fbProxy).setCallback(0, new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})___			return fbProxy__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,type,method,interceptor,class,class,fb,class,enhancer,create,class,object,fb,proxy,null,if,objenesis,is,worth,trying,try,fb,proxy,objenesis,new,instance,fb,class,enhancer,get,use,cache,catch,objenesis,exception,ex,logger,debug,unable,to,instantiate,enhanced,factory,bean,using,objenesis,falling,back,to,regular,construction,ex,if,fb,proxy,null,try,fb,proxy,fb,class,new,instance,catch,exception,ex,throw,new,illegal,state,exception,unable,to,instantiate,enhanced,factory,bean,using,objenesis,and,regular,factory,bean,instantiation,via,default,constructor,fails,as,well,ex,factory,fb,proxy,set,callback,0,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,fb,proxy
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName);1458754760;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallbackType(MethodInterceptor.class)___			_			_			Class<?> fbClass = enhancer.createClass()__			Object fbProxy = null___			if (objenesis.isWorthTrying()) {_				try {_					fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache())__				}_				catch (ObjenesisException ex) {_					logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"falling back to regular construction", ex)__				}_			}__			if (fbProxy == null) {_				try {_					fbProxy = fbClass.newInstance()__				}_				catch (Exception ex) {_					throw new IllegalStateException("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"and regular FactoryBean instantiation via default constructor fails as well", ex)__				}_			}__			((Factory) fbProxy).setCallback(0, new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})___			return fbProxy__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,type,method,interceptor,class,class,fb,class,enhancer,create,class,object,fb,proxy,null,if,objenesis,is,worth,trying,try,fb,proxy,objenesis,new,instance,fb,class,enhancer,get,use,cache,catch,objenesis,exception,ex,logger,debug,unable,to,instantiate,enhanced,factory,bean,using,objenesis,falling,back,to,regular,construction,ex,if,fb,proxy,null,try,fb,proxy,fb,class,new,instance,catch,exception,ex,throw,new,illegal,state,exception,unable,to,instantiate,enhanced,factory,bean,using,objenesis,and,regular,factory,bean,instantiation,via,default,constructor,fails,as,well,ex,factory,fb,proxy,set,callback,0,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,fb,proxy
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName);1462195145;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallbackType(MethodInterceptor.class)___			_			_			Class<?> fbClass = enhancer.createClass()__			Object fbProxy = null___			if (objenesis.isWorthTrying()) {_				try {_					fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache())__				}_				catch (ObjenesisException ex) {_					logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"falling back to regular construction", ex)__				}_			}__			if (fbProxy == null) {_				try {_					fbProxy = fbClass.newInstance()__				}_				catch (Exception ex) {_					throw new IllegalStateException("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"and regular FactoryBean instantiation via default constructor fails as well", ex)__				}_			}__			((Factory) fbProxy).setCallback(0, new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})___			return fbProxy__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,type,method,interceptor,class,class,fb,class,enhancer,create,class,object,fb,proxy,null,if,objenesis,is,worth,trying,try,fb,proxy,objenesis,new,instance,fb,class,enhancer,get,use,cache,catch,objenesis,exception,ex,logger,debug,unable,to,instantiate,enhanced,factory,bean,using,objenesis,falling,back,to,regular,construction,ex,if,fb,proxy,null,try,fb,proxy,fb,class,new,instance,catch,exception,ex,throw,new,illegal,state,exception,unable,to,instantiate,enhanced,factory,bean,using,objenesis,and,regular,factory,bean,instantiation,via,default,constructor,fails,as,well,ex,factory,fb,proxy,set,callback,0,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,fb,proxy
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName);1467808333;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallbackType(MethodInterceptor.class)___			_			_			Class<?> fbClass = enhancer.createClass()__			Object fbProxy = null___			if (objenesis.isWorthTrying()) {_				try {_					fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache())__				}_				catch (ObjenesisException ex) {_					logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"falling back to regular construction", ex)__				}_			}__			if (fbProxy == null) {_				try {_					fbProxy = fbClass.newInstance()__				}_				catch (Exception ex) {_					throw new IllegalStateException("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"and regular FactoryBean instantiation via default constructor fails as well", ex)__				}_			}__			((Factory) fbProxy).setCallback(0, new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})___			return fbProxy__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,type,method,interceptor,class,class,fb,class,enhancer,create,class,object,fb,proxy,null,if,objenesis,is,worth,trying,try,fb,proxy,objenesis,new,instance,fb,class,enhancer,get,use,cache,catch,objenesis,exception,ex,logger,debug,unable,to,instantiate,enhanced,factory,bean,using,objenesis,falling,back,to,regular,construction,ex,if,fb,proxy,null,try,fb,proxy,fb,class,new,instance,catch,exception,ex,throw,new,illegal,state,exception,unable,to,instantiate,enhanced,factory,bean,using,objenesis,and,regular,factory,bean,instantiation,via,default,constructor,fails,as,well,ex,factory,fb,proxy,set,callback,0,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,fb,proxy
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName);1467846264;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallbackType(MethodInterceptor.class)___			_			_			Class<?> fbClass = enhancer.createClass()__			Object fbProxy = null___			if (objenesis.isWorthTrying()) {_				try {_					fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache())__				}_				catch (ObjenesisException ex) {_					logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"falling back to regular construction", ex)__				}_			}__			if (fbProxy == null) {_				try {_					fbProxy = fbClass.newInstance()__				}_				catch (Exception ex) {_					throw new IllegalStateException("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"and regular FactoryBean instantiation via default constructor fails as well", ex)__				}_			}__			((Factory) fbProxy).setCallback(0, new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})___			return fbProxy__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,type,method,interceptor,class,class,fb,class,enhancer,create,class,object,fb,proxy,null,if,objenesis,is,worth,trying,try,fb,proxy,objenesis,new,instance,fb,class,enhancer,get,use,cache,catch,objenesis,exception,ex,logger,debug,unable,to,instantiate,enhanced,factory,bean,using,objenesis,falling,back,to,regular,construction,ex,if,fb,proxy,null,try,fb,proxy,fb,class,new,instance,catch,exception,ex,throw,new,illegal,state,exception,unable,to,instantiate,enhanced,factory,bean,using,objenesis,and,regular,factory,bean,instantiation,via,default,constructor,fails,as,well,ex,factory,fb,proxy,set,callback,0,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,fb,proxy
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName);1468948866;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallbackType(MethodInterceptor.class)___			_			_			Class<?> fbClass = enhancer.createClass()__			Object fbProxy = null___			if (objenesis.isWorthTrying()) {_				try {_					fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache())__				}_				catch (ObjenesisException ex) {_					logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"falling back to regular construction", ex)__				}_			}__			if (fbProxy == null) {_				try {_					fbProxy = ReflectionUtils.accessibleConstructor(fbClass).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"and regular FactoryBean instantiation via default constructor fails as well", ex)__				}_			}__			((Factory) fbProxy).setCallback(0, new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})___			return fbProxy__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,type,method,interceptor,class,class,fb,class,enhancer,create,class,object,fb,proxy,null,if,objenesis,is,worth,trying,try,fb,proxy,objenesis,new,instance,fb,class,enhancer,get,use,cache,catch,objenesis,exception,ex,logger,debug,unable,to,instantiate,enhanced,factory,bean,using,objenesis,falling,back,to,regular,construction,ex,if,fb,proxy,null,try,fb,proxy,reflection,utils,accessible,constructor,fb,class,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,unable,to,instantiate,enhanced,factory,bean,using,objenesis,and,regular,factory,bean,instantiation,via,default,constructor,fails,as,well,ex,factory,fb,proxy,set,callback,0,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,fb,proxy
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName);1482232576;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallbackType(MethodInterceptor.class)___			_			_			Class<?> fbClass = enhancer.createClass()__			Object fbProxy = null___			if (objenesis.isWorthTrying()) {_				try {_					fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache())__				}_				catch (ObjenesisException ex) {_					logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"falling back to regular construction", ex)__				}_			}__			if (fbProxy == null) {_				try {_					fbProxy = ReflectionUtils.accessibleConstructor(fbClass).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"and regular FactoryBean instantiation via default constructor fails as well", ex)__				}_			}__			((Factory) fbProxy).setCallback(0, new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})___			return fbProxy__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,type,method,interceptor,class,class,fb,class,enhancer,create,class,object,fb,proxy,null,if,objenesis,is,worth,trying,try,fb,proxy,objenesis,new,instance,fb,class,enhancer,get,use,cache,catch,objenesis,exception,ex,logger,debug,unable,to,instantiate,enhanced,factory,bean,using,objenesis,falling,back,to,regular,construction,ex,if,fb,proxy,null,try,fb,proxy,reflection,utils,accessible,constructor,fb,class,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,unable,to,instantiate,enhanced,factory,bean,using,objenesis,and,regular,factory,bean,instantiation,via,default,constructor,fails,as,well,ex,factory,fb,proxy,set,callback,0,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,fb,proxy
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName);1483047480;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallbackType(MethodInterceptor.class)___			_			_			Class<?> fbClass = enhancer.createClass()__			Object fbProxy = null___			if (objenesis.isWorthTrying()) {_				try {_					fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache())__				}_				catch (ObjenesisException ex) {_					logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"falling back to regular construction", ex)__				}_			}__			if (fbProxy == null) {_				try {_					fbProxy = ReflectionUtils.accessibleConstructor(fbClass).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Unable to instantiate enhanced FactoryBean using Objenesis, " +_							"and regular FactoryBean instantiation via default constructor fails as well", ex)__				}_			}__			((Factory) fbProxy).setCallback(0, new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})___			return fbProxy__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,type,method,interceptor,class,class,fb,class,enhancer,create,class,object,fb,proxy,null,if,objenesis,is,worth,trying,try,fb,proxy,objenesis,new,instance,fb,class,enhancer,get,use,cache,catch,objenesis,exception,ex,logger,debug,unable,to,instantiate,enhanced,factory,bean,using,objenesis,falling,back,to,regular,construction,ex,if,fb,proxy,null,try,fb,proxy,reflection,utils,accessible,constructor,fb,class,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,unable,to,instantiate,enhanced,factory,bean,using,objenesis,and,regular,factory,bean,instantiation,via,default,constructor,fails,as,well,ex,factory,fb,proxy,set,callback,0,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,fb,proxy
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1448383082;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1455886852;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1458754760;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1462195145;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1467808333;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1467846264;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1468948866;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1482232576;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1483047480;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1487773924;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1488891103;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1495868221;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1496263893;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, ClassLoader classLoader);1496837955;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(String beanName);1328020251;Check the beanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(String beanName) {_			boolean containsBean = this.beanFactory.containsBean(beanName)__			boolean currentlyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__			return (containsBean && !currentlyInCreation)__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,string,bean,name,boolean,contains,bean,this,bean,factory,contains,bean,bean,name,boolean,currently,in,creation,this,bean,factory,is,currently,in,creation,bean,name,return,contains,bean,currently,in,creation
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(String beanName);1344552803;Check the beanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(String beanName) {_			boolean containsBean = this.beanFactory.containsBean(beanName)__			boolean currentlyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__			return (containsBean && !currentlyInCreation)__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,string,bean,name,boolean,contains,bean,this,bean,factory,contains,bean,bean,name,boolean,currently,in,creation,this,bean,factory,is,currently,in,creation,bean,name,return,contains,bean,currently,in,creation
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(String beanName);1350071785;Check the beanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(String beanName) {_			boolean containsBean = this.beanFactory.containsBean(beanName)__			boolean currentlyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__			return (containsBean && !currentlyInCreation)__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,string,bean,name,boolean,contains,bean,this,bean,factory,contains,bean,bean,name,boolean,currently,in,creation,this,bean,factory,is,currently,in,creation,bean,name,return,contains,bean,currently,in,creation
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(String beanName);1352418897;Check the beanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(String beanName) {_			boolean containsBean = this.beanFactory.containsBean(beanName)__			boolean currentlyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__			return (containsBean && !currentlyInCreation)__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,string,bean,name,boolean,contains,bean,this,bean,factory,contains,bean,bean,name,boolean,currently,in,creation,this,bean,factory,is,currently,in,creation,bean,name,return,contains,bean,currently,in,creation
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(String beanName);1356735495;Check the beanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(String beanName) {_			boolean containsBean = this.beanFactory.containsBean(beanName)__			boolean currentlyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__			return (containsBean && !currentlyInCreation)__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,string,bean,name,boolean,contains,bean,this,bean,factory,contains,bean,bean,name,boolean,currently,in,creation,this,bean,factory,is,currently,in,creation,bean,name,return,contains,bean,currently,in,creation
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(String beanName);1357119239;Check the beanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(String beanName) {_			boolean containsBean = this.beanFactory.containsBean(beanName)__			boolean currentlyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__			return (containsBean && !currentlyInCreation)__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,string,bean,name,boolean,contains,bean,this,bean,factory,contains,bean,bean,name,boolean,currently,in,creation,this,bean,factory,is,currently,in,creation,bean,name,return,contains,bean,currently,in,creation
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(String beanName);1362408075;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(String beanName) {_			return (this.beanFactory.containsBean(beanName) && !this.beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,string,bean,name,return,this,bean,factory,contains,bean,bean,name,this,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(String beanName);1363208506;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(String beanName) {_			return (this.beanFactory.containsBean(beanName) && !this.beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,string,bean,name,return,this,bean,factory,contains,bean,bean,name,this,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1362408075;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1363208506;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1368137140;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1368482696;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1372363092;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1385159394;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1385412762;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1386019951;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1391714711;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1391904536;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1409688815;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1416668785;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1417457791;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1417525010;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1417981938;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1429130993;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1429133871;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1429201126;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1432125256;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1433455782;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1434484897;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1448383082;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1455886852;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1458754760;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1462195145;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1467808333;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1467846264;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1468948866;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1482232576;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1483047480;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1487773924;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1488891103;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1495868221;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1496263893;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1496837955;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1498780456;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1504267514;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1506097334;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1522448294;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1522580239;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1523443675;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1530174524;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1532091916;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1532706365;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1533116608;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1533598532;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean isCurrentlyInvokedFactoryMethod(Method method);1542899558;Check whether the given method corresponds to the container's currently invoked_factory method. Compares method name and parameter types only in order to work_around a potential problem with covariant return types (currently only known_to happen on Groovy classes).;private boolean isCurrentlyInvokedFactoryMethod(Method method) {_			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod()__			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&_					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()))__		};check,whether,the,given,method,corresponds,to,the,container,s,currently,invoked,factory,method,compares,method,name,and,parameter,types,only,in,order,to,work,around,a,potential,problem,with,covariant,return,types,currently,only,known,to,happen,on,groovy,classes;private,boolean,is,currently,invoked,factory,method,method,method,method,currently,invoked,simple,instantiation,strategy,get,currently,invoked,factory,method,return,currently,invoked,null,method,get,name,equals,currently,invoked,get,name,arrays,equals,method,get,parameter,types,currently,invoked,get,parameter,types
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1498780456;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1504267514;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1506097334;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1522448294;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1522580239;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1523443675;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1530174524;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1532091916;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1532706365;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,trace,enabled,logger,trace,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1533116608;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,trace,enabled,logger,trace,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1533598532;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,trace,enabled,logger,trace,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader);1542899558;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader))__		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,nullable,class,loader,class,loader,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,class,loader,if,logger,is,trace,enabled,logger,trace,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1368137140;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallback(new MethodInterceptor() {_				public Object intercept(Object obj, Method method, Object[] args,_						MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,new,method,interceptor,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1368482696;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args,_						MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1372363092;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args,_						MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1385159394;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1385412762;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1386019951;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1391714711;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1391904536;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1409688815;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1416668785;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1417457791;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1417525010;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1417981938;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invokeSuper(obj, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,super,obj,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException;1328020251;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setUseCache(false)__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallbackFilter(new CallbackFilter() {_				public int accept(Method method) {_					return method.getName().equals("getObject") ? 0 : 1__				}_			})__			List<Callback> callbackInstances = new ArrayList<Callback>()__			callbackInstances.add(new GetObjectMethodInterceptor(this.beanFactory, beanName))__			callbackInstances.add(NoOp.INSTANCE)__			_			List<Class<? extends Callback>> callbackTypes = new ArrayList<Class<? extends Callback>>()__			for (Callback callback : callbackInstances) {_				callbackTypes.add(callback.getClass())__			}_			_			enhancer.setCallbackTypes(callbackTypes.toArray(new Class[callbackTypes.size()]))__			Class<?> fbSubclass = enhancer.createClass()__			Enhancer.registerCallbacks(fbSubclass, callbackInstances.toArray(new Callback[callbackInstances.size()]))__			return fbSubclass.newInstance()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,use,cache,false,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,new,callback,filter,public,int,accept,method,method,return,method,get,name,equals,get,object,0,1,list,callback,callback,instances,new,array,list,callback,callback,instances,add,new,get,object,method,interceptor,this,bean,factory,bean,name,callback,instances,add,no,op,instance,list,class,extends,callback,callback,types,new,array,list,class,extends,callback,for,callback,callback,callback,instances,callback,types,add,callback,get,class,enhancer,set,callback,types,callback,types,to,array,new,class,callback,types,size,class,fb,subclass,enhancer,create,class,enhancer,register,callbacks,fb,subclass,callback,instances,to,array,new,callback,callback,instances,size,return,fb,subclass,new,instance
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException;1344552803;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setUseCache(false)__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallbackFilter(new CallbackFilter() {_				public int accept(Method method) {_					return method.getName().equals("getObject") ? 0 : 1__				}_			})__			List<Callback> callbackInstances = new ArrayList<Callback>()__			callbackInstances.add(new GetObjectMethodInterceptor(this.beanFactory, beanName))__			callbackInstances.add(NoOp.INSTANCE)__			_			List<Class<? extends Callback>> callbackTypes = new ArrayList<Class<? extends Callback>>()__			for (Callback callback : callbackInstances) {_				callbackTypes.add(callback.getClass())__			}_			_			enhancer.setCallbackTypes(callbackTypes.toArray(new Class[callbackTypes.size()]))__			Class<?> fbSubclass = enhancer.createClass()__			Enhancer.registerCallbacks(fbSubclass, callbackInstances.toArray(new Callback[callbackInstances.size()]))__			return fbSubclass.newInstance()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,use,cache,false,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,new,callback,filter,public,int,accept,method,method,return,method,get,name,equals,get,object,0,1,list,callback,callback,instances,new,array,list,callback,callback,instances,add,new,get,object,method,interceptor,this,bean,factory,bean,name,callback,instances,add,no,op,instance,list,class,extends,callback,callback,types,new,array,list,class,extends,callback,for,callback,callback,callback,instances,callback,types,add,callback,get,class,enhancer,set,callback,types,callback,types,to,array,new,class,callback,types,size,class,fb,subclass,enhancer,create,class,enhancer,register,callbacks,fb,subclass,callback,instances,to,array,new,callback,callback,instances,size,return,fb,subclass,new,instance
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException;1350071785;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallbackFilter(CALLBACK_FITLER)__			_			Callback[] callbackInstances = new Callback[] {_					new GetObjectMethodInterceptor(this.beanFactory, beanName),_					NoOp.INSTANCE_			}___			enhancer.setCallbackTypes(CALLBACK_TYPES)__			Class<?> fbSubclass = enhancer.createClass()__			Enhancer.registerCallbacks(fbSubclass, callbackInstances)__			return fbSubclass.newInstance()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,callback,callback,instances,new,callback,new,get,object,method,interceptor,this,bean,factory,bean,name,no,op,instance,enhancer,set,callback,types,class,fb,subclass,enhancer,create,class,enhancer,register,callbacks,fb,subclass,callback,instances,return,fb,subclass,new,instance
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException;1352418897;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallbackFilter(CALLBACK_FITLER)__			_			Callback[] callbackInstances = new Callback[] {_					new GetObjectMethodInterceptor(this.beanFactory, beanName),_					NoOp.INSTANCE_			}___			enhancer.setCallbackTypes(CALLBACK_TYPES)__			Class<?> fbSubclass = enhancer.createClass()__			Enhancer.registerCallbacks(fbSubclass, callbackInstances)__			return fbSubclass.newInstance()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,callback,callback,instances,new,callback,new,get,object,method,interceptor,this,bean,factory,bean,name,no,op,instance,enhancer,set,callback,types,class,fb,subclass,enhancer,create,class,enhancer,register,callbacks,fb,subclass,callback,instances,return,fb,subclass,new,instance
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException;1356735495;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallbackFilter(CALLBACK_FITLER)__			_			Callback[] callbackInstances = new Callback[] {_					new GetObjectMethodInterceptor(this.beanFactory, beanName),_					NoOp.INSTANCE_			}___			enhancer.setCallbackTypes(CALLBACK_TYPES)__			Class<?> fbSubclass = enhancer.createClass()__			Enhancer.registerCallbacks(fbSubclass, callbackInstances)__			return fbSubclass.newInstance()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,callback,callback,instances,new,callback,new,get,object,method,interceptor,this,bean,factory,bean,name,no,op,instance,enhancer,set,callback,types,class,fb,subclass,enhancer,create,class,enhancer,register,callbacks,fb,subclass,callback,instances,return,fb,subclass,new,instance
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException;1357119239;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallbackFilter(CALLBACK_FITLER)__			_			Callback[] callbackInstances = new Callback[] {_					new GetObjectMethodInterceptor(this.beanFactory, beanName),_					NoOp.INSTANCE_			}___			enhancer.setCallbackTypes(CALLBACK_TYPES)__			Class<?> fbSubclass = enhancer.createClass()__			Enhancer.registerCallbacks(fbSubclass, callbackInstances)__			return fbSubclass.newInstance()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,callback,callback,instances,new,callback,new,get,object,method,interceptor,this,bean,factory,bean,name,no,op,instance,enhancer,set,callback,types,class,fb,subclass,enhancer,create,class,enhancer,register,callbacks,fb,subclass,callback,instances,return,fb,subclass,new,instance
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException;1362408075;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallbackFilter(CALLBACK_FILTER)__			_			Callback[] callbackInstances = new Callback[] {_					new GetObjectMethodInterceptor(this.beanFactory, beanName),_					NoOp.INSTANCE_			}__			enhancer.setCallbackTypes(CALLBACK_TYPES)__			Class<?> fbSubclass = enhancer.createClass()__			Enhancer.registerCallbacks(fbSubclass, callbackInstances)__			return fbSubclass.newInstance()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,callback,callback,instances,new,callback,new,get,object,method,interceptor,this,bean,factory,bean,name,no,op,instance,enhancer,set,callback,types,class,fb,subclass,enhancer,create,class,enhancer,register,callbacks,fb,subclass,callback,instances,return,fb,subclass,new,instance
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException;1363208506;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws InstantiationException, IllegalAccessException {_			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(fbClass)__			enhancer.setUseFactory(false)__			enhancer.setCallbackFilter(CALLBACK_FILTER)__			_			Callback[] callbackInstances = new Callback[] {_					new GetObjectMethodInterceptor(this.beanFactory, beanName),_					NoOp.INSTANCE_			}__			enhancer.setCallbackTypes(CALLBACK_TYPES)__			Class<?> fbSubclass = enhancer.createClass()__			Enhancer.registerCallbacks(fbSubclass, callbackInstances)__			return fbSubclass.newInstance()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,class,fb,class,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,fb,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,callback,callback,instances,new,callback,new,get,object,method,interceptor,this,bean,factory,bean,name,no,op,instance,enhancer,set,callback,types,class,fb,subclass,enhancer,create,class,enhancer,register,callbacks,fb,subclass,callback,instances,return,fb,subclass,new,instance
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1448383082;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1455886852;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1458754760;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1462195145;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1467808333;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1467846264;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1468948866;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1482232576;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1483047480;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1487773924;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1488891103;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1495868221;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1496263893;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader);1496837955;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1328020251;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		_		_		_		enhancer.setUseCache(false)__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(this.callbackFilter)__		enhancer.setCallbackTypes(this.callbackTypes.toArray(new Class[this.callbackTypes.size()]))__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,use,cache,false,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,this,callback,filter,enhancer,set,callback,types,this,callback,types,to,array,new,class,this,callback,types,size,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1344552803;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		_		_		_		enhancer.setUseCache(false)__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(this.callbackFilter)__		enhancer.setCallbackTypes(this.callbackTypes.toArray(new Class[this.callbackTypes.size()]))__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,use,cache,false,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,this,callback,filter,enhancer,set,callback,types,this,callback,types,to,array,new,class,this,callback,types,size,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1350071785;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_TYPES)__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1352418897;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_TYPES)__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1356735495;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_TYPES)__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1357119239;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_TYPES)__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1362408075;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_TYPES)__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1363208506;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_TYPES)__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1368137140;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		enhancer.setStrategy(new DefaultGeneratorStrategy() {_			@Override_			protected ClassGenerator transform(ClassGenerator cg) throws Exception {_				ClassEmitterTransformer transformer = new ClassEmitterTransformer() {_					@Override_					public void end_class() {_						declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD,_								Type.getType(BeanFactory.class), null)__						super.end_class()__					}_				}__				return new TransformingClassGenerator(cg, transformer)__			}_		})__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,enhancer,set,strategy,new,default,generator,strategy,override,protected,class,generator,transform,class,generator,cg,throws,exception,class,emitter,transformer,transformer,new,class,emitter,transformer,override,public,void,constants,type,get,type,bean,factory,class,null,super,return,new,transforming,class,generator,cg,transformer,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1368482696;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		enhancer.setStrategy(new DefaultGeneratorStrategy() {_			@Override_			protected ClassGenerator transform(ClassGenerator cg) throws Exception {_				ClassEmitterTransformer transformer = new ClassEmitterTransformer() {_					@Override_					public void end_class() {_						declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD,_								Type.getType(BeanFactory.class), null)__						super.end_class()__					}_				}__				return new TransformingClassGenerator(cg, transformer)__			}_		})__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,enhancer,set,strategy,new,default,generator,strategy,override,protected,class,generator,transform,class,generator,cg,throws,exception,class,emitter,transformer,transformer,new,class,emitter,transformer,override,public,void,constants,type,get,type,bean,factory,class,null,super,return,new,transforming,class,generator,cg,transformer,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1372363092;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		enhancer.setStrategy(new DefaultGeneratorStrategy() {_			@Override_			protected ClassGenerator transform(ClassGenerator cg) throws Exception {_				ClassEmitterTransformer transformer = new ClassEmitterTransformer() {_					@Override_					public void end_class() {_						declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD,_								Type.getType(BeanFactory.class), null)__						super.end_class()__					}_				}__				return new TransformingClassGenerator(cg, transformer)__			}_		})__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,enhancer,set,strategy,new,default,generator,strategy,override,protected,class,generator,transform,class,generator,cg,throws,exception,class,emitter,transformer,transformer,new,class,emitter,transformer,override,public,void,constants,type,get,type,bean,factory,class,null,super,return,new,transforming,class,generator,cg,transformer,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1385159394;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		enhancer.setStrategy(new DefaultGeneratorStrategy() {_			@Override_			protected ClassGenerator transform(ClassGenerator cg) throws Exception {_				ClassEmitterTransformer transformer = new ClassEmitterTransformer() {_					@Override_					public void end_class() {_						declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD,_								Type.getType(BeanFactory.class), null)__						super.end_class()__					}_				}__				return new TransformingClassGenerator(cg, transformer)__			}_		})__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,enhancer,set,strategy,new,default,generator,strategy,override,protected,class,generator,transform,class,generator,cg,throws,exception,class,emitter,transformer,transformer,new,class,emitter,transformer,override,public,void,constants,type,get,type,bean,factory,class,null,super,return,new,transforming,class,generator,cg,transformer,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1385412762;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		enhancer.setStrategy(new DefaultGeneratorStrategy() {_			@Override_			protected ClassGenerator transform(ClassGenerator cg) throws Exception {_				ClassEmitterTransformer transformer = new ClassEmitterTransformer() {_					@Override_					public void end_class() {_						declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD,_								Type.getType(BeanFactory.class), null)__						super.end_class()__					}_				}__				return new TransformingClassGenerator(cg, transformer)__			}_		})__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,enhancer,set,strategy,new,default,generator,strategy,override,protected,class,generator,transform,class,generator,cg,throws,exception,class,emitter,transformer,transformer,new,class,emitter,transformer,override,public,void,constants,type,get,type,bean,factory,class,null,super,return,new,transforming,class,generator,cg,transformer,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1386019951;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		enhancer.setStrategy(new DefaultGeneratorStrategy() {_			@Override_			protected ClassGenerator transform(ClassGenerator cg) throws Exception {_				ClassEmitterTransformer transformer = new ClassEmitterTransformer() {_					@Override_					public void end_class() {_						declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD,_								Type.getType(BeanFactory.class), null)__						super.end_class()__					}_				}__				return new TransformingClassGenerator(cg, transformer)__			}_		})__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,enhancer,set,strategy,new,default,generator,strategy,override,protected,class,generator,transform,class,generator,cg,throws,exception,class,emitter,transformer,transformer,new,class,emitter,transformer,override,public,void,constants,type,get,type,bean,factory,class,null,super,return,new,transforming,class,generator,cg,transformer,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1391714711;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1391904536;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1409688815;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1416668785;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1417457791;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1417525010;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1417981938;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1429130993;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1429133871;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1429201126;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1432125256;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1433455782;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass);1434484897;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(GENERATOR_STRATEGY)__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1368137140;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1368482696;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1372363092;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1385159394;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1385412762;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1386019951;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1391714711;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1391904536;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1409688815;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1416668785;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1417457791;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1417525010;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1417981938;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1429130993;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1429133871;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1429201126;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1432125256;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1433455782;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1434484897;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1448383082;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1455886852;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1458754760;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1462195145;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1467808333;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1467846264;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1468948866;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1482232576;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1483047480;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1487773924;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1488891103;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1495868221;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1496263893;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1496837955;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1498780456;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1504267514;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1506097334;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1522448294;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1522580239;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1523443675;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1530174524;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1532091916;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1532706365;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1533116608;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1533598532;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName);1542899558;Check the BeanFactory to see whether the bean named <var>beanName</var> already_exists. Accounts for the fact that the requested bean may be "in creation", i.e.:_we're in the middle of servicing the initial request for this bean. From an enhanced_factory method's perspective, this means that the bean does not actually yet exist,_and that it is now our job to create it for the first time by executing the logic_in the corresponding factory method._<p>Said another way, this check repurposes_{@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether_the container is calling this method or the user is calling this method._@param beanName name of bean to check for_@return whether <var>beanName</var> already exists in the factory;private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {_			return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName))__		};check,the,bean,factory,to,see,whether,the,bean,named,var,bean,name,var,already,exists,accounts,for,the,fact,that,the,requested,bean,may,be,in,creation,i,e,we,re,in,the,middle,of,servicing,the,initial,request,for,this,bean,from,an,enhanced,factory,method,s,perspective,this,means,that,the,bean,does,not,actually,yet,exist,and,that,it,is,now,our,job,to,create,it,for,the,first,time,by,executing,the,logic,in,the,corresponding,factory,method,p,said,another,way,this,check,repurposes,link,configurable,bean,factory,is,currently,in,creation,string,to,determine,whether,the,container,is,calling,this,method,or,the,user,is,calling,this,method,param,bean,name,name,of,bean,to,check,for,return,whether,var,bean,name,var,already,exists,in,the,factory;private,boolean,factory,contains,bean,configurable,bean,factory,bean,factory,string,bean,name,return,bean,factory,contains,bean,bean,name,bean,factory,is,currently,in,creation,bean,name
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1328020251;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1344552803;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1350071785;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1352418897;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1356735495;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1357119239;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1362408075;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1363208506;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1368137140;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1368482696;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1372363092;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1385159394;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1385412762;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1386019951;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1391714711;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1391904536;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1409688815;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1416668785;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1417457791;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1417525010;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1417981938;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1429130993;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1429133871;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1429201126;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1432125256;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1433455782;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> public Class<?> enhance(Class<?> configClass);1434484897;Loads the specified class and generates a CGLIB subclass of it equipped with_container-aware callbacks capable of respecting scoping and other bean semantics._@return the enhanced subclass;public Class<?> enhance(Class<?> configClass) {_		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Ignoring request to enhance %s as it has " +_						"already been enhanced. This usually indicates that more than one " +_						"ConfigurationClassPostProcessor has been registered (e.g. via " +_						"<context:annotation-config>). This is harmless, but you may " +_						"want check your configuration and remove one CCPP if possible",_						configClass.getName()))__			}_			return configClass__		}_		Class<?> enhancedClass = createClass(newEnhancer(configClass))__		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Successfully enhanced %s_ enhanced class name is: %s",_					configClass.getName(), enhancedClass.getName()))__		}_		return enhancedClass__	};loads,the,specified,class,and,generates,a,cglib,subclass,of,it,equipped,with,container,aware,callbacks,capable,of,respecting,scoping,and,other,bean,semantics,return,the,enhanced,subclass;public,class,enhance,class,config,class,if,enhanced,configuration,class,is,assignable,from,config,class,if,logger,is,debug,enabled,logger,debug,string,format,ignoring,request,to,enhance,s,as,it,has,already,been,enhanced,this,usually,indicates,that,more,than,one,configuration,class,post,processor,has,been,registered,e,g,via,context,annotation,config,this,is,harmless,but,you,may,want,check,your,configuration,and,remove,one,ccpp,if,possible,config,class,get,name,return,config,class,class,enhanced,class,create,class,new,enhancer,config,class,if,logger,is,debug,enabled,logger,debug,string,format,successfully,enhanced,s,enhanced,class,name,is,s,config,class,get,name,enhanced,class,get,name,return,enhanced,class
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1328020251;Uses enhancer to generate a subclass of superclass, ensuring that_{@link #callbackInstances} are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		Enhancer.registerStaticCallbacks(subclass, this.callbackInstances.toArray(new Callback[this.callbackInstances.size()]))__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,link,callback,instances,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,this,callback,instances,to,array,new,callback,this,callback,instances,size,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1344552803;Uses enhancer to generate a subclass of superclass, ensuring that_{@link #callbackInstances} are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		Enhancer.registerStaticCallbacks(subclass, this.callbackInstances.toArray(new Callback[this.callbackInstances.size()]))__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,link,callback,instances,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,this,callback,instances,to,array,new,callback,this,callback,instances,size,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1350071785;Uses enhancer to generate a subclass of superclass, ensuring that_{@link #callbackInstances} are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		Enhancer.registerStaticCallbacks(subclass, this.callbackInstances)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,link,callback,instances,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,this,callback,instances,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1352418897;Uses enhancer to generate a subclass of superclass, ensuring that_{@link #callbackInstances} are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		Enhancer.registerStaticCallbacks(subclass, this.callbackInstances)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,link,callback,instances,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,this,callback,instances,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1356735495;Uses enhancer to generate a subclass of superclass, ensuring that_{@link #callbackInstances} are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		Enhancer.registerStaticCallbacks(subclass, this.callbackInstances)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,link,callback,instances,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,this,callback,instances,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1357119239;Uses enhancer to generate a subclass of superclass, ensuring that_{@link #callbackInstances} are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		Enhancer.registerStaticCallbacks(subclass, this.callbackInstances)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,link,callback,instances,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,this,callback,instances,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1362408075;Uses enhancer to generate a subclass of superclass, ensuring that_{@link #callbackInstances} are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		Enhancer.registerStaticCallbacks(subclass, this.callbackInstances)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,link,callback,instances,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,this,callback,instances,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1363208506;Uses enhancer to generate a subclass of superclass, ensuring that_{@link #callbackInstances} are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		Enhancer.registerStaticCallbacks(subclass, this.callbackInstances)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,link,callback,instances,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,this,callback,instances,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1368137140;Uses enhancer to generate a subclass of superclass, ensuring that_{@link #callbackInstances} are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,link,callback,instances,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1368482696;Uses enhancer to generate a subclass of superclass, ensuring that_{@link #callbackInstances} are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,link,callback,instances,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1372363092;Uses enhancer to generate a subclass of superclass, ensuring that_{@link #callbackInstances} are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,link,callback,instances,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1385159394;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1385412762;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1386019951;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1391714711;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1391904536;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1409688815;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1416668785;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1417457791;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1417525010;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1417981938;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1429130993;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1429133871;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1429201126;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1432125256;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1433455782;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1434484897;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1448383082;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1455886852;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1458754760;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1462195145;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1467808333;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1467846264;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1468948866;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1482232576;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1483047480;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1487773924;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1488891103;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1495868221;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1496263893;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1496837955;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1498780456;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1504267514;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1506097334;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1522448294;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1522580239;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1523443675;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1530174524;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1532091916;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1532706365;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1533116608;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1533598532;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> private Class<?> createClass(Enhancer enhancer);1542899558;Uses enhancer to generate a subclass of superclass,_ensuring that callbacks are registered for the new subclass.;private Class<?> createClass(Enhancer enhancer) {_		Class<?> subclass = enhancer.createClass()__		_		_		Enhancer.registerStaticCallbacks(subclass, CALLBACKS)__		return subclass__	};uses,enhancer,to,generate,a,subclass,of,superclass,ensuring,that,callbacks,are,registered,for,the,new,subclass;private,class,create,class,enhancer,enhancer,class,subclass,enhancer,create,class,enhancer,register,static,callbacks,subclass,callbacks,return,subclass
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1429130993;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setUseFactory(false)__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1429133871;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setUseFactory(false)__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1429201126;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setUseFactory(false)__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1432125256;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setUseFactory(false)__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallback(new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})__			return enhancer.create()__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,enhancer,create
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, 				final String beanName) throws InstantiationException, IllegalAccessException;1433455782;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory,_				final String beanName) throws InstantiationException, IllegalAccessException {__			Enhancer enhancer = new Enhancer()__			enhancer.setSuperclass(factoryBean.getClass())__			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__			enhancer.setCallbackType(MethodInterceptor.class)___			_			_			Class<?> fbClass = enhancer.createClass()__			Objenesis objenesis = (enhancer.getUseCache() ? cachedObjenesis : nonCachedObjenesis)__			Factory factory__			try {_				factory = (Factory) objenesis.newInstance(fbClass)__			}_			catch (ObjenesisException ex) {_				_				logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " +_						"falling back to regular construction", ex)__				factory = (Factory) fbClass.newInstance()__			}__			factory.setCallback(0, new MethodInterceptor() {_				@Override_				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {_					if (method.getName().equals("getObject") && args.length == 0) {_						return beanFactory.getBean(beanName)__					}_					return proxy.invoke(factoryBean, args)__				}_			})___			return factory__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,final,configurable,bean,factory,bean,factory,final,string,bean,name,throws,instantiation,exception,illegal,access,exception,enhancer,enhancer,new,enhancer,enhancer,set,superclass,factory,bean,get,class,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,callback,type,method,interceptor,class,class,fb,class,enhancer,create,class,objenesis,objenesis,enhancer,get,use,cache,cached,objenesis,non,cached,objenesis,factory,factory,try,factory,factory,objenesis,new,instance,fb,class,catch,objenesis,exception,ex,logger,debug,unable,to,instantiate,enhanced,factory,bean,using,objenesis,falling,back,to,regular,construction,ex,factory,factory,fb,class,new,instance,factory,set,callback,0,new,method,interceptor,override,public,object,intercept,object,obj,method,method,object,args,method,proxy,proxy,throws,throwable,if,method,get,name,equals,get,object,args,length,0,return,bean,factory,get,bean,bean,name,return,proxy,invoke,factory,bean,args,return,factory
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1487773924;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1488891103;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1495868221;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1496263893;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1496837955;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1498780456;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1504267514;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1506097334;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1522448294;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1522580239;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1523443675;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1530174524;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isDebugEnabled()) {_							logger.debug("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isInfoEnabled()) {_							logger.info("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,debug,enabled,logger,debug,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,info,enabled,logger,info,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1532091916;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isTraceEnabled()) {_							logger.trace("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isDebugEnabled()) {_							logger.debug("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,trace,enabled,logger,trace,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,debug,enabled,logger,debug,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1532706365;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isTraceEnabled()) {_							logger.trace("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isDebugEnabled()) {_							logger.debug("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,trace,enabled,logger,trace,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,debug,enabled,logger,debug,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1533116608;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isTraceEnabled()) {_							logger.trace("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isDebugEnabled()) {_							logger.debug("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,trace,enabled,logger,trace,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,debug,enabled,logger,debug,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1533598532;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isTraceEnabled()) {_							logger.trace("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isDebugEnabled()) {_							logger.debug("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,trace,enabled,logger,trace,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,debug,enabled,logger,debug,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, 				final ConfigurableBeanFactory beanFactory, final String beanName);1542899558;Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory_instead of creating a new instance. These proxies are created only when calling a FactoryBean from_within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean_instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,_it will not be proxied. This too is aligned with the way XML configuration works.;private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType,_				final ConfigurableBeanFactory beanFactory, final String beanName) {__			try {_				Class<?> clazz = factoryBean.getClass()__				boolean finalClass = Modifier.isFinal(clazz.getModifiers())__				boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers())__				if (finalClass || finalMethod) {_					if (exposedType.isInterface()) {_						if (logger.isTraceEnabled()) {_							logger.trace("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: Otherwise a getObject() call would not be routed to the factory.")__						}_						return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName)__					}_					else {_						if (logger.isDebugEnabled()) {_							logger.debug("Unable to proxy FactoryBean '" + beanName + "' of type [" +_									clazz.getName() + "] for use within another @Bean method because its " +_									(finalClass ? "implementation class" : "getObject() method") +_									" is final: A getObject() call will NOT be routed to the factory. " +_									"Consider declaring the return type as a FactoryBean interface.")__						}_						return factoryBean__					}_				}_			}_			catch (NoSuchMethodException ex) {_				_			}__			return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName)__		};create,a,subclass,proxy,that,intercepts,calls,to,get,object,delegating,to,the,current,bean,factory,instead,of,creating,a,new,instance,these,proxies,are,created,only,when,calling,a,factory,bean,from,within,a,bean,method,allowing,for,proper,scoping,semantics,even,when,working,against,the,factory,bean,instance,directly,if,a,factory,bean,instance,is,fetched,through,the,container,via,dereferencing,it,will,not,be,proxied,this,too,is,aligned,with,the,way,xml,configuration,works;private,object,enhance,factory,bean,final,object,factory,bean,class,exposed,type,final,configurable,bean,factory,bean,factory,final,string,bean,name,try,class,clazz,factory,bean,get,class,boolean,final,class,modifier,is,final,clazz,get,modifiers,boolean,final,method,modifier,is,final,clazz,get,method,get,object,get,modifiers,if,final,class,final,method,if,exposed,type,is,interface,if,logger,is,trace,enabled,logger,trace,creating,interface,proxy,for,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,otherwise,a,get,object,call,would,not,be,routed,to,the,factory,return,create,interface,proxy,for,factory,bean,factory,bean,exposed,type,bean,factory,bean,name,else,if,logger,is,debug,enabled,logger,debug,unable,to,proxy,factory,bean,bean,name,of,type,clazz,get,name,for,use,within,another,bean,method,because,its,final,class,implementation,class,get,object,method,is,final,a,get,object,call,will,not,be,routed,to,the,factory,consider,declaring,the,return,type,as,a,factory,bean,interface,return,factory,bean,catch,no,such,method,exception,ex,return,create,cglib,proxy,for,factory,bean,factory,bean,bean,factory,bean,name
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, @Nullable ClassLoader classLoader);1498780456;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, @Nullable ClassLoader classLoader);1504267514;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, @Nullable ClassLoader classLoader);1506097334;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, @Nullable ClassLoader classLoader);1522448294;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> private Enhancer newEnhancer(Class<?> superclass, @Nullable ClassLoader classLoader);1522580239;Creates a new CGLIB {@link Enhancer} instance.;private Enhancer newEnhancer(Class<?> superclass, @Nullable ClassLoader classLoader) {_		Enhancer enhancer = new Enhancer()__		enhancer.setSuperclass(superclass)__		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class})__		enhancer.setUseFactory(false)__		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE)__		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))__		enhancer.setCallbackFilter(CALLBACK_FILTER)__		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes())__		return enhancer__	};creates,a,new,cglib,link,enhancer,instance;private,enhancer,new,enhancer,class,superclass,nullable,class,loader,class,loader,enhancer,enhancer,new,enhancer,enhancer,set,superclass,superclass,enhancer,set,interfaces,new,class,enhanced,configuration,class,enhancer,set,use,factory,false,enhancer,set,naming,policy,spring,naming,policy,instance,enhancer,set,strategy,new,bean,factory,aware,generator,strategy,class,loader,enhancer,set,callback,filter,enhancer,set,callback,types,get,callback,types,return,enhancer
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		@Nullable 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1504267514;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		@Nullable_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,nullable,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,resolve,bean,reference,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		@Nullable 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1506097334;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		@Nullable_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,nullable,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,resolve,bean,reference,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		@Nullable 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1522448294;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		@Nullable_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,nullable,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,resolve,bean,reference,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		@Nullable 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1522580239;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		@Nullable_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,nullable,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,resolve,bean,reference,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		@Nullable 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1523443675;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		@Nullable_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,nullable,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,resolve,bean,reference,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		@Nullable 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1530174524;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		@Nullable_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isWarnEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,nullable,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,warn,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,resolve,bean,reference,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		@Nullable 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1532091916;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		@Nullable_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isInfoEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.info(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,nullable,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,info,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,info,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,resolve,bean,reference,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		@Nullable 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1532706365;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		@Nullable_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isInfoEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.info(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,nullable,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotated,element,utils,find,merged,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,info,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,info,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,resolve,bean,reference,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		@Nullable 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1533116608;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		@Nullable_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			if (BeanAnnotationHelper.isScopedProxy(beanMethod)) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isInfoEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.info(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,nullable,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,if,bean,annotation,helper,is,scoped,proxy,bean,method,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,info,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,info,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,resolve,bean,reference,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		@Nullable 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1533598532;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		@Nullable_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			if (BeanAnnotationHelper.isScopedProxy(beanMethod)) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isInfoEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.info(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,nullable,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,if,bean,annotation,helper,is,scoped,proxy,bean,method,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,info,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,info,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,resolve,bean,reference,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> @Override 		@Nullable 		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1542899558;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when invoking the_super implementation of the proxied method i.e., the actual {@code @Bean} method;@Override_		@Nullable_		public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			if (BeanAnnotationHelper.isScopedProxy(beanMethod)) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod)) {_				_				_				_				if (logger.isInfoEnabled() &&_						BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.info(String.format("@Bean method %s.%s is non-static and returns an object " +_									"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_									"result in a failure to process annotations such as @Autowired, " +_									"@Resource and @PostConstruct within the method's declaring " +_									"@Configuration class. Add the 'static' modifier to this method to avoid " +_									"these container lifecycle issues_ see @Bean javadoc for complete details.",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}__			return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName)__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;override,nullable,public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,if,bean,annotation,helper,is,scoped,proxy,bean,method,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,bean,method,get,return,type,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,if,logger,is,info,enabled,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,info,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,return,resolve,bean,reference,bean,method,bean,method,args,bean,factory,bean,name
ConfigurationClassEnhancer -> BeanMethodInterceptor -> public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1328020251;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object.__@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (this.beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			_			_			_			_			_			_			if (factoryContainsBean('&'+beanName) && factoryContainsBean(beanName)) {_				Object factoryBean = this.beanFactory.getBean('&'+beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanName)__				}_			}__			boolean factoryIsCaller = beanMethod.equals(SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod())__			boolean factoryAlreadyContainsSingleton = this.beanFactory.containsSingleton(beanName)__			if (factoryIsCaller && !factoryAlreadyContainsSingleton) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return this.beanFactory.getBean(beanName)__				} finally {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,this,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,name,factory,contains,bean,bean,name,object,factory,bean,this,bean,factory,get,bean,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,name,boolean,factory,is,caller,bean,method,equals,simple,instantiation,strategy,get,currently,invoked,factory,method,boolean,factory,already,contains,singleton,this,bean,factory,contains,singleton,bean,name,if,factory,is,caller,factory,already,contains,singleton,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,this,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,false,return,this,bean,factory,get,bean,bean,name,finally,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1344552803;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object.__@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (this.beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			_			_			_			_			_			_			if (factoryContainsBean('&'+beanName) && factoryContainsBean(beanName)) {_				Object factoryBean = this.beanFactory.getBean('&'+beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanName)__				}_			}__			boolean factoryIsCaller = beanMethod.equals(SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod())__			boolean factoryAlreadyContainsSingleton = this.beanFactory.containsSingleton(beanName)__			if (factoryIsCaller && !factoryAlreadyContainsSingleton) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return this.beanFactory.getBean(beanName)__				} finally {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,this,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,name,factory,contains,bean,bean,name,object,factory,bean,this,bean,factory,get,bean,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,name,boolean,factory,is,caller,bean,method,equals,simple,instantiation,strategy,get,currently,invoked,factory,method,boolean,factory,already,contains,singleton,this,bean,factory,contains,singleton,bean,name,if,factory,is,caller,factory,already,contains,singleton,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,this,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,false,return,this,bean,factory,get,bean,bean,name,finally,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1350071785;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object.__@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (this.beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean('&'+beanName) && factoryContainsBean(beanName)) {_				Object factoryBean = this.beanFactory.getBean('&'+beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanName)__				}_			}__			boolean factoryIsCaller = beanMethod.equals(SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod())__			boolean factoryAlreadyContainsSingleton = this.beanFactory.containsSingleton(beanName)__			if (factoryIsCaller && !factoryAlreadyContainsSingleton) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return this.beanFactory.getBean(beanName)__				} finally {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,this,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,name,factory,contains,bean,bean,name,object,factory,bean,this,bean,factory,get,bean,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,name,boolean,factory,is,caller,bean,method,equals,simple,instantiation,strategy,get,currently,invoked,factory,method,boolean,factory,already,contains,singleton,this,bean,factory,contains,singleton,bean,name,if,factory,is,caller,factory,already,contains,singleton,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,this,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,false,return,this,bean,factory,get,bean,bean,name,finally,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1352418897;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object.__@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (this.beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean('&'+beanName) && factoryContainsBean(beanName)) {_				Object factoryBean = this.beanFactory.getBean('&'+beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanName)__				}_			}__			boolean factoryIsCaller = beanMethod.equals(SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod())__			boolean factoryAlreadyContainsSingleton = this.beanFactory.containsSingleton(beanName)__			if (factoryIsCaller && !factoryAlreadyContainsSingleton) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return this.beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,this,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,name,factory,contains,bean,bean,name,object,factory,bean,this,bean,factory,get,bean,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,name,boolean,factory,is,caller,bean,method,equals,simple,instantiation,strategy,get,currently,invoked,factory,method,boolean,factory,already,contains,singleton,this,bean,factory,contains,singleton,bean,name,if,factory,is,caller,factory,already,contains,singleton,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,this,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,false,return,this,bean,factory,get,bean,bean,name,finally,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1357119239;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object.__@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (this.beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean('&'+beanName) && factoryContainsBean(beanName)) {_				Object factoryBean = this.beanFactory.getBean('&'+beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanName)__				}_			}__			boolean factoryIsCaller = beanMethod.equals(SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod())__			boolean factoryAlreadyContainsSingleton = this.beanFactory.containsSingleton(beanName)__			if (factoryIsCaller && !factoryAlreadyContainsSingleton) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return this.beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,this,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,name,factory,contains,bean,bean,name,object,factory,bean,this,bean,factory,get,bean,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,name,boolean,factory,is,caller,bean,method,equals,simple,instantiation,strategy,get,currently,invoked,factory,method,boolean,factory,already,contains,singleton,this,bean,factory,contains,singleton,bean,name,if,factory,is,caller,factory,already,contains,singleton,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,this,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,false,return,this,bean,factory,get,bean,bean,name,finally,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1362408075;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (this.beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName) && factoryContainsBean(beanName)) {_				Object factoryBean = this.beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod) && !this.beanFactory.containsSingleton(beanName)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return this.beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,this,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,name,factory,contains,bean,bean,name,object,factory,bean,this,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,name,if,is,currently,invoked,factory,method,bean,method,this,bean,factory,contains,singleton,bean,name,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,this,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,false,return,this,bean,factory,get,bean,bean,name,finally,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1363208506;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (this.beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName) && factoryContainsBean(beanName)) {_				Object factoryBean = this.beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod) && !this.beanFactory.containsSingleton(beanName)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = this.beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return this.beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						this.beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}__		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,this,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,name,factory,contains,bean,bean,name,object,factory,bean,this,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,name,if,is,currently,invoked,factory,method,bean,method,this,bean,factory,contains,singleton,bean,name,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,this,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,false,return,this,bean,factory,get,bean,bean,name,finally,if,already,in,creation,this,bean,factory,set,currently,in,creation,bean,name,true
ConfigurationClassEnhancer -> BeanMethodInterceptor -> public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, 					MethodProxy cglibMethodProxy) throws Throwable;1368137140;Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the_existence of this bean object._@throws Throwable as a catch-all for any exception that may be thrown when_invoking the super implementation of the proxied method i.e., the actual_{@code @Bean} method.;public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,_					MethodProxy cglibMethodProxy) throws Throwable {__			ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)__			String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)___			_			Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)__			if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {_				String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)__				if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {_					beanName = scopedBeanName__				}_			}__			_			__			_			_			_			_			if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&_					factoryContainsBean(beanFactory, beanName)) {_				Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)__				if (factoryBean instanceof ScopedProxyFactoryBean) {_					_					_				}_				else {_					_					return enhanceFactoryBean(factoryBean.getClass(), beanFactory, beanName)__				}_			}__			if (isCurrentlyInvokedFactoryMethod(beanMethod) && !beanFactory.containsSingleton(beanName)) {_				_				_				_				if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {_					logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +_							"assignable to Spring's BeanFactoryPostProcessor interface. This will " +_							"result in a failure to process annotations such as @Autowired, " +_							"@Resource and @PostConstruct within the method's declaring " +_							"@Configuration class. Add the 'static' modifier to this method to avoid " +_							"these container lifecycle issues_ see @Bean Javadoc for complete details",_							beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))__				}_				return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)__			}_			else {_				_				_				_				_				boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)__				try {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, false)__					}_					return beanFactory.getBean(beanName)__				}_				finally {_					if (alreadyInCreation) {_						beanFactory.setCurrentlyInCreation(beanName, true)__					}_				}_			}_		};enhance,a,link,bean,bean,method,to,check,the,supplied,bean,factory,for,the,existence,of,this,bean,object,throws,throwable,as,a,catch,all,for,any,exception,that,may,be,thrown,when,invoking,the,super,implementation,of,the,proxied,method,i,e,the,actual,code,bean,method;public,object,intercept,object,enhanced,config,instance,method,bean,method,object,bean,method,args,method,proxy,cglib,method,proxy,throws,throwable,configurable,bean,factory,bean,factory,get,bean,factory,enhanced,config,instance,string,bean,name,bean,annotation,helper,determine,bean,name,for,bean,method,scope,scope,annotation,utils,find,annotation,bean,method,scope,class,if,scope,null,scope,proxy,mode,scoped,proxy,mode,no,string,scoped,bean,name,scoped,proxy,creator,get,target,bean,name,bean,name,if,bean,factory,is,currently,in,creation,scoped,bean,name,bean,name,scoped,bean,name,if,factory,contains,bean,bean,factory,bean,factory,bean,name,factory,contains,bean,bean,factory,bean,name,object,factory,bean,bean,factory,get,bean,bean,factory,bean,name,if,factory,bean,instanceof,scoped,proxy,factory,bean,else,return,enhance,factory,bean,factory,bean,get,class,bean,factory,bean,name,if,is,currently,invoked,factory,method,bean,method,bean,factory,contains,singleton,bean,name,if,bean,factory,post,processor,class,is,assignable,from,bean,method,get,return,type,logger,warn,string,format,bean,method,s,s,is,non,static,and,returns,an,object,assignable,to,spring,s,bean,factory,post,processor,interface,this,will,result,in,a,failure,to,process,annotations,such,as,autowired,resource,and,post,construct,within,the,method,s,declaring,configuration,class,add,the,static,modifier,to,this,method,to,avoid,these,container,lifecycle,issues,see,bean,javadoc,for,complete,details,bean,method,get,declaring,class,get,simple,name,bean,method,get,name,return,cglib,method,proxy,invoke,super,enhanced,config,instance,bean,method,args,else,boolean,already,in,creation,bean,factory,is,currently,in,creation,bean,name,try,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,false,return,bean,factory,get,bean,bean,name,finally,if,already,in,creation,bean,factory,set,currently,in,creation,bean,name,true
