commented;modifiers;parameterAmount;loc;comment;code
true;public;2;19;/**  * Loads the specified class and generates a CGLIB subclass of it equipped with  * container-aware callbacks capable of respecting scoping and other bean semantics.  * @return the enhanced subclass  */ ;/**  * Loads the specified class and generates a CGLIB subclass of it equipped with  * container-aware callbacks capable of respecting scoping and other bean semantics.  * @return the enhanced subclass  */ public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {     if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {         if (logger.isDebugEnabled()) {             logger.debug(String.format("Ignoring request to enhance %s as it has " + "already been enhanced. This usually indicates that more than one " + "ConfigurationClassPostProcessor has been registered (e.g. via " + "<context:annotation-config>). This is harmless, but you may " + "want check your configuration and remove one CCPP if possible", configClass.getName())).         }         return configClass.     }     Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader)).     if (logger.isTraceEnabled()) {         logger.trace(String.format("Successfully enhanced %s. enhanced class name is: %s", configClass.getName(), enhancedClass.getName())).     }     return enhancedClass. }
true;private;2;11;/**  * Creates a new CGLIB {@link Enhancer} instance.  */ ;/**  * Creates a new CGLIB {@link Enhancer} instance.  */ private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {     Enhancer enhancer = new Enhancer().     enhancer.setSuperclass(configSuperClass).     enhancer.setInterfaces(new Class<?>[] { EnhancedConfiguration.class }).     enhancer.setUseFactory(false).     enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE).     enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader)).     enhancer.setCallbackFilter(CALLBACK_FILTER).     enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes()).     return enhancer. }
true;private;1;7;/**  * Uses enhancer to generate a subclass of superclass,  * ensuring that callbacks are registered for the new subclass.  */ ;/**  * Uses enhancer to generate a subclass of superclass,  * ensuring that callbacks are registered for the new subclass.  */ private Class<?> createClass(Enhancer enhancer) {     Class<?> subclass = enhancer.createClass().     // Registering callbacks statically (as opposed to thread-local)     // is critical for usage in an OSGi environment (SPR-5932)...     Enhancer.registerStaticCallbacks(subclass, CALLBACKS).     return subclass. }
false;;1;1;;boolean isMatch(Method candidateMethod).
false;public;1;10;;@Override public int accept(Method method) {     for (int i = 0. i < this.callbacks.length. i++) {         Callback callback = this.callbacks[i].         if (!(callback instanceof ConditionalCallback) || ((ConditionalCallback) callback).isMatch(method)) {             return i.         }     }     throw new IllegalStateException("No callback available for method " + method.getName()). }
false;public;0;3;;public Class<?>[] getCallbackTypes() {     return this.callbackTypes. }
false;public;0;5;;@Override public void end_class() {     declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD, Type.getType(BeanFactory.class), null).     super.end_class(). }
false;protected;1;11;;@Override protected ClassGenerator transform(ClassGenerator cg) throws Exception {     ClassEmitterTransformer transformer = new ClassEmitterTransformer() {          @Override         public void end_class() {             declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD, Type.getType(BeanFactory.class), null).             super.end_class().         }     }.     return new TransformingClassGenerator(cg, transformer). }
false;public;1;30;;@Override public byte[] generate(ClassGenerator cg) throws Exception {     if (this.classLoader == null) {         return super.generate(cg).     }     Thread currentThread = Thread.currentThread().     ClassLoader threadContextClassLoader.     try {         threadContextClassLoader = currentThread.getContextClassLoader().     } catch (Throwable ex) {         // Cannot access thread context ClassLoader - falling back...         return super.generate(cg).     }     boolean overrideClassLoader = !this.classLoader.equals(threadContextClassLoader).     if (overrideClassLoader) {         currentThread.setContextClassLoader(this.classLoader).     }     try {         return super.generate(cg).     } finally {         if (overrideClassLoader) {             // Reset original thread context ClassLoader.             currentThread.setContextClassLoader(threadContextClassLoader).         }     } }
false;public;4;14;;@Override @Nullable public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {     Field field = ReflectionUtils.findField(obj.getClass(), BEAN_FACTORY_FIELD).     Assert.state(field != null, "Unable to find generated BeanFactory field").     field.set(obj, args[0]).     // If so, call its setBeanFactory() method. If not, just exit.     if (BeanFactoryAware.class.isAssignableFrom(ClassUtils.getUserClass(obj.getClass().getSuperclass()))) {         return proxy.invokeSuper(obj, args).     }     return null. }
false;public;1;4;;@Override public boolean isMatch(Method candidateMethod) {     return isSetBeanFactory(candidateMethod). }
false;public,static;1;6;;public static boolean isSetBeanFactory(Method candidateMethod) {     return (candidateMethod.getName().equals("setBeanFactory") && candidateMethod.getParameterCount() == 1 && BeanFactory.class == candidateMethod.getParameterTypes()[0] && BeanFactoryAware.class.isAssignableFrom(candidateMethod.getDeclaringClass())). }
true;public;4;54;/**  * Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the  * existence of this bean object.  * @throws Throwable as a catch-all for any exception that may be thrown when invoking the  * super implementation of the proxied method i.e., the actual {@code @Bean} method  */ ;/**  * Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the  * existence of this bean object.  * @throws Throwable as a catch-all for any exception that may be thrown when invoking the  * super implementation of the proxied method i.e., the actual {@code @Bean} method  */ @Override @Nullable public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable {     ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance).     String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod).     // Determine whether this bean is a scoped-proxy     if (BeanAnnotationHelper.isScopedProxy(beanMethod)) {         String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName).         if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {             beanName = scopedBeanName.         }     }     // is the same as that of referring to a FactoryBean within XML. See SPR-6602.     if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) && factoryContainsBean(beanFactory, beanName)) {         Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName).         if (factoryBean instanceof ScopedProxyFactoryBean) {         // Scoped proxy factory beans are a special case and should not be further proxied         } else {             // It is a candidate FactoryBean - go ahead with enhancement             return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName).         }     }     if (isCurrentlyInvokedFactoryMethod(beanMethod)) {         // create the bean instance.         if (logger.isInfoEnabled() && BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {             logger.info(String.format("@Bean method %s.%s is non-static and returns an object " + "assignable to Spring's BeanFactoryPostProcessor interface. This will " + "result in a failure to process annotations such as @Autowired, " + "@Resource and @PostConstruct within the method's declaring " + "@Configuration class. Add the 'static' modifier to this method to avoid " + "these container lifecycle issues. see @Bean javadoc for complete details.", beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName())).         }         return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs).     }     return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName). }
false;private;4;65;;private Object resolveBeanReference(Method beanMethod, Object[] beanMethodArgs, ConfigurableBeanFactory beanFactory, String beanName) {     // The user (i.e. not the factory) is requesting this bean through a call to     // the bean method, direct or indirect. The bean may have already been marked     // as 'in creation' in certain autowiring scenarios. if so, temporarily set     // the in-creation status to false in order to avoid an exception.     boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName).     try {         if (alreadyInCreation) {             beanFactory.setCurrentlyInCreation(beanName, false).         }         boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs).         if (useArgs && beanFactory.isSingleton(beanName)) {             // A safe assumption since @Bean singleton arguments cannot be optional...             for (Object arg : beanMethodArgs) {                 if (arg == null) {                     useArgs = false.                     break.                 }             }         }         Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName)).         if (!ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {             // Detect package-protected NullBean instance through equals(null) check             if (beanInstance.equals(null)) {                 if (logger.isDebugEnabled()) {                     logger.debug(String.format("@Bean method %s.%s called as bean reference " + "for type [%s] returned null bean. resolving to null value.", beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(), beanMethod.getReturnType().getName())).                 }                 beanInstance = null.             } else {                 String msg = String.format("@Bean method %s.%s called as bean reference " + "for type [%s] but overridden by non-compatible bean instance of type [%s].", beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(), beanMethod.getReturnType().getName(), beanInstance.getClass().getName()).                 try {                     BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName).                     msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription().                 } catch (NoSuchBeanDefinitionException ex) {                 // Ignore - simply no detailed message then.                 }                 throw new IllegalStateException(msg).             }         }         Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod().         if (currentlyInvoked != null) {             String outerBeanName = BeanAnnotationHelper.determineBeanNameFor(currentlyInvoked).             beanFactory.registerDependentBean(beanName, outerBeanName).         }         return beanInstance.     } finally {         if (alreadyInCreation) {             beanFactory.setCurrentlyInCreation(beanName, true).         }     } }
false;public;1;6;;@Override public boolean isMatch(Method candidateMethod) {     return (candidateMethod.getDeclaringClass() != Object.class && !BeanFactoryAwareMethodInterceptor.isSetBeanFactory(candidateMethod) && BeanAnnotationHelper.isBeanAnnotated(candidateMethod)). }
false;private;1;9;;private ConfigurableBeanFactory getBeanFactory(Object enhancedConfigInstance) {     Field field = ReflectionUtils.findField(enhancedConfigInstance.getClass(), BEAN_FACTORY_FIELD).     Assert.state(field != null, "Unable to find generated bean factory field").     Object beanFactory = ReflectionUtils.getField(field, enhancedConfigInstance).     Assert.state(beanFactory != null, "BeanFactory has not been injected into @Configuration class").     Assert.state(beanFactory instanceof ConfigurableBeanFactory, "Injected BeanFactory is not a ConfigurableBeanFactory").     return (ConfigurableBeanFactory) beanFactory. }
true;private;2;3;/**  * Check the BeanFactory to see whether the bean named <var>beanName</var> already  * exists. Accounts for the fact that the requested bean may be "in creation", i.e.:  * we're in the middle of servicing the initial request for this bean. From an enhanced  * factory method's perspective, this means that the bean does not actually yet exist,  * and that it is now our job to create it for the first time by executing the logic  * in the corresponding factory method.  * <p>Said another way, this check repurposes  * {@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether  * the container is calling this method or the user is calling this method.  * @param beanName name of bean to check for  * @return whether <var>beanName</var> already exists in the factory  */ ;/**  * Check the BeanFactory to see whether the bean named <var>beanName</var> already  * exists. Accounts for the fact that the requested bean may be "in creation", i.e.:  * we're in the middle of servicing the initial request for this bean. From an enhanced  * factory method's perspective, this means that the bean does not actually yet exist,  * and that it is now our job to create it for the first time by executing the logic  * in the corresponding factory method.  * <p>Said another way, this check repurposes  * {@link ConfigurableBeanFactory#isCurrentlyInCreation(String)} to determine whether  * the container is calling this method or the user is calling this method.  * @param beanName name of bean to check for  * @return whether <var>beanName</var> already exists in the factory  */ private boolean factoryContainsBean(ConfigurableBeanFactory beanFactory, String beanName) {     return (beanFactory.containsBean(beanName) && !beanFactory.isCurrentlyInCreation(beanName)). }
true;private;1;5;/**  * Check whether the given method corresponds to the container's currently invoked  * factory method. Compares method name and parameter types only in order to work  * around a potential problem with covariant return types (currently only known  * to happen on Groovy classes).  */ ;/**  * Check whether the given method corresponds to the container's currently invoked  * factory method. Compares method name and parameter types only in order to work  * around a potential problem with covariant return types (currently only known  * to happen on Groovy classes).  */ private boolean isCurrentlyInvokedFactoryMethod(Method method) {     Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod().     return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) && Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes())). }
true;private;4;35;/**  * Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory  * instead of creating a new instance. These proxies are created only when calling a FactoryBean from  * within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean  * instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,  * it will not be proxied. This too is aligned with the way XML configuration works.  */ ;/**  * Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory  * instead of creating a new instance. These proxies are created only when calling a FactoryBean from  * within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean  * instance directly. If a FactoryBean instance is fetched through the container via &-dereferencing,  * it will not be proxied. This too is aligned with the way XML configuration works.  */ private Object enhanceFactoryBean(final Object factoryBean, Class<?> exposedType, final ConfigurableBeanFactory beanFactory, final String beanName) {     try {         Class<?> clazz = factoryBean.getClass().         boolean finalClass = Modifier.isFinal(clazz.getModifiers()).         boolean finalMethod = Modifier.isFinal(clazz.getMethod("getObject").getModifiers()).         if (finalClass || finalMethod) {             if (exposedType.isInterface()) {                 if (logger.isTraceEnabled()) {                     logger.trace("Creating interface proxy for FactoryBean '" + beanName + "' of type [" + clazz.getName() + "] for use within another @Bean method because its " + (finalClass ? "implementation class" : "getObject() method") + " is final: Otherwise a getObject() call would not be routed to the factory.").                 }                 return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName).             } else {                 if (logger.isDebugEnabled()) {                     logger.debug("Unable to proxy FactoryBean '" + beanName + "' of type [" + clazz.getName() + "] for use within another @Bean method because its " + (finalClass ? "implementation class" : "getObject() method") + " is final: A getObject() call will NOT be routed to the factory. " + "Consider declaring the return type as a FactoryBean interface.").                 }                 return factoryBean.             }         }     } catch (NoSuchMethodException ex) {     // No getObject() method -> shouldn't happen, but as long as nobody is trying to call it...     }     return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName). }
false;private;4;12;;private Object createInterfaceProxyForFactoryBean(final Object factoryBean, Class<?> interfaceType, final ConfigurableBeanFactory beanFactory, final String beanName) {     return Proxy.newProxyInstance(factoryBean.getClass().getClassLoader(), new Class<?>[] { interfaceType }, (proxy, method, args) -> {         if (method.getName().equals("getObject") && args == null) {             return beanFactory.getBean(beanName).         }         return ReflectionUtils.invokeMethod(method, factoryBean, args).     }). }
false;private;3;42;;private Object createCglibProxyForFactoryBean(final Object factoryBean, final ConfigurableBeanFactory beanFactory, final String beanName) {     Enhancer enhancer = new Enhancer().     enhancer.setSuperclass(factoryBean.getClass()).     enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE).     enhancer.setCallbackType(MethodInterceptor.class).     // Ideally create enhanced FactoryBean proxy without constructor side effects,     // analogous to AOP proxy creation in ObjenesisCglibAopProxy...     Class<?> fbClass = enhancer.createClass().     Object fbProxy = null.     if (objenesis.isWorthTrying()) {         try {             fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache()).         } catch (ObjenesisException ex) {             logger.debug("Unable to instantiate enhanced FactoryBean using Objenesis, " + "falling back to regular construction", ex).         }     }     if (fbProxy == null) {         try {             fbProxy = ReflectionUtils.accessibleConstructor(fbClass).newInstance().         } catch (Throwable ex) {             throw new IllegalStateException("Unable to instantiate enhanced FactoryBean using Objenesis, " + "and regular FactoryBean instantiation via default constructor fails as well", ex).         }     }     ((Factory) fbProxy).setCallback(0, (MethodInterceptor) (obj, method, args, proxy) -> {         if (method.getName().equals("getObject") && args.length == 0) {             return beanFactory.getBean(beanName).         }         return proxy.invoke(factoryBean, args).     }).     return fbProxy. }
