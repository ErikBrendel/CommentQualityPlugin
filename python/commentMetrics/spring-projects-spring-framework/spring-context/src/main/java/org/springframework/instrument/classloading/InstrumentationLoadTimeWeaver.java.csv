commented;modifiers;parameterAmount;loc;comment;code
false;public;1;12;;@Override public void addTransformer(ClassFileTransformer transformer) {     Assert.notNull(transformer, "Transformer must not be null").     FilteringClassFileTransformer actualTransformer = new FilteringClassFileTransformer(transformer, this.classLoader).     synchronized (this.transformers) {         Assert.state(this.instrumentation != null, "Must start with Java agent to use InstrumentationLoadTimeWeaver. See Spring documentation.").         this.instrumentation.addTransformer(actualTransformer).         this.transformers.add(actualTransformer).     } }
true;public;0;5;/**  * We have the ability to weave the current class loader when starting the  * JVM in this way, so the instrumentable class loader will always be the  * current loader.  */ ;/**  * We have the ability to weave the current class loader when starting the  * JVM in this way, so the instrumentable class loader will always be the  * current loader.  */ @Override public ClassLoader getInstrumentableClassLoader() {     Assert.state(this.classLoader != null, "No ClassLoader available").     return this.classLoader. }
true;public;0;4;/**  * This implementation always returns a {@link SimpleThrowawayClassLoader}.  */ ;/**  * This implementation always returns a {@link SimpleThrowawayClassLoader}.  */ @Override public ClassLoader getThrowawayClassLoader() {     return new SimpleThrowawayClassLoader(getInstrumentableClassLoader()). }
true;public;0;10;/**  * Remove all registered transformers, in inverse order of registration.  */ ;/**  * Remove all registered transformers, in inverse order of registration.  */ public void removeTransformers() {     synchronized (this.transformers) {         if (this.instrumentation != null && !this.transformers.isEmpty()) {             for (int i = this.transformers.size() - 1. i >= 0. i--) {                 this.instrumentation.removeTransformer(this.transformers.get(i)).             }             this.transformers.clear().         }     } }
true;public,static;0;3;/**  * Check whether an Instrumentation instance is available for the current VM.  * @see #getInstrumentation()  */ ;/**  * Check whether an Instrumentation instance is available for the current VM.  * @see #getInstrumentation()  */ public static boolean isInstrumentationAvailable() {     return (getInstrumentation() != null). }
true;private,static;0;9;/**  * Obtain the Instrumentation instance for the current VM, if available.  * @return the Instrumentation instance, or {@code null} if none found  * @see #isInstrumentationAvailable()  */ ;/**  * Obtain the Instrumentation instance for the current VM, if available.  * @return the Instrumentation instance, or {@code null} if none found  * @see #isInstrumentationAvailable()  */ @Nullable private static Instrumentation getInstrumentation() {     if (AGENT_CLASS_PRESENT) {         return InstrumentationAccessor.getInstrumentation().     } else {         return null.     } }
false;public,static;0;3;;public static Instrumentation getInstrumentation() {     return InstrumentationSavingAgent.getInstrumentation(). }
false;public;5;11;;@Override @Nullable public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {     if (this.targetClassLoader != loader) {         return null.     }     return this.targetTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer). }
false;public;0;4;;@Override public String toString() {     return "FilteringClassFileTransformer for: " + this.targetTransformer.toString(). }
