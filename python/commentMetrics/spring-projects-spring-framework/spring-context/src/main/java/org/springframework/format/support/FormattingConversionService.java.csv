commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setEmbeddedValueResolver(StringValueResolver resolver) {     this.embeddedValueResolver = resolver. }
false;public;1;4;;@Override public void addFormatter(Formatter<?> formatter) {     addFormatterForFieldType(getFieldType(formatter), formatter). }
false;public;2;5;;@Override public void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter) {     addConverter(new PrinterConverter(fieldType, formatter, this)).     addConverter(new ParserConverter(fieldType, formatter, this)). }
false;public;3;5;;@Override public void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser) {     addConverter(new PrinterConverter(fieldType, printer, this)).     addConverter(new ParserConverter(fieldType, parser, this)). }
false;public;1;12;;@Override public void addFormatterForFieldAnnotation(AnnotationFormatterFactory<? extends Annotation> annotationFormatterFactory) {     Class<? extends Annotation> annotationType = getAnnotationType(annotationFormatterFactory).     if (this.embeddedValueResolver != null && annotationFormatterFactory instanceof EmbeddedValueResolverAware) {         ((EmbeddedValueResolverAware) annotationFormatterFactory).setEmbeddedValueResolver(this.embeddedValueResolver).     }     Set<Class<?>> fieldTypes = annotationFormatterFactory.getFieldTypes().     for (Class<?> fieldType : fieldTypes) {         addConverter(new AnnotationPrinterConverter(annotationType, annotationFormatterFactory, fieldType)).         addConverter(new AnnotationParserConverter(annotationType, annotationFormatterFactory, fieldType)).     } }
false;static;1;12;;static Class<?> getFieldType(Formatter<?> formatter) {     Class<?> fieldType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class).     if (fieldType == null && formatter instanceof DecoratingProxy) {         fieldType = GenericTypeResolver.resolveTypeArgument(((DecoratingProxy) formatter).getDecoratedClass(), Formatter.class).     }     if (fieldType == null) {         throw new IllegalArgumentException("Unable to extract the parameterized field type from Formatter [" + formatter.getClass().getName() + "]. does the class parameterize the <T> generic type?").     }     return fieldType. }
false;static;1;11;;@SuppressWarnings("unchecked") static Class<? extends Annotation> getAnnotationType(AnnotationFormatterFactory<? extends Annotation> factory) {     Class<? extends Annotation> annotationType = (Class<? extends Annotation>) GenericTypeResolver.resolveTypeArgument(factory.getClass(), AnnotationFormatterFactory.class).     if (annotationType == null) {         throw new IllegalArgumentException("Unable to extract parameterized Annotation type argument from " + "AnnotationFormatterFactory [" + factory.getClass().getName() + "]. does the factory parameterize the <A extends Annotation> generic type?").     }     return annotationType. }
false;public;0;4;;@Override public Set<ConvertiblePair> getConvertibleTypes() {     return Collections.singleton(new ConvertiblePair(this.fieldType, String.class)). }
false;public;3;11;;@Override @SuppressWarnings("unchecked") public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {     if (!sourceType.isAssignableTo(this.printerObjectType)) {         source = this.conversionService.convert(source, sourceType, this.printerObjectType).     }     if (source == null) {         return "".     }     return this.printer.print(source, LocaleContextHolder.getLocale()). }
false;private;1;4;;@Nullable private Class<?> resolvePrinterObjectType(Printer<?> printer) {     return GenericTypeResolver.resolveTypeArgument(printer.getClass(), Printer.class). }
false;public;0;4;;@Override public String toString() {     return (this.fieldType.getName() + " -> " + String.class.getName() + " : " + this.printer). }
false;public;0;4;;@Override public Set<ConvertiblePair> getConvertibleTypes() {     return Collections.singleton(new ConvertiblePair(String.class, this.fieldType)). }
false;public;3;23;;@Override @Nullable public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {     String text = (String) source.     if (!StringUtils.hasText(text)) {         return null.     }     Object result.     try {         result = this.parser.parse(text, LocaleContextHolder.getLocale()).     } catch (IllegalArgumentException ex) {         throw ex.     } catch (Throwable ex) {         throw new IllegalArgumentException("Parse attempt failed for value [" + text + "]", ex).     }     TypeDescriptor resultType = TypeDescriptor.valueOf(result.getClass()).     if (!resultType.isAssignableTo(targetType)) {         result = this.conversionService.convert(result, resultType, targetType).     }     return result. }
false;public;0;4;;@Override public String toString() {     return (String.class.getName() + " -> " + this.fieldType.getName() + ": " + this.parser). }
false;public;0;4;;@Override public Set<ConvertiblePair> getConvertibleTypes() {     return Collections.singleton(new ConvertiblePair(this.fieldType, String.class)). }
false;public;2;4;;@Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {     return sourceType.hasAnnotation(this.annotationType). }
false;public;3;19;;@Override @SuppressWarnings("unchecked") @Nullable public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {     Annotation ann = sourceType.getAnnotation(this.annotationType).     if (ann == null) {         throw new IllegalStateException("Expected [" + this.annotationType.getName() + "] to be present on " + sourceType).     }     AnnotationConverterKey converterKey = new AnnotationConverterKey(ann, sourceType.getObjectType()).     GenericConverter converter = cachedPrinters.get(converterKey).     if (converter == null) {         Printer<?> printer = this.annotationFormatterFactory.getPrinter(converterKey.getAnnotation(), converterKey.getFieldType()).         converter = new PrinterConverter(this.fieldType, printer, FormattingConversionService.this).         cachedPrinters.put(converterKey, converter).     }     return converter.convert(source, sourceType, targetType). }
false;public;0;5;;@Override public String toString() {     return ("@" + this.annotationType.getName() + " " + this.fieldType.getName() + " -> " + String.class.getName() + ": " + this.annotationFormatterFactory). }
false;public;0;4;;@Override public Set<ConvertiblePair> getConvertibleTypes() {     return Collections.singleton(new ConvertiblePair(String.class, this.fieldType)). }
false;public;2;4;;@Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {     return targetType.hasAnnotation(this.annotationType). }
false;public;3;19;;@Override @SuppressWarnings("unchecked") @Nullable public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {     Annotation ann = targetType.getAnnotation(this.annotationType).     if (ann == null) {         throw new IllegalStateException("Expected [" + this.annotationType.getName() + "] to be present on " + targetType).     }     AnnotationConverterKey converterKey = new AnnotationConverterKey(ann, targetType.getObjectType()).     GenericConverter converter = cachedParsers.get(converterKey).     if (converter == null) {         Parser<?> parser = this.annotationFormatterFactory.getParser(converterKey.getAnnotation(), converterKey.getFieldType()).         converter = new ParserConverter(this.fieldType, parser, FormattingConversionService.this).         cachedParsers.put(converterKey, converter).     }     return converter.convert(source, sourceType, targetType). }
false;public;0;5;;@Override public String toString() {     return (String.class.getName() + " -> @" + this.annotationType.getName() + " " + this.fieldType.getName() + ": " + this.annotationFormatterFactory). }
false;public;0;3;;public Annotation getAnnotation() {     return this.annotation. }
false;public;0;3;;public Class<?> getFieldType() {     return this.fieldType. }
false;public;1;8;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     AnnotationConverterKey otherKey = (AnnotationConverterKey) other.     return (this.fieldType == otherKey.fieldType && this.annotation.equals(otherKey.annotation)). }
false;public;0;4;;@Override public int hashCode() {     return (this.fieldType.hashCode() * 29 + this.annotation.hashCode()). }
