commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the JSR-303 Validator to delegate to for validating beans.  * <p>Default is the default ValidatorFactory's default Validator.  */ ;/**  * Set the JSR-303 Validator to delegate to for validating beans.  * <p>Default is the default ValidatorFactory's default Validator.  */ public void setValidator(Validator validator) {     this.validator = validator. }
true;public;1;3;/**  * Set the JSR-303 ValidatorFactory to delegate to for validating beans,  * using its default Validator.  * <p>Default is the default ValidatorFactory's default Validator.  * @see javax.validation.ValidatorFactory#getValidator()  */ ;/**  * Set the JSR-303 ValidatorFactory to delegate to for validating beans,  * using its default Validator.  * <p>Default is the default ValidatorFactory's default Validator.  * @see javax.validation.ValidatorFactory#getValidator()  */ public void setValidatorFactory(ValidatorFactory validatorFactory) {     this.validator = validatorFactory.getValidator(). }
true;public;1;3;/**  * Choose whether to perform validation after bean initialization  * (i.e. after init methods) instead of before (which is the default).  * <p>Default is "false" (before initialization). Switch this to "true"  * (after initialization) if you would like to give init methods a chance  * to populate constrained fields before they get validated.  */ ;/**  * Choose whether to perform validation after bean initialization  * (i.e. after init methods) instead of before (which is the default).  * <p>Default is "false" (before initialization). Switch this to "true"  * (after initialization) if you would like to give init methods a chance  * to populate constrained fields before they get validated.  */ public void setAfterInitialization(boolean afterInitialization) {     this.afterInitialization = afterInitialization. }
false;public;0;6;;@Override public void afterPropertiesSet() {     if (this.validator == null) {         this.validator = Validation.buildDefaultValidatorFactory().getValidator().     } }
false;public;2;7;;@Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {     if (!this.afterInitialization) {         doValidate(bean).     }     return bean. }
false;public;2;7;;@Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {     if (this.afterInitialization) {         doValidate(bean).     }     return bean. }
true;protected;1;20;/**  * Perform validation of the given bean.  * @param bean the bean instance to validate  * @see javax.validation.Validator#validate  */ ;/**  * Perform validation of the given bean.  * @param bean the bean instance to validate  * @see javax.validation.Validator#validate  */ protected void doValidate(Object bean) {     Assert.state(this.validator != null, "No Validator set").     Object objectToValidate = AopProxyUtils.getSingletonTarget(bean).     if (objectToValidate == null) {         objectToValidate = bean.     }     Set<ConstraintViolation<Object>> result = this.validator.validate(objectToValidate).     if (!result.isEmpty()) {         StringBuilder sb = new StringBuilder("Bean state is invalid: ").         for (Iterator<ConstraintViolation<Object>> it = result.iterator(). it.hasNext(). ) {             ConstraintViolation<Object> violation = it.next().             sb.append(violation.getPropertyPath()).append(" - ").append(violation.getMessage()).             if (it.hasNext()) {                 sb.append(". ").             }         }         throw new BeanInitializationException(sb.toString()).     } }
