commented;modifiers;parameterAmount;loc;comment;code
false;public;1;28;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader).     if (serverSpecificLoadTimeWeaver != null) {         if (logger.isDebugEnabled()) {             logger.debug("Determined server-specific load-time weaver: " + serverSpecificLoadTimeWeaver.getClass().getName()).         }         this.loadTimeWeaver = serverSpecificLoadTimeWeaver.     } else if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {         logger.debug("Found Spring's JVM agent for instrumentation").         this.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader).     } else {         try {             this.loadTimeWeaver = new ReflectiveLoadTimeWeaver(classLoader).             if (logger.isDebugEnabled()) {                 logger.debug("Using reflective load-time weaver for class loader: " + this.loadTimeWeaver.getInstrumentableClassLoader().getClass().getName()).             }         } catch (IllegalStateException ex) {             throw new IllegalStateException(ex.getMessage() + " Specify a custom LoadTimeWeaver or start your " + "Java virtual machine with Spring's agent: -javaagent:spring-instrument-{version}.jar").         }     } }
true;protected;1;27;/* 	 * This method never fails, allowing to try other possible ways to use an 	 * server-agnostic weaver. This non-failure logic is required since 	 * determining a load-time weaver based on the ClassLoader name alone may 	 * legitimately fail due to other mismatches. 	 */ ;/* 	 * This method never fails, allowing to try other possible ways to use an 	 * server-agnostic weaver. This non-failure logic is required since 	 * determining a load-time weaver based on the ClassLoader name alone may 	 * legitimately fail due to other mismatches. 	 */ @Nullable protected LoadTimeWeaver createServerSpecificLoadTimeWeaver(ClassLoader classLoader) {     String name = classLoader.getClass().getName().     try {         if (name.startsWith("org.apache.catalina")) {             return new TomcatLoadTimeWeaver(classLoader).         } else if (name.startsWith("org.glassfish")) {             return new GlassFishLoadTimeWeaver(classLoader).         } else if (name.startsWith("org.jboss.modules")) {             return new JBossLoadTimeWeaver(classLoader).         } else if (name.startsWith("com.ibm.ws.classloader")) {             return new WebSphereLoadTimeWeaver(classLoader).         } else if (name.startsWith("weblogic")) {             return new WebLogicLoadTimeWeaver(classLoader).         }     } catch (Exception ex) {         if (logger.isInfoEnabled()) {             logger.info("Could not obtain server-specific LoadTimeWeaver: " + ex.getMessage()).         }     }     return null. }
false;public;0;10;;@Override public void destroy() {     if (this.loadTimeWeaver instanceof InstrumentationLoadTimeWeaver) {         if (logger.isDebugEnabled()) {             logger.debug("Removing all registered transformers for class loader: " + this.loadTimeWeaver.getInstrumentableClassLoader().getClass().getName()).         }         ((InstrumentationLoadTimeWeaver) this.loadTimeWeaver).removeTransformers().     } }
false;public;1;5;;@Override public void addTransformer(ClassFileTransformer transformer) {     Assert.state(this.loadTimeWeaver != null, "Not initialized").     this.loadTimeWeaver.addTransformer(transformer). }
false;public;0;5;;@Override public ClassLoader getInstrumentableClassLoader() {     Assert.state(this.loadTimeWeaver != null, "Not initialized").     return this.loadTimeWeaver.getInstrumentableClassLoader(). }
false;public;0;5;;@Override public ClassLoader getThrowawayClassLoader() {     Assert.state(this.loadTimeWeaver != null, "Not initialized").     return this.loadTimeWeaver.getThrowawayClassLoader(). }
