# id;timestamp;commentText;codeText;commentWords;codeWords
AutoProxyRegistrar -> @Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1356735495;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying.__<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;@Override_	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = attributesFor(importingClassMetadata, annoType)__			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null_					&& mode.getClass().equals(AdviceMode.class)_					&& proxyTargetClass.getClass().equals(Boolean.class)) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean)proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occured as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;override,public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,attributes,for,importing,class,metadata,anno,type,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,mode,get,class,equals,advice,mode,class,proxy,target,class,get,class,equals,boolean,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occured,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> @Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1368482696;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying.__<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;@Override_	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = attributesFor(importingClassMetadata, annoType)__			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null_					&& mode.getClass().equals(AdviceMode.class)_					&& proxyTargetClass.getClass().equals(Boolean.class)) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean)proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occured as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;override,public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,attributes,for,importing,class,metadata,anno,type,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,mode,get,class,equals,advice,mode,class,proxy,target,class,get,class,equals,boolean,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occured,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> @Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1377269365;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying.__<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;@Override_	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType)__			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null_					&& mode.getClass().equals(AdviceMode.class)_					&& proxyTargetClass.getClass().equals(Boolean.class)) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean)proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occured as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;override,public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,annotation,config,utils,attributes,for,importing,class,metadata,anno,type,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,mode,get,class,equals,advice,mode,class,proxy,target,class,get,class,equals,boolean,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occured,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> @Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1385978426;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying._<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;@Override_	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType)__			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null && mode.getClass().equals(AdviceMode.class) &&_					proxyTargetClass.getClass().equals(Boolean.class)) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean) proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occured as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;override,public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,annotation,config,utils,attributes,for,importing,class,metadata,anno,type,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,mode,get,class,equals,advice,mode,class,proxy,target,class,get,class,equals,boolean,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occured,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> @Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1432125256;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying._<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;@Override_	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType)__			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null && AdviceMode.class == mode.getClass() &&_					Boolean.class == proxyTargetClass.getClass()) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean) proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occured as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;override,public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,annotation,config,utils,attributes,for,importing,class,metadata,anno,type,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,advice,mode,class,mode,get,class,boolean,class,proxy,target,class,get,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occured,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> @Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1467983536;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying._<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;@Override_	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType)__			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null && AdviceMode.class == mode.getClass() &&_					Boolean.class == proxyTargetClass.getClass()) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean) proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occurred as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;override,public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,annotation,config,utils,attributes,for,importing,class,metadata,anno,type,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,advice,mode,class,mode,get,class,boolean,class,proxy,target,class,get,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occurred,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> @Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1482853021;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying._<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;@Override_	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType)__			if (candidate == null) {_				continue__			}_			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null && AdviceMode.class == mode.getClass() &&_					Boolean.class == proxyTargetClass.getClass()) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean) proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occurred as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;override,public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,annotation,config,utils,attributes,for,importing,class,metadata,anno,type,if,candidate,null,continue,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,advice,mode,class,mode,get,class,boolean,class,proxy,target,class,get,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occurred,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> @Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1496263893;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying._<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;@Override_	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType)__			if (candidate == null) {_				continue__			}_			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null && AdviceMode.class == mode.getClass() &&_					Boolean.class == proxyTargetClass.getClass()) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean) proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occurred as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;override,public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,annotation,config,utils,attributes,for,importing,class,metadata,anno,type,if,candidate,null,continue,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,advice,mode,class,mode,get,class,boolean,class,proxy,target,class,get,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occurred,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> @Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1496837955;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying._<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;@Override_	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType)__			if (candidate == null) {_				continue__			}_			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null && AdviceMode.class == mode.getClass() &&_					Boolean.class == proxyTargetClass.getClass()) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean) proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occurred as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;override,public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,annotation,config,utils,attributes,for,importing,class,metadata,anno,type,if,candidate,null,continue,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,advice,mode,class,mode,get,class,boolean,class,proxy,target,class,get,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occurred,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> @Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1532091916;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying._<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;@Override_	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType)__			if (candidate == null) {_				continue__			}_			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null && AdviceMode.class == mode.getClass() &&_					Boolean.class == proxyTargetClass.getClass()) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean) proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound && logger.isInfoEnabled()) {_			String name = getClass().getSimpleName()__			logger.info(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occurred as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;override,public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,annotation,config,utils,attributes,for,importing,class,metadata,anno,type,if,candidate,null,continue,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,advice,mode,class,mode,get,class,boolean,class,proxy,target,class,get,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,logger,is,info,enabled,string,name,get,class,get,simple,name,logger,info,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occurred,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1328020251;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying.__<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			Map<String, Object> candidate = importingClassMetadata.getAnnotationAttributes(annoType)__			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null_					&& mode.getClass().equals(AdviceMode.class)_					&& proxyTargetClass.getClass().equals(Boolean.class)) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean)proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occured as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,map,string,object,candidate,importing,class,metadata,get,annotation,attributes,anno,type,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,mode,get,class,equals,advice,mode,class,proxy,target,class,get,class,equals,boolean,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occured,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1329142650;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying.__<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = attributesFor(importingClassMetadata, annoType)__			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null_					&& mode.getClass().equals(AdviceMode.class)_					&& proxyTargetClass.getClass().equals(Boolean.class)) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean)proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occured as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,attributes,for,importing,class,metadata,anno,type,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,mode,get,class,equals,advice,mode,class,proxy,target,class,get,class,equals,boolean,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occured,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
AutoProxyRegistrar -> public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);1357119239;Register, escalate, and configure the standard auto proxy creator (APC) against the_given registry. Works by finding the nearest annotation declared on the importing_{@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}_attributes. If {@code mode} is set to {@code PROXY}, the APC is registered_ if_{@code proxyTargetClass} is set to {@code true}, then the APC is forced to use_subclass (CGLIB) proxying.__<p>Several {@code @Enable*} annotations expose both {@code mode} and_{@code proxyTargetClass} attributes. It is important to note that most of these_capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME_single APC}. For this reason, this implementation doesn't "care" exactly which_annotation it finds -- as long as it exposes the right {@code mode} and_{@code proxyTargetClass} attributes, the APC can be registered and configured all_the same.;public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {_		boolean candidateFound = false__		Set<String> annoTypes = importingClassMetadata.getAnnotationTypes()__		for (String annoType : annoTypes) {_			AnnotationAttributes candidate = attributesFor(importingClassMetadata, annoType)__			Object mode = candidate.get("mode")__			Object proxyTargetClass = candidate.get("proxyTargetClass")__			if (mode != null && proxyTargetClass != null_					&& mode.getClass().equals(AdviceMode.class)_					&& proxyTargetClass.getClass().equals(Boolean.class)) {_				candidateFound = true__				if (mode == AdviceMode.PROXY) {_					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)__					if ((Boolean)proxyTargetClass) {_						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)__						return__					}_				}_			}_		}_		if (!candidateFound) {_			String name = getClass().getSimpleName()__			logger.warn(String.format("%s was imported but no annotations were found " +_					"having both 'mode' and 'proxyTargetClass' attributes of type " +_					"AdviceMode and boolean respectively. This means that auto proxy " +_					"creator registration and configuration may not have occured as " +_					"intended, and components may not be proxied as expected. Check to " +_					"ensure that %s has been @Import'ed on the same class where these " +_					"annotations are declared_ otherwise remove the import of %s " +_					"altogether.", name, name, name))__		}_	};register,escalate,and,configure,the,standard,auto,proxy,creator,apc,against,the,given,registry,works,by,finding,the,nearest,annotation,declared,on,the,importing,code,configuration,class,that,has,both,code,mode,and,code,proxy,target,class,attributes,if,code,mode,is,set,to,code,proxy,the,apc,is,registered,if,code,proxy,target,class,is,set,to,code,true,then,the,apc,is,forced,to,use,subclass,cglib,proxying,p,several,code,enable,annotations,expose,both,code,mode,and,code,proxy,target,class,attributes,it,is,important,to,note,that,most,of,these,capabilities,end,up,sharing,a,linkplain,aop,config,utils,single,apc,for,this,reason,this,implementation,doesn,t,care,exactly,which,annotation,it,finds,as,long,as,it,exposes,the,right,code,mode,and,code,proxy,target,class,attributes,the,apc,can,be,registered,and,configured,all,the,same;public,void,register,bean,definitions,annotation,metadata,importing,class,metadata,bean,definition,registry,registry,boolean,candidate,found,false,set,string,anno,types,importing,class,metadata,get,annotation,types,for,string,anno,type,anno,types,annotation,attributes,candidate,attributes,for,importing,class,metadata,anno,type,object,mode,candidate,get,mode,object,proxy,target,class,candidate,get,proxy,target,class,if,mode,null,proxy,target,class,null,mode,get,class,equals,advice,mode,class,proxy,target,class,get,class,equals,boolean,class,candidate,found,true,if,mode,advice,mode,proxy,aop,config,utils,register,auto,proxy,creator,if,necessary,registry,if,boolean,proxy,target,class,aop,config,utils,force,auto,proxy,creator,to,use,class,proxying,registry,return,if,candidate,found,string,name,get,class,get,simple,name,logger,warn,string,format,s,was,imported,but,no,annotations,were,found,having,both,mode,and,proxy,target,class,attributes,of,type,advice,mode,and,boolean,respectively,this,means,that,auto,proxy,creator,registration,and,configuration,may,not,have,occured,as,intended,and,components,may,not,be,proxied,as,expected,check,to,ensure,that,s,has,been,import,ed,on,the,same,class,where,these,annotations,are,declared,otherwise,remove,the,import,of,s,altogether,name,name,name
