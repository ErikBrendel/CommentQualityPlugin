commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify the maximum time allotted in milliseconds for the shutdown of  * any phase (group of SmartLifecycle beans with the same 'phase' value).  * <p>The default value is 30 seconds.  */ ;/**  * Specify the maximum time allotted in milliseconds for the shutdown of  * any phase (group of SmartLifecycle beans with the same 'phase' value).  * <p>The default value is 30 seconds.  */ public void setTimeoutPerShutdownPhase(long timeoutPerShutdownPhase) {     this.timeoutPerShutdownPhase = timeoutPerShutdownPhase. }
false;public;1;8;;@Override public void setBeanFactory(BeanFactory beanFactory) {     if (!(beanFactory instanceof ConfigurableListableBeanFactory)) {         throw new IllegalArgumentException("DefaultLifecycleProcessor requires a ConfigurableListableBeanFactory: " + beanFactory).     }     this.beanFactory = (ConfigurableListableBeanFactory) beanFactory. }
false;private;0;5;;private ConfigurableListableBeanFactory getBeanFactory() {     ConfigurableListableBeanFactory beanFactory = this.beanFactory.     Assert.state(beanFactory != null, "No BeanFactory available").     return beanFactory. }
true;public;0;5;/**  * Start all registered beans that implement {@link Lifecycle} and are <i>not</i>  * already running. Any bean that implements {@link SmartLifecycle} will be  * started within its 'phase', and all phases will be ordered from lowest to  * highest value. All beans that do not implement {@link SmartLifecycle} will be  * started in the default phase 0. A bean declared as a dependency of another bean  * will be started before the dependent bean regardless of the declared phase.  */ ;// Lifecycle implementation /**  * Start all registered beans that implement {@link Lifecycle} and are <i>not</i>  * already running. Any bean that implements {@link SmartLifecycle} will be  * started within its 'phase', and all phases will be ordered from lowest to  * highest value. All beans that do not implement {@link SmartLifecycle} will be  * started in the default phase 0. A bean declared as a dependency of another bean  * will be started before the dependent bean regardless of the declared phase.  */ @Override public void start() {     startBeans(false).     this.running = true. }
true;public;0;5;/**  * Stop all registered beans that implement {@link Lifecycle} and <i>are</i>  * currently running. Any bean that implements {@link SmartLifecycle} will be  * stopped within its 'phase', and all phases will be ordered from highest to  * lowest value. All beans that do not implement {@link SmartLifecycle} will be  * stopped in the default phase 0. A bean declared as dependent on another bean  * will be stopped before the dependency bean regardless of the declared phase.  */ ;/**  * Stop all registered beans that implement {@link Lifecycle} and <i>are</i>  * currently running. Any bean that implements {@link SmartLifecycle} will be  * stopped within its 'phase', and all phases will be ordered from highest to  * lowest value. All beans that do not implement {@link SmartLifecycle} will be  * stopped in the default phase 0. A bean declared as dependent on another bean  * will be stopped before the dependency bean regardless of the declared phase.  */ @Override public void stop() {     stopBeans().     this.running = false. }
false;public;0;5;;@Override public void onRefresh() {     startBeans(true).     this.running = true. }
false;public;0;5;;@Override public void onClose() {     stopBeans().     this.running = false. }
false;public;0;4;;@Override public boolean isRunning() {     return this.running. }
false;private;1;22;;// Internal helpers private void startBeans(boolean autoStartupOnly) {     Map<String, Lifecycle> lifecycleBeans = getLifecycleBeans().     Map<Integer, LifecycleGroup> phases = new HashMap<>().     lifecycleBeans.forEach((beanName, bean) -> {         if (!autoStartupOnly || (bean instanceof SmartLifecycle && ((SmartLifecycle) bean).isAutoStartup())) {             int phase = getPhase(bean).             LifecycleGroup group = phases.get(phase).             if (group == null) {                 group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly).                 phases.put(phase, group).             }             group.add(beanName, bean).         }     }).     if (!phases.isEmpty()) {         List<Integer> keys = new ArrayList<>(phases.keySet()).         Collections.sort(keys).         for (Integer key : keys) {             phases.get(key).start().         }     } }
true;private;3;24;/**  * Start the specified bean as part of the given set of Lifecycle beans,  * making sure that any beans that it depends on are started first.  * @param lifecycleBeans a Map with bean name as key and Lifecycle instance as value  * @param beanName the name of the bean to start  */ ;/**  * Start the specified bean as part of the given set of Lifecycle beans,  * making sure that any beans that it depends on are started first.  * @param lifecycleBeans a Map with bean name as key and Lifecycle instance as value  * @param beanName the name of the bean to start  */ private void doStart(Map<String, ? extends Lifecycle> lifecycleBeans, String beanName, boolean autoStartupOnly) {     Lifecycle bean = lifecycleBeans.remove(beanName).     if (bean != null && bean != this) {         String[] dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName).         for (String dependency : dependenciesForBean) {             doStart(lifecycleBeans, dependency, autoStartupOnly).         }         if (!bean.isRunning() && (!autoStartupOnly || !(bean instanceof SmartLifecycle) || ((SmartLifecycle) bean).isAutoStartup())) {             if (logger.isTraceEnabled()) {                 logger.trace("Starting bean '" + beanName + "' of type [" + bean.getClass().getName() + "]").             }             try {                 bean.start().             } catch (Throwable ex) {                 throw new ApplicationContextException("Failed to start bean '" + beanName + "'", ex).             }             if (logger.isDebugEnabled()) {                 logger.debug("Successfully started bean '" + beanName + "'").             }         }     } }
false;private;0;20;;private void stopBeans() {     Map<String, Lifecycle> lifecycleBeans = getLifecycleBeans().     Map<Integer, LifecycleGroup> phases = new HashMap<>().     lifecycleBeans.forEach((beanName, bean) -> {         int shutdownPhase = getPhase(bean).         LifecycleGroup group = phases.get(shutdownPhase).         if (group == null) {             group = new LifecycleGroup(shutdownPhase, this.timeoutPerShutdownPhase, lifecycleBeans, false).             phases.put(shutdownPhase, group).         }         group.add(beanName, bean).     }).     if (!phases.isEmpty()) {         List<Integer> keys = new ArrayList<>(phases.keySet()).         keys.sort(Collections.reverseOrder()).         for (Integer key : keys) {             phases.get(key).stop().         }     } }
true;private;4;48;/**  * Stop the specified bean as part of the given set of Lifecycle beans,  * making sure that any beans that depends on it are stopped first.  * @param lifecycleBeans a Map with bean name as key and Lifecycle instance as value  * @param beanName the name of the bean to stop  */ ;/**  * Stop the specified bean as part of the given set of Lifecycle beans,  * making sure that any beans that depends on it are stopped first.  * @param lifecycleBeans a Map with bean name as key and Lifecycle instance as value  * @param beanName the name of the bean to stop  */ private void doStop(Map<String, ? extends Lifecycle> lifecycleBeans, final String beanName, final CountDownLatch latch, final Set<String> countDownBeanNames) {     Lifecycle bean = lifecycleBeans.remove(beanName).     if (bean != null) {         String[] dependentBeans = getBeanFactory().getDependentBeans(beanName).         for (String dependentBean : dependentBeans) {             doStop(lifecycleBeans, dependentBean, latch, countDownBeanNames).         }         try {             if (bean.isRunning()) {                 if (bean instanceof SmartLifecycle) {                     if (logger.isTraceEnabled()) {                         logger.trace("Asking bean '" + beanName + "' of type [" + bean.getClass().getName() + "] to stop").                     }                     countDownBeanNames.add(beanName).                     ((SmartLifecycle) bean).stop(() -> {                         latch.countDown().                         countDownBeanNames.remove(beanName).                         if (logger.isDebugEnabled()) {                             logger.debug("Bean '" + beanName + "' completed its stop procedure").                         }                     }).                 } else {                     if (logger.isTraceEnabled()) {                         logger.trace("Stopping bean '" + beanName + "' of type [" + bean.getClass().getName() + "]").                     }                     bean.stop().                     if (logger.isDebugEnabled()) {                         logger.debug("Successfully stopped bean '" + beanName + "'").                     }                 }             } else if (bean instanceof SmartLifecycle) {                 // Don't wait for beans that aren't running...                 latch.countDown().             }         } catch (Throwable ex) {             if (logger.isWarnEnabled()) {                 logger.warn("Failed to stop bean '" + beanName + "'", ex).             }         }     } }
true;protected;0;19;/**  * Retrieve all applicable Lifecycle beans: all singletons that have already been created,  * as well as all SmartLifecycle beans (even if they are marked as lazy-init).  * @return the Map of applicable beans, with bean names as keys and bean instances as values  */ ;// overridable hooks /**  * Retrieve all applicable Lifecycle beans: all singletons that have already been created,  * as well as all SmartLifecycle beans (even if they are marked as lazy-init).  * @return the Map of applicable beans, with bean names as keys and bean instances as values  */ protected Map<String, Lifecycle> getLifecycleBeans() {     ConfigurableListableBeanFactory beanFactory = getBeanFactory().     Map<String, Lifecycle> beans = new LinkedHashMap<>().     String[] beanNames = beanFactory.getBeanNamesForType(Lifecycle.class, false, false).     for (String beanName : beanNames) {         String beanNameToRegister = BeanFactoryUtils.transformedBeanName(beanName).         boolean isFactoryBean = beanFactory.isFactoryBean(beanNameToRegister).         String beanNameToCheck = (isFactoryBean ? BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName).         if ((beanFactory.containsSingleton(beanNameToRegister) && (!isFactoryBean || matchesBeanType(Lifecycle.class, beanNameToCheck, beanFactory))) || matchesBeanType(SmartLifecycle.class, beanNameToCheck, beanFactory)) {             Object bean = beanFactory.getBean(beanNameToCheck).             if (bean != this && bean instanceof Lifecycle) {                 beans.put(beanNameToRegister, (Lifecycle) bean).             }         }     }     return beans. }
false;private;3;4;;private boolean matchesBeanType(Class<?> targetType, String beanName, BeanFactory beanFactory) {     Class<?> beanType = beanFactory.getType(beanName).     return (beanType != null && targetType.isAssignableFrom(beanType)). }
true;protected;1;3;/**  * Determine the lifecycle phase of the given bean.  * <p>The default implementation checks for the {@link Phased} interface, using  * a default of 0 otherwise. Can be overridden to apply other/further policies.  * @param bean the bean to introspect  * @return the phase (an integer value)  * @see Phased#getPhase()  * @see SmartLifecycle  */ ;/**  * Determine the lifecycle phase of the given bean.  * <p>The default implementation checks for the {@link Phased} interface, using  * a default of 0 otherwise. Can be overridden to apply other/further policies.  * @param bean the bean to introspect  * @return the phase (an integer value)  * @see Phased#getPhase()  * @see SmartLifecycle  */ protected int getPhase(Lifecycle bean) {     return (bean instanceof Phased ? ((Phased) bean).getPhase() : 0). }
false;public;2;6;;public void add(String name, Lifecycle bean) {     this.members.add(new LifecycleGroupMember(name, bean)).     if (bean instanceof SmartLifecycle) {         this.smartMemberCount++.     } }
false;public;0;12;;public void start() {     if (this.members.isEmpty()) {         return.     }     if (logger.isDebugEnabled()) {         logger.debug("Starting beans in phase " + this.phase).     }     Collections.sort(this.members).     for (LifecycleGroupMember member : this.members) {         doStart(this.lifecycleBeans, member.name, this.autoStartupOnly).     } }
false;public;0;32;;public void stop() {     if (this.members.isEmpty()) {         return.     }     if (logger.isDebugEnabled()) {         logger.debug("Stopping beans in phase " + this.phase).     }     this.members.sort(Collections.reverseOrder()).     CountDownLatch latch = new CountDownLatch(this.smartMemberCount).     Set<String> countDownBeanNames = Collections.synchronizedSet(new LinkedHashSet<>()).     Set<String> lifecycleBeanNames = new HashSet<>(this.lifecycleBeans.keySet()).     for (LifecycleGroupMember member : this.members) {         if (lifecycleBeanNames.contains(member.name)) {             doStop(this.lifecycleBeans, member.name, latch, countDownBeanNames).         } else if (member.bean instanceof SmartLifecycle) {             // Already removed: must have been a dependent bean from another phase             latch.countDown().         }     }     try {         latch.await(this.timeout, TimeUnit.MILLISECONDS).         if (latch.getCount() > 0 && !countDownBeanNames.isEmpty() && logger.isInfoEnabled()) {             logger.info("Failed to shut down " + countDownBeanNames.size() + " bean" + (countDownBeanNames.size() > 1 ? "s" : "") + " with phase value " + this.phase + " within timeout of " + this.timeout + ": " + countDownBeanNames).         }     } catch (InterruptedException ex) {         Thread.currentThread().interrupt().     } }
false;public;1;6;;@Override public int compareTo(LifecycleGroupMember other) {     int thisPhase = getPhase(this.bean).     int otherPhase = getPhase(other.bean).     return Integer.compare(thisPhase, otherPhase). }
