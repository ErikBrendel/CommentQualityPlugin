commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Specify the content type to use for sending remote invocation responses.  * <p>Default is "application/x-java-serialized-object".  */ ;/**  * Specify the content type to use for sending remote invocation responses.  * <p>Default is "application/x-java-serialized-object".  */ public void setContentType(String contentType) {     Assert.notNull(contentType, "'contentType' must not be null").     this.contentType = contentType. }
true;public;0;3;/**  * Return the content type to use for sending remote invocation responses.  */ ;/**  * Return the content type to use for sending remote invocation responses.  */ public String getContentType() {     return this.contentType. }
true;public;1;3;/**  * Set whether to accept deserialization of proxy classes.  * <p>Default is "true". May be deactivated as a security measure.  */ ;/**  * Set whether to accept deserialization of proxy classes.  * <p>Default is "true". May be deactivated as a security measure.  */ public void setAcceptProxyClasses(boolean acceptProxyClasses) {     this.acceptProxyClasses = acceptProxyClasses. }
true;public;0;3;/**  * Return whether to accept deserialization of proxy classes.  */ ;/**  * Return whether to accept deserialization of proxy classes.  */ public boolean isAcceptProxyClasses() {     return this.acceptProxyClasses. }
false;public;0;4;;@Override public void afterPropertiesSet() {     prepare(). }
true;public;0;3;/**  * Initialize this service exporter.  */ ;/**  * Initialize this service exporter.  */ public void prepare() {     this.proxy = getProxyForService(). }
false;protected,final;0;6;;protected final Object getProxy() {     if (this.proxy == null) {         throw new IllegalStateException(ClassUtils.getShortName(getClass()) + " has not been initialized").     }     return this.proxy. }
true;protected;1;3;/**  * Create an ObjectInputStream for the given InputStream.  * <p>The default implementation creates a Spring {@link CodebaseAwareObjectInputStream}.  * @param is the InputStream to read from  * @return the new ObjectInputStream instance to use  * @throws java.io.IOException if creation of the ObjectInputStream failed  */ ;/**  * Create an ObjectInputStream for the given InputStream.  * <p>The default implementation creates a Spring {@link CodebaseAwareObjectInputStream}.  * @param is the InputStream to read from  * @return the new ObjectInputStream instance to use  * @throws java.io.IOException if creation of the ObjectInputStream failed  */ protected ObjectInputStream createObjectInputStream(InputStream is) throws IOException {     return new CodebaseAwareObjectInputStream(is, getBeanClassLoader(), isAcceptProxyClasses()). }
true;protected;1;10;/**  * Perform the actual reading of an invocation result object from the  * given ObjectInputStream.  * <p>The default implementation simply calls  * {@link java.io.ObjectInputStream#readObject()}.  * Can be overridden for deserialization of a custom wrapper object rather  * than the plain invocation, for example an encryption-aware holder.  * @param ois the ObjectInputStream to read from  * @return the RemoteInvocationResult object  * @throws java.io.IOException in case of I/O failure  * @throws ClassNotFoundException if case of a transferred class not  * being found in the local ClassLoader  */ ;/**  * Perform the actual reading of an invocation result object from the  * given ObjectInputStream.  * <p>The default implementation simply calls  * {@link java.io.ObjectInputStream#readObject()}.  * Can be overridden for deserialization of a custom wrapper object rather  * than the plain invocation, for example an encryption-aware holder.  * @param ois the ObjectInputStream to read from  * @return the RemoteInvocationResult object  * @throws java.io.IOException in case of I/O failure  * @throws ClassNotFoundException if case of a transferred class not  * being found in the local ClassLoader  */ protected RemoteInvocation doReadRemoteInvocation(ObjectInputStream ois) throws IOException, ClassNotFoundException {     Object obj = ois.readObject().     if (!(obj instanceof RemoteInvocation)) {         throw new RemoteException("Deserialized object needs to be assignable to type [" + RemoteInvocation.class.getName() + "]: " + ClassUtils.getDescriptiveType(obj)).     }     return (RemoteInvocation) obj. }
true;protected;1;3;/**  * Create an ObjectOutputStream for the given OutputStream.  * <p>The default implementation creates a plain  * {@link java.io.ObjectOutputStream}.  * @param os the OutputStream to write to  * @return the new ObjectOutputStream instance to use  * @throws java.io.IOException if creation of the ObjectOutputStream failed  */ ;/**  * Create an ObjectOutputStream for the given OutputStream.  * <p>The default implementation creates a plain  * {@link java.io.ObjectOutputStream}.  * @param os the OutputStream to write to  * @return the new ObjectOutputStream instance to use  * @throws java.io.IOException if creation of the ObjectOutputStream failed  */ protected ObjectOutputStream createObjectOutputStream(OutputStream os) throws IOException {     return new ObjectOutputStream(os). }
true;protected;2;5;/**  * Perform the actual writing of the given invocation result object  * to the given ObjectOutputStream.  * <p>The default implementation simply calls  * {@link java.io.ObjectOutputStream#writeObject}.  * Can be overridden for serialization of a custom wrapper object rather  * than the plain invocation, for example an encryption-aware holder.  * @param result the RemoteInvocationResult object  * @param oos the ObjectOutputStream to write to  * @throws java.io.IOException if thrown by I/O methods  */ ;/**  * Perform the actual writing of the given invocation result object  * to the given ObjectOutputStream.  * <p>The default implementation simply calls  * {@link java.io.ObjectOutputStream#writeObject}.  * Can be overridden for serialization of a custom wrapper object rather  * than the plain invocation, for example an encryption-aware holder.  * @param result the RemoteInvocationResult object  * @param oos the ObjectOutputStream to write to  * @throws java.io.IOException if thrown by I/O methods  */ protected void doWriteRemoteInvocationResult(RemoteInvocationResult result, ObjectOutputStream oos) throws IOException {     oos.writeObject(result). }
