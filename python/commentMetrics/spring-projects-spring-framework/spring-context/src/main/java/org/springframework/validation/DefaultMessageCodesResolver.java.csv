commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify a prefix to be applied to any code built by this resolver.  * <p>Default is none. Specify, for example, "validation." to get  * error codes like "validation.typeMismatch.name".  */ ;/**  * Specify a prefix to be applied to any code built by this resolver.  * <p>Default is none. Specify, for example, "validation." to get  * error codes like "validation.typeMismatch.name".  */ public void setPrefix(@Nullable String prefix) {     this.prefix = (prefix != null ? prefix : ""). }
true;protected;0;3;/**  * Return the prefix to be applied to any code built by this resolver.  * <p>Returns an empty String in case of no prefix.  */ ;/**  * Return the prefix to be applied to any code built by this resolver.  * <p>Returns an empty String in case of no prefix.  */ protected String getPrefix() {     return this.prefix. }
true;public;1;3;/**  * Specify the format for message codes built by this resolver.  * <p>The default is {@link Format#PREFIX_ERROR_CODE}.  * @since 3.2  * @see Format  */ ;/**  * Specify the format for message codes built by this resolver.  * <p>The default is {@link Format#PREFIX_ERROR_CODE}.  * @since 3.2  * @see Format  */ public void setMessageCodeFormatter(@Nullable MessageCodeFormatter formatter) {     this.formatter = (formatter != null ? formatter : DEFAULT_FORMATTER). }
false;public;2;4;;@Override public String[] resolveMessageCodes(String errorCode, String objectName) {     return resolveMessageCodes(errorCode, objectName, "", null). }
true;public;4;17;/**  * Build the code list for the given code and field: an  * object/field-specific code, a field-specific code, a plain error code.  * <p>Arrays, Lists and Maps are resolved both for specific elements and  * the whole collection.  * <p>See the {@link DefaultMessageCodesResolver class level javadoc} for  * details on the generated codes.  * @return the list of codes  */ ;/**  * Build the code list for the given code and field: an  * object/field-specific code, a field-specific code, a plain error code.  * <p>Arrays, Lists and Maps are resolved both for specific elements and  * the whole collection.  * <p>See the {@link DefaultMessageCodesResolver class level javadoc} for  * details on the generated codes.  * @return the list of codes  */ @Override public String[] resolveMessageCodes(String errorCode, String objectName, String field, @Nullable Class<?> fieldType) {     Set<String> codeList = new LinkedHashSet<>().     List<String> fieldList = new ArrayList<>().     buildFieldList(field, fieldList).     addCodes(codeList, errorCode, objectName, fieldList).     int dotIndex = field.lastIndexOf('.').     if (dotIndex != -1) {         buildFieldList(field.substring(dotIndex + 1), fieldList).     }     addCodes(codeList, errorCode, null, fieldList).     if (fieldType != null) {         addCode(codeList, errorCode, null, fieldType.getName()).     }     addCode(codeList, errorCode, null, null).     return StringUtils.toStringArray(codeList). }
false;private;4;5;;private void addCodes(Collection<String> codeList, String errorCode, @Nullable String objectName, Iterable<String> fields) {     for (String field : fields) {         addCode(codeList, errorCode, objectName, field).     } }
false;private;4;3;;private void addCode(Collection<String> codeList, String errorCode, @Nullable String objectName, @Nullable String field) {     codeList.add(postProcessMessageCode(this.formatter.format(errorCode, objectName, field))). }
true;protected;2;16;/**  * Add both keyed and non-keyed entries for the supplied {@code field}  * to the supplied field list.  */ ;/**  * Add both keyed and non-keyed entries for the supplied {@code field}  * to the supplied field list.  */ protected void buildFieldList(String field, List<String> fieldList) {     fieldList.add(field).     String plainField = field.     int keyIndex = plainField.lastIndexOf('[').     while (keyIndex != -1) {         int endKeyIndex = plainField.indexOf(']', keyIndex).         if (endKeyIndex != -1) {             plainField = plainField.substring(0, keyIndex) + plainField.substring(endKeyIndex + 1).             fieldList.add(plainField).             keyIndex = plainField.lastIndexOf('[').         } else {             keyIndex = -1.         }     } }
true;protected;1;3;/**  * Post-process the given message code, built by this resolver.  * <p>The default implementation applies the specified prefix, if any.  * @param code the message code as built by this resolver  * @return the final message code to be returned  * @see #setPrefix  */ ;/**  * Post-process the given message code, built by this resolver.  * <p>The default implementation applies the specified prefix, if any.  * @param code the message code as built by this resolver  * @return the final message code to be returned  * @see #setPrefix  */ protected String postProcessMessageCode(String code) {     return getPrefix() + code. }
false;public;3;4;;@Override public String format(String errorCode, @Nullable String objectName, @Nullable String field) {     return toDelimitedString(errorCode, objectName, field). }
false;public;3;4;;@Override public String format(String errorCode, @Nullable String objectName, @Nullable String field) {     return toDelimitedString(objectName, field, errorCode). }
true;public,static;1;10;/**  * Concatenate the given elements, delimiting each with  * {@link DefaultMessageCodesResolver#CODE_SEPARATOR}, skipping zero-length or  * null elements altogether.  */ ;/**  * Concatenate the given elements, delimiting each with  * {@link DefaultMessageCodesResolver#CODE_SEPARATOR}, skipping zero-length or  * null elements altogether.  */ public static String toDelimitedString(String... elements) {     StringBuilder rtn = new StringBuilder().     for (String element : elements) {         if (StringUtils.hasLength(element)) {             rtn.append(rtn.length() == 0 ? "" : CODE_SEPARATOR).             rtn.append(element).         }     }     return rtn.toString(). }
