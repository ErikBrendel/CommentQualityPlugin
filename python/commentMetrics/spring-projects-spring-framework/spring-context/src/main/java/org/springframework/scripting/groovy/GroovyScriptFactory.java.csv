commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void setBeanFactory(BeanFactory beanFactory) {     if (beanFactory instanceof ConfigurableListableBeanFactory) {         ((ConfigurableListableBeanFactory) beanFactory).ignoreDependencyType(MetaClass.class).     } }
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.groovyClassLoader = buildGroovyClassLoader(classLoader). }
true;public;0;8;/**  * Return the GroovyClassLoader used by this script factory.  */ ;/**  * Return the GroovyClassLoader used by this script factory.  */ public GroovyClassLoader getGroovyClassLoader() {     synchronized (this.scriptClassMonitor) {         if (this.groovyClassLoader == null) {             this.groovyClassLoader = buildGroovyClassLoader(ClassUtils.getDefaultClassLoader()).         }         return this.groovyClassLoader.     } }
true;protected;1;4;/**  * Build a {@link GroovyClassLoader} for the given {@code ClassLoader}.  * @param classLoader the ClassLoader to build a GroovyClassLoader for  * @since 4.3.3  */ ;/**  * Build a {@link GroovyClassLoader} for the given {@code ClassLoader}.  * @param classLoader the ClassLoader to build a GroovyClassLoader for  * @since 4.3.3  */ protected GroovyClassLoader buildGroovyClassLoader(@Nullable ClassLoader classLoader) {     return (this.compilerConfiguration != null ? new GroovyClassLoader(classLoader, this.compilerConfiguration) : new GroovyClassLoader(classLoader)). }
false;public;0;4;;@Override public String getScriptSourceLocator() {     return this.scriptSourceLocator. }
true;public;0;5;/**  * Groovy scripts determine their interfaces themselves,  * hence we don't need to explicitly expose interfaces here.  * @return {@code null} always  */ ;/**  * Groovy scripts determine their interfaces themselves,  * hence we don't need to explicitly expose interfaces here.  * @return {@code null} always  */ @Override @Nullable public Class<?>[] getScriptInterfaces() {     return null. }
true;public;0;4;/**  * Groovy scripts do not need a config interface,  * since they expose their setters as public methods.  */ ;/**  * Groovy scripts do not need a config interface,  * since they expose their setters as public methods.  */ @Override public boolean requiresConfigInterface() {     return false. }
true;public;2;43;/**  * Loads and parses the Groovy script via the GroovyClassLoader.  * @see groovy.lang.GroovyClassLoader  */ ;/**  * Loads and parses the Groovy script via the GroovyClassLoader.  * @see groovy.lang.GroovyClassLoader  */ @Override @Nullable public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces) throws IOException, ScriptCompilationException {     synchronized (this.scriptClassMonitor) {         try {             Class<?> scriptClassToExecute.             this.wasModifiedForTypeCheck = false.             if (this.cachedResult != null) {                 Object result = this.cachedResult.object.                 this.cachedResult = null.                 return result.             }             if (this.scriptClass == null || scriptSource.isModified()) {                 // New script content...                 this.scriptClass = getGroovyClassLoader().parseClass(scriptSource.getScriptAsString(), scriptSource.suggestedClassName()).                 if (Script.class.isAssignableFrom(this.scriptClass)) {                     // A Groovy script, probably creating an instance: let's execute it.                     Object result = executeScript(scriptSource, this.scriptClass).                     this.scriptResultClass = (result != null ? result.getClass() : null).                     return result.                 } else {                     this.scriptResultClass = this.scriptClass.                 }             }             scriptClassToExecute = this.scriptClass.             // Process re-execution outside of the synchronized block.             return executeScript(scriptSource, scriptClassToExecute).         } catch (CompilationFailedException ex) {             this.scriptClass = null.             this.scriptResultClass = null.             throw new ScriptCompilationException(scriptSource, ex).         }     } }
false;public;1;33;;@Override @Nullable public Class<?> getScriptedObjectType(ScriptSource scriptSource) throws IOException, ScriptCompilationException {     synchronized (this.scriptClassMonitor) {         try {             if (this.scriptClass == null || scriptSource.isModified()) {                 // New script content...                 this.wasModifiedForTypeCheck = true.                 this.scriptClass = getGroovyClassLoader().parseClass(scriptSource.getScriptAsString(), scriptSource.suggestedClassName()).                 if (Script.class.isAssignableFrom(this.scriptClass)) {                     // A Groovy script, probably creating an instance: let's execute it.                     Object result = executeScript(scriptSource, this.scriptClass).                     this.scriptResultClass = (result != null ? result.getClass() : null).                     this.cachedResult = new CachedResultHolder(result).                 } else {                     this.scriptResultClass = this.scriptClass.                 }             }             return this.scriptResultClass.         } catch (CompilationFailedException ex) {             this.scriptClass = null.             this.scriptResultClass = null.             this.cachedResult = null.             throw new ScriptCompilationException(scriptSource, ex).         }     } }
false;public;1;6;;@Override public boolean requiresScriptedObjectRefresh(ScriptSource scriptSource) {     synchronized (this.scriptClassMonitor) {         return (scriptSource.isModified() || this.wasModifiedForTypeCheck).     } }
true;protected;2;36;/**  * Instantiate the given Groovy script class and run it if necessary.  * @param scriptSource the source for the underlying script  * @param scriptClass the Groovy script class  * @return the result object (either an instance of the script class  * or the result of running the script instance)  * @throws ScriptCompilationException in case of instantiation failure  */ ;/**  * Instantiate the given Groovy script class and run it if necessary.  * @param scriptSource the source for the underlying script  * @param scriptClass the Groovy script class  * @return the result object (either an instance of the script class  * or the result of running the script instance)  * @throws ScriptCompilationException in case of instantiation failure  */ @Nullable protected Object executeScript(ScriptSource scriptSource, Class<?> scriptClass) throws ScriptCompilationException {     try {         GroovyObject goo = (GroovyObject) ReflectionUtils.accessibleConstructor(scriptClass).newInstance().         if (this.groovyObjectCustomizer != null) {             // Allow metaclass and other customization.             this.groovyObjectCustomizer.customize(goo).         }         if (goo instanceof Script) {             // A Groovy script, probably creating an instance: let's execute it.             return ((Script) goo).run().         } else {             // An instance of the scripted class: let's return it as-is.             return goo.         }     } catch (NoSuchMethodException ex) {         throw new ScriptCompilationException("No default constructor on Groovy script class: " + scriptClass.getName(), ex).     } catch (InstantiationException ex) {         throw new ScriptCompilationException(scriptSource, "Unable to instantiate Groovy script class: " + scriptClass.getName(), ex).     } catch (IllegalAccessException ex) {         throw new ScriptCompilationException(scriptSource, "Could not access Groovy script constructor: " + scriptClass.getName(), ex).     } catch (InvocationTargetException ex) {         throw new ScriptCompilationException("Failed to invoke Groovy script constructor: " + scriptClass.getName(), ex.getTargetException()).     } }
false;public;0;4;;@Override public String toString() {     return "GroovyScriptFactory: script source locator [" + this.scriptSourceLocator + "]". }
