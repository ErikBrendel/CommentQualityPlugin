commented;modifiers;parameterAmount;loc;comment;code
false;private;1;12;;private ScheduledExecutorService initScheduledExecutor(@Nullable ScheduledExecutorService scheduledExecutor) {     if (scheduledExecutor != null) {         this.scheduledExecutor = scheduledExecutor.         this.enterpriseConcurrentScheduler = (managedScheduledExecutorServiceClass != null && managedScheduledExecutorServiceClass.isInstance(scheduledExecutor)).     } else {         this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor().         this.enterpriseConcurrentScheduler = false.     }     return this.scheduledExecutor. }
true;public;1;3;/**  * Specify the {@link java.util.concurrent.ScheduledExecutorService} to delegate to.  * <p>Autodetects a JSR-236 {@link javax.enterprise.concurrent.ManagedScheduledExecutorService}  * in order to use it for trigger-based scheduling if possible,  * instead of Spring's local trigger management.  * <p>Note: This will only apply to {@link TaskScheduler} invocations.  * If you want the given executor to apply to  * {@link org.springframework.scheduling.SchedulingTaskExecutor} invocations  * as well, pass the same executor reference to {@link #setConcurrentExecutor}.  * @see #setConcurrentExecutor  */ ;/**  * Specify the {@link java.util.concurrent.ScheduledExecutorService} to delegate to.  * <p>Autodetects a JSR-236 {@link javax.enterprise.concurrent.ManagedScheduledExecutorService}  * in order to use it for trigger-based scheduling if possible,  * instead of Spring's local trigger management.  * <p>Note: This will only apply to {@link TaskScheduler} invocations.  * If you want the given executor to apply to  * {@link org.springframework.scheduling.SchedulingTaskExecutor} invocations  * as well, pass the same executor reference to {@link #setConcurrentExecutor}.  * @see #setConcurrentExecutor  */ public void setScheduledExecutor(@Nullable ScheduledExecutorService scheduledExecutor) {     initScheduledExecutor(scheduledExecutor). }
true;public;1;4;/**  * Provide an {@link ErrorHandler} strategy.  */ ;/**  * Provide an {@link ErrorHandler} strategy.  */ public void setErrorHandler(ErrorHandler errorHandler) {     Assert.notNull(errorHandler, "ErrorHandler must not be null").     this.errorHandler = errorHandler. }
false;public;2;17;;@Override @Nullable public ScheduledFuture<?> schedule(Runnable task, Trigger trigger) {     try {         if (this.enterpriseConcurrentScheduler) {             return new EnterpriseConcurrentTriggerScheduler().schedule(decorateTask(task, true), trigger).         } else {             ErrorHandler errorHandler = (this.errorHandler != null ? this.errorHandler : TaskUtils.getDefaultErrorHandler(true)).             return new ReschedulingRunnable(task, trigger, this.scheduledExecutor, errorHandler).schedule().         }     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + this.scheduledExecutor + "] did not accept task: " + task, ex).     } }
false;public;2;10;;@Override public ScheduledFuture<?> schedule(Runnable task, Date startTime) {     long initialDelay = startTime.getTime() - System.currentTimeMillis().     try {         return this.scheduledExecutor.schedule(decorateTask(task, false), initialDelay, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + this.scheduledExecutor + "] did not accept task: " + task, ex).     } }
false;public;3;10;;@Override public ScheduledFuture<?> scheduleAtFixedRate(Runnable task, Date startTime, long period) {     long initialDelay = startTime.getTime() - System.currentTimeMillis().     try {         return this.scheduledExecutor.scheduleAtFixedRate(decorateTask(task, true), initialDelay, period, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + this.scheduledExecutor + "] did not accept task: " + task, ex).     } }
false;public;2;9;;@Override public ScheduledFuture<?> scheduleAtFixedRate(Runnable task, long period) {     try {         return this.scheduledExecutor.scheduleAtFixedRate(decorateTask(task, true), 0, period, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + this.scheduledExecutor + "] did not accept task: " + task, ex).     } }
false;public;3;10;;@Override public ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, Date startTime, long delay) {     long initialDelay = startTime.getTime() - System.currentTimeMillis().     try {         return this.scheduledExecutor.scheduleWithFixedDelay(decorateTask(task, true), initialDelay, delay, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + this.scheduledExecutor + "] did not accept task: " + task, ex).     } }
false;public;2;9;;@Override public ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, long delay) {     try {         return this.scheduledExecutor.scheduleWithFixedDelay(decorateTask(task, true), 0, delay, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + this.scheduledExecutor + "] did not accept task: " + task, ex).     } }
false;private;2;7;;private Runnable decorateTask(Runnable task, boolean isRepeatingTask) {     Runnable result = TaskUtils.decorateTaskWithErrorHandler(task, this.errorHandler, isRepeatingTask).     if (this.enterpriseConcurrentScheduler) {         result = ManagedTaskBuilder.buildManagedTask(result, task.toString()).     }     return result. }
false;public;2;7;;@Override @Nullable public Date getNextRunTime(@Nullable LastExecution le, Date taskScheduledTime) {     return (trigger.nextExecutionTime(le != null ? new SimpleTriggerContext(le.getScheduledStart(), le.getRunStart(), le.getRunEnd()) : new SimpleTriggerContext())). }
false;public;2;4;;@Override public boolean skipRun(LastExecution lastExecution, Date scheduledRunTime) {     return false. }
false;public;2;16;;public ScheduledFuture<?> schedule(Runnable task, final Trigger trigger) {     ManagedScheduledExecutorService executor = (ManagedScheduledExecutorService) scheduledExecutor.     return executor.schedule(task, new javax.enterprise.concurrent.Trigger() {          @Override         @Nullable         public Date getNextRunTime(@Nullable LastExecution le, Date taskScheduledTime) {             return (trigger.nextExecutionTime(le != null ? new SimpleTriggerContext(le.getScheduledStart(), le.getRunStart(), le.getRunEnd()) : new SimpleTriggerContext())).         }          @Override         public boolean skipRun(LastExecution lastExecution, Date scheduledRunTime) {             return false.         }     }). }
