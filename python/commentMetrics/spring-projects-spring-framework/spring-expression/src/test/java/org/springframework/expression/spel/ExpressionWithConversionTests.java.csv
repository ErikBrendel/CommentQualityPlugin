commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void setUp() throws Exception {     ExpressionWithConversionTests.typeDescriptorForListOfString = new TypeDescriptor(ExpressionWithConversionTests.class.getDeclaredField("listOfString")).     ExpressionWithConversionTests.typeDescriptorForListOfInteger = new TypeDescriptor(ExpressionWithConversionTests.class.getDeclaredField("listOfInteger")). }
true;public;0;17;/**  * Test the service can convert what we are about to use in the expression evaluation tests.  */ ;/**  * Test the service can convert what we are about to use in the expression evaluation tests.  */ @Test public void testConversionsAvailable() throws Exception {     TypeConvertorUsingConversionService tcs = new TypeConvertorUsingConversionService().     // ArrayList containing List<Integer> to List<String>     Class<?> clazz = typeDescriptorForListOfString.getElementTypeDescriptor().getType().     assertEquals(String.class, clazz).     List<?> l = (List<?>) tcs.convertValue(listOfInteger, TypeDescriptor.forObject(listOfInteger), typeDescriptorForListOfString).     assertNotNull(l).     // ArrayList containing List<String> to List<Integer>     clazz = typeDescriptorForListOfInteger.getElementTypeDescriptor().getType().     assertEquals(Integer.class, clazz).     l = (List<?>) tcs.convertValue(listOfString, TypeDescriptor.forObject(listOfString), typeDescriptorForListOfString).     assertNotNull(l). }
false;public;0;12;;@Test public void testSetParameterizedList() throws Exception {     StandardEvaluationContext context = TestScenarioCreator.getTestEvaluationContext().     Expression e = parser.parseExpression("listOfInteger.size()").     assertEquals(0, e.getValue(context, Integer.class).intValue()).     context.setTypeConverter(new TypeConvertorUsingConversionService()).     // Assign a List<String> to the List<Integer> field - the component elements should be converted     parser.parseExpression("listOfInteger").setValue(context, listOfString).     // size now 3     assertEquals(3, e.getValue(context, Integer.class).intValue()).     // element type correctly Integer     Class<?> clazz = parser.parseExpression("listOfInteger[1].getClass()").getValue(context, Class.class).     assertEquals(Integer.class, clazz). }
false;public;1;8;;@SuppressWarnings("unused") public int sum(Collection<Integer> numbers) {     int total = 0.     for (int i : numbers) {         total += i.     }     return total. }
false;public;0;32;;@Test public void testCoercionToCollectionOfPrimitive() throws Exception {     class TestTarget {          @SuppressWarnings("unused")         public int sum(Collection<Integer> numbers) {             int total = 0.             for (int i : numbers) {                 total += i.             }             return total.         }     }     StandardEvaluationContext evaluationContext = new StandardEvaluationContext().     TypeDescriptor collectionType = new TypeDescriptor(new MethodParameter(TestTarget.class.getDeclaredMethod("sum", Collection.class), 0)).     // The type conversion is possible     assertTrue(evaluationContext.getTypeConverter().canConvert(TypeDescriptor.valueOf(String.class), collectionType)).     // ... and it can be done successfully     assertEquals("[1, 2, 3, 4]", evaluationContext.getTypeConverter().convertValue("1,2,3,4", TypeDescriptor.valueOf(String.class), collectionType).toString()).     evaluationContext.setVariable("target", new TestTarget()).     // OK up to here, so the evaluation should be fine...     // ... but this fails     int result = (Integer) parser.parseExpression("#target.sum(#root)").getValue(evaluationContext, "1,2,3,4").     assertEquals("Wrong result: " + result, 10, result). }
false;public;0;32;;@Test public void testConvert() {     Foo root = new Foo("bar").     Collection<String> foos = Collections.singletonList("baz").     StandardEvaluationContext context = new StandardEvaluationContext(root).     // property access     Expression expression = parser.parseExpression("foos").     expression.setValue(context, foos).     Foo baz = root.getFoos().iterator().next().     assertEquals("baz", baz.value).     // method call     expression = parser.parseExpression("setFoos(#foos)").     context.setVariable("foos", foos).     expression.getValue(context).     baz = root.getFoos().iterator().next().     assertEquals("baz", baz.value).     // method call with result from method call     expression = parser.parseExpression("setFoos(getFoosAsStrings())").     expression.getValue(context).     baz = root.getFoos().iterator().next().     assertEquals("baz", baz.value).     // method call with result from method call     expression = parser.parseExpression("setFoos(getFoosAsObjects())").     expression.getValue(context).     baz = root.getFoos().iterator().next().     assertEquals("baz", baz.value). }
false;public;2;4;;@Override public boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {     return this.service.canConvert(sourceType, targetType). }
false;public;3;4;;@Override public Object convertValue(Object value, TypeDescriptor sourceType, TypeDescriptor targetType) throws EvaluationException {     return this.service.convert(value, sourceType, targetType). }
false;public;1;3;;public void setFoos(Collection<Foo> foos) {     this.foos = foos. }
false;public;0;3;;public Collection<Foo> getFoos() {     return this.foos. }
false;public;0;3;;public Collection<String> getFoosAsStrings() {     return Collections.singletonList("baz"). }
false;public;0;3;;public Collection<?> getFoosAsObjects() {     return Collections.singletonList("baz"). }
