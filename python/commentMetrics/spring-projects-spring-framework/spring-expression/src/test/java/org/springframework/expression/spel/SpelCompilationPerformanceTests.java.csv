commented;modifiers;parameterAmount;loc;comment;code
true;public;0;83;/**  * This test verifies the new support for compiling mathematical expressions with  * different operand types.  */ ;/**  * This test verifies the new support for compiling mathematical expressions with  * different operand types.  */ @Test public void compilingMathematicalExpressionsWithDifferentOperandTypes() throws Exception {     NumberHolder nh = new NumberHolder().     expression = parser.parseExpression("(T(Integer).valueOf(payload).doubleValue())/18D").     Object o = expression.getValue(nh).     assertEquals(2d, o).     System.out.println("Performance check for SpEL expression: '(T(Integer).valueOf(payload).doubleValue())/18D'").     long stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     compile(expression).     System.out.println("Now compiled:").     o = expression.getValue(nh).     assertEquals(2d, o).     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     expression = parser.parseExpression("payload/18D").     o = expression.getValue(nh).     assertEquals(2d, o).     System.out.println("Performance check for SpEL expression: 'payload/18D'").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     compile(expression).     System.out.println("Now compiled:").     o = expression.getValue(nh).     assertEquals(2d, o).     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(nh).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms"). }
false;public;0;42;;@Test public void inlineLists() throws Exception {     expression = parser.parseExpression("{'abcde','ijklm'}[0].substring({1,3,4}[0],{1,3,4}[1])").     Object o = expression.getValue().     assertEquals("bc", o).     System.out.println("Performance check for SpEL expression: '{'abcde','ijklm'}[0].substring({1,3,4}[0],{1,3,4}[1])'").     long stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     compile(expression).     System.out.println("Now compiled:").     o = expression.getValue().     assertEquals("bc", o).     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms"). }
false;public;0;42;;@Test public void inlineNestedLists() throws Exception {     expression = parser.parseExpression("{'abcde',{'ijklm','nopqr'}}[1][0].substring({1,3,4}[0],{1,3,4}[1])").     Object o = expression.getValue().     assertEquals("jk", o).     System.out.println("Performance check for SpEL expression: '{'abcde','ijklm'}[0].substring({1,3,4}[0],{1,3,4}[1])'").     long stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     compile(expression).     System.out.println("Now compiled:").     o = expression.getValue().     assertEquals("jk", o).     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue().     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms"). }
false;public;0;44;;@Test public void stringConcatenation() throws Exception {     expression = parser.parseExpression("'hello' + getWorld() + ' spring'").     Greeter g = new Greeter().     Object o = expression.getValue(g).     assertEquals("helloworld spring", o).     System.out.println("Performance check for SpEL expression: 'hello' + getWorld() + ' spring'").     long stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(g).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(g).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(g).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     compile(expression).     System.out.println("Now compiled:").     o = expression.getValue(g).     assertEquals("helloworld spring", o).     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(g).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(g).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms").     stime = System.currentTimeMillis().     for (int i = 0. i < 1000000. i++) {         o = expression.getValue(g).     }     System.out.println("One million iterations: " + (System.currentTimeMillis() - stime) + "ms"). }
false;public;0;54;;@Test public void complexExpressionPerformance() throws Exception {     Payload payload = new Payload().     Expression expression = parser.parseExpression("DR[0].DRFixedSection.duration lt 0.1").     boolean b = false.     long iTotal = 0, cTotal = 0.     // warmup     for (int i = 0. i < count. i++) {         b = expression.getValue(payload, Boolean.TYPE).     }     log("timing interpreted: ").     for (int i = 0. i < iterations. i++) {         long stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             b = expression.getValue(payload, Boolean.TYPE).         }         long etime = System.currentTimeMillis().         long interpretedSpeed = (etime - stime).         iTotal += interpretedSpeed.         log(interpretedSpeed + "ms ").     }     logln().     compile(expression).     boolean bc = false.     expression.getValue(payload, Boolean.TYPE).     log("timing compiled: ").     for (int i = 0. i < iterations. i++) {         long stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             bc = expression.getValue(payload, Boolean.TYPE).         }         long etime = System.currentTimeMillis().         long compiledSpeed = (etime - stime).         cTotal += compiledSpeed.         log(compiledSpeed + "ms ").     }     logln().     reportPerformance("complex expression", iTotal, cTotal).     // Verify the result     assertFalse(b).     // Verify the same result for compiled vs interpreted     assertEquals(b, bc).     // Verify if the input changes, the result changes     payload.DR[0].DRFixedSection.duration = 0.04d.     bc = expression.getValue(payload, Boolean.TYPE).     assertTrue(bc). }
false;public;0;3;;public String hello() {     return "foobar". }
false;public;0;49;;@Test public void compilingMethodReference() throws Exception {     long interpretedTotal = 0, compiledTotal = 0.     long stime, etime.     String interpretedResult = null, compiledResult = null.     HW testdata = new HW().     Expression expression = parser.parseExpression("hello()").     // warmup     for (int i = 0. i < count. i++) {         interpretedResult = expression.getValue(testdata, String.class).     }     log("timing interpreted: ").     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             interpretedResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long interpretedSpeed = (etime - stime).         interpretedTotal += interpretedSpeed.         log(interpretedSpeed + "ms ").     }     logln().     compile(expression).     log("timing compiled: ").     expression.getValue(testdata, String.class).     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             compiledResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long compiledSpeed = (etime - stime).         compiledTotal += compiledSpeed.         log(compiledSpeed + "ms ").     }     logln().     assertEquals(interpretedResult, compiledResult).     reportPerformance("method reference", interpretedTotal, compiledTotal).     if (compiledTotal >= interpretedTotal) {         fail("Compiled version is slower than interpreted!").     } }
false;public;0;45;;@Test public void compilingPropertyReferenceField() throws Exception {     long interpretedTotal = 0, compiledTotal = 0, stime, etime.     String interpretedResult = null, compiledResult = null.     TestClass2 testdata = new TestClass2().     Expression expression = parser.parseExpression("name").     // warmup     for (int i = 0. i < count. i++) {         expression.getValue(testdata, String.class).     }     log("timing interpreted: ").     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             interpretedResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long interpretedSpeed = (etime - stime).         interpretedTotal += interpretedSpeed.         log(interpretedSpeed + "ms ").     }     logln().     compile(expression).     log("timing compiled: ").     expression.getValue(testdata, String.class).     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             compiledResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long compiledSpeed = (etime - stime).         compiledTotal += compiledSpeed.         log(compiledSpeed + "ms ").     }     logln().     assertEquals(interpretedResult, compiledResult).     reportPerformance("property reference (field)", interpretedTotal, compiledTotal). }
false;public;0;45;;@Test public void compilingPropertyReferenceNestedField() throws Exception {     long interpretedTotal = 0, compiledTotal = 0, stime, etime.     String interpretedResult = null, compiledResult = null.     TestClass2 testdata = new TestClass2().     Expression expression = parser.parseExpression("foo.bar.boo").     // warmup     for (int i = 0. i < count. i++) {         expression.getValue(testdata, String.class).     }     log("timing interpreted: ").     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             interpretedResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long interpretedSpeed = (etime - stime).         interpretedTotal += interpretedSpeed.         log(interpretedSpeed + "ms ").     }     logln().     compile(expression).     log("timing compiled: ").     expression.getValue(testdata, String.class).     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             compiledResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long compiledSpeed = (etime - stime).         compiledTotal += compiledSpeed.         log(compiledSpeed + "ms ").     }     logln().     assertEquals(interpretedResult, compiledResult).     reportPerformance("property reference (nested field)", interpretedTotal, compiledTotal). }
false;public;0;44;;@Test public void compilingPropertyReferenceNestedMixedFieldGetter() throws Exception {     long interpretedTotal = 0, compiledTotal = 0, stime, etime.     String interpretedResult = null, compiledResult = null.     TestClass2 testdata = new TestClass2().     Expression expression = parser.parseExpression("foo.baz.boo").     // warmup     for (int i = 0. i < count. i++) {         expression.getValue(testdata, String.class).     }     log("timing interpreted: ").     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             interpretedResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long interpretedSpeed = (etime - stime).         interpretedTotal += interpretedSpeed.         log(interpretedSpeed + "ms ").     }     logln().     compile(expression).     log("timing compiled: ").     expression.getValue(testdata, String.class).     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             compiledResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long compiledSpeed = (etime - stime).         compiledTotal += compiledSpeed.         log(compiledSpeed + "ms ").     }     logln().     assertEquals(interpretedResult, compiledResult).     reportPerformance("nested property reference (mixed field/getter)", interpretedTotal, compiledTotal). }
false;public;0;46;;@Test public void compilingNestedMixedFieldPropertyReferenceMethodReference() throws Exception {     long interpretedTotal = 0, compiledTotal = 0, stime, etime.     String interpretedResult = null, compiledResult = null.     TestClass2 testdata = new TestClass2().     Expression expression = parser.parseExpression("foo.bay().boo").     // warmup     for (int i = 0. i < count. i++) {         expression.getValue(testdata, String.class).     }     log("timing interpreted: ").     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             interpretedResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long interpretedSpeed = (etime - stime).         interpretedTotal += interpretedSpeed.         log(interpretedSpeed + "ms ").     }     logln().     compile(expression).     log("timing compiled: ").     expression.getValue(testdata, String.class).     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             compiledResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long compiledSpeed = (etime - stime).         compiledTotal += compiledSpeed.         log(compiledSpeed + "ms ").     }     logln().     assertEquals(interpretedResult, compiledResult).     reportPerformance("nested reference (mixed field/method)", interpretedTotal, compiledTotal). }
false;public;0;51;;@Test public void compilingPropertyReferenceGetter() throws Exception {     long interpretedTotal = 0, compiledTotal = 0, stime, etime.     String interpretedResult = null, compiledResult = null.     TestClass2 testdata = new TestClass2().     Expression expression = parser.parseExpression("name2").     // warmup     for (int i = 0. i < count. i++) {         expression.getValue(testdata, String.class).     }     log("timing interpreted: ").     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             interpretedResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long interpretedSpeed = (etime - stime).         interpretedTotal += interpretedSpeed.         log(interpretedSpeed + "ms ").     }     logln().     compile(expression).     log("timing compiled: ").     expression.getValue(testdata, String.class).     for (int i = 0. i < iterations. i++) {         stime = System.currentTimeMillis().         for (int j = 0. j < count. j++) {             compiledResult = expression.getValue(testdata, String.class).         }         etime = System.currentTimeMillis().         long compiledSpeed = (etime - stime).         compiledTotal += compiledSpeed.         log(compiledSpeed + "ms ").     }     logln().     assertEquals(interpretedResult, compiledResult).     reportPerformance("property reference (getter)", interpretedTotal, compiledTotal).     if (compiledTotal >= interpretedTotal) {         fail("Compiled version is slower than interpreted!").     } }
false;private;3;13;;private void reportPerformance(String title, long interpretedTotal, long compiledTotal) {     double averageInterpreted = interpretedTotal / iterations.     double averageCompiled = compiledTotal / iterations.     double ratio = (averageCompiled / averageInterpreted) * 100.0d.     logln(">>" + title + ": average for " + count + ": compiled=" + averageCompiled + "ms interpreted=" + averageInterpreted + "ms: compiled takes " + ((int) ratio) + "% of the interpreted time").     if (averageCompiled > averageInterpreted) {         fail("Compiled version took longer than interpreted! CompiledSpeed=~" + averageCompiled + "ms InterpretedSpeed=" + averageInterpreted + "ms").     }     logln(). }
false;private;1;5;;private void log(String message) {     if (noisyTests) {         System.out.print(message).     } }
false;private;1;10;;private void logln(String... message) {     if (noisyTests) {         if (message.length > 0) {             System.out.println(message[0]).         } else {             System.out.println().         }     } }
false;private;1;3;;private void compile(Expression expression) {     assertTrue(SpelCompiler.compile(expression)). }
false;public;0;3;;public Two[] getDR() {     return DR. }
false;public;0;3;;public Three getDRFixedSection() {     return DRFixedSection. }
false;public;0;3;;public double getDuration() {     return duration. }
false;public;0;3;;public String getWorld() {     return "world". }
false;public;0;3;;public String getName2() {     return name2. }
false;public;0;3;;public Bar getBaz() {     return b. }
false;public;0;3;;public Bar bay() {     return b. }
