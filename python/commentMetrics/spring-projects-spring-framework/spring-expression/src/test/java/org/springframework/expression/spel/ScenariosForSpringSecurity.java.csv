commented;modifiers;parameterAmount;loc;comment;code
false;public;0;21;;@Test public void testScenario01_Roles() throws Exception {     try {         SpelExpressionParser parser = new SpelExpressionParser().         StandardEvaluationContext ctx = new StandardEvaluationContext().         Expression expr = parser.parseRaw("hasAnyRole('MANAGER','TELLER')").         ctx.setRootObject(new Person("Ben")).         Boolean value = expr.getValue(ctx, Boolean.class).         assertFalse(value).         ctx.setRootObject(new Manager("Luke")).         value = expr.getValue(ctx, Boolean.class).         assertTrue(value).     } catch (EvaluationException ee) {         ee.printStackTrace().         fail("Unexpected SpelException: " + ee.getMessage()).     } }
false;public;0;34;;@Test public void testScenario02_ComparingNames() throws Exception {     SpelExpressionParser parser = new SpelExpressionParser().     StandardEvaluationContext ctx = new StandardEvaluationContext().     ctx.addPropertyAccessor(new SecurityPrincipalAccessor()).     // Multiple options for supporting this expression: "p.name == principal.name"     // (1) If the right person is the root context object then "name==principal.name" is good enough     Expression expr = parser.parseRaw("name == principal.name").     ctx.setRootObject(new Person("Andy")).     Boolean value = expr.getValue(ctx, Boolean.class).     assertTrue(value).     ctx.setRootObject(new Person("Christian")).     value = expr.getValue(ctx, Boolean.class).     assertFalse(value).     // (2) Or register an accessor that can understand 'p' and return the right person     expr = parser.parseRaw("p.name == principal.name").     PersonAccessor pAccessor = new PersonAccessor().     ctx.addPropertyAccessor(pAccessor).     ctx.setRootObject(null).     pAccessor.setPerson(new Person("Andy")).     value = expr.getValue(ctx, Boolean.class).     assertTrue(value).     pAccessor.setPerson(new Person("Christian")).     value = expr.getValue(ctx, Boolean.class).     assertFalse(value). }
false;public;0;21;;@Test public void testScenario03_Arithmetic() throws Exception {     SpelExpressionParser parser = new SpelExpressionParser().     StandardEvaluationContext ctx = new StandardEvaluationContext().     // Might be better with a as a variable although it would work as a property too...     // Variable references using a '#'     Expression expr = parser.parseRaw("(hasRole('SUPERVISOR') or (#a <  1.042)) and hasIpAddress('10.10.0.0/16')").     Boolean value = null.     // referenced as #a in the expression     ctx.setVariable("a", 1.0d).     // so non-qualified references 'hasRole()' 'hasIpAddress()' are invoked against it     ctx.setRootObject(new Supervisor("Ben")).     value = expr.getValue(ctx, Boolean.class).     assertTrue(value).     ctx.setRootObject(new Manager("Luke")).     ctx.setVariable("a", 1.043d).     value = expr.getValue(ctx, Boolean.class).     assertFalse(value). }
true;public;0;24;// Here i'm going to change which hasRole() executes and make it one of my own Java methods ;// Here i'm going to change which hasRole() executes and make it one of my own Java methods @Test public void testScenario04_ControllingWhichMethodsRun() throws Exception {     SpelExpressionParser parser = new SpelExpressionParser().     StandardEvaluationContext ctx = new StandardEvaluationContext().     // so non-qualified references 'hasRole()' 'hasIpAddress()' are invoked against it).     ctx.setRootObject(new Supervisor("Ben")).     // NEEDS TO OVERRIDE THE REFLECTION ONE - SHOW REORDERING MECHANISM     ctx.addMethodResolver(new MyMethodResolver()).     // Might be better with a as a variable although it would work as a property too...     // Variable references using a '#'     // SpelExpression expr = parser.parseExpression("(hasRole('SUPERVISOR') or (#a <  1.042)) and hasIpAddress('10.10.0.0/16')").     Expression expr = parser.parseRaw("(hasRole(3) or (#a <  1.042)) and hasIpAddress('10.10.0.0/16')").     Boolean value = null.     // referenced as #a in the expression     ctx.setVariable("a", 1.0d).     value = expr.getValue(ctx, Boolean.class).     assertTrue(value). // ctx.setRootObject(new Manager("Luke")). // ctx.setVariable("a",1.043d). // value = (Boolean)expr.getValue(ctx,Boolean.class). // assertFalse(value). }
false;public;0;1;;public String[] getRoles() {     return new String[] { "NONE" }. }
false;public;1;10;;public boolean hasAnyRole(String... roles) {     if (roles == null)         return true.     String[] myRoles = getRoles().     for (int i = 0. i < myRoles.length. i++) {         for (int j = 0. j < roles.length. j++) {             if (myRoles[i].equals(roles[j]))                 return true.         }     }     return false. }
false;public;1;3;;public boolean hasRole(String role) {     return hasAnyRole(role). }
false;public;1;3;;public boolean hasIpAddress(String ipaddr) {     return true. }
false;public;0;1;;public String getName() {     return n. }
false;public;0;2;;@Override public String[] getRoles() {     return new String[] { "MANAGER" }. }
false;public;0;2;;@Override public String[] getRoles() {     return new String[] { "TELLER" }. }
false;public;0;2;;@Override public String[] getRoles() {     return new String[] { "SUPERVISOR" }. }
false;public;3;4;;@Override public boolean canRead(EvaluationContext context, Object target, String name) throws AccessException {     return name.equals("principal"). }
false;public;3;4;;@Override public TypedValue read(EvaluationContext context, Object target, String name) throws AccessException {     return new TypedValue(new Principal()). }
false;public;3;4;;@Override public boolean canWrite(EvaluationContext context, Object target, String name) throws AccessException {     return false. }
false;public;4;4;;@Override public void write(EvaluationContext context, Object target, String name, Object newValue) throws AccessException { }
false;public;0;4;;@Override public Class<?>[] getSpecificTargetClasses() {     return null. }
false;;1;1;;void setPerson(Person p) {     this.activePerson = p. }
false;public;3;4;;@Override public boolean canRead(EvaluationContext context, Object target, String name) throws AccessException {     return name.equals("p"). }
false;public;3;4;;@Override public TypedValue read(EvaluationContext context, Object target, String name) throws AccessException {     return new TypedValue(activePerson). }
false;public;3;4;;@Override public boolean canWrite(EvaluationContext context, Object target, String name) throws AccessException {     return false. }
false;public;4;4;;@Override public void write(EvaluationContext context, Object target, String name, Object newValue) throws AccessException { }
false;public;0;4;;@Override public Class<?>[] getSpecificTargetClasses() {     return null. }
false;public;3;18;;@Override public TypedValue execute(EvaluationContext context, Object target, Object... arguments) throws AccessException {     try {         Method m = HasRoleExecutor.class.getMethod("hasRole", String[].class).         Object[] args = arguments.         if (args != null) {             ReflectionHelper.convertAllArguments(tc, args, m).         }         if (m.isVarArgs()) {             args = ReflectionHelper.setupArgumentsForVarargsInvocation(m.getParameterTypes(), args).         }         return new TypedValue(m.invoke(null, args), new TypeDescriptor(new MethodParameter(m, -1))).     } catch (Exception ex) {         throw new AccessException("Problem invoking hasRole", ex).     } }
false;public,static;1;3;;public static boolean hasRole(String... strings) {     return true. }
false;public;4;8;;@Override public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, List<TypeDescriptor> arguments) throws AccessException {     if (name.equals("hasRole")) {         return new HasRoleExecutor(context.getTypeConverter()).     }     return null. }
