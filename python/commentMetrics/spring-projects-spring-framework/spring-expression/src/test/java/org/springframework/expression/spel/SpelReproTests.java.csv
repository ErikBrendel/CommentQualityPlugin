# id;timestamp;commentText;codeText;commentWords;codeWords
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1391876651;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {__			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {__			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1394055372;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1394115082;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1394454836;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1394533229;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1395866798;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1396794328;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1414924858;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1417644204;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1419274456;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1426108143;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1426267018;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1432307229;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1432857824;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1436017596;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1453421656;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1454934182;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1456768377;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1458843770;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1460149585;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1467730834;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1467968225;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1468964586;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1472477110;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1479982135;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1496837955;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1498780456;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1507112596;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_8224() throws Exception;1509050974;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1351600760;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1353028965;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1355390119;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1356735495;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1362408075;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1368482696;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1378301821;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1378305831;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1382378529;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1382748902;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1385064520;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1385412762;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1386100884;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1389887689;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		try {_			ExpressionParser parser = new SpelExpressionParser()__			StandardEvaluationContext context = new StandardEvaluationContext()__			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__			methodResolvers.add(new ReflectiveMethodResolver() {_				@Override_				protected Method[] getMethods(Class<?> type) {_					try {_						return new Method[] {_								Integer.class.getDeclaredMethod("parseInt", new Class[] {_										String.class, Integer.TYPE }) }__					} catch (NoSuchMethodException e1) {_						return new Method[0]__					}_				}_			})___			context.setMethodResolvers(methodResolvers)__			org.springframework.expression.Expression expression =_					parser.parseExpression("parseInt('-FF', 16)")___			Integer result = expression.getValue(context, "", Integer.class)__			assertEquals("Equal assertion failed: ", -255, result.intValue())__		} catch (Exception e) {_			e.printStackTrace()__			fail("Unexpected exception: "+e.toString())__		}_	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,try,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,e1,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value,catch,exception,e,e,print,stack,trace,fail,unexpected,exception,e,to,string
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1389892680;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {Integer.class.getDeclaredMethod("parseInt",_							new Class[] {String.class, Integer.TYPE })}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		org.springframework.expression.Expression expression =_				parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals("Equal assertion failed: ", -255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value
SpelReproTests -> @Test 	public void testCustomStaticFunctions_SPR9038();1390506741;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void testCustomStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {Integer.class.getDeclaredMethod("parseInt",_							new Class[] {String.class, Integer.TYPE })}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		org.springframework.expression.Expression expression =_				parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals("Equal assertion failed: ", -255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,org,springframework,expression,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,equal,assertion,failed,255,result,int,value
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1351600760;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1353028965;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1355390119;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1356735495;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1362408075;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1368482696;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1378301821;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1378305831;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1382378529;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1382748902;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1385064520;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1385412762;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1386100884;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1389887689;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1389892680;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testPropertyAccessorOrder_8211();1390506741;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void testPropertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext =_			new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first",_			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second",_				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third",_				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth",_				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1351600760;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		Assert.assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1353028965;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		Assert.assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1355390119;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1356735495;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1362408075;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1368482696;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1378301821;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1378305831;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1382378529;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1382748902;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1385064520;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1385412762;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1386100884;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1389887689;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1389892680;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_1();1390506741;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1391876651;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1394055372;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1394115082;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1394454836;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1394533229;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1395866798;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1396794328;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1414924858;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1417644204;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1419274456;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1426108143;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1426267018;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1432307229;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1432857824;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1436017596;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1453421656;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1454934182;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1456768377;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1458843770;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1460149585;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1467730834;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1467968225;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1468964586;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1472477110;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1479982135;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1496837955;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1498780456;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1507112596;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_8224() throws Exception;1509050974;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1391876651;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1394055372;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1394115082;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1394454836;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1394533229;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1395866798;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1396794328;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1414924858;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1417644204;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1419274456;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1426108143;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1426267018;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1432307229;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1432857824;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1436017596;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1453421656;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1454934182;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1456768377;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1458843770;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1460149585;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1467730834;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1467968225;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1468964586;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1472477110;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1479982135;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1496837955;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1498780456;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1507112596;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_8211();1509050974;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1351600760;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		Assert.assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1353028965;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		Assert.assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1355390119;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1356735495;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1362408075;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1368482696;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1378301821;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1378305831;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1382378529;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1382748902;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1385064520;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1385412762;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1386100884;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1389887689;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1389892680;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_2();1390506741;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext,String.class)__		assertEquals("hello",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("hello",name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1351600760;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		Assert.assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		Assert.assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1353028965;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		Assert.assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		Assert.assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1355390119;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1356735495;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1362408075;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1368482696;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1378301821;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1378305831;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1382378529;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1382748902;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1385064520;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1385412762;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1386100884;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1389887689;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1389892680;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_5();1390506741;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext,String.class)__		assertEquals("world",g.value)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1351600760;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		Assert.assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1353028965;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		Assert.assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1355390119;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1356735495;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1362408075;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1368482696;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1378301821;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1378305831;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1382378529;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1382748902;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1385064520;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1385412762;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1386100884;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1389887689;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1389892680;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_3();1390506741;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar","wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)__		name = expr.getValue(eContext,String.class)_ _		assertEquals("wobble",name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1351600760;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		Assert.assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		Assert.assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1353028965;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		Assert.assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		Assert.assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1355390119;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1356735495;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1362408075;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1368482696;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1378301821;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1378305831;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1382378529;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1382748902;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1385064520;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1385412762;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1386100884;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1389887689;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1389892680;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testIndexingAsAPropertyAccess_SPR6968_4();1390506741;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void testIndexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar","wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext,String.class)__		assertEquals("world",g.wibble)__		expr.getValue(eContext,String.class)_ _		assertEquals("world",g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1351600760;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1353028965;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1355390119;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1356735495;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1362408075;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1368482696;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1378301821;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1378305831;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1382378529;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1382748902;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1385064520;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1385412762;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1386100884;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1389887689;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1389892680;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testWideningPrimitiveConversion_8224() throws Exception;1390506741;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void testWideningPrimitiveConversion_8224() throws Exception {__		class WideningPrimitiveConversion {__			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)___		WideningPrimitiveConversion target = new WideningPrimitiveConversion()___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)___		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)___		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1351600760;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1353028965;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		Assert.assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1355390119;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1356735495;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1362408075;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1368482696;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1378301821;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1378305831;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1382378529;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1382748902;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1385064520;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1385412762;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1386100884;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1389887689;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1389892680;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void testDollarPrefixedIdentifier_SPR7100();1390506741;$ related identifiers;@Test_	public void testDollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo","wibble")__		h.map.put("foo$bar","wobble")__		h.map.put("foobar$$","wabble")__		h.map.put("$","wubble")__		h.map.put("$$","webble")__		h.map.put("$_$","tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext,String.class)__		assertEquals("wibble",name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext,String.class)__		assertEquals("wobble",name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wabble",name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext,String.class)__		assertEquals("wubble",name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext,String.class)__		assertEquals("webble",name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext,String.class)__		assertEquals("tribble",name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void propertyAccessorOrder_SPR8211();1509094364;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_SPR8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_SPR8211();1509110931;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_SPR8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_SPR8211();1510610453;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_SPR8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_SPR8211();1521632355;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_SPR8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_SPR8211();1522231598;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_SPR8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void propertyAccessorOrder_SPR8211();1547763210;We add property accessors in the order:_First, Second, Third, Fourth._They are not utilized in this order_ preventing a priority or order of operations_in evaluation of SPEL expressions for a given context.;@Test_	public void propertyAccessorOrder_SPR8211() {_		ExpressionParser expressionParser = new SpelExpressionParser()__		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new ContextObject())___		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"))__		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"))___		assertEquals("first", expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext))__		assertEquals("second", expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext))__		assertEquals("third", expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext))__		assertEquals("fourth", expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext))__	};we,add,property,accessors,in,the,order,first,second,third,fourth,they,are,not,utilized,in,this,order,preventing,a,priority,or,order,of,operations,in,evaluation,of,spel,expressions,for,a,given,context;test,public,void,expression,parser,expression,parser,new,spel,expression,parser,standard,evaluation,context,evaluation,context,new,standard,evaluation,context,new,context,object,evaluation,context,add,property,accessor,new,test,property,accessor,first,context,evaluation,context,add,property,accessor,new,test,property,accessor,second,context,evaluation,context,add,property,accessor,new,test,property,accessor,third,context,evaluation,context,add,property,accessor,new,test,property,accessor,fourth,context,assert,equals,first,expression,parser,parse,expression,should,be,first,get,value,evaluation,context,assert,equals,second,expression,parser,parse,expression,should,be,second,get,value,evaluation,context,assert,equals,third,expression,parser,parse,expression,should,be,third,get,value,evaluation,context,assert,equals,fourth,expression,parser,parse,expression,should,be,fourth,get,value,evaluation,context
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1351600760;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1353028965;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1355390119;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1356735495;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1362408075;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1368482696;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1378301821;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1378305831;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1382378529;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1382748902;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1385064520;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1385412762;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1386100884;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1389887689;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1389892680;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void testConversionPriority_8224() throws Exception;1390506741;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void testConversionPriority_8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}__			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}__			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<TypeDescriptor>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,type,descriptor,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1391876651;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1394055372;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1394115082;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1394454836;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1394533229;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1395866798;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1396794328;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1414924858;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1417644204;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1419274456;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1426108143;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1426267018;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1432307229;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1432857824;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1436017596;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1453421656;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1454934182;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1456768377;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1458843770;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1460149585;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1467730834;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1467968225;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1468964586;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1472477110;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1479982135;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1496837955;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1498780456;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1507112596;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1509050974;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1509094364;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1509110931;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1510610453;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext eContext = new StandardEvaluationContext(h)__		eContext.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(eContext, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(eContext, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(eContext, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(eContext, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,e,context,new,standard,evaluation,context,h,e,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,e,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,e,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,e,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1521632355;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext context = new StandardEvaluationContext(h)__		context.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(context, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(context, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(context, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(context, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(context, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(context, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,context,new,standard,evaluation,context,h,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1522231598;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext context = new StandardEvaluationContext(h)__		context.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(context, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(context, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(context, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(context, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(context, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(context, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,context,new,standard,evaluation,context,h,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void dollarPrefixedIdentifier_SPR7100();1547763210;$ related identifiers;@Test_	public void dollarPrefixedIdentifier_SPR7100() {_		Holder h = new Holder()__		StandardEvaluationContext context = new StandardEvaluationContext(h)__		context.addPropertyAccessor(new MapAccessor())__		h.map.put("$foo", "wibble")__		h.map.put("foo$bar", "wobble")__		h.map.put("foobar$$", "wabble")__		h.map.put("$", "wubble")__		h.map.put("$$", "webble")__		h.map.put("$_$", "tribble")__		String name = null__		Expression expr = null___		expr = new SpelExpressionParser().parseRaw("map.$foo")__		name = expr.getValue(context, String.class)__		assertEquals("wibble", name)___		expr = new SpelExpressionParser().parseRaw("map.foo$bar")__		name = expr.getValue(context, String.class)__		assertEquals("wobble", name)___		expr = new SpelExpressionParser().parseRaw("map.foobar$$")__		name = expr.getValue(context, String.class)__		assertEquals("wabble", name)___		expr = new SpelExpressionParser().parseRaw("map.$")__		name = expr.getValue(context, String.class)__		assertEquals("wubble", name)___		expr = new SpelExpressionParser().parseRaw("map.$$")__		name = expr.getValue(context, String.class)__		assertEquals("webble", name)___		expr = new SpelExpressionParser().parseRaw("map.$_$")__		name = expr.getValue(context, String.class)__		assertEquals("tribble", name)__	};related,identifiers;test,public,void,holder,h,new,holder,standard,evaluation,context,context,new,standard,evaluation,context,h,context,add,property,accessor,new,map,accessor,h,map,put,foo,wibble,h,map,put,foo,bar,wobble,h,map,put,foobar,wabble,h,map,put,wubble,h,map,put,webble,h,map,put,tribble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,map,foo,name,expr,get,value,context,string,class,assert,equals,wibble,name,expr,new,spel,expression,parser,parse,raw,map,foo,bar,name,expr,get,value,context,string,class,assert,equals,wobble,name,expr,new,spel,expression,parser,parse,raw,map,foobar,name,expr,get,value,context,string,class,assert,equals,wabble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,context,string,class,assert,equals,wubble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,context,string,class,assert,equals,webble,name,expr,new,spel,expression,parser,parse,raw,map,name,expr,get,value,context,string,class,assert,equals,tribble,name
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_SPR8224() throws Exception;1509094364;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_SPR8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_SPR8224() throws Exception;1509110931;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_SPR8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_SPR8224() throws Exception;1510610453;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_SPR8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_SPR8224() throws Exception;1521632355;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_SPR8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_SPR8224() throws Exception;1522231598;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_SPR8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void wideningPrimitiveConversion_SPR8224() throws Exception;1547763210;Test whether {@link ReflectiveMethodResolver} handles Widening Primitive Conversion. That's passing an 'int' to a_method accepting 'long' is ok.;@Test_	public void wideningPrimitiveConversion_SPR8224() throws Exception {__		class WideningPrimitiveConversion {_			public int getX(long i) {_				return 10__			}_		}__		final Integer INTEGER_VALUE = Integer.valueOf(7)__		WideningPrimitiveConversion target = new WideningPrimitiveConversion()__		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(INTEGER_VALUE))___		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		final int actual = (Integer) me.execute(emptyEvalContext, target, INTEGER_VALUE).getValue()___		final int compiler = target.getX(INTEGER_VALUE)__		assertEquals(compiler, actual)__	};test,whether,link,reflective,method,resolver,handles,widening,primitive,conversion,that,s,passing,an,int,to,a,method,accepting,long,is,ok;test,public,void,throws,exception,class,widening,primitive,conversion,public,int,get,x,long,i,return,10,final,integer,integer,value,of,7,widening,primitive,conversion,target,new,widening,primitive,conversion,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,get,value,final,int,compiler,target,get,x,assert,equals,compiler,actual
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1391876651;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _												_		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1394055372;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1394115082;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1394454836;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1394533229;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1395866798;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1396794328;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1414924858;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1417644204;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1419274456;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1426108143;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1426267018;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1432307229;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1432857824;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1436017596;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1453421656;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1454934182;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1456768377;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1458843770;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1460149585;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1467730834;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1467968225;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1468964586;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1472477110;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1479982135;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1496837955;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1498780456;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1507112596;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1509050974;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1509094364;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1509110931;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1510610453;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(eContext, String.class)__		assertEquals("world", g.value)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,value,expr,get,value,e,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1521632355;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext context = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(context, String.class)__		assertEquals("world", g.value)__		expr.getValue(context, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,context,string,class,assert,equals,world,g,value,expr,get,value,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1522231598;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext context = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(context, String.class)__		assertEquals("world", g.value)__		expr.getValue(context, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,context,string,class,assert,equals,world,g,value,expr,get,value,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_5();1547763210;Should be accessing Goo.setKey field because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_5() {_		Goo g = Goo.instance__		StandardEvaluationContext context = new StandardEvaluationContext(g)__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]='world'")__		expr.getValue(context, String.class)__		assertEquals("world", g.value)__		expr.getValue(context, String.class)_ _		assertEquals("world", g.value)__	};should,be,accessing,goo,set,key,field,because,bar,variable,evaluates,to,key;test,public,void,goo,g,goo,instance,standard,evaluation,context,context,new,standard,evaluation,context,g,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,context,string,class,assert,equals,world,g,value,expr,get,value,context,string,class,assert,equals,world,g,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1391876651;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _												_		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1394055372;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1394115082;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1394454836;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1394533229;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1395866798;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1396794328;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1414924858;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1417644204;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1419274456;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1426108143;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1426267018;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1432307229;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1432857824;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1436017596;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1453421656;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1454934182;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1456768377;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1458843770;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1460149585;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1467730834;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1467968225;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1468964586;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1472477110;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1479982135;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1496837955;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1498780456;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1507112596;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1509050974;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1509094364;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1509110931;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1510610453;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext eContext = new StandardEvaluationContext(g)__		eContext.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(eContext, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(eContext, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,e,context,new,standard,evaluation,context,g,e,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,e,context,string,class,assert,equals,world,g,wibble,expr,get,value,e,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1521632355;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext context = new StandardEvaluationContext(g)__		context.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(context, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(context, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,context,new,standard,evaluation,context,g,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,context,string,class,assert,equals,world,g,wibble,expr,get,value,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1522231598;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext context = new StandardEvaluationContext(g)__		context.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(context, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(context, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,context,new,standard,evaluation,context,g,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,context,string,class,assert,equals,world,g,wibble,expr,get,value,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_4();1547763210;Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to_"wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_4() {_		Goo g = Goo.instance__		StandardEvaluationContext context = new StandardEvaluationContext(g)__		context.setVariable("bar", "wibble")__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]='world'")__		_		expr.getValue(context, String.class)__		assertEquals("world", g.wibble)__		expr.getValue(context, String.class)_ _		assertEquals("world", g.wibble)__	};should,be,accessing,setting,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,goo,g,goo,instance,standard,evaluation,context,context,new,standard,evaluation,context,g,context,set,variable,bar,wibble,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,world,expr,get,value,context,string,class,assert,equals,world,g,wibble,expr,get,value,context,string,class,assert,equals,world,g,wibble
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1391876651;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {__			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] { Integer.class.getDeclaredMethod("parseInt", new Class[] { String.class,_						Integer.TYPE }) }__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1394055372;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] { Integer.class.getDeclaredMethod("parseInt", new Class[] { String.class,_						Integer.TYPE }) }__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1394115082;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] { Integer.class.getDeclaredMethod("parseInt", new Class[] { String.class,_						Integer.TYPE }) }__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1394454836;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class[] { String.class, Integer.TYPE }) }__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1394533229;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class[] { String.class, Integer.TYPE }) }__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1395866798;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class[] { String.class, Integer.TYPE }) }__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1396794328;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class[] { String.class, Integer.TYPE }) }__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1414924858;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class[] { String.class, Integer.TYPE }) }__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1417644204;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1419274456;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1426108143;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1426267018;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1432307229;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1432857824;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1436017596;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1453421656;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1454934182;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1456768377;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1458843770;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1460149585;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolver,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1467730834;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1467968225;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1468964586;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1472477110;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1479982135;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1496837955;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1498780456;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1507112596;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1509050974;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {_							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,new,class,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1509094364;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {Integer.class.getDeclaredMethod("parseInt", String.class, Integer.TYPE)}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1509110931;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {Integer.class.getDeclaredMethod("parseInt", String.class, Integer.TYPE)}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1510610453;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {Integer.class.getDeclaredMethod("parseInt", String.class, Integer.TYPE)}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1521632355;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {Integer.class.getDeclaredMethod("parseInt", String.class, Integer.TYPE)}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1522231598;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {Integer.class.getDeclaredMethod("parseInt", String.class, Integer.TYPE)}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void customStaticFunctions_SPR9038();1547763210;Test the ability to subclass the ReflectiveMethodResolver and change how it_determines the set of methods for a type.;@Test_	public void customStaticFunctions_SPR9038() {_		ExpressionParser parser = new SpelExpressionParser()__		StandardEvaluationContext context = new StandardEvaluationContext()__		List<MethodResolver> methodResolvers = new ArrayList<>()__		methodResolvers.add(new ReflectiveMethodResolver() {_			@Override_			protected Method[] getMethods(Class<?> type) {_				try {_					return new Method[] {Integer.class.getDeclaredMethod("parseInt", String.class, Integer.TYPE)}__				}_				catch (NoSuchMethodException ex) {_					return new Method[0]__				}_			}_		})___		context.setMethodResolvers(methodResolvers)__		Expression expression = parser.parseExpression("parseInt('-FF', 16)")___		Integer result = expression.getValue(context, "", Integer.class)__		assertEquals(-255, result.intValue())__	};test,the,ability,to,subclass,the,reflective,method,resolver,and,change,how,it,determines,the,set,of,methods,for,a,type;test,public,void,expression,parser,parser,new,spel,expression,parser,standard,evaluation,context,context,new,standard,evaluation,context,list,method,resolver,method,resolvers,new,array,list,method,resolvers,add,new,reflective,method,resolver,override,protected,method,get,methods,class,type,try,return,new,method,integer,class,get,declared,method,parse,int,string,class,integer,type,catch,no,such,method,exception,ex,return,new,method,0,context,set,method,resolvers,method,resolvers,expression,expression,parser,parse,expression,parse,int,ff,16,integer,result,expression,get,value,context,integer,class,assert,equals,255,result,int,value
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1391876651;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _														_		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1394055372;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1394115082;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1394454836;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1394533229;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1395866798;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1396794328;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1414924858;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1417644204;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1419274456;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1426108143;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1426267018;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1432307229;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1432857824;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1436017596;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1453421656;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1454934182;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1456768377;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1458843770;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1460149585;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1467730834;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1467968225;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1468964586;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1472477110;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1479982135;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1496837955;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1498780456;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1507112596;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1509050974;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1509094364;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1509110931;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1510610453;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(eContext, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,wobble,name,name,expr,get,value,e,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1521632355;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext context = new StandardEvaluationContext(new Goo())__		context.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(context, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(context, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,context,new,standard,evaluation,context,new,goo,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,context,string,class,assert,equals,wobble,name,name,expr,get,value,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1522231598;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext context = new StandardEvaluationContext(new Goo())__		context.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(context, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(context, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,context,new,standard,evaluation,context,new,goo,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,context,string,class,assert,equals,wobble,name,name,expr,get,value,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_3();1547763210;Should be accessing Goo.wibble field because 'bar' variable evaluates to "wibble";@Test_	public void indexingAsAPropertyAccess_SPR6968_3() {_		StandardEvaluationContext context = new StandardEvaluationContext(new Goo())__		context.setVariable("bar", "wibble")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		_		name = expr.getValue(context, String.class)__		assertEquals("wobble", name)__		name = expr.getValue(context, String.class)_ _		assertEquals("wobble", name)__	};should,be,accessing,goo,wibble,field,because,bar,variable,evaluates,to,wibble;test,public,void,standard,evaluation,context,context,new,standard,evaluation,context,new,goo,context,set,variable,bar,wibble,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,context,string,class,assert,equals,wobble,name,name,expr,get,value,context,string,class,assert,equals,wobble,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1391876651;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _														_		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1394055372;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _														_		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1394115082;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _														_		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1394454836;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1394533229;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1395866798;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1396794328;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1414924858;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1417644204;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1419274456;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1426108143;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1426267018;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1432307229;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1432857824;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1436017596;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1453421656;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1454934182;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1456768377;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1458843770;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1460149585;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1467730834;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1467968225;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1468964586;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1472477110;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1479982135;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1496837955;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1498780456;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1507112596;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1509050974;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1509094364;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1509110931;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1510610453;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		eContext.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,e,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1521632355;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext context = new StandardEvaluationContext(new Goo())__		context.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(context, String.class)__		assertEquals("hello", name)__		name = expr.getValue(context, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,context,new,standard,evaluation,context,new,goo,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,context,string,class,assert,equals,hello,name,name,expr,get,value,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1522231598;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext context = new StandardEvaluationContext(new Goo())__		context.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(context, String.class)__		assertEquals("hello", name)__		name = expr.getValue(context, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,context,new,standard,evaluation,context,new,goo,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,context,string,class,assert,equals,hello,name,name,expr,get,value,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_2();1547763210;Should be accessing Goo.getKey because 'bar' variable evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_2() {_		StandardEvaluationContext context = new StandardEvaluationContext(new Goo())__		context.setVariable("bar", "key")__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[#bar]")__		name = expr.getValue(context, String.class)__		assertEquals("hello", name)__		name = expr.getValue(context, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,variable,evaluates,to,key;test,public,void,standard,evaluation,context,context,new,standard,evaluation,context,new,goo,context,set,variable,bar,key,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,context,string,class,assert,equals,hello,name,name,expr,get,value,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void conversionPriority_SPR8224() throws Exception;1509094364;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_SPR8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_SPR8224() throws Exception;1509110931;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_SPR8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_SPR8224() throws Exception;1510610453;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_SPR8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_SPR8224() throws Exception;1521632355;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_SPR8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_SPR8224() throws Exception;1522231598;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_SPR8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void conversionPriority_SPR8224() throws Exception;1547763210;Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation_Conversion order. And more precisely that widening reference conversion is 'higher'_than a unboxing conversion.;@Test_	public void conversionPriority_SPR8224() throws Exception {__		@SuppressWarnings("unused")_		class ConversionPriority1 {_			public int getX(Number i) {_				return 20__			}_			public int getX(int i) {_				return 10__			}_		}__		@SuppressWarnings("unused")_		class ConversionPriority2 {_			public int getX(int i) {_				return 10__			}_			public int getX(Number i) {_				return 20__			}_		}__		final Integer INTEGER = Integer.valueOf(7)___		EvaluationContext emptyEvalContext = new StandardEvaluationContext()___		List<TypeDescriptor> args = new ArrayList<>()__		args.add(TypeDescriptor.forObject(new Integer(42)))___		ConversionPriority1 target = new ConversionPriority1()__		MethodExecutor me = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target, "getX", args)__		_		final int actual = (Integer) me.execute(emptyEvalContext, target, new Integer(42)).getValue()__		_		final int compiler = target.getX(INTEGER)__		_		assertEquals(compiler, actual)___		ConversionPriority2 target2 = new ConversionPriority2()__		MethodExecutor me2 = new ReflectiveMethodResolver(true).resolve(emptyEvalContext, target2, "getX", args)__		_		int actual2 = (Integer) me2.execute(emptyEvalContext, target2, new Integer(42)).getValue()__		_		int compiler2 = target2.getX(INTEGER)__		_		assertEquals(compiler2, actual2)___	};test,whether,link,reflective,method,resolver,follows,java,method,invocation,conversion,order,and,more,precisely,that,widening,reference,conversion,is,higher,than,a,unboxing,conversion;test,public,void,throws,exception,suppress,warnings,unused,class,conversion,priority1,public,int,get,x,number,i,return,20,public,int,get,x,int,i,return,10,suppress,warnings,unused,class,conversion,priority2,public,int,get,x,int,i,return,10,public,int,get,x,number,i,return,20,final,integer,integer,integer,value,of,7,evaluation,context,empty,eval,context,new,standard,evaluation,context,list,type,descriptor,args,new,array,list,args,add,type,descriptor,for,object,new,integer,42,conversion,priority1,target,new,conversion,priority1,method,executor,me,new,reflective,method,resolver,true,resolve,empty,eval,context,target,get,x,args,final,int,actual,integer,me,execute,empty,eval,context,target,new,integer,42,get,value,final,int,compiler,target,get,x,integer,assert,equals,compiler,actual,conversion,priority2,target2,new,conversion,priority2,method,executor,me2,new,reflective,method,resolver,true,resolve,empty,eval,context,target2,get,x,args,int,actual2,integer,me2,execute,empty,eval,context,target2,new,integer,42,get,value,int,compiler2,target2,get,x,integer,assert,equals,compiler2,actual2
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1391876651;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _														_		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1394055372;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _														_		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1394115082;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _														_		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1394454836;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1394533229;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1395866798;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1396794328;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1414924858;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1417644204;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1419274456;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1426108143;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1426267018;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1432307229;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1432857824;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1436017596;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1453421656;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1454934182;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1456768377;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1458843770;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1460149585;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1467730834;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1467968225;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1468964586;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1472477110;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1479982135;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1496837955;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1498780456;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1507112596;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1509050974;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1509094364;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1509110931;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1510610453;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext eContext = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(eContext, String.class)__		assertEquals("hello", name)__		name = expr.getValue(eContext, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,e,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,e,context,string,class,assert,equals,hello,name,name,expr,get,value,e,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1521632355;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext context = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(context, String.class)__		assertEquals("hello", name)__		name = expr.getValue(context, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,context,string,class,assert,equals,hello,name,name,expr,get,value,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1522231598;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext context = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(context, String.class)__		assertEquals("hello", name)__		name = expr.getValue(context, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,context,string,class,assert,equals,hello,name,name,expr,get,value,context,string,class,assert,equals,hello,name
SpelReproTests -> @Test 	public void indexingAsAPropertyAccess_SPR6968_1();1547763210;Should be accessing Goo.getKey because 'bar' field evaluates to "key";@Test_	public void indexingAsAPropertyAccess_SPR6968_1() {_		StandardEvaluationContext context = new StandardEvaluationContext(new Goo())__		String name = null__		Expression expr = null__		expr = new SpelExpressionParser().parseRaw("instance[bar]")__		name = expr.getValue(context, String.class)__		assertEquals("hello", name)__		name = expr.getValue(context, String.class)_ _		assertEquals("hello", name)__	};should,be,accessing,goo,get,key,because,bar,field,evaluates,to,key;test,public,void,standard,evaluation,context,context,new,standard,evaluation,context,new,goo,string,name,null,expression,expr,null,expr,new,spel,expression,parser,parse,raw,instance,bar,name,expr,get,value,context,string,class,assert,equals,hello,name,name,expr,get,value,context,string,class,assert,equals,hello,name
