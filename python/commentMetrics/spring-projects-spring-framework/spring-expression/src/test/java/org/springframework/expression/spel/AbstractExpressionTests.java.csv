# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractExpressionTests -> protected void parseAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties);1391876651;Parse the specified expression and ensure the expected message comes out. The message may have inserts and they_will be checked if otherProperties is specified. The first entry in otherProperties should always be the_position._@param expression The expression to evaluate_@param expectedMessage The expected message_@param otherProperties The expected inserts within the message;protected void parseAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties) {_		try {_			Expression expr = parser.parseExpression(expression)__			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__			fail("Parsing should have failed!")__		}_		catch (ParseException pe) {_			_			_			_			_			_			_			_			_			_			_			_			SpelParseException ex = (SpelParseException) pe__			if (ex.getMessageCode() != expectedMessage) {_				_				ex.printStackTrace()__				assertEquals("Failed to get expected message", expectedMessage, ex.getMessageCode())__			}_			if (otherProperties != null && otherProperties.length != 0) {_				_				int pos = ((Integer) otherProperties[0]).intValue()__				assertEquals("Did not get correct position reported in error ", pos, ex.getPosition())__				if (otherProperties.length > 1) {_					_					Object[] inserts = ex.getInserts()__					if (inserts == null) {_						inserts = new Object[0]__					}_					if (inserts.length < otherProperties.length - 1) {_						ex.printStackTrace()__						fail("Cannot check " + (otherProperties.length - 1)_								+ " properties of the exception, it only has " + inserts.length + " inserts")__					}_					for (int i = 1_ i < otherProperties.length_ i++) {_						if (!inserts[i - 1].equals(otherProperties[i])) {_							ex.printStackTrace()__							fail("Insert does not match, expected '" + otherProperties[i] + "' but insert value was '"_									+ inserts[i - 1] + "'")__						}_					}_				}_			}_		}_	};parse,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,parse,and,check,error,string,expression,spel,message,expected,message,object,other,properties,try,expression,expr,parser,parse,expression,expression,spel,utilities,print,abstract,syntax,tree,system,out,expr,fail,parsing,should,have,failed,catch,parse,exception,pe,spel,parse,exception,ex,spel,parse,exception,pe,if,ex,get,message,code,expected,message,ex,print,stack,trace,assert,equals,failed,to,get,expected,message,expected,message,ex,get,message,code,if,other,properties,null,other,properties,length,0,int,pos,integer,other,properties,0,int,value,assert,equals,did,not,get,correct,position,reported,in,error,pos,ex,get,position,if,other,properties,length,1,object,inserts,ex,get,inserts,if,inserts,null,inserts,new,object,0,if,inserts,length,other,properties,length,1,ex,print,stack,trace,fail,cannot,check,other,properties,length,1,properties,of,the,exception,it,only,has,inserts,length,inserts,for,int,i,1,i,other,properties,length,i,if,inserts,i,1,equals,other,properties,i,ex,print,stack,trace,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,inserts,i,1
AbstractExpressionTests -> protected void parseAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties);1426108143;Parse the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void parseAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties) {_		try {_			Expression expr = parser.parseExpression(expression)__			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__			fail("Parsing should have failed!")__		}_		catch (ParseException pe) {_			SpelParseException ex = (SpelParseException)pe__			if (ex.getMessageCode() != expectedMessage) {_				assertEquals("Failed to get expected message", expectedMessage, ex.getMessageCode())__			}_			if (otherProperties != null && otherProperties.length != 0) {_				_				int pos = ((Integer) otherProperties[0]).intValue()__				assertEquals("Did not get correct position reported in error ", pos, ex.getPosition())__				if (otherProperties.length > 1) {_					_					Object[] inserts = ex.getInserts()__					if (inserts == null) {_						inserts = new Object[0]__					}_					if (inserts.length < otherProperties.length - 1) {_						fail("Cannot check " + (otherProperties.length - 1) +_								" properties of the exception, it only has " + inserts.length + " inserts")__					}_					for (int i = 1_ i < otherProperties.length_ i++) {_						if (!inserts[i - 1].equals(otherProperties[i])) {_							fail("Insert does not match, expected '" + otherProperties[i] +_									"' but insert value was '" + inserts[i - 1] + "'")__						}_					}_				}_			}_		}_	};parse,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,parse,and,check,error,string,expression,spel,message,expected,message,object,other,properties,try,expression,expr,parser,parse,expression,expression,spel,utilities,print,abstract,syntax,tree,system,out,expr,fail,parsing,should,have,failed,catch,parse,exception,pe,spel,parse,exception,ex,spel,parse,exception,pe,if,ex,get,message,code,expected,message,assert,equals,failed,to,get,expected,message,expected,message,ex,get,message,code,if,other,properties,null,other,properties,length,0,int,pos,integer,other,properties,0,int,value,assert,equals,did,not,get,correct,position,reported,in,error,pos,ex,get,position,if,other,properties,length,1,object,inserts,ex,get,inserts,if,inserts,null,inserts,new,object,0,if,inserts,length,other,properties,length,1,fail,cannot,check,other,properties,length,1,properties,of,the,exception,it,only,has,inserts,length,inserts,for,int,i,1,i,other,properties,length,i,if,inserts,i,1,equals,other,properties,i,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,inserts,i,1
AbstractExpressionTests -> protected void parseAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties);1518279448;Parse the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void parseAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties) {_		try {_			Expression expr = parser.parseExpression(expression)__			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__			fail("Parsing should have failed!")__		}_		catch (ParseException pe) {_			SpelParseException ex = (SpelParseException)pe__			if (ex.getMessageCode() != expectedMessage) {_				assertEquals("Failed to get expected message", expectedMessage, ex.getMessageCode())__			}_			if (otherProperties != null && otherProperties.length != 0) {_				_				int pos = ((Integer) otherProperties[0]).intValue()__				assertEquals("Did not get correct position reported in error ", pos, ex.getPosition())__				if (otherProperties.length > 1) {_					_					Object[] inserts = ex.getInserts()__					if (inserts == null) {_						inserts = new Object[0]__					}_					if (inserts.length < otherProperties.length - 1) {_						fail("Cannot check " + (otherProperties.length - 1) +_								" properties of the exception, it only has " + inserts.length + " inserts")__					}_					for (int i = 1_ i < otherProperties.length_ i++) {_						if (!inserts[i - 1].equals(otherProperties[i])) {_							fail("Insert does not match, expected '" + otherProperties[i] +_									"' but insert value was '" + inserts[i - 1] + "'")__						}_					}_				}_			}_		}_	};parse,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,parse,and,check,error,string,expression,spel,message,expected,message,object,other,properties,try,expression,expr,parser,parse,expression,expression,spel,utilities,print,abstract,syntax,tree,system,out,expr,fail,parsing,should,have,failed,catch,parse,exception,pe,spel,parse,exception,ex,spel,parse,exception,pe,if,ex,get,message,code,expected,message,assert,equals,failed,to,get,expected,message,expected,message,ex,get,message,code,if,other,properties,null,other,properties,length,0,int,pos,integer,other,properties,0,int,value,assert,equals,did,not,get,correct,position,reported,in,error,pos,ex,get,position,if,other,properties,length,1,object,inserts,ex,get,inserts,if,inserts,null,inserts,new,object,0,if,inserts,length,other,properties,length,1,fail,cannot,check,other,properties,length,1,properties,of,the,exception,it,only,has,inserts,length,inserts,for,int,i,1,i,other,properties,length,i,if,inserts,i,1,equals,other,properties,i,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,inserts,i,1
AbstractExpressionTests -> protected void parseAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties);1518283060;Parse the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void parseAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties) {_		try {_			Expression expr = parser.parseExpression(expression)__			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__			fail("Parsing should have failed!")__		}_		catch (ParseException pe) {_			SpelParseException ex = (SpelParseException)pe__			if (ex.getMessageCode() != expectedMessage) {_				assertEquals("Failed to get expected message", expectedMessage, ex.getMessageCode())__			}_			if (otherProperties != null && otherProperties.length != 0) {_				_				int pos = ((Integer) otherProperties[0]).intValue()__				assertEquals("Did not get correct position reported in error ", pos, ex.getPosition())__				if (otherProperties.length > 1) {_					_					Object[] inserts = ex.getInserts()__					if (inserts == null) {_						inserts = new Object[0]__					}_					if (inserts.length < otherProperties.length - 1) {_						fail("Cannot check " + (otherProperties.length - 1) +_								" properties of the exception, it only has " + inserts.length + " inserts")__					}_					for (int i = 1_ i < otherProperties.length_ i++) {_						if (!inserts[i - 1].equals(otherProperties[i])) {_							fail("Insert does not match, expected '" + otherProperties[i] +_									"' but insert value was '" + inserts[i - 1] + "'")__						}_					}_				}_			}_		}_	};parse,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,parse,and,check,error,string,expression,spel,message,expected,message,object,other,properties,try,expression,expr,parser,parse,expression,expression,spel,utilities,print,abstract,syntax,tree,system,out,expr,fail,parsing,should,have,failed,catch,parse,exception,pe,spel,parse,exception,ex,spel,parse,exception,pe,if,ex,get,message,code,expected,message,assert,equals,failed,to,get,expected,message,expected,message,ex,get,message,code,if,other,properties,null,other,properties,length,0,int,pos,integer,other,properties,0,int,value,assert,equals,did,not,get,correct,position,reported,in,error,pos,ex,get,position,if,other,properties,length,1,object,inserts,ex,get,inserts,if,inserts,null,inserts,new,object,0,if,inserts,length,other,properties,length,1,fail,cannot,check,other,properties,length,1,properties,of,the,exception,it,only,has,inserts,length,inserts,for,int,i,1,i,other,properties,length,i,if,inserts,i,1,equals,other,properties,i,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,inserts,i,1
AbstractExpressionTests -> protected void parseAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties);1521632355;Parse the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void parseAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties) {_		try {_			Expression expr = parser.parseExpression(expression)__			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__			fail("Parsing should have failed!")__		}_		catch (ParseException pe) {_			SpelParseException ex = (SpelParseException)pe__			if (ex.getMessageCode() != expectedMessage) {_				assertEquals("Failed to get expected message", expectedMessage, ex.getMessageCode())__			}_			if (otherProperties != null && otherProperties.length != 0) {_				_				int pos = ((Integer) otherProperties[0]).intValue()__				assertEquals("Did not get correct position reported in error ", pos, ex.getPosition())__				if (otherProperties.length > 1) {_					_					Object[] inserts = ex.getInserts()__					if (inserts == null) {_						inserts = new Object[0]__					}_					if (inserts.length < otherProperties.length - 1) {_						fail("Cannot check " + (otherProperties.length - 1) +_								" properties of the exception, it only has " + inserts.length + " inserts")__					}_					for (int i = 1_ i < otherProperties.length_ i++) {_						if (!inserts[i - 1].equals(otherProperties[i])) {_							fail("Insert does not match, expected '" + otherProperties[i] +_									"' but insert value was '" + inserts[i - 1] + "'")__						}_					}_				}_			}_		}_	};parse,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,parse,and,check,error,string,expression,spel,message,expected,message,object,other,properties,try,expression,expr,parser,parse,expression,expression,spel,utilities,print,abstract,syntax,tree,system,out,expr,fail,parsing,should,have,failed,catch,parse,exception,pe,spel,parse,exception,ex,spel,parse,exception,pe,if,ex,get,message,code,expected,message,assert,equals,failed,to,get,expected,message,expected,message,ex,get,message,code,if,other,properties,null,other,properties,length,0,int,pos,integer,other,properties,0,int,value,assert,equals,did,not,get,correct,position,reported,in,error,pos,ex,get,position,if,other,properties,length,1,object,inserts,ex,get,inserts,if,inserts,null,inserts,new,object,0,if,inserts,length,other,properties,length,1,fail,cannot,check,other,properties,length,1,properties,of,the,exception,it,only,has,inserts,length,inserts,for,int,i,1,i,other,properties,length,i,if,inserts,i,1,equals,other,properties,i,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,inserts,i,1
AbstractExpressionTests -> protected void evaluateAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties);1391876651;Evaluate the specified expression and ensure the expected message comes out. The message may have inserts and_they will be checked if otherProperties is specified. The first entry in otherProperties should always be the_position._@param expression The expression to evaluate_@param expectedMessage The expected message_@param otherProperties The expected inserts within the message;protected void evaluateAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties) {_		evaluateAndCheckError(expression, null, expectedMessage, otherProperties)__	};evaluate,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,evaluate,and,check,error,string,expression,spel,message,expected,message,object,other,properties,evaluate,and,check,error,expression,null,expected,message,other,properties
AbstractExpressionTests -> protected void evaluateAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties);1426108143;Evaluate the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void evaluateAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties) {_		evaluateAndCheckError(expression, null, expectedMessage, otherProperties)__	};evaluate,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,evaluate,and,check,error,string,expression,spel,message,expected,message,object,other,properties,evaluate,and,check,error,expression,null,expected,message,other,properties
AbstractExpressionTests -> protected void evaluateAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties);1518279448;Evaluate the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void evaluateAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties) {_		evaluateAndCheckError(expression, null, expectedMessage, otherProperties)__	};evaluate,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,evaluate,and,check,error,string,expression,spel,message,expected,message,object,other,properties,evaluate,and,check,error,expression,null,expected,message,other,properties
AbstractExpressionTests -> protected void evaluateAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties);1518283060;Evaluate the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void evaluateAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties) {_		evaluateAndCheckError(expression, null, expectedMessage, otherProperties)__	};evaluate,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,evaluate,and,check,error,string,expression,spel,message,expected,message,object,other,properties,evaluate,and,check,error,expression,null,expected,message,other,properties
AbstractExpressionTests -> protected void evaluateAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties);1521632355;Evaluate the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void evaluateAndCheckError(String expression, SpelMessage expectedMessage, Object... otherProperties) {_		evaluateAndCheckError(expression, null, expectedMessage, otherProperties)__	};evaluate,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,evaluate,and,check,error,string,expression,spel,message,expected,message,object,other,properties,evaluate,and,check,error,expression,null,expected,message,other,properties
AbstractExpressionTests -> protected void evaluateAndCheckError(String expression, Class<?> expectedReturnType, SpelMessage expectedMessage, 			Object... otherProperties);1391876651;Evaluate the specified expression and ensure the expected message comes out. The message may have inserts and_they will be checked if otherProperties is specified. The first entry in otherProperties should always be the_position._@param expression The expression to evaluate_@param expectedReturnType Ask the expression return value to be of this type if possible (null indicates don't_ask for conversion)_@param expectedMessage The expected message_@param otherProperties The expected inserts within the message;protected void evaluateAndCheckError(String expression, Class<?> expectedReturnType, SpelMessage expectedMessage,_			Object... otherProperties) {_		try {_			Expression expr = parser.parseExpression(expression)__			if (expr == null) {_				fail("Parser returned null for expression")__			}_			if (expectedReturnType != null) {_				@SuppressWarnings("unused")_				Object value = expr.getValue(eContext, expectedReturnType)__			}_			else {_				@SuppressWarnings("unused")_				Object value = expr.getValue(eContext)__			}_			fail("Should have failed with message " + expectedMessage)__		}_		catch (EvaluationException ee) {_			SpelEvaluationException ex = (SpelEvaluationException) ee__			if (ex.getMessageCode() != expectedMessage) {_				ex.printStackTrace()__				assertEquals("Failed to get expected message", expectedMessage, ex.getMessageCode())__			}_			if (otherProperties != null && otherProperties.length != 0) {_				_				int pos = ((Integer) otherProperties[0]).intValue()__				assertEquals("Did not get correct position reported in error ", pos, ex.getPosition())__				if (otherProperties.length > 1) {_					_					Object[] inserts = ex.getInserts()__					if (inserts == null) {_						inserts = new Object[0]__					}_					if (inserts.length < otherProperties.length - 1) {_						ex.printStackTrace()__						fail("Cannot check " + (otherProperties.length - 1)_								+ " properties of the exception, it only has " + inserts.length + " inserts")__					}_					for (int i = 1_ i < otherProperties.length_ i++) {_						if (otherProperties[i] == null) {_							if (inserts[i - 1] != null) {_								ex.printStackTrace()__								fail("Insert does not match, expected 'null' but insert value was '" + inserts[i - 1]_										+ "'")__							}_						}_						else if (inserts[i - 1] == null) {_							if (otherProperties[i] != null) {_								ex.printStackTrace()__								fail("Insert does not match, expected '" + otherProperties[i]_										+ "' but insert value was 'null'")__							}_						}_						else if (!inserts[i - 1].equals(otherProperties[i])) {_							ex.printStackTrace()__							fail("Insert does not match, expected '" + otherProperties[i] + "' but insert value was '"_									+ inserts[i - 1] + "'")__						}_					}_				}_			}_		}_		catch (ParseException pe) {_			pe.printStackTrace()__			fail("Unexpected Exception: " + pe.getMessage())__		}_	};evaluate,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,return,type,ask,the,expression,return,value,to,be,of,this,type,if,possible,null,indicates,don,t,ask,for,conversion,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,evaluate,and,check,error,string,expression,class,expected,return,type,spel,message,expected,message,object,other,properties,try,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,expected,return,type,null,suppress,warnings,unused,object,value,expr,get,value,e,context,expected,return,type,else,suppress,warnings,unused,object,value,expr,get,value,e,context,fail,should,have,failed,with,message,expected,message,catch,evaluation,exception,ee,spel,evaluation,exception,ex,spel,evaluation,exception,ee,if,ex,get,message,code,expected,message,ex,print,stack,trace,assert,equals,failed,to,get,expected,message,expected,message,ex,get,message,code,if,other,properties,null,other,properties,length,0,int,pos,integer,other,properties,0,int,value,assert,equals,did,not,get,correct,position,reported,in,error,pos,ex,get,position,if,other,properties,length,1,object,inserts,ex,get,inserts,if,inserts,null,inserts,new,object,0,if,inserts,length,other,properties,length,1,ex,print,stack,trace,fail,cannot,check,other,properties,length,1,properties,of,the,exception,it,only,has,inserts,length,inserts,for,int,i,1,i,other,properties,length,i,if,other,properties,i,null,if,inserts,i,1,null,ex,print,stack,trace,fail,insert,does,not,match,expected,null,but,insert,value,was,inserts,i,1,else,if,inserts,i,1,null,if,other,properties,i,null,ex,print,stack,trace,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,null,else,if,inserts,i,1,equals,other,properties,i,ex,print,stack,trace,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,inserts,i,1,catch,parse,exception,pe,pe,print,stack,trace,fail,unexpected,exception,pe,get,message
AbstractExpressionTests -> protected void evaluateAndCheckError(String expression, Class<?> expectedReturnType, SpelMessage expectedMessage, 			Object... otherProperties);1426108143;Evaluate the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedReturnType ask the expression return value to be of this type if possible_({@code null} indicates don't ask for conversion)_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void evaluateAndCheckError(String expression, Class<?> expectedReturnType, SpelMessage expectedMessage,_			Object... otherProperties) {_		try {_			Expression expr = parser.parseExpression(expression)__			if (expr == null) {_				fail("Parser returned null for expression")__			}_			if (expectedReturnType != null) {_				expr.getValue(eContext, expectedReturnType)__			}_			else {_				expr.getValue(eContext)__			}_			fail("Should have failed with message " + expectedMessage)__		}_		catch (EvaluationException ee) {_			SpelEvaluationException ex = (SpelEvaluationException) ee__			if (ex.getMessageCode() != expectedMessage) {_				assertEquals("Failed to get expected message", expectedMessage, ex.getMessageCode())__			}_			if (otherProperties != null && otherProperties.length != 0) {_				_				int pos = ((Integer) otherProperties[0]).intValue()__				assertEquals("Did not get correct position reported in error ", pos, ex.getPosition())__				if (otherProperties.length > 1) {_					_					Object[] inserts = ex.getInserts()__					if (inserts == null) {_						inserts = new Object[0]__					}_					if (inserts.length < otherProperties.length - 1) {_						fail("Cannot check " + (otherProperties.length - 1) +_								" properties of the exception, it only has " + inserts.length + " inserts")__					}_					for (int i = 1_ i < otherProperties.length_ i++) {_						if (otherProperties[i] == null) {_							if (inserts[i - 1] != null) {_								fail("Insert does not match, expected 'null' but insert value was '" +_										inserts[i - 1] + "'")__							}_						}_						else if (inserts[i - 1] == null) {_							if (otherProperties[i] != null) {_								fail("Insert does not match, expected '" + otherProperties[i] +_										"' but insert value was 'null'")__							}_						}_						else if (!inserts[i - 1].equals(otherProperties[i])) {_							fail("Insert does not match, expected '" + otherProperties[i] +_									"' but insert value was '" + inserts[i - 1] + "'")__						}_					}_				}_			}_		}_	};evaluate,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,return,type,ask,the,expression,return,value,to,be,of,this,type,if,possible,code,null,indicates,don,t,ask,for,conversion,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,evaluate,and,check,error,string,expression,class,expected,return,type,spel,message,expected,message,object,other,properties,try,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,expected,return,type,null,expr,get,value,e,context,expected,return,type,else,expr,get,value,e,context,fail,should,have,failed,with,message,expected,message,catch,evaluation,exception,ee,spel,evaluation,exception,ex,spel,evaluation,exception,ee,if,ex,get,message,code,expected,message,assert,equals,failed,to,get,expected,message,expected,message,ex,get,message,code,if,other,properties,null,other,properties,length,0,int,pos,integer,other,properties,0,int,value,assert,equals,did,not,get,correct,position,reported,in,error,pos,ex,get,position,if,other,properties,length,1,object,inserts,ex,get,inserts,if,inserts,null,inserts,new,object,0,if,inserts,length,other,properties,length,1,fail,cannot,check,other,properties,length,1,properties,of,the,exception,it,only,has,inserts,length,inserts,for,int,i,1,i,other,properties,length,i,if,other,properties,i,null,if,inserts,i,1,null,fail,insert,does,not,match,expected,null,but,insert,value,was,inserts,i,1,else,if,inserts,i,1,null,if,other,properties,i,null,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,null,else,if,inserts,i,1,equals,other,properties,i,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,inserts,i,1
AbstractExpressionTests -> protected void evaluateAndCheckError(String expression, Class<?> expectedReturnType, SpelMessage expectedMessage, 			Object... otherProperties);1518279448;Evaluate the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedReturnType ask the expression return value to be of this type if possible_({@code null} indicates don't ask for conversion)_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void evaluateAndCheckError(String expression, Class<?> expectedReturnType, SpelMessage expectedMessage,_			Object... otherProperties) {_		try {_			Expression expr = parser.parseExpression(expression)__			if (expr == null) {_				fail("Parser returned null for expression")__			}_			if (expectedReturnType != null) {_				expr.getValue(eContext, expectedReturnType)__			}_			else {_				expr.getValue(eContext)__			}_			fail("Should have failed with message " + expectedMessage)__		}_		catch (EvaluationException ee) {_			SpelEvaluationException ex = (SpelEvaluationException) ee__			if (ex.getMessageCode() != expectedMessage) {_				assertEquals("Failed to get expected message", expectedMessage, ex.getMessageCode())__			}_			if (otherProperties != null && otherProperties.length != 0) {_				_				int pos = ((Integer) otherProperties[0]).intValue()__				assertEquals("Did not get correct position reported in error ", pos, ex.getPosition())__				if (otherProperties.length > 1) {_					_					Object[] inserts = ex.getInserts()__					if (inserts == null) {_						inserts = new Object[0]__					}_					if (inserts.length < otherProperties.length - 1) {_						fail("Cannot check " + (otherProperties.length - 1) +_								" properties of the exception, it only has " + inserts.length + " inserts")__					}_					for (int i = 1_ i < otherProperties.length_ i++) {_						if (otherProperties[i] == null) {_							if (inserts[i - 1] != null) {_								fail("Insert does not match, expected 'null' but insert value was '" +_										inserts[i - 1] + "'")__							}_						}_						else if (inserts[i - 1] == null) {_							if (otherProperties[i] != null) {_								fail("Insert does not match, expected '" + otherProperties[i] +_										"' but insert value was 'null'")__							}_						}_						else if (!inserts[i - 1].equals(otherProperties[i])) {_							fail("Insert does not match, expected '" + otherProperties[i] +_									"' but insert value was '" + inserts[i - 1] + "'")__						}_					}_				}_			}_		}_	};evaluate,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,return,type,ask,the,expression,return,value,to,be,of,this,type,if,possible,code,null,indicates,don,t,ask,for,conversion,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,evaluate,and,check,error,string,expression,class,expected,return,type,spel,message,expected,message,object,other,properties,try,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,expected,return,type,null,expr,get,value,e,context,expected,return,type,else,expr,get,value,e,context,fail,should,have,failed,with,message,expected,message,catch,evaluation,exception,ee,spel,evaluation,exception,ex,spel,evaluation,exception,ee,if,ex,get,message,code,expected,message,assert,equals,failed,to,get,expected,message,expected,message,ex,get,message,code,if,other,properties,null,other,properties,length,0,int,pos,integer,other,properties,0,int,value,assert,equals,did,not,get,correct,position,reported,in,error,pos,ex,get,position,if,other,properties,length,1,object,inserts,ex,get,inserts,if,inserts,null,inserts,new,object,0,if,inserts,length,other,properties,length,1,fail,cannot,check,other,properties,length,1,properties,of,the,exception,it,only,has,inserts,length,inserts,for,int,i,1,i,other,properties,length,i,if,other,properties,i,null,if,inserts,i,1,null,fail,insert,does,not,match,expected,null,but,insert,value,was,inserts,i,1,else,if,inserts,i,1,null,if,other,properties,i,null,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,null,else,if,inserts,i,1,equals,other,properties,i,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,inserts,i,1
AbstractExpressionTests -> protected void evaluateAndCheckError(String expression, Class<?> expectedReturnType, SpelMessage expectedMessage, 			Object... otherProperties);1518283060;Evaluate the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedReturnType ask the expression return value to be of this type if possible_({@code null} indicates don't ask for conversion)_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void evaluateAndCheckError(String expression, Class<?> expectedReturnType, SpelMessage expectedMessage,_			Object... otherProperties) {_		try {_			Expression expr = parser.parseExpression(expression)__			if (expr == null) {_				fail("Parser returned null for expression")__			}_			if (expectedReturnType != null) {_				expr.getValue(eContext, expectedReturnType)__			}_			else {_				expr.getValue(eContext)__			}_			fail("Should have failed with message " + expectedMessage)__		}_		catch (EvaluationException ee) {_			SpelEvaluationException ex = (SpelEvaluationException) ee__			if (ex.getMessageCode() != expectedMessage) {_				assertEquals("Failed to get expected message", expectedMessage, ex.getMessageCode())__			}_			if (otherProperties != null && otherProperties.length != 0) {_				_				int pos = ((Integer) otherProperties[0]).intValue()__				assertEquals("Did not get correct position reported in error ", pos, ex.getPosition())__				if (otherProperties.length > 1) {_					_					Object[] inserts = ex.getInserts()__					if (inserts == null) {_						inserts = new Object[0]__					}_					if (inserts.length < otherProperties.length - 1) {_						fail("Cannot check " + (otherProperties.length - 1) +_								" properties of the exception, it only has " + inserts.length + " inserts")__					}_					for (int i = 1_ i < otherProperties.length_ i++) {_						if (otherProperties[i] == null) {_							if (inserts[i - 1] != null) {_								fail("Insert does not match, expected 'null' but insert value was '" +_										inserts[i - 1] + "'")__							}_						}_						else if (inserts[i - 1] == null) {_							if (otherProperties[i] != null) {_								fail("Insert does not match, expected '" + otherProperties[i] +_										"' but insert value was 'null'")__							}_						}_						else if (!inserts[i - 1].equals(otherProperties[i])) {_							fail("Insert does not match, expected '" + otherProperties[i] +_									"' but insert value was '" + inserts[i - 1] + "'")__						}_					}_				}_			}_		}_	};evaluate,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,return,type,ask,the,expression,return,value,to,be,of,this,type,if,possible,code,null,indicates,don,t,ask,for,conversion,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,evaluate,and,check,error,string,expression,class,expected,return,type,spel,message,expected,message,object,other,properties,try,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,expected,return,type,null,expr,get,value,e,context,expected,return,type,else,expr,get,value,e,context,fail,should,have,failed,with,message,expected,message,catch,evaluation,exception,ee,spel,evaluation,exception,ex,spel,evaluation,exception,ee,if,ex,get,message,code,expected,message,assert,equals,failed,to,get,expected,message,expected,message,ex,get,message,code,if,other,properties,null,other,properties,length,0,int,pos,integer,other,properties,0,int,value,assert,equals,did,not,get,correct,position,reported,in,error,pos,ex,get,position,if,other,properties,length,1,object,inserts,ex,get,inserts,if,inserts,null,inserts,new,object,0,if,inserts,length,other,properties,length,1,fail,cannot,check,other,properties,length,1,properties,of,the,exception,it,only,has,inserts,length,inserts,for,int,i,1,i,other,properties,length,i,if,other,properties,i,null,if,inserts,i,1,null,fail,insert,does,not,match,expected,null,but,insert,value,was,inserts,i,1,else,if,inserts,i,1,null,if,other,properties,i,null,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,null,else,if,inserts,i,1,equals,other,properties,i,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,inserts,i,1
AbstractExpressionTests -> protected void evaluateAndCheckError(String expression, Class<?> expectedReturnType, SpelMessage expectedMessage, 			Object... otherProperties);1521632355;Evaluate the specified expression and ensure the expected message comes out._The message may have inserts and they will be checked if otherProperties is specified._The first entry in otherProperties should always be the position._@param expression the expression to evaluate_@param expectedReturnType ask the expression return value to be of this type if possible_({@code null} indicates don't ask for conversion)_@param expectedMessage the expected message_@param otherProperties the expected inserts within the message;protected void evaluateAndCheckError(String expression, Class<?> expectedReturnType, SpelMessage expectedMessage,_			Object... otherProperties) {_		try {_			Expression expr = parser.parseExpression(expression)__			if (expr == null) {_				fail("Parser returned null for expression")__			}_			if (expectedReturnType != null) {_				expr.getValue(context, expectedReturnType)__			}_			else {_				expr.getValue(context)__			}_			fail("Should have failed with message " + expectedMessage)__		}_		catch (EvaluationException ee) {_			SpelEvaluationException ex = (SpelEvaluationException) ee__			if (ex.getMessageCode() != expectedMessage) {_				assertEquals("Failed to get expected message", expectedMessage, ex.getMessageCode())__			}_			if (otherProperties != null && otherProperties.length != 0) {_				_				int pos = ((Integer) otherProperties[0]).intValue()__				assertEquals("Did not get correct position reported in error ", pos, ex.getPosition())__				if (otherProperties.length > 1) {_					_					Object[] inserts = ex.getInserts()__					if (inserts == null) {_						inserts = new Object[0]__					}_					if (inserts.length < otherProperties.length - 1) {_						fail("Cannot check " + (otherProperties.length - 1) +_								" properties of the exception, it only has " + inserts.length + " inserts")__					}_					for (int i = 1_ i < otherProperties.length_ i++) {_						if (otherProperties[i] == null) {_							if (inserts[i - 1] != null) {_								fail("Insert does not match, expected 'null' but insert value was '" +_										inserts[i - 1] + "'")__							}_						}_						else if (inserts[i - 1] == null) {_							if (otherProperties[i] != null) {_								fail("Insert does not match, expected '" + otherProperties[i] +_										"' but insert value was 'null'")__							}_						}_						else if (!inserts[i - 1].equals(otherProperties[i])) {_							fail("Insert does not match, expected '" + otherProperties[i] +_									"' but insert value was '" + inserts[i - 1] + "'")__						}_					}_				}_			}_		}_	};evaluate,the,specified,expression,and,ensure,the,expected,message,comes,out,the,message,may,have,inserts,and,they,will,be,checked,if,other,properties,is,specified,the,first,entry,in,other,properties,should,always,be,the,position,param,expression,the,expression,to,evaluate,param,expected,return,type,ask,the,expression,return,value,to,be,of,this,type,if,possible,code,null,indicates,don,t,ask,for,conversion,param,expected,message,the,expected,message,param,other,properties,the,expected,inserts,within,the,message;protected,void,evaluate,and,check,error,string,expression,class,expected,return,type,spel,message,expected,message,object,other,properties,try,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,expected,return,type,null,expr,get,value,context,expected,return,type,else,expr,get,value,context,fail,should,have,failed,with,message,expected,message,catch,evaluation,exception,ee,spel,evaluation,exception,ex,spel,evaluation,exception,ee,if,ex,get,message,code,expected,message,assert,equals,failed,to,get,expected,message,expected,message,ex,get,message,code,if,other,properties,null,other,properties,length,0,int,pos,integer,other,properties,0,int,value,assert,equals,did,not,get,correct,position,reported,in,error,pos,ex,get,position,if,other,properties,length,1,object,inserts,ex,get,inserts,if,inserts,null,inserts,new,object,0,if,inserts,length,other,properties,length,1,fail,cannot,check,other,properties,length,1,properties,of,the,exception,it,only,has,inserts,length,inserts,for,int,i,1,i,other,properties,length,i,if,other,properties,i,null,if,inserts,i,1,null,fail,insert,does,not,match,expected,null,but,insert,value,was,inserts,i,1,else,if,inserts,i,1,null,if,other,properties,i,null,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,null,else,if,inserts,i,1,equals,other,properties,i,fail,insert,does,not,match,expected,other,properties,i,but,insert,value,was,inserts,i,1
AbstractExpressionTests -> protected static String stringValueOf(Object value, boolean isNested);1391876651;Produce a nice string representation of the input object.__@param value object to be formatted_@return a nice string;protected static String stringValueOf(Object value, boolean isNested) {_		_		if (value == null) {_			return "null"__		}_		if (value.getClass().isArray()) {_			StringBuilder sb = new StringBuilder()__			if (value.getClass().getComponentType().isPrimitive()) {_				Class<?> primitiveType = value.getClass().getComponentType()__				if (primitiveType == Integer.TYPE) {_					int[] l = (int[]) value__					sb.append("int[").append(l.length).append("]{")__					for (int j = 0_ j < l.length_ j++) {_						if (j > 0) {_							sb.append(",")__						}_						sb.append(stringValueOf(l[j]))__					}_					sb.append("}")__				}_				else if (primitiveType == Long.TYPE) {_					long[] l = (long[]) value__					sb.append("long[").append(l.length).append("]{")__					for (int j = 0_ j < l.length_ j++) {_						if (j > 0) {_							sb.append(",")__						}_						sb.append(stringValueOf(l[j]))__					}_					sb.append("}")__				}_				else {_					throw new RuntimeException("Please implement support for type " + primitiveType.getName()_							+ " in ExpressionTestCase.stringValueOf()")__				}_			}_			else if (value.getClass().getComponentType().isArray()) {_				List<Object> l = Arrays.asList((Object[]) value)__				if (!isNested) {_					sb.append(value.getClass().getComponentType().getName())__				}_				sb.append("[").append(l.size()).append("]{")__				int i = 0__				for (Object object : l) {_					if (i > 0) {_						sb.append(",")__					}_					i++__					sb.append(stringValueOf(object, true))__				}_				sb.append("}")__			}_			else {_				List<Object> l = Arrays.asList((Object[]) value)__				if (!isNested) {_					sb.append(value.getClass().getComponentType().getName())__				}_				sb.append("[").append(l.size()).append("]{")__				int i = 0__				for (Object object : l) {_					if (i > 0) {_						sb.append(",")__					}_					i++__					sb.append(stringValueOf(object))__				}_				sb.append("}")__			}_			return sb.toString()__		}_		else {_			return value.toString()__		}_	};produce,a,nice,string,representation,of,the,input,object,param,value,object,to,be,formatted,return,a,nice,string;protected,static,string,string,value,of,object,value,boolean,is,nested,if,value,null,return,null,if,value,get,class,is,array,string,builder,sb,new,string,builder,if,value,get,class,get,component,type,is,primitive,class,primitive,type,value,get,class,get,component,type,if,primitive,type,integer,type,int,l,int,value,sb,append,int,append,l,length,append,for,int,j,0,j,l,length,j,if,j,0,sb,append,sb,append,string,value,of,l,j,sb,append,else,if,primitive,type,long,type,long,l,long,value,sb,append,long,append,l,length,append,for,int,j,0,j,l,length,j,if,j,0,sb,append,sb,append,string,value,of,l,j,sb,append,else,throw,new,runtime,exception,please,implement,support,for,type,primitive,type,get,name,in,expression,test,case,string,value,of,else,if,value,get,class,get,component,type,is,array,list,object,l,arrays,as,list,object,value,if,is,nested,sb,append,value,get,class,get,component,type,get,name,sb,append,append,l,size,append,int,i,0,for,object,object,l,if,i,0,sb,append,i,sb,append,string,value,of,object,true,sb,append,else,list,object,l,arrays,as,list,object,value,if,is,nested,sb,append,value,get,class,get,component,type,get,name,sb,append,append,l,size,append,int,i,0,for,object,object,l,if,i,0,sb,append,i,sb,append,string,value,of,object,sb,append,return,sb,to,string,else,return,value,to,string
AbstractExpressionTests -> protected static String stringValueOf(Object value, boolean isNested);1426108143;Produce a nice string representation of the input object._@param value object to be formatted_@return a nice string;protected static String stringValueOf(Object value, boolean isNested) {_		_		if (value == null) {_			return "null"__		}_		if (value.getClass().isArray()) {_			StringBuilder sb = new StringBuilder()__			if (value.getClass().getComponentType().isPrimitive()) {_				Class<?> primitiveType = value.getClass().getComponentType()__				if (primitiveType == Integer.TYPE) {_					int[] l = (int[]) value__					sb.append("int[").append(l.length).append("]{")__					for (int j = 0_ j < l.length_ j++) {_						if (j > 0) {_							sb.append(",")__						}_						sb.append(stringValueOf(l[j]))__					}_					sb.append("}")__				}_				else if (primitiveType == Long.TYPE) {_					long[] l = (long[]) value__					sb.append("long[").append(l.length).append("]{")__					for (int j = 0_ j < l.length_ j++) {_						if (j > 0) {_							sb.append(",")__						}_						sb.append(stringValueOf(l[j]))__					}_					sb.append("}")__				}_				else {_					throw new RuntimeException("Please implement support for type " + primitiveType.getName() +_							" in ExpressionTestCase.stringValueOf()")__				}_			}_			else if (value.getClass().getComponentType().isArray()) {_				List<Object> l = Arrays.asList((Object[]) value)__				if (!isNested) {_					sb.append(value.getClass().getComponentType().getName())__				}_				sb.append("[").append(l.size()).append("]{")__				int i = 0__				for (Object object : l) {_					if (i > 0) {_						sb.append(",")__					}_					i++__					sb.append(stringValueOf(object, true))__				}_				sb.append("}")__			}_			else {_				List<Object> l = Arrays.asList((Object[]) value)__				if (!isNested) {_					sb.append(value.getClass().getComponentType().getName())__				}_				sb.append("[").append(l.size()).append("]{")__				int i = 0__				for (Object object : l) {_					if (i > 0) {_						sb.append(",")__					}_					i++__					sb.append(stringValueOf(object))__				}_				sb.append("}")__			}_			return sb.toString()__		}_		else {_			return value.toString()__		}_	};produce,a,nice,string,representation,of,the,input,object,param,value,object,to,be,formatted,return,a,nice,string;protected,static,string,string,value,of,object,value,boolean,is,nested,if,value,null,return,null,if,value,get,class,is,array,string,builder,sb,new,string,builder,if,value,get,class,get,component,type,is,primitive,class,primitive,type,value,get,class,get,component,type,if,primitive,type,integer,type,int,l,int,value,sb,append,int,append,l,length,append,for,int,j,0,j,l,length,j,if,j,0,sb,append,sb,append,string,value,of,l,j,sb,append,else,if,primitive,type,long,type,long,l,long,value,sb,append,long,append,l,length,append,for,int,j,0,j,l,length,j,if,j,0,sb,append,sb,append,string,value,of,l,j,sb,append,else,throw,new,runtime,exception,please,implement,support,for,type,primitive,type,get,name,in,expression,test,case,string,value,of,else,if,value,get,class,get,component,type,is,array,list,object,l,arrays,as,list,object,value,if,is,nested,sb,append,value,get,class,get,component,type,get,name,sb,append,append,l,size,append,int,i,0,for,object,object,l,if,i,0,sb,append,i,sb,append,string,value,of,object,true,sb,append,else,list,object,l,arrays,as,list,object,value,if,is,nested,sb,append,value,get,class,get,component,type,get,name,sb,append,append,l,size,append,int,i,0,for,object,object,l,if,i,0,sb,append,i,sb,append,string,value,of,object,sb,append,return,sb,to,string,else,return,value,to,string
AbstractExpressionTests -> protected static String stringValueOf(Object value, boolean isNested);1518279448;Produce a nice string representation of the input object._@param value object to be formatted_@return a nice string;protected static String stringValueOf(Object value, boolean isNested) {_		_		if (value == null) {_			return "null"__		}_		if (value.getClass().isArray()) {_			StringBuilder sb = new StringBuilder()__			if (value.getClass().getComponentType().isPrimitive()) {_				Class<?> primitiveType = value.getClass().getComponentType()__				if (primitiveType == Integer.TYPE) {_					int[] l = (int[]) value__					sb.append("int[").append(l.length).append("]{")__					for (int j = 0_ j < l.length_ j++) {_						if (j > 0) {_							sb.append(",")__						}_						sb.append(stringValueOf(l[j]))__					}_					sb.append("}")__				}_				else if (primitiveType == Long.TYPE) {_					long[] l = (long[]) value__					sb.append("long[").append(l.length).append("]{")__					for (int j = 0_ j < l.length_ j++) {_						if (j > 0) {_							sb.append(",")__						}_						sb.append(stringValueOf(l[j]))__					}_					sb.append("}")__				}_				else {_					throw new RuntimeException("Please implement support for type " + primitiveType.getName() +_							" in ExpressionTestCase.stringValueOf()")__				}_			}_			else if (value.getClass().getComponentType().isArray()) {_				List<Object> l = Arrays.asList((Object[]) value)__				if (!isNested) {_					sb.append(value.getClass().getComponentType().getName())__				}_				sb.append("[").append(l.size()).append("]{")__				int i = 0__				for (Object object : l) {_					if (i > 0) {_						sb.append(",")__					}_					i++__					sb.append(stringValueOf(object, true))__				}_				sb.append("}")__			}_			else {_				List<Object> l = Arrays.asList((Object[]) value)__				if (!isNested) {_					sb.append(value.getClass().getComponentType().getName())__				}_				sb.append("[").append(l.size()).append("]{")__				int i = 0__				for (Object object : l) {_					if (i > 0) {_						sb.append(",")__					}_					i++__					sb.append(stringValueOf(object))__				}_				sb.append("}")__			}_			return sb.toString()__		}_		else {_			return value.toString()__		}_	};produce,a,nice,string,representation,of,the,input,object,param,value,object,to,be,formatted,return,a,nice,string;protected,static,string,string,value,of,object,value,boolean,is,nested,if,value,null,return,null,if,value,get,class,is,array,string,builder,sb,new,string,builder,if,value,get,class,get,component,type,is,primitive,class,primitive,type,value,get,class,get,component,type,if,primitive,type,integer,type,int,l,int,value,sb,append,int,append,l,length,append,for,int,j,0,j,l,length,j,if,j,0,sb,append,sb,append,string,value,of,l,j,sb,append,else,if,primitive,type,long,type,long,l,long,value,sb,append,long,append,l,length,append,for,int,j,0,j,l,length,j,if,j,0,sb,append,sb,append,string,value,of,l,j,sb,append,else,throw,new,runtime,exception,please,implement,support,for,type,primitive,type,get,name,in,expression,test,case,string,value,of,else,if,value,get,class,get,component,type,is,array,list,object,l,arrays,as,list,object,value,if,is,nested,sb,append,value,get,class,get,component,type,get,name,sb,append,append,l,size,append,int,i,0,for,object,object,l,if,i,0,sb,append,i,sb,append,string,value,of,object,true,sb,append,else,list,object,l,arrays,as,list,object,value,if,is,nested,sb,append,value,get,class,get,component,type,get,name,sb,append,append,l,size,append,int,i,0,for,object,object,l,if,i,0,sb,append,i,sb,append,string,value,of,object,sb,append,return,sb,to,string,else,return,value,to,string
AbstractExpressionTests -> protected static String stringValueOf(Object value, boolean isNested);1518283060;Produce a nice string representation of the input object._@param value object to be formatted_@return a nice string;protected static String stringValueOf(Object value, boolean isNested) {_		_		if (value == null) {_			return "null"__		}_		if (value.getClass().isArray()) {_			StringBuilder sb = new StringBuilder()__			if (value.getClass().getComponentType().isPrimitive()) {_				Class<?> primitiveType = value.getClass().getComponentType()__				if (primitiveType == Integer.TYPE) {_					int[] l = (int[]) value__					sb.append("int[").append(l.length).append("]{")__					for (int j = 0_ j < l.length_ j++) {_						if (j > 0) {_							sb.append(",")__						}_						sb.append(stringValueOf(l[j]))__					}_					sb.append("}")__				}_				else if (primitiveType == Long.TYPE) {_					long[] l = (long[]) value__					sb.append("long[").append(l.length).append("]{")__					for (int j = 0_ j < l.length_ j++) {_						if (j > 0) {_							sb.append(",")__						}_						sb.append(stringValueOf(l[j]))__					}_					sb.append("}")__				}_				else {_					throw new RuntimeException("Please implement support for type " + primitiveType.getName() +_							" in ExpressionTestCase.stringValueOf()")__				}_			}_			else if (value.getClass().getComponentType().isArray()) {_				List<Object> l = Arrays.asList((Object[]) value)__				if (!isNested) {_					sb.append(value.getClass().getComponentType().getName())__				}_				sb.append("[").append(l.size()).append("]{")__				int i = 0__				for (Object object : l) {_					if (i > 0) {_						sb.append(",")__					}_					i++__					sb.append(stringValueOf(object, true))__				}_				sb.append("}")__			}_			else {_				List<Object> l = Arrays.asList((Object[]) value)__				if (!isNested) {_					sb.append(value.getClass().getComponentType().getName())__				}_				sb.append("[").append(l.size()).append("]{")__				int i = 0__				for (Object object : l) {_					if (i > 0) {_						sb.append(",")__					}_					i++__					sb.append(stringValueOf(object))__				}_				sb.append("}")__			}_			return sb.toString()__		}_		else {_			return value.toString()__		}_	};produce,a,nice,string,representation,of,the,input,object,param,value,object,to,be,formatted,return,a,nice,string;protected,static,string,string,value,of,object,value,boolean,is,nested,if,value,null,return,null,if,value,get,class,is,array,string,builder,sb,new,string,builder,if,value,get,class,get,component,type,is,primitive,class,primitive,type,value,get,class,get,component,type,if,primitive,type,integer,type,int,l,int,value,sb,append,int,append,l,length,append,for,int,j,0,j,l,length,j,if,j,0,sb,append,sb,append,string,value,of,l,j,sb,append,else,if,primitive,type,long,type,long,l,long,value,sb,append,long,append,l,length,append,for,int,j,0,j,l,length,j,if,j,0,sb,append,sb,append,string,value,of,l,j,sb,append,else,throw,new,runtime,exception,please,implement,support,for,type,primitive,type,get,name,in,expression,test,case,string,value,of,else,if,value,get,class,get,component,type,is,array,list,object,l,arrays,as,list,object,value,if,is,nested,sb,append,value,get,class,get,component,type,get,name,sb,append,append,l,size,append,int,i,0,for,object,object,l,if,i,0,sb,append,i,sb,append,string,value,of,object,true,sb,append,else,list,object,l,arrays,as,list,object,value,if,is,nested,sb,append,value,get,class,get,component,type,get,name,sb,append,append,l,size,append,int,i,0,for,object,object,l,if,i,0,sb,append,i,sb,append,string,value,of,object,sb,append,return,sb,to,string,else,return,value,to,string
AbstractExpressionTests -> protected static String stringValueOf(Object value, boolean isNested);1521632355;Produce a nice string representation of the input object._@param value object to be formatted_@return a nice string;protected static String stringValueOf(Object value, boolean isNested) {_		_		if (value == null) {_			return "null"__		}_		if (value.getClass().isArray()) {_			StringBuilder sb = new StringBuilder()__			if (value.getClass().getComponentType().isPrimitive()) {_				Class<?> primitiveType = value.getClass().getComponentType()__				if (primitiveType == Integer.TYPE) {_					int[] l = (int[]) value__					sb.append("int[").append(l.length).append("]{")__					for (int j = 0_ j < l.length_ j++) {_						if (j > 0) {_							sb.append(",")__						}_						sb.append(stringValueOf(l[j]))__					}_					sb.append("}")__				}_				else if (primitiveType == Long.TYPE) {_					long[] l = (long[]) value__					sb.append("long[").append(l.length).append("]{")__					for (int j = 0_ j < l.length_ j++) {_						if (j > 0) {_							sb.append(",")__						}_						sb.append(stringValueOf(l[j]))__					}_					sb.append("}")__				}_				else {_					throw new RuntimeException("Please implement support for type " + primitiveType.getName() +_							" in ExpressionTestCase.stringValueOf()")__				}_			}_			else if (value.getClass().getComponentType().isArray()) {_				List<Object> l = Arrays.asList((Object[]) value)__				if (!isNested) {_					sb.append(value.getClass().getComponentType().getName())__				}_				sb.append("[").append(l.size()).append("]{")__				int i = 0__				for (Object object : l) {_					if (i > 0) {_						sb.append(",")__					}_					i++__					sb.append(stringValueOf(object, true))__				}_				sb.append("}")__			}_			else {_				List<Object> l = Arrays.asList((Object[]) value)__				if (!isNested) {_					sb.append(value.getClass().getComponentType().getName())__				}_				sb.append("[").append(l.size()).append("]{")__				int i = 0__				for (Object object : l) {_					if (i > 0) {_						sb.append(",")__					}_					i++__					sb.append(stringValueOf(object))__				}_				sb.append("}")__			}_			return sb.toString()__		}_		else {_			return value.toString()__		}_	};produce,a,nice,string,representation,of,the,input,object,param,value,object,to,be,formatted,return,a,nice,string;protected,static,string,string,value,of,object,value,boolean,is,nested,if,value,null,return,null,if,value,get,class,is,array,string,builder,sb,new,string,builder,if,value,get,class,get,component,type,is,primitive,class,primitive,type,value,get,class,get,component,type,if,primitive,type,integer,type,int,l,int,value,sb,append,int,append,l,length,append,for,int,j,0,j,l,length,j,if,j,0,sb,append,sb,append,string,value,of,l,j,sb,append,else,if,primitive,type,long,type,long,l,long,value,sb,append,long,append,l,length,append,for,int,j,0,j,l,length,j,if,j,0,sb,append,sb,append,string,value,of,l,j,sb,append,else,throw,new,runtime,exception,please,implement,support,for,type,primitive,type,get,name,in,expression,test,case,string,value,of,else,if,value,get,class,get,component,type,is,array,list,object,l,arrays,as,list,object,value,if,is,nested,sb,append,value,get,class,get,component,type,get,name,sb,append,append,l,size,append,int,i,0,for,object,object,l,if,i,0,sb,append,i,sb,append,string,value,of,object,true,sb,append,else,list,object,l,arrays,as,list,object,value,if,is,nested,sb,append,value,get,class,get,component,type,get,name,sb,append,append,l,size,append,int,i,0,for,object,object,l,if,i,0,sb,append,i,sb,append,string,value,of,object,sb,append,return,sb,to,string,else,return,value,to,string
AbstractExpressionTests -> public void evaluate(String expression, Object expectedValue, Class<?> expectedResultType);1426108143;Evaluate an expression and check that the actual result matches the_expectedValue and the class of the result matches the expectedClassOfResult._@param expression the expression to evaluate_@param expectedValue the expected result for evaluating the expression_@param expectedResultType the expected class of the evaluation result;public void evaluate(String expression, Object expectedValue, Class<?> expectedResultType) {_		Expression expr = parser.parseExpression(expression)__		if (expr == null) {_			fail("Parser returned null for expression")__		}_		if (DEBUG) {_			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__		}__		Object value = expr.getValue(eContext)___		_		if (value == null) {_			if (expectedValue == null) {_				return_  _			}_			assertEquals("Expression returned null value, but expected '" + expectedValue + "'", expectedValue, null)__		}__		Class<?> resultType = value.getClass()__		assertEquals("Type of the actual result was not as expected.  Expected '" + expectedResultType +_				"' but result was of type '" + resultType + "'", expectedResultType, resultType)___		if (expectedValue instanceof String) {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue,_					AbstractExpressionTests.stringValueOf(value))__		}_		else {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue, value)__		}_	};evaluate,an,expression,and,check,that,the,actual,result,matches,the,expected,value,and,the,class,of,the,result,matches,the,expected,class,of,result,param,expression,the,expression,to,evaluate,param,expected,value,the,expected,result,for,evaluating,the,expression,param,expected,result,type,the,expected,class,of,the,evaluation,result;public,void,evaluate,string,expression,object,expected,value,class,expected,result,type,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,debug,spel,utilities,print,abstract,syntax,tree,system,out,expr,object,value,expr,get,value,e,context,if,value,null,if,expected,value,null,return,assert,equals,expression,returned,null,value,but,expected,expected,value,expected,value,null,class,result,type,value,get,class,assert,equals,type,of,the,actual,result,was,not,as,expected,expected,expected,result,type,but,result,was,of,type,result,type,expected,result,type,result,type,if,expected,value,instanceof,string,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,abstract,expression,tests,string,value,of,value,else,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,value
AbstractExpressionTests -> public void evaluate(String expression, Object expectedValue, Class<?> expectedResultType);1518279448;Evaluate an expression and check that the actual result matches the_expectedValue and the class of the result matches the expectedClassOfResult._@param expression the expression to evaluate_@param expectedValue the expected result for evaluating the expression_@param expectedResultType the expected class of the evaluation result;public void evaluate(String expression, Object expectedValue, Class<?> expectedResultType) {_		Expression expr = parser.parseExpression(expression)__		if (expr == null) {_			fail("Parser returned null for expression")__		}_		if (DEBUG) {_			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__		}__		Object value = expr.getValue(eContext)___		_		if (value == null) {_			if (expectedValue == null) {_				return_  _			}_			assertNull("Expression returned null value, but expected '" + expectedValue + "'", expectedValue)__		}__		Class<?> resultType = value.getClass()__		assertEquals("Type of the actual result was not as expected.  Expected '" + expectedResultType +_				"' but result was of type '" + resultType + "'", expectedResultType, resultType)___		if (expectedValue instanceof String) {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue,_					AbstractExpressionTests.stringValueOf(value))__		}_		else {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue, value)__		}_	};evaluate,an,expression,and,check,that,the,actual,result,matches,the,expected,value,and,the,class,of,the,result,matches,the,expected,class,of,result,param,expression,the,expression,to,evaluate,param,expected,value,the,expected,result,for,evaluating,the,expression,param,expected,result,type,the,expected,class,of,the,evaluation,result;public,void,evaluate,string,expression,object,expected,value,class,expected,result,type,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,debug,spel,utilities,print,abstract,syntax,tree,system,out,expr,object,value,expr,get,value,e,context,if,value,null,if,expected,value,null,return,assert,null,expression,returned,null,value,but,expected,expected,value,expected,value,class,result,type,value,get,class,assert,equals,type,of,the,actual,result,was,not,as,expected,expected,expected,result,type,but,result,was,of,type,result,type,expected,result,type,result,type,if,expected,value,instanceof,string,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,abstract,expression,tests,string,value,of,value,else,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,value
AbstractExpressionTests -> public void evaluate(String expression, Object expectedValue, Class<?> expectedResultType);1518283060;Evaluate an expression and check that the actual result matches the_expectedValue and the class of the result matches the expectedClassOfResult._@param expression the expression to evaluate_@param expectedValue the expected result for evaluating the expression_@param expectedResultType the expected class of the evaluation result;public void evaluate(String expression, Object expectedValue, Class<?> expectedResultType) {_		Expression expr = parser.parseExpression(expression)__		if (expr == null) {_			fail("Parser returned null for expression")__		}_		if (DEBUG) {_			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__		}__		Object value = expr.getValue(eContext)___		_		if (value == null) {_			if (expectedValue == null) {_				return_  _			}_			assertNull("Expression returned null value, but expected '" + expectedValue + "'", expectedValue)__		}__		Class<?> resultType = value.getClass()__		assertEquals("Type of the actual result was not as expected.  Expected '" + expectedResultType +_				"' but result was of type '" + resultType + "'", expectedResultType, resultType)___		if (expectedValue instanceof String) {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue,_					AbstractExpressionTests.stringValueOf(value))__		}_		else {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue, value)__		}_	};evaluate,an,expression,and,check,that,the,actual,result,matches,the,expected,value,and,the,class,of,the,result,matches,the,expected,class,of,result,param,expression,the,expression,to,evaluate,param,expected,value,the,expected,result,for,evaluating,the,expression,param,expected,result,type,the,expected,class,of,the,evaluation,result;public,void,evaluate,string,expression,object,expected,value,class,expected,result,type,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,debug,spel,utilities,print,abstract,syntax,tree,system,out,expr,object,value,expr,get,value,e,context,if,value,null,if,expected,value,null,return,assert,null,expression,returned,null,value,but,expected,expected,value,expected,value,class,result,type,value,get,class,assert,equals,type,of,the,actual,result,was,not,as,expected,expected,expected,result,type,but,result,was,of,type,result,type,expected,result,type,result,type,if,expected,value,instanceof,string,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,abstract,expression,tests,string,value,of,value,else,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,value
AbstractExpressionTests -> public void evaluate(String expression, Object expectedValue, Class<?> expectedResultType);1521632355;Evaluate an expression and check that the actual result matches the_expectedValue and the class of the result matches the expectedClassOfResult._@param expression the expression to evaluate_@param expectedValue the expected result for evaluating the expression_@param expectedResultType the expected class of the evaluation result;public void evaluate(String expression, Object expectedValue, Class<?> expectedResultType) {_		Expression expr = parser.parseExpression(expression)__		if (expr == null) {_			fail("Parser returned null for expression")__		}_		if (DEBUG) {_			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__		}__		Object value = expr.getValue(context)___		_		if (value == null) {_			if (expectedValue == null) {_				return_  _			}_			assertNull("Expression returned null value, but expected '" + expectedValue + "'", expectedValue)__		}__		Class<?> resultType = value.getClass()__		assertEquals("Type of the actual result was not as expected.  Expected '" + expectedResultType +_				"' but result was of type '" + resultType + "'", expectedResultType, resultType)___		if (expectedValue instanceof String) {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue,_					AbstractExpressionTests.stringValueOf(value))__		}_		else {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue, value)__		}_	};evaluate,an,expression,and,check,that,the,actual,result,matches,the,expected,value,and,the,class,of,the,result,matches,the,expected,class,of,result,param,expression,the,expression,to,evaluate,param,expected,value,the,expected,result,for,evaluating,the,expression,param,expected,result,type,the,expected,class,of,the,evaluation,result;public,void,evaluate,string,expression,object,expected,value,class,expected,result,type,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,debug,spel,utilities,print,abstract,syntax,tree,system,out,expr,object,value,expr,get,value,context,if,value,null,if,expected,value,null,return,assert,null,expression,returned,null,value,but,expected,expected,value,expected,value,class,result,type,value,get,class,assert,equals,type,of,the,actual,result,was,not,as,expected,expected,expected,result,type,but,result,was,of,type,result,type,expected,result,type,result,type,if,expected,value,instanceof,string,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,abstract,expression,tests,string,value,of,value,else,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,value
AbstractExpressionTests -> public void evaluate(String expression, Object expectedValue, Class<?> expectedClassOfResult, boolean shouldBeWritable);1426108143;Evaluate an expression and check that the actual result matches the_expectedValue and the class of the result matches the expectedClassOfResult._This method can also check if the expression is writable (for example,_it is a variable or property reference)._@param expression the expression to evaluate_@param expectedValue the expected result for evaluating the expression_@param expectedClassOfResult the expected class of the evaluation result_@param shouldBeWritable should the parsed expression be writable?;public void evaluate(String expression, Object expectedValue, Class<?> expectedClassOfResult, boolean shouldBeWritable) {_		Expression expr = parser.parseExpression(expression)__		if (expr == null) {_			fail("Parser returned null for expression")__		}_		if (DEBUG) {_			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__		}_		Object value = expr.getValue(eContext)__		if (value == null) {_			if (expectedValue == null) {_				return_  _			}_			assertEquals("Expression returned null value, but expected '" + expectedValue + "'", expectedValue, null)__		}_		Class<? extends Object> resultType = value.getClass()__		if (expectedValue instanceof String) {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue,_					AbstractExpressionTests.stringValueOf(value))__		}_		else {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue, value)__		}_		assertEquals("Type of the result was not as expected.  Expected '" + expectedClassOfResult +_				"' but result was of type '" + resultType + "'", expectedClassOfResult.equals(resultType), true)___		boolean isWritable = expr.isWritable(eContext)__		if (isWritable != shouldBeWritable) {_			if (shouldBeWritable)_				fail("Expected the expression to be writable but it is not")__			else_				fail("Expected the expression to be readonly but it is not")__		}_	};evaluate,an,expression,and,check,that,the,actual,result,matches,the,expected,value,and,the,class,of,the,result,matches,the,expected,class,of,result,this,method,can,also,check,if,the,expression,is,writable,for,example,it,is,a,variable,or,property,reference,param,expression,the,expression,to,evaluate,param,expected,value,the,expected,result,for,evaluating,the,expression,param,expected,class,of,result,the,expected,class,of,the,evaluation,result,param,should,be,writable,should,the,parsed,expression,be,writable;public,void,evaluate,string,expression,object,expected,value,class,expected,class,of,result,boolean,should,be,writable,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,debug,spel,utilities,print,abstract,syntax,tree,system,out,expr,object,value,expr,get,value,e,context,if,value,null,if,expected,value,null,return,assert,equals,expression,returned,null,value,but,expected,expected,value,expected,value,null,class,extends,object,result,type,value,get,class,if,expected,value,instanceof,string,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,abstract,expression,tests,string,value,of,value,else,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,value,assert,equals,type,of,the,result,was,not,as,expected,expected,expected,class,of,result,but,result,was,of,type,result,type,expected,class,of,result,equals,result,type,true,boolean,is,writable,expr,is,writable,e,context,if,is,writable,should,be,writable,if,should,be,writable,fail,expected,the,expression,to,be,writable,but,it,is,not,else,fail,expected,the,expression,to,be,readonly,but,it,is,not
AbstractExpressionTests -> public void evaluate(String expression, Object expectedValue, Class<?> expectedClassOfResult, boolean shouldBeWritable);1518279448;Evaluate an expression and check that the actual result matches the_expectedValue and the class of the result matches the expectedClassOfResult._This method can also check if the expression is writable (for example,_it is a variable or property reference)._@param expression the expression to evaluate_@param expectedValue the expected result for evaluating the expression_@param expectedClassOfResult the expected class of the evaluation result_@param shouldBeWritable should the parsed expression be writable?;public void evaluate(String expression, Object expectedValue, Class<?> expectedClassOfResult, boolean shouldBeWritable) {_		Expression expr = parser.parseExpression(expression)__		if (expr == null) {_			fail("Parser returned null for expression")__		}_		if (DEBUG) {_			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__		}_		Object value = expr.getValue(eContext)__		if (value == null) {_			if (expectedValue == null) {_				return_  _			}_			assertNull("Expression returned null value, but expected '" + expectedValue + "'", expectedValue)__		}_		Class<? extends Object> resultType = value.getClass()__		if (expectedValue instanceof String) {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue,_					AbstractExpressionTests.stringValueOf(value))__		}_		else {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue, value)__		}_		assertNull("Type of the result was not as expected.  Expected '" + expectedClassOfResult +_				"' but result was of type '" + resultType + "'", expectedClassOfResult.equals(resultType))___		boolean isWritable = expr.isWritable(eContext)__		if (isWritable != shouldBeWritable) {_			if (shouldBeWritable)_				fail("Expected the expression to be writable but it is not")__			else_				fail("Expected the expression to be readonly but it is not")__		}_	};evaluate,an,expression,and,check,that,the,actual,result,matches,the,expected,value,and,the,class,of,the,result,matches,the,expected,class,of,result,this,method,can,also,check,if,the,expression,is,writable,for,example,it,is,a,variable,or,property,reference,param,expression,the,expression,to,evaluate,param,expected,value,the,expected,result,for,evaluating,the,expression,param,expected,class,of,result,the,expected,class,of,the,evaluation,result,param,should,be,writable,should,the,parsed,expression,be,writable;public,void,evaluate,string,expression,object,expected,value,class,expected,class,of,result,boolean,should,be,writable,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,debug,spel,utilities,print,abstract,syntax,tree,system,out,expr,object,value,expr,get,value,e,context,if,value,null,if,expected,value,null,return,assert,null,expression,returned,null,value,but,expected,expected,value,expected,value,class,extends,object,result,type,value,get,class,if,expected,value,instanceof,string,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,abstract,expression,tests,string,value,of,value,else,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,value,assert,null,type,of,the,result,was,not,as,expected,expected,expected,class,of,result,but,result,was,of,type,result,type,expected,class,of,result,equals,result,type,boolean,is,writable,expr,is,writable,e,context,if,is,writable,should,be,writable,if,should,be,writable,fail,expected,the,expression,to,be,writable,but,it,is,not,else,fail,expected,the,expression,to,be,readonly,but,it,is,not
AbstractExpressionTests -> public void evaluate(String expression, Object expectedValue, Class<?> expectedClassOfResult, boolean shouldBeWritable);1518283060;Evaluate an expression and check that the actual result matches the_expectedValue and the class of the result matches the expectedClassOfResult._This method can also check if the expression is writable (for example,_it is a variable or property reference)._@param expression the expression to evaluate_@param expectedValue the expected result for evaluating the expression_@param expectedClassOfResult the expected class of the evaluation result_@param shouldBeWritable should the parsed expression be writable?;public void evaluate(String expression, Object expectedValue, Class<?> expectedClassOfResult, boolean shouldBeWritable) {_		Expression expr = parser.parseExpression(expression)__		if (expr == null) {_			fail("Parser returned null for expression")__		}_		if (DEBUG) {_			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__		}_		Object value = expr.getValue(eContext)__		if (value == null) {_			if (expectedValue == null) {_				return_  _			}_			assertNull("Expression returned null value, but expected '" + expectedValue + "'", expectedValue)__		}_		Class<? extends Object> resultType = value.getClass()__		if (expectedValue instanceof String) {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue,_					AbstractExpressionTests.stringValueOf(value))__		}_		else {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue, value)__		}_		assertTrue("Type of the result was not as expected.  Expected '" + expectedClassOfResult +_				"' but result was of type '" + resultType + "'", expectedClassOfResult.equals(resultType))___		boolean isWritable = expr.isWritable(eContext)__		if (isWritable != shouldBeWritable) {_			if (shouldBeWritable)_				fail("Expected the expression to be writable but it is not")__			else_				fail("Expected the expression to be readonly but it is not")__		}_	};evaluate,an,expression,and,check,that,the,actual,result,matches,the,expected,value,and,the,class,of,the,result,matches,the,expected,class,of,result,this,method,can,also,check,if,the,expression,is,writable,for,example,it,is,a,variable,or,property,reference,param,expression,the,expression,to,evaluate,param,expected,value,the,expected,result,for,evaluating,the,expression,param,expected,class,of,result,the,expected,class,of,the,evaluation,result,param,should,be,writable,should,the,parsed,expression,be,writable;public,void,evaluate,string,expression,object,expected,value,class,expected,class,of,result,boolean,should,be,writable,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,debug,spel,utilities,print,abstract,syntax,tree,system,out,expr,object,value,expr,get,value,e,context,if,value,null,if,expected,value,null,return,assert,null,expression,returned,null,value,but,expected,expected,value,expected,value,class,extends,object,result,type,value,get,class,if,expected,value,instanceof,string,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,abstract,expression,tests,string,value,of,value,else,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,value,assert,true,type,of,the,result,was,not,as,expected,expected,expected,class,of,result,but,result,was,of,type,result,type,expected,class,of,result,equals,result,type,boolean,is,writable,expr,is,writable,e,context,if,is,writable,should,be,writable,if,should,be,writable,fail,expected,the,expression,to,be,writable,but,it,is,not,else,fail,expected,the,expression,to,be,readonly,but,it,is,not
AbstractExpressionTests -> public void evaluate(String expression, Object expectedValue, Class<?> expectedClassOfResult, boolean shouldBeWritable);1521632355;Evaluate an expression and check that the actual result matches the_expectedValue and the class of the result matches the expectedClassOfResult._This method can also check if the expression is writable (for example,_it is a variable or property reference)._@param expression the expression to evaluate_@param expectedValue the expected result for evaluating the expression_@param expectedClassOfResult the expected class of the evaluation result_@param shouldBeWritable should the parsed expression be writable?;public void evaluate(String expression, Object expectedValue, Class<?> expectedClassOfResult, boolean shouldBeWritable) {_		Expression expr = parser.parseExpression(expression)__		if (expr == null) {_			fail("Parser returned null for expression")__		}_		if (DEBUG) {_			SpelUtilities.printAbstractSyntaxTree(System.out, expr)__		}_		Object value = expr.getValue(context)__		if (value == null) {_			if (expectedValue == null) {_				return_  _			}_			assertNull("Expression returned null value, but expected '" + expectedValue + "'", expectedValue)__		}_		Class<? extends Object> resultType = value.getClass()__		if (expectedValue instanceof String) {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue,_					AbstractExpressionTests.stringValueOf(value))__		}_		else {_			assertEquals("Did not get expected value for expression '" + expression + "'.", expectedValue, value)__		}_		assertTrue("Type of the result was not as expected.  Expected '" + expectedClassOfResult +_				"' but result was of type '" + resultType + "'", expectedClassOfResult.equals(resultType))___		boolean isWritable = expr.isWritable(context)__		if (isWritable != shouldBeWritable) {_			if (shouldBeWritable)_				fail("Expected the expression to be writable but it is not")__			else_				fail("Expected the expression to be readonly but it is not")__		}_	};evaluate,an,expression,and,check,that,the,actual,result,matches,the,expected,value,and,the,class,of,the,result,matches,the,expected,class,of,result,this,method,can,also,check,if,the,expression,is,writable,for,example,it,is,a,variable,or,property,reference,param,expression,the,expression,to,evaluate,param,expected,value,the,expected,result,for,evaluating,the,expression,param,expected,class,of,result,the,expected,class,of,the,evaluation,result,param,should,be,writable,should,the,parsed,expression,be,writable;public,void,evaluate,string,expression,object,expected,value,class,expected,class,of,result,boolean,should,be,writable,expression,expr,parser,parse,expression,expression,if,expr,null,fail,parser,returned,null,for,expression,if,debug,spel,utilities,print,abstract,syntax,tree,system,out,expr,object,value,expr,get,value,context,if,value,null,if,expected,value,null,return,assert,null,expression,returned,null,value,but,expected,expected,value,expected,value,class,extends,object,result,type,value,get,class,if,expected,value,instanceof,string,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,abstract,expression,tests,string,value,of,value,else,assert,equals,did,not,get,expected,value,for,expression,expression,expected,value,value,assert,true,type,of,the,result,was,not,as,expected,expected,expected,class,of,result,but,result,was,of,type,result,type,expected,class,of,result,equals,result,type,boolean,is,writable,expr,is,writable,context,if,is,writable,should,be,writable,if,should,be,writable,fail,expected,the,expression,to,be,writable,but,it,is,not,else,fail,expected,the,expression,to,be,readonly,but,it,is,not
