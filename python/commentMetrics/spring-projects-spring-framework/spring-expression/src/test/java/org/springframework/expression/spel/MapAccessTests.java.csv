commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test public void testSimpleMapAccess01() {     evaluate("testMap.get('monday')", "montag", String.class). }
false;public;0;4;;@Test public void testMapAccessThroughIndexer() {     evaluate("testMap['monday']", "montag", String.class). }
false;public;0;10;;@Test public void testCustomMapAccessor() throws Exception {     ExpressionParser parser = new SpelExpressionParser().     StandardEvaluationContext ctx = TestScenarioCreator.getTestEvaluationContext().     ctx.addPropertyAccessor(new MapAccessor()).     Expression expr = parser.parseExpression("testMap.monday").     Object value = expr.getValue(ctx, String.class).     assertEquals("montag", value). }
false;public;0;10;;@Test public void testVariableMapAccess() throws Exception {     ExpressionParser parser = new SpelExpressionParser().     StandardEvaluationContext ctx = TestScenarioCreator.getTestEvaluationContext().     ctx.setVariable("day", "saturday").     Expression expr = parser.parseExpression("testMap[#day]").     Object value = expr.getValue(ctx, String.class).     assertEquals("samstag", value). }
false;public;0;13;;@Test public void testGetValue() {     Map<String, String> props1 = new HashMap<>().     props1.put("key1", "value1").     props1.put("key2", "value2").     props1.put("key3", "value3").     Object bean = new TestBean("name1", new TestBean("name2", null, "Description 2", 15, props1), "description 1", 6, props1).     ExpressionParser parser = new SpelExpressionParser().     Expression expr = parser.parseExpression("testBean.properties['key2']").     assertEquals("value2", expr.getValue(bean)). }
false;public;0;9;;@Test public void testGetValueFromRootMap() {     Map<String, String> map = new HashMap<>().     map.put("key", "value").     ExpressionParser spelExpressionParser = new SpelExpressionParser().     Expression expr = spelExpressionParser.parseExpression("#root['key']").     assertEquals("value", expr.getValue(map)). }
false;public;0;18;;@Test public void testGetValuePerformance() throws Exception {     Assume.group(TestGroup.PERFORMANCE).     Map<String, String> map = new HashMap<>().     map.put("key", "value").     EvaluationContext context = new StandardEvaluationContext(map).     ExpressionParser spelExpressionParser = new SpelExpressionParser().     Expression expr = spelExpressionParser.parseExpression("#root['key']").     StopWatch s = new StopWatch().     s.start().     for (int i = 0. i < 10000. i++) {         expr.getValue(context).     }     s.stop().     assertThat(s.getTotalTimeMillis(), lessThan(200L)). }
false;public;0;3;;public String getName() {     return name. }
false;public;1;3;;public void setName(String name) {     this.name = name. }
false;public;0;3;;public TestBean getTestBean() {     return testBean. }
false;public;1;3;;public void setTestBean(TestBean testBean) {     this.testBean = testBean. }
false;public;0;3;;public String getDescription() {     return description. }
false;public;1;3;;public void setDescription(String description) {     this.description = description. }
false;public;0;3;;public Integer getPriority() {     return priority. }
false;public;1;3;;public void setPriority(Integer priority) {     this.priority = priority. }
false;public;0;3;;public Map<String, String> getProperties() {     return properties. }
false;public;1;3;;public void setProperties(Map<String, String> properties) {     this.properties = properties. }
false;public;3;4;;@Override public boolean canRead(EvaluationContext context, Object target, String name) throws AccessException {     return (((Map<?, ?>) target).containsKey(name)). }
false;public;3;4;;@Override public TypedValue read(EvaluationContext context, Object target, String name) throws AccessException {     return new TypedValue(((Map<?, ?>) target).get(name)). }
false;public;3;4;;@Override public boolean canWrite(EvaluationContext context, Object target, String name) throws AccessException {     return true. }
false;public;4;5;;@Override @SuppressWarnings("unchecked") public void write(EvaluationContext context, Object target, String name, Object newValue) throws AccessException {     ((Map<Object, Object>) target).put(name, newValue). }
false;public;0;4;;@Override public Class<?>[] getSpecificTargetClasses() {     return new Class<?>[] { Map.class }. }
