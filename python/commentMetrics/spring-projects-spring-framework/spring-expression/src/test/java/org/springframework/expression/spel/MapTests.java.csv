commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Test public void testInlineMapCreation01() {     evaluate("{'a':1, 'b':2, 'c':3, 'd':4, 'e':5}", "{a=1, b=2, c=3, d=4, e=5}", unmodifiableClass).     evaluate("{'a':1}", "{a=1}", unmodifiableClass). }
false;public;0;4;;@Test public void testInlineMapCreation02() {     evaluate("{'abc':'def', 'uvw':'xyz'}", "{abc=def, uvw=xyz}", unmodifiableClass). }
false;public;0;4;;@Test public void testInlineMapCreation03() {     evaluate("{:}", "{}", unmodifiableClass). }
false;public;0;8;;@Test public void testInlineMapCreation04() {     evaluate("{'key':'abc'=='xyz'}", "{key=false}", LinkedHashMap.class).     evaluate("{key:'abc'=='xyz'}", "{key=false}", LinkedHashMap.class).     evaluate("{key:'abc'=='xyz',key2:true}[key]", "false", Boolean.class).     evaluate("{key:'abc'=='xyz',key2:true}.get('key2')", "true", Boolean.class).     evaluate("{key:'abc'=='xyz',key2:true}['key2']", "true", Boolean.class). }
false;public;0;6;;@Test public void testInlineMapAndNesting() {     evaluate("{a:{a:1,b:2,c:3},b:{d:4,e:5,f:6}}", "{a={a=1, b=2, c=3}, b={d=4, e=5, f=6}}", unmodifiableClass).     evaluate("{a:{x:1,y:'2',z:3},b:{u:4,v:{'a','b'},w:5,x:6}}", "{a={x=1, y=2, z=3}, b={u=4, v=[a, b], w=5, x=6}}", unmodifiableClass).     evaluate("{a:{1,2,3},b:{4,5,6}}", "{a=[1, 2, 3], b=[4, 5, 6]}", unmodifiableClass). }
false;public;0;4;;@Test public void testInlineMapWithFunkyKeys() {     evaluate("{#root.name:true}", "{Nikola Tesla=true}", LinkedHashMap.class). }
false;public;0;4;;@Test public void testInlineMapError() {     parseAndCheckError("{key:'abc'", SpelMessage.OOD). }
false;public;0;4;;@Test public void testRelOperatorsIs02() {     evaluate("{a:1, b:2, c:3, d:4, e:5} instanceof T(java.util.Map)", "true", Boolean.class). }
false;public;0;8;;@Test public void testInlineMapAndProjectionSelection() {     evaluate("{a:1,b:2,c:3,d:4,e:5,f:6}.![value>3]", "[false, false, false, true, true, true]", ArrayList.class).     evaluate("{a:1,b:2,c:3,d:4,e:5,f:6}.?[value>3]", "{d=4, e=5, f=6}", HashMap.class).     evaluate("{a:1,b:2,c:3,d:4,e:5,f:6,g:7,h:8,i:9,j:10}.?[value%2==0]", "{b=2, d=4, f=6, h=8, j=10}", HashMap.class). // TODO this looks like a serious issue (but not a new one): the context object against which arguments are evaluated seems wrong: // evaluate("{a:1,b:2,c:3,d:4,e:5,f:6,g:7,h:8,i:9,j:10}.?[isEven(value) == 'y']", "[2, 4, 6, 8, 10]", ArrayList.class). }
false;public;0;4;;@Test public void testSetConstruction01() {     evaluate("new java.util.HashMap().putAll({a:'a',b:'b',c:'c'})", null, Object.class). }
false;public;0;13;;@Test public void testConstantRepresentation1() {     checkConstantMap("{f:{'a','b','c'}}", true).     checkConstantMap("{'a':1,'b':2,'c':3,'d':4,'e':5}", true).     checkConstantMap("{aaa:'abc'}", true).     checkConstantMap("{:}", true).     checkConstantMap("{a:#a,b:2,c:3}", false).     checkConstantMap("{a:1,b:2,c:Integer.valueOf(4)}", false).     checkConstantMap("{a:1,b:2,c:{#a}}", false).     checkConstantMap("{#root.name:true}", false).     checkConstantMap("{a:1,b:2,c:{d:true,e:false}}", true).     checkConstantMap("{a:1,b:2,c:{d:{1,2,3},e:{4,5,6},f:{'a','b','c'}}}", true). }
false;private;2;13;;private void checkConstantMap(String expressionText, boolean expectedToBeConstant) {     SpelExpressionParser parser = new SpelExpressionParser().     SpelExpression expression = (SpelExpression) parser.parseExpression(expressionText).     SpelNode node = expression.getAST().     assertTrue(node instanceof InlineMap).     InlineMap inlineMap = (InlineMap) node.     if (expectedToBeConstant) {         assertTrue(inlineMap.isConstant()).     } else {         assertFalse(inlineMap.isConstant()).     } }
false;public;0;5;;@Test(expected = UnsupportedOperationException.class) public void testInlineMapWriting() {     // list should be unmodifiable     evaluate("{a:1, b:2, c:3, d:4, e:5}[a]=6", "[a:1,b: 2,c: 3,d: 4,e: 5]", unmodifiableClass). }
false;public;0;42;;@Test public void testMapKeysThatAreAlsoSpELKeywords() {     SpelExpressionParser parser = new SpelExpressionParser().     SpelExpression expression = null.     Object o = null.     // expression = (SpelExpression) parser.parseExpression("foo['NEW']").     // o = expression.getValue(new MapHolder()).     // assertEquals("VALUE",o).     expression = (SpelExpression) parser.parseExpression("foo[T]").     o = expression.getValue(new MapHolder()).     assertEquals("TV", o).     expression = (SpelExpression) parser.parseExpression("foo[t]").     o = expression.getValue(new MapHolder()).     assertEquals("tv", o).     expression = (SpelExpression) parser.parseExpression("foo[NEW]").     o = expression.getValue(new MapHolder()).     assertEquals("VALUE", o).     expression = (SpelExpression) parser.parseExpression("foo[new]").     o = expression.getValue(new MapHolder()).     assertEquals("value", o).     expression = (SpelExpression) parser.parseExpression("foo['abc.def']").     o = expression.getValue(new MapHolder()).     assertEquals("value", o).     expression = (SpelExpression) parser.parseExpression("foo[foo[NEW]]").     o = expression.getValue(new MapHolder()).     assertEquals("37", o).     expression = (SpelExpression) parser.parseExpression("foo[foo[new]]").     o = expression.getValue(new MapHolder()).     assertEquals("38", o).     expression = (SpelExpression) parser.parseExpression("foo[foo[foo[T]]]").     o = expression.getValue(new MapHolder()).     assertEquals("value", o). }
