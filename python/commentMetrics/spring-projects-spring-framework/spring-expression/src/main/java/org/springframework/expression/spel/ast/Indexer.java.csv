commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {     return getValueRef(state).getValue(). }
false;public;2;4;;@Override public void setValue(ExpressionState state, @Nullable Object newValue) throws EvaluationException {     getValueRef(state).setValue(newValue). }
false;public;1;4;;@Override public boolean isWritable(ExpressionState expressionState) throws SpelEvaluationException {     return true. }
false;protected;1;79;;@Override protected ValueRef getValueRef(ExpressionState state) throws EvaluationException {     TypedValue context = state.getActiveContextObject().     Object target = context.getValue().     TypeDescriptor targetDescriptor = context.getTypeDescriptor().     TypedValue indexValue.     Object index.     // This first part of the if clause prevents a 'double dereference' of the property (SPR-5847)     if (target instanceof Map && (this.children[0] instanceof PropertyOrFieldReference)) {         PropertyOrFieldReference reference = (PropertyOrFieldReference) this.children[0].         index = reference.getName().         indexValue = new TypedValue(index).     } else {         // so temporarily push that on whilst evaluating the key         try {             state.pushActiveContextObject(state.getRootContextObject()).             indexValue = this.children[0].getValueInternal(state).             index = indexValue.getValue().             Assert.state(index != null, "No index").         } finally {             state.popActiveContextObject().         }     }     // Raise a proper exception in case of a null target     if (target == null) {         throw new SpelEvaluationException(getStartPosition(), SpelMessage.CANNOT_INDEX_INTO_NULL_VALUE).     }     // At this point, we need a TypeDescriptor for a non-null target object     Assert.state(targetDescriptor != null, "No type descriptor").     // Indexing into a Map     if (target instanceof Map) {         Object key = index.         if (targetDescriptor.getMapKeyTypeDescriptor() != null) {             key = state.convertValue(key, targetDescriptor.getMapKeyTypeDescriptor()).         }         this.indexedType = IndexedType.MAP.         return new MapIndexingValueRef(state.getTypeConverter(), (Map<?, ?>) target, key, targetDescriptor).     }     // attempt to treat the index value as a number     if (target.getClass().isArray() || target instanceof Collection || target instanceof String) {         int idx = (Integer) state.convertValue(index, TypeDescriptor.valueOf(Integer.class)).         if (target.getClass().isArray()) {             this.indexedType = IndexedType.ARRAY.             return new ArrayIndexingValueRef(state.getTypeConverter(), target, idx, targetDescriptor).         } else if (target instanceof Collection) {             if (target instanceof List) {                 this.indexedType = IndexedType.LIST.             }             return new CollectionIndexingValueRef((Collection<?>) target, idx, targetDescriptor, state.getTypeConverter(), state.getConfiguration().isAutoGrowCollections(), state.getConfiguration().getMaximumAutoGrowSize()).         } else {             this.indexedType = IndexedType.STRING.             return new StringIndexingLValue((String) target, idx, targetDescriptor).         }     }     // Try and treat the index value as a property of the context object     // TODO: could call the conversion service to convert the value to a String     TypeDescriptor valueType = indexValue.getTypeDescriptor().     if (valueType != null && String.class == valueType.getType()) {         this.indexedType = IndexedType.OBJECT.         return new PropertyIndexingValueRef(target, (String) index, state.getEvaluationContext(), targetDescriptor).     }     throw new SpelEvaluationException(getStartPosition(), SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE, targetDescriptor). }
false;public;0;19;;@Override public boolean isCompilable() {     if (this.indexedType == IndexedType.ARRAY) {         return (this.exitTypeDescriptor != null).     } else if (this.indexedType == IndexedType.LIST) {         return this.children[0].isCompilable().     } else if (this.indexedType == IndexedType.MAP) {         return (this.children[0] instanceof PropertyOrFieldReference || this.children[0].isCompilable()).     } else if (this.indexedType == IndexedType.OBJECT) {         // If the string name is changing the accessor is clearly going to change (so no compilation possible)         return (this.cachedReadAccessor != null && this.cachedReadAccessor instanceof ReflectivePropertyAccessor.OptimalPropertyAccessor && getChild(0) instanceof StringLiteral).     }     return false. }
false;public;2;106;;@Override public void generateCode(MethodVisitor mv, CodeFlow cf) {     String descriptor = cf.lastDescriptor().     if (descriptor == null) {         // Stack is empty, should use context object         cf.loadTarget(mv).     }     if (this.indexedType == IndexedType.ARRAY) {         int insn.         if ("D".equals(this.exitTypeDescriptor)) {             mv.visitTypeInsn(CHECKCAST, "[D").             insn = DALOAD.         } else if ("F".equals(this.exitTypeDescriptor)) {             mv.visitTypeInsn(CHECKCAST, "[F").             insn = FALOAD.         } else if ("J".equals(this.exitTypeDescriptor)) {             mv.visitTypeInsn(CHECKCAST, "[J").             insn = LALOAD.         } else if ("I".equals(this.exitTypeDescriptor)) {             mv.visitTypeInsn(CHECKCAST, "[I").             insn = IALOAD.         } else if ("S".equals(this.exitTypeDescriptor)) {             mv.visitTypeInsn(CHECKCAST, "[S").             insn = SALOAD.         } else if ("B".equals(this.exitTypeDescriptor)) {             mv.visitTypeInsn(CHECKCAST, "[B").             insn = BALOAD.         } else if ("C".equals(this.exitTypeDescriptor)) {             mv.visitTypeInsn(CHECKCAST, "[C").             insn = CALOAD.         } else {             mv.visitTypeInsn(CHECKCAST, "[" + this.exitTypeDescriptor + (CodeFlow.isPrimitiveArray(this.exitTypeDescriptor) ? "" : ".")).             // depthPlusOne(exitTypeDescriptor)+"Ljava/lang/Object.").             insn = AALOAD.         }         SpelNodeImpl index = this.children[0].         cf.enterCompilationScope().         index.generateCode(mv, cf).         cf.exitCompilationScope().         mv.visitInsn(insn).     } else if (this.indexedType == IndexedType.LIST) {         mv.visitTypeInsn(CHECKCAST, "java/util/List").         cf.enterCompilationScope().         this.children[0].generateCode(mv, cf).         cf.exitCompilationScope().         mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "get", "(I)Ljava/lang/Object.", true).     } else if (this.indexedType == IndexedType.MAP) {         mv.visitTypeInsn(CHECKCAST, "java/util/Map").         // a property/field reference         if ((this.children[0] instanceof PropertyOrFieldReference)) {             PropertyOrFieldReference reference = (PropertyOrFieldReference) this.children[0].             String mapKeyName = reference.getName().             mv.visitLdcInsn(mapKeyName).         } else {             cf.enterCompilationScope().             this.children[0].generateCode(mv, cf).             cf.exitCompilationScope().         }         mv.visitMethodInsn(INVOKEINTERFACE, "java/util/Map", "get", "(Ljava/lang/Object.)Ljava/lang/Object.", true).     } else if (this.indexedType == IndexedType.OBJECT) {         ReflectivePropertyAccessor.OptimalPropertyAccessor accessor = (ReflectivePropertyAccessor.OptimalPropertyAccessor) this.cachedReadAccessor.         Assert.state(accessor != null, "No cached read accessor").         Member member = accessor.member.         boolean isStatic = Modifier.isStatic(member.getModifiers()).         String classDesc = member.getDeclaringClass().getName().replace('.', '/').         if (!isStatic) {             if (descriptor == null) {                 cf.loadTarget(mv).             }             if (descriptor == null || !classDesc.equals(descriptor.substring(1))) {                 mv.visitTypeInsn(CHECKCAST, classDesc).             }         }         if (member instanceof Method) {             mv.visitMethodInsn((isStatic ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, member.getName(), CodeFlow.createSignatureDescriptor((Method) member), false).         } else {             mv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, member.getName(), CodeFlow.toJvmDescriptor(((Field) member).getType())).         }     }     cf.pushDescriptor(this.exitTypeDescriptor). }
false;public;0;8;;@Override public String toStringAST() {     StringJoiner sj = new StringJoiner(",", "[", "]").     for (int i = 0. i < getChildCount(). i++) {         sj.add(getChild(i).toStringAST()).     }     return sj.toString(). }
false;private;5;49;;private void setArrayElement(TypeConverter converter, Object ctx, int idx, @Nullable Object newValue, Class<?> arrayComponentType) throws EvaluationException {     if (arrayComponentType == Boolean.TYPE) {         boolean[] array = (boolean[]) ctx.         checkAccess(array.length, idx).         array[idx] = convertValue(converter, newValue, Boolean.class).     } else if (arrayComponentType == Byte.TYPE) {         byte[] array = (byte[]) ctx.         checkAccess(array.length, idx).         array[idx] = convertValue(converter, newValue, Byte.class).     } else if (arrayComponentType == Character.TYPE) {         char[] array = (char[]) ctx.         checkAccess(array.length, idx).         array[idx] = convertValue(converter, newValue, Character.class).     } else if (arrayComponentType == Double.TYPE) {         double[] array = (double[]) ctx.         checkAccess(array.length, idx).         array[idx] = convertValue(converter, newValue, Double.class).     } else if (arrayComponentType == Float.TYPE) {         float[] array = (float[]) ctx.         checkAccess(array.length, idx).         array[idx] = convertValue(converter, newValue, Float.class).     } else if (arrayComponentType == Integer.TYPE) {         int[] array = (int[]) ctx.         checkAccess(array.length, idx).         array[idx] = convertValue(converter, newValue, Integer.class).     } else if (arrayComponentType == Long.TYPE) {         long[] array = (long[]) ctx.         checkAccess(array.length, idx).         array[idx] = convertValue(converter, newValue, Long.class).     } else if (arrayComponentType == Short.TYPE) {         short[] array = (short[]) ctx.         checkAccess(array.length, idx).         array[idx] = convertValue(converter, newValue, Short.class).     } else {         Object[] array = (Object[]) ctx.         checkAccess(array.length, idx).         array[idx] = convertValue(converter, newValue, arrayComponentType).     } }
false;private;2;58;;private Object accessArrayElement(Object ctx, int idx) throws SpelEvaluationException {     Class<?> arrayComponentType = ctx.getClass().getComponentType().     if (arrayComponentType == Boolean.TYPE) {         boolean[] array = (boolean[]) ctx.         checkAccess(array.length, idx).         this.exitTypeDescriptor = "Z".         return array[idx].     } else if (arrayComponentType == Byte.TYPE) {         byte[] array = (byte[]) ctx.         checkAccess(array.length, idx).         this.exitTypeDescriptor = "B".         return array[idx].     } else if (arrayComponentType == Character.TYPE) {         char[] array = (char[]) ctx.         checkAccess(array.length, idx).         this.exitTypeDescriptor = "C".         return array[idx].     } else if (arrayComponentType == Double.TYPE) {         double[] array = (double[]) ctx.         checkAccess(array.length, idx).         this.exitTypeDescriptor = "D".         return array[idx].     } else if (arrayComponentType == Float.TYPE) {         float[] array = (float[]) ctx.         checkAccess(array.length, idx).         this.exitTypeDescriptor = "F".         return array[idx].     } else if (arrayComponentType == Integer.TYPE) {         int[] array = (int[]) ctx.         checkAccess(array.length, idx).         this.exitTypeDescriptor = "I".         return array[idx].     } else if (arrayComponentType == Long.TYPE) {         long[] array = (long[]) ctx.         checkAccess(array.length, idx).         this.exitTypeDescriptor = "J".         return array[idx].     } else if (arrayComponentType == Short.TYPE) {         short[] array = (short[]) ctx.         checkAccess(array.length, idx).         this.exitTypeDescriptor = "S".         return array[idx].     } else {         Object[] array = (Object[]) ctx.         checkAccess(array.length, idx).         Object retValue = array[idx].         this.exitTypeDescriptor = CodeFlow.toDescriptor(arrayComponentType).         return retValue.     } }
false;private;2;6;;private void checkAccess(int arrayLength, int index) throws SpelEvaluationException {     if (index > arrayLength) {         throw new SpelEvaluationException(getStartPosition(), SpelMessage.ARRAY_INDEX_OUT_OF_BOUNDS, arrayLength, index).     } }
false;private;3;9;;@SuppressWarnings("unchecked") private <T> T convertValue(TypeConverter converter, @Nullable Object value, Class<T> targetType) {     T result = (T) converter.convertValue(value, TypeDescriptor.forObject(value), TypeDescriptor.valueOf(targetType)).     if (result == null) {         throw new IllegalStateException("Null conversion result for index [" + value + "]").     }     return result. }
false;public;0;5;;@Override public TypedValue getValue() {     Object arrayElement = accessArrayElement(this.array, this.index).     return new TypedValue(arrayElement, this.typeDescriptor.elementTypeDescriptor(arrayElement)). }
false;public;1;6;;@Override public void setValue(@Nullable Object newValue) {     TypeDescriptor elementType = this.typeDescriptor.getElementTypeDescriptor().     Assert.state(elementType != null, "No element type").     setArrayElement(this.typeConverter, this.array, this.index, newValue, elementType.getType()). }
false;public;0;4;;@Override public boolean isWritable() {     return true. }
false;public;0;6;;@Override public TypedValue getValue() {     Object value = this.map.get(this.key).     exitTypeDescriptor = CodeFlow.toDescriptor(Object.class).     return new TypedValue(value, this.mapEntryDescriptor.getMapValueTypeDescriptor(value)). }
false;public;1;8;;@Override public void setValue(@Nullable Object newValue) {     if (this.mapEntryDescriptor.getMapValueTypeDescriptor() != null) {         newValue = this.typeConverter.convertValue(newValue, TypeDescriptor.forObject(newValue), this.mapEntryDescriptor.getMapValueTypeDescriptor()).     }     this.map.put(this.key, newValue). }
false;public;0;4;;@Override public boolean isWritable() {     return true. }
false;public;0;41;;@Override public TypedValue getValue() {     Class<?> targetObjectRuntimeClass = getObjectClass(this.targetObject).     try {         if (Indexer.this.cachedReadName != null && Indexer.this.cachedReadName.equals(this.name) && Indexer.this.cachedReadTargetType != null && Indexer.this.cachedReadTargetType.equals(targetObjectRuntimeClass)) {             // It is OK to use the cached accessor             PropertyAccessor accessor = Indexer.this.cachedReadAccessor.             Assert.state(accessor != null, "No cached read accessor").             return accessor.read(this.evaluationContext, this.targetObject, this.name).         }         List<PropertyAccessor> accessorsToTry = AstUtils.getPropertyAccessorsToTry(targetObjectRuntimeClass, this.evaluationContext.getPropertyAccessors()).         for (PropertyAccessor accessor : accessorsToTry) {             if (accessor.canRead(this.evaluationContext, this.targetObject, this.name)) {                 if (accessor instanceof ReflectivePropertyAccessor) {                     accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(this.evaluationContext, this.targetObject, this.name).                 }                 Indexer.this.cachedReadAccessor = accessor.                 Indexer.this.cachedReadName = this.name.                 Indexer.this.cachedReadTargetType = targetObjectRuntimeClass.                 if (accessor instanceof ReflectivePropertyAccessor.OptimalPropertyAccessor) {                     ReflectivePropertyAccessor.OptimalPropertyAccessor optimalAccessor = (ReflectivePropertyAccessor.OptimalPropertyAccessor) accessor.                     Member member = optimalAccessor.member.                     Indexer.this.exitTypeDescriptor = CodeFlow.toDescriptor(member instanceof Method ? ((Method) member).getReturnType() : ((Field) member).getType()).                 }                 return accessor.read(this.evaluationContext, this.targetObject, this.name).             }         }     } catch (AccessException ex) {         throw new SpelEvaluationException(getStartPosition(), ex, SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE, this.targetObjectTypeDescriptor.toString()).     }     throw new SpelEvaluationException(getStartPosition(), SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE, this.targetObjectTypeDescriptor.toString()). }
false;public;1;30;;@Override public void setValue(@Nullable Object newValue) {     Class<?> contextObjectClass = getObjectClass(this.targetObject).     try {         if (Indexer.this.cachedWriteName != null && Indexer.this.cachedWriteName.equals(this.name) && Indexer.this.cachedWriteTargetType != null && Indexer.this.cachedWriteTargetType.equals(contextObjectClass)) {             // It is OK to use the cached accessor             PropertyAccessor accessor = Indexer.this.cachedWriteAccessor.             Assert.state(accessor != null, "No cached write accessor").             accessor.write(this.evaluationContext, this.targetObject, this.name, newValue).             return.         }         List<PropertyAccessor> accessorsToTry = AstUtils.getPropertyAccessorsToTry(contextObjectClass, this.evaluationContext.getPropertyAccessors()).         for (PropertyAccessor accessor : accessorsToTry) {             if (accessor.canWrite(this.evaluationContext, this.targetObject, this.name)) {                 Indexer.this.cachedWriteName = this.name.                 Indexer.this.cachedWriteTargetType = contextObjectClass.                 Indexer.this.cachedWriteAccessor = accessor.                 accessor.write(this.evaluationContext, this.targetObject, this.name, newValue).                 return.             }         }     } catch (AccessException ex) {         throw new SpelEvaluationException(getStartPosition(), ex, SpelMessage.EXCEPTION_DURING_PROPERTY_WRITE, this.name, ex.getMessage()).     } }
false;public;0;4;;@Override public boolean isWritable() {     return true. }
false;public;0;17;;@Override public TypedValue getValue() {     growCollectionIfNecessary().     if (this.collection instanceof List) {         Object o = ((List) this.collection).get(this.index).         exitTypeDescriptor = CodeFlow.toDescriptor(Object.class).         return new TypedValue(o, this.collectionEntryDescriptor.elementTypeDescriptor(o)).     }     int pos = 0.     for (Object o : this.collection) {         if (pos == this.index) {             return new TypedValue(o, this.collectionEntryDescriptor.elementTypeDescriptor(o)).         }         pos++.     }     throw new IllegalStateException("Failed to find indexed element " + this.index + ": " + this.collection). }
false;public;1;16;;@Override public void setValue(@Nullable Object newValue) {     growCollectionIfNecessary().     if (this.collection instanceof List) {         List list = (List) this.collection.         if (this.collectionEntryDescriptor.getElementTypeDescriptor() != null) {             newValue = this.typeConverter.convertValue(newValue, TypeDescriptor.forObject(newValue), this.collectionEntryDescriptor.getElementTypeDescriptor()).         }         list.set(this.index, newValue).     } else {         throw new SpelEvaluationException(getStartPosition(), SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE, this.collectionEntryDescriptor.toString()).     } }
false;private;0;27;;private void growCollectionIfNecessary() {     if (this.index >= this.collection.size()) {         if (!this.growCollection) {             throw new SpelEvaluationException(getStartPosition(), SpelMessage.COLLECTION_INDEX_OUT_OF_BOUNDS, this.collection.size(), this.index).         }         if (this.index >= this.maximumSize) {             throw new SpelEvaluationException(getStartPosition(), SpelMessage.UNABLE_TO_GROW_COLLECTION).         }         if (this.collectionEntryDescriptor.getElementTypeDescriptor() == null) {             throw new SpelEvaluationException(getStartPosition(), SpelMessage.UNABLE_TO_GROW_COLLECTION_UNKNOWN_ELEMENT_TYPE).         }         TypeDescriptor elementType = this.collectionEntryDescriptor.getElementTypeDescriptor().         try {             Constructor<?> ctor = ReflectionUtils.accessibleConstructor(elementType.getType()).             int newElements = this.index - this.collection.size().             while (newElements >= 0) {                 this.collection.add(ctor.newInstance()).                 newElements--.             }         } catch (Throwable ex) {             throw new SpelEvaluationException(getStartPosition(), ex, SpelMessage.UNABLE_TO_GROW_COLLECTION).         }     } }
false;public;0;4;;@Override public boolean isWritable() {     return true. }
false;public;0;8;;@Override public TypedValue getValue() {     if (this.index >= this.target.length()) {         throw new SpelEvaluationException(getStartPosition(), SpelMessage.STRING_INDEX_OUT_OF_BOUNDS, this.target.length(), this.index).     }     return new TypedValue(String.valueOf(this.target.charAt(this.index))). }
false;public;1;5;;@Override public void setValue(@Nullable Object newValue) {     throw new SpelEvaluationException(getStartPosition(), SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE, this.typeDescriptor.toString()). }
false;public;0;4;;@Override public boolean isWritable() {     return true. }
