# id;timestamp;commentText;codeText;commentWords;codeWords
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1328020251;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1337251576;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1344037836;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1344539137;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1351041784;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1351600760;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1362408075;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1372363092;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1405514506;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1405696918;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1407348911;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1412630983;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1425759378;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1427757604;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1430935722;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1432857824;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1453421656;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1467730834;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1485810955;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1485860413;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1495868221;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1496259743;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1496837955;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1498780456;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1506097334;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1507112596;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1518380146;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1519295386;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1530174524;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1531945062;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> public InternalSpelExpressionParser(SpelParserConfiguration configuration);1548712256;Create a parser with some configured behavior._@param configuration custom configuration options;public InternalSpelExpressionParser(SpelParserConfiguration configuration) {_		this.configuration = configuration__	};create,a,parser,with,some,configured,behavior,param,configuration,custom,configuration,options;public,internal,spel,expression,parser,spel,parser,configuration,configuration,this,configuration,configuration
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1328020251;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startpos__		Token next = null__		do {_			nextToken()__			Token t = peekToken()__			if (t==null) {_				raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind!=TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		} while (next!=null && next.kind==TokenKind.COMMA)__		if (next==null) {_			raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,startpos,token,next,null,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1337251576;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startpos__		Token next = null__		do {_			nextToken()__			Token t = peekToken()__			if (t==null) {_				raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind!=TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		} while (next!=null && next.kind==TokenKind.COMMA)__		if (next==null) {_			raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,startpos,token,next,null,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1344037836;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startpos__		Token next = null__		do {_			nextToken()__			Token t = peekToken()__			if (t==null) {_				raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind!=TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		} while (next!=null && next.kind==TokenKind.COMMA)__		if (next==null) {_			raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,startpos,token,next,null,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1344539137;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startpos__		Token next = null__		do {_			nextToken()__			Token t = peekToken()__			if (t==null) {_				raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind!=TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		} while (next!=null && next.kind==TokenKind.COMMA)__		if (next==null) {_			raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,startpos,token,next,null,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1351041784;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startpos__		Token next = null__		do {_			nextToken()__			Token t = peekToken()__			if (t==null) {_				raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind!=TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		} while (next!=null && next.kind==TokenKind.COMMA)__		if (next==null) {_			raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,startpos,token,next,null,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1351600760;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startpos__		Token next = null__		do {_			nextToken()__			Token t = peekToken()__			if (t==null) {_				raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind!=TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		} while (next!=null && next.kind==TokenKind.COMMA)__		if (next==null) {_			raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,startpos,token,next,null,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1362408075;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startpos__		Token next = null__		do {_			nextToken()__			Token t = peekToken()__			if (t==null) {_				raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind!=TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		} while (next!=null && next.kind==TokenKind.COMMA)__		if (next==null) {_			raiseInternalException(pos,SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,startpos,token,next,null,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1372363092;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startpos__		Token next = null__		do {_			nextToken()__			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,startpos,token,next,null,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1405514506;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startpos__		Token next = null__		do {_			nextToken()__			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,startpos,token,next,null,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1405696918;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startpos__		Token next = null__		do {_			nextToken()__			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,startpos,token,next,null,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1407348911;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startpos__		Token next = null__		do {_			nextToken()__			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,startpos,token,next,null,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1412630983;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1425759378;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1427757604;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1430935722;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1432857824;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1453421656;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1467730834;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1485810955;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1485860413;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1495868221;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1496259743;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1496837955;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		int pos = peekToken().startPos__		Token next__		do {_			nextToken()_  _			Token t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,int,pos,peek,token,start,pos,token,next,do,next,token,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1498780456;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		Token t = peekToken()__		Assert.state(t != null, "Expected token")__		int pos = t.startPos__		Token next__		do {_			nextToken()_  _			t = peekToken()__			if (t == null) {_				raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			raiseInternalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,token,t,peek,token,assert,state,t,null,expected,token,int,pos,t,start,pos,token,next,do,next,token,t,peek,token,if,t,null,raise,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,raise,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1506097334;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		Token t = peekToken()__		Assert.state(t != null, "Expected token")__		int pos = t.startPos__		Token next__		do {_			nextToken()_  _			t = peekToken()__			if (t == null) {_				throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,token,t,peek,token,assert,state,t,null,expected,token,int,pos,t,start,pos,token,next,do,next,token,t,peek,token,if,t,null,throw,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,throw,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1507112596;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		Token t = peekToken()__		Assert.state(t != null, "Expected token")__		int pos = t.startPos__		Token next__		do {_			nextToken()_  _			t = peekToken()__			if (t == null) {_				throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,token,t,peek,token,assert,state,t,null,expected,token,int,pos,t,start,pos,token,next,do,next,token,t,peek,token,if,t,null,throw,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,throw,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1518380146;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		Token t = peekToken()__		Assert.state(t != null, "Expected token")__		int pos = t.startPos__		Token next__		do {_			nextToken()_  _			t = peekToken()__			if (t == null) {_				throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,token,t,peek,token,assert,state,t,null,expected,token,int,pos,t,start,pos,token,next,do,next,token,t,peek,token,if,t,null,throw,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,throw,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1519295386;Used for consuming arguments for either a method or a constructor call;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		Token t = peekToken()__		Assert.state(t != null, "Expected token")__		int pos = t.startPos__		Token next__		do {_			nextToken()_  _			t = peekToken()__			if (t == null) {_				throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,token,t,peek,token,assert,state,t,null,expected,token,int,pos,t,start,pos,token,next,do,next,token,t,peek,token,if,t,null,throw,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,throw,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1530174524;Used for consuming arguments for either a method or a constructor call.;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		Token t = peekToken()__		Assert.state(t != null, "Expected token")__		int pos = t.startPos__		Token next__		do {_			nextToken()_  _			t = peekToken()__			if (t == null) {_				throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,token,t,peek,token,assert,state,t,null,expected,token,int,pos,t,start,pos,token,next,do,next,token,t,peek,token,if,t,null,throw,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,throw,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1531945062;Used for consuming arguments for either a method or a constructor call.;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		Token t = peekToken()__		Assert.state(t != null, "Expected token")__		int pos = t.startPos__		Token next__		do {_			nextToken()_  _			t = peekToken()__			if (t == null) {_				throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,token,t,peek,token,assert,state,t,null,expected,token,int,pos,t,start,pos,token,next,do,next,token,t,peek,token,if,t,null,throw,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,throw,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private void consumeArguments(List<SpelNodeImpl> accumulatedArguments);1548712256;Used for consuming arguments for either a method or a constructor call.;private void consumeArguments(List<SpelNodeImpl> accumulatedArguments) {_		Token t = peekToken()__		Assert.state(t != null, "Expected token")__		int pos = t.startPos__		Token next__		do {_			nextToken()_  _			t = peekToken()__			if (t == null) {_				throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__			}_			if (t.kind != TokenKind.RPAREN) {_				accumulatedArguments.add(eatExpression())__			}_			next = peekToken()__		}_		while (next != null && next.kind == TokenKind.COMMA)___		if (next == null) {_			throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS)__		}_	};used,for,consuming,arguments,for,either,a,method,or,a,constructor,call;private,void,consume,arguments,list,spel,node,impl,accumulated,arguments,token,t,peek,token,assert,state,t,null,expected,token,int,pos,t,start,pos,token,next,do,next,token,t,peek,token,if,t,null,throw,internal,exception,pos,spel,message,if,t,kind,token,kind,rparen,accumulated,arguments,add,eat,expression,next,peek,token,while,next,null,next,kind,token,kind,comma,if,next,null,throw,internal,exception,pos,spel,message
InternalSpelExpressionParser -> private int toPos(Token t);1328020251;Compress the start and end of a token into a single int;private int toPos(Token t) {_		return (t.startpos<<16)+t.endpos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,startpos,16,t,endpos
InternalSpelExpressionParser -> private int toPos(Token t);1337251576;Compress the start and end of a token into a single int;private int toPos(Token t) {_		return (t.startpos<<16)+t.endpos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,startpos,16,t,endpos
InternalSpelExpressionParser -> private int toPos(Token t);1344037836;Compress the start and end of a token into a single int;private int toPos(Token t) {_		return (t.startpos<<16)+t.endpos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,startpos,16,t,endpos
InternalSpelExpressionParser -> private int toPos(Token t);1344539137;Compress the start and end of a token into a single int;private int toPos(Token t) {_		return (t.startpos<<16)+t.endpos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,startpos,16,t,endpos
InternalSpelExpressionParser -> private int toPos(Token t);1351041784;Compress the start and end of a token into a single int;private int toPos(Token t) {_		return (t.startpos<<16)+t.endpos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,startpos,16,t,endpos
InternalSpelExpressionParser -> private int toPos(Token t);1351600760;Compress the start and end of a token into a single int;private int toPos(Token t) {_		return (t.startpos<<16)+t.endpos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,startpos,16,t,endpos
InternalSpelExpressionParser -> private int toPos(Token t);1362408075;Compress the start and end of a token into a single int;private int toPos(Token t) {_		return (t.startpos<<16)+t.endpos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,startpos,16,t,endpos
InternalSpelExpressionParser -> private int toPos(Token t);1372363092;Compress the start and end of a token into a single int;private int toPos(Token t) {_		return (t.startpos<<16)+t.endpos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,startpos,16,t,endpos
InternalSpelExpressionParser -> private int toPos(Token t);1405514506;Compress the start and end of a token into a single int;private int toPos(Token t) {_		return (t.startpos<<16)+t.endpos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,startpos,16,t,endpos
InternalSpelExpressionParser -> private int toPos(Token t);1405696918;Compress the start and end of a token into a single int.;private int toPos(Token t) {_		return (t.startpos<<16) + t.endpos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,startpos,16,t,endpos
InternalSpelExpressionParser -> private int toPos(Token t);1407348911;Compress the start and end of a token into a single int.;private int toPos(Token t) {_		return (t.startpos<<16) + t.endpos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,startpos,16,t,endpos
InternalSpelExpressionParser -> private int toPos(Token t);1412630983;Compress the start and end of a token into a single int.;private int toPos(Token t) {_		return (t.startPos<<16) + t.endPos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,start,pos,16,t,end,pos
InternalSpelExpressionParser -> private int toPos(Token t);1425759378;Compress the start and end of a token into a single int.;private int toPos(Token t) {_		return (t.startPos<<16) + t.endPos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,start,pos,16,t,end,pos
InternalSpelExpressionParser -> private int toPos(Token t);1427757604;Compress the start and end of a token into a single int.;private int toPos(Token t) {_		return (t.startPos<<16) + t.endPos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,start,pos,16,t,end,pos
InternalSpelExpressionParser -> private int toPos(Token t);1430935722;Compress the start and end of a token into a single int.;private int toPos(Token t) {_		return (t.startPos<<16) + t.endPos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,start,pos,16,t,end,pos
InternalSpelExpressionParser -> private int toPos(Token t);1432857824;Compress the start and end of a token into a single int.;private int toPos(Token t) {_		return (t.startPos<<16) + t.endPos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,start,pos,16,t,end,pos
InternalSpelExpressionParser -> private int toPos(Token t);1453421656;Compress the start and end of a token into a single int.;private int toPos(Token t) {_		return (t.startPos<<16) + t.endPos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,start,pos,16,t,end,pos
InternalSpelExpressionParser -> private int toPos(Token t);1467730834;Compress the start and end of a token into a single int.;private int toPos(Token t) {_		return (t.startPos<<16) + t.endPos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,start,pos,16,t,end,pos
InternalSpelExpressionParser -> private int toPos(Token t);1485810955;Compress the start and end of a token into a single int.;private int toPos(Token t) {_		return (t.startPos<<16) + t.endPos__	};compress,the,start,and,end,of,a,token,into,a,single,int;private,int,to,pos,token,t,return,t,start,pos,16,t,end,pos
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1328020251;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		List<SpelNodeImpl> qualifiedIdPieces = new ArrayList<SpelNodeImpl>()__		Token startnode = eatToken(TokenKind.IDENTIFIER)__		qualifiedIdPieces.add(new Identifier(startnode.stringValue(),toPos(startnode)))__		while (peekToken(TokenKind.DOT,true)) {_			Token node = eatToken(TokenKind.IDENTIFIER)__			qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))_							_		}_		return new QualifiedIdentifier(toPos(startnode.startpos,qualifiedIdPieces.get(qualifiedIdPieces.size()-1).getEndPosition()),qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,list,spel,node,impl,qualified,id,pieces,new,array,list,spel,node,impl,token,startnode,eat,token,token,kind,identifier,qualified,id,pieces,add,new,identifier,startnode,string,value,to,pos,startnode,while,peek,token,token,kind,dot,true,token,node,eat,token,token,kind,identifier,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,return,new,qualified,identifier,to,pos,startnode,startpos,qualified,id,pieces,get,qualified,id,pieces,size,1,get,end,position,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1337251576;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		List<SpelNodeImpl> qualifiedIdPieces = new ArrayList<SpelNodeImpl>()__		Token startnode = eatToken(TokenKind.IDENTIFIER)__		qualifiedIdPieces.add(new Identifier(startnode.stringValue(),toPos(startnode)))__		while (peekToken(TokenKind.DOT,true)) {_			Token node = eatToken(TokenKind.IDENTIFIER)__			qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__		}_		return new QualifiedIdentifier(toPos(startnode.startpos,qualifiedIdPieces.get(qualifiedIdPieces.size()-1).getEndPosition()),qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,list,spel,node,impl,qualified,id,pieces,new,array,list,spel,node,impl,token,startnode,eat,token,token,kind,identifier,qualified,id,pieces,add,new,identifier,startnode,string,value,to,pos,startnode,while,peek,token,token,kind,dot,true,token,node,eat,token,token,kind,identifier,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,return,new,qualified,identifier,to,pos,startnode,startpos,qualified,id,pieces,get,qualified,id,pieces,size,1,get,end,position,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1344037836;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		List<SpelNodeImpl> qualifiedIdPieces = new ArrayList<SpelNodeImpl>()__		Token startnode = eatToken(TokenKind.IDENTIFIER)__		qualifiedIdPieces.add(new Identifier(startnode.stringValue(),toPos(startnode)))__		while (peekToken(TokenKind.DOT,true)) {_			Token node = eatToken(TokenKind.IDENTIFIER)__			qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__		}_		return new QualifiedIdentifier(toPos(startnode.startpos,qualifiedIdPieces.get(qualifiedIdPieces.size()-1).getEndPosition()),qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,list,spel,node,impl,qualified,id,pieces,new,array,list,spel,node,impl,token,startnode,eat,token,token,kind,identifier,qualified,id,pieces,add,new,identifier,startnode,string,value,to,pos,startnode,while,peek,token,token,kind,dot,true,token,node,eat,token,token,kind,identifier,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,return,new,qualified,identifier,to,pos,startnode,startpos,qualified,id,pieces,get,qualified,id,pieces,size,1,get,end,position,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1344539137;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		List<SpelNodeImpl> qualifiedIdPieces = new ArrayList<SpelNodeImpl>()__		Token startnode = eatToken(TokenKind.IDENTIFIER)__		qualifiedIdPieces.add(new Identifier(startnode.stringValue(),toPos(startnode)))__		while (peekToken(TokenKind.DOT,true)) {_			Token node = eatToken(TokenKind.IDENTIFIER)__			qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__		}_		return new QualifiedIdentifier(toPos(startnode.startpos,qualifiedIdPieces.get(qualifiedIdPieces.size()-1).getEndPosition()),qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,list,spel,node,impl,qualified,id,pieces,new,array,list,spel,node,impl,token,startnode,eat,token,token,kind,identifier,qualified,id,pieces,add,new,identifier,startnode,string,value,to,pos,startnode,while,peek,token,token,kind,dot,true,token,node,eat,token,token,kind,identifier,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,return,new,qualified,identifier,to,pos,startnode,startpos,qualified,id,pieces,get,qualified,id,pieces,size,1,get,end,position,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1351041784;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		List<SpelNodeImpl> qualifiedIdPieces = new ArrayList<SpelNodeImpl>()__		Token startnode = eatToken(TokenKind.IDENTIFIER)__		qualifiedIdPieces.add(new Identifier(startnode.stringValue(),toPos(startnode)))__		while (peekToken(TokenKind.DOT,true)) {_			Token node = eatToken(TokenKind.IDENTIFIER)__			qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__		}_		return new QualifiedIdentifier(toPos(startnode.startpos,qualifiedIdPieces.get(qualifiedIdPieces.size()-1).getEndPosition()),qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,list,spel,node,impl,qualified,id,pieces,new,array,list,spel,node,impl,token,startnode,eat,token,token,kind,identifier,qualified,id,pieces,add,new,identifier,startnode,string,value,to,pos,startnode,while,peek,token,token,kind,dot,true,token,node,eat,token,token,kind,identifier,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,return,new,qualified,identifier,to,pos,startnode,startpos,qualified,id,pieces,get,qualified,id,pieces,size,1,get,end,position,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1351600760;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if(node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if(qualifiedIdPieces.isEmpty()) {_			if(node == null) {_				raiseInternalException( expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startpos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,expression,string,length,spel,message,ood,raise,internal,exception,node,startpos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1362408075;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if(node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if(qualifiedIdPieces.isEmpty()) {_			if(node == null) {_				raiseInternalException( expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startpos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,expression,string,length,spel,message,ood,raise,internal,exception,node,startpos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1372363092;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if(node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if(qualifiedIdPieces.isEmpty()) {_			if(node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startpos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,startpos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1405514506;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if(node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if(qualifiedIdPieces.isEmpty()) {_			if(node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startpos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,startpos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1405696918;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startpos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,startpos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1407348911;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startpos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,startpos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1412630983;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1425759378;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1427757604;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1430935722;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1432857824;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1453421656;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,spel,node,impl,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1467730834;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1485810955;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(),toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1485860413;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(),_				qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos,_				qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1495868221;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(),_				qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos,_				qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1496259743;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(),_				qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos,_				qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1496837955;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(),_				qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos,_				qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1498780456;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				raiseInternalException( this.expressionString.length(), SpelMessage.OOD)__			}_			raiseInternalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(),_				qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos,_				qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,raise,internal,exception,this,expression,string,length,spel,message,ood,raise,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1506097334;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				throw internalException( this.expressionString.length(), SpelMessage.OOD)__			}_			throw internalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(),_				qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos,_				qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,throw,internal,exception,this,expression,string,length,spel,message,ood,throw,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1507112596;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				throw internalException( this.expressionString.length(), SpelMessage.OOD)__			}_			throw internalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(),_				qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos,_				qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,throw,internal,exception,this,expression,string,length,spel,message,ood,throw,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1518380146;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				throw internalException( this.expressionString.length(), SpelMessage.OOD)__			}_			throw internalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(),_				qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos,_				qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,throw,internal,exception,this,expression,string,length,spel,message,ood,throw,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,qualified,id,pieces,size
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1519295386;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				throw internalException( this.expressionString.length(), SpelMessage.OOD)__			}_			throw internalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[0]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,throw,internal,exception,this,expression,string,length,spel,message,ood,throw,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,0
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1530174524;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				throw internalException( this.expressionString.length(), SpelMessage.OOD)__			}_			throw internalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[0]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,linked,list,spel,node,impl,qualified,id,pieces,new,linked,list,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,throw,internal,exception,this,expression,string,length,spel,message,ood,throw,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,0
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1531945062;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		Deque<SpelNodeImpl> qualifiedIdPieces = new ArrayDeque<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), toPos(node)))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				throw internalException( this.expressionString.length(), SpelMessage.OOD)__			}_			throw internalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition())__		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[0]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,deque,spel,node,impl,qualified,id,pieces,new,array,deque,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,to,pos,node,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,throw,internal,exception,this,expression,string,length,spel,message,ood,throw,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,int,pos,to,pos,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,return,new,qualified,identifier,pos,qualified,id,pieces,to,array,new,spel,node,impl,0
InternalSpelExpressionParser -> private SpelNodeImpl eatPossiblyQualifiedId();1548712256;Eat an identifier, possibly qualified (meaning that it is dotted)._TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c);private SpelNodeImpl eatPossiblyQualifiedId() {_		Deque<SpelNodeImpl> qualifiedIdPieces = new ArrayDeque<>()__		Token node = peekToken()__		while (isValidQualifiedId(node)) {_			nextToken()__			if (node.kind != TokenKind.DOT) {_				qualifiedIdPieces.add(new Identifier(node.stringValue(), node.startPos, node.endPos))__			}_			node = peekToken()__		}_		if (qualifiedIdPieces.isEmpty()) {_			if (node == null) {_				throw internalException( this.expressionString.length(), SpelMessage.OOD)__			}_			throw internalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,_					"qualified ID", node.getKind().toString().toLowerCase())__		}_		return new QualifiedIdentifier(qualifiedIdPieces.getFirst().getStartPosition(),_				qualifiedIdPieces.getLast().getEndPosition(), qualifiedIdPieces.toArray(new SpelNodeImpl[0]))__	};eat,an,identifier,possibly,qualified,meaning,that,it,is,dotted,todo,andy,c,could,create,complete,identifiers,a,b,c,here,rather,than,a,sequence,of,them,a,b,c;private,spel,node,impl,eat,possibly,qualified,id,deque,spel,node,impl,qualified,id,pieces,new,array,deque,token,node,peek,token,while,is,valid,qualified,id,node,next,token,if,node,kind,token,kind,dot,qualified,id,pieces,add,new,identifier,node,string,value,node,start,pos,node,end,pos,node,peek,token,if,qualified,id,pieces,is,empty,if,node,null,throw,internal,exception,this,expression,string,length,spel,message,ood,throw,internal,exception,node,start,pos,spel,message,qualified,id,node,get,kind,to,string,to,lower,case,return,new,qualified,identifier,qualified,id,pieces,get,first,get,start,position,qualified,id,pieces,get,last,get,end,position,qualified,id,pieces,to,array,new,spel,node,impl,0
