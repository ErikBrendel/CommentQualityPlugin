# id;timestamp;commentText;codeText;commentWords;codeWords
ReflectiveConstructorResolver -> public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes) 			throws AccessException;1328020251;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor, according to the_registered type converter._</ol>;public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typename)__			Constructor[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor>() {_				public int compare(Constructor c1, Constructor c2) {_					int c1pl = c1.getParameterTypes().length__					int c2pl = c2.getParameterTypes().length__					return (new Integer(c1pl)).compareTo(c2pl)__				}_			})___			Constructor closeMatch = null__			int[] argsToConvert = null__			Constructor matchRequiringConversion = null___			for (Constructor ctor : ctors) {_				Class[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_						return new ReflectiveConstructorExecutor(ctor, null)__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_						closeMatch = ctor__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_						argsToConvert = matchInfo.argsRequiringConversion__						matchRequiringConversion = ctor__					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;public,constructor,executor,resolve,evaluation,context,context,string,typename,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,typename,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,constructor,close,match,null,int,args,to,convert,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,constructor,executor,ctor,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,close,match,ctor,else,if,match,info,kind,reflection,helper,args,match,kind,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,null,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes) 			throws AccessException;1357119239;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor, according to the_registered type converter._</ol>;public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typename)__			Constructor[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor>() {_				public int compare(Constructor c1, Constructor c2) {_					int c1pl = c1.getParameterTypes().length__					int c2pl = c2.getParameterTypes().length__					return (new Integer(c1pl)).compareTo(c2pl)__				}_			})___			Constructor closeMatch = null__			int[] argsToConvert = null__			Constructor matchRequiringConversion = null___			for (Constructor ctor : ctors) {_				Class[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_						return new ReflectiveConstructorExecutor(ctor, null)__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_						closeMatch = ctor__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_						argsToConvert = matchInfo.argsRequiringConversion__						matchRequiringConversion = ctor__					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;public,constructor,executor,resolve,evaluation,context,context,string,typename,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,typename,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,constructor,close,match,null,int,args,to,convert,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,constructor,executor,ctor,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,close,match,ctor,else,if,match,info,kind,reflection,helper,args,match,kind,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,null,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes) 			throws AccessException;1356735495;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor, according to the_registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typename)__			Constructor[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor>() {_				@Override_				public int compare(Constructor c1, Constructor c2) {_					int c1pl = c1.getParameterTypes().length__					int c2pl = c2.getParameterTypes().length__					return (new Integer(c1pl)).compareTo(c2pl)__				}_			})___			Constructor closeMatch = null__			int[] argsToConvert = null__			Constructor matchRequiringConversion = null___			for (Constructor ctor : ctors) {_				Class[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_						return new ReflectiveConstructorExecutor(ctor, null)__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_						closeMatch = ctor__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_						argsToConvert = matchInfo.argsRequiringConversion__						matchRequiringConversion = ctor__					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,typename,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,typename,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,constructor,close,match,null,int,args,to,convert,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,constructor,executor,ctor,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,close,match,ctor,else,if,match,info,kind,reflection,helper,args,match,kind,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,null,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes) 			throws AccessException;1368482696;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor, according to the_registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typename)__			Constructor[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor>() {_				@Override_				public int compare(Constructor c1, Constructor c2) {_					int c1pl = c1.getParameterTypes().length__					int c2pl = c2.getParameterTypes().length__					return (new Integer(c1pl)).compareTo(c2pl)__				}_			})___			Constructor closeMatch = null__			int[] argsToConvert = null__			Constructor matchRequiringConversion = null___			for (Constructor ctor : ctors) {_				Class[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_						return new ReflectiveConstructorExecutor(ctor, null)__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_						closeMatch = ctor__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_						argsToConvert = matchInfo.argsRequiringConversion__						matchRequiringConversion = ctor__					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,typename,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,typename,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,constructor,close,match,null,int,args,to,convert,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,constructor,executor,ctor,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,close,match,ctor,else,if,match,info,kind,reflection,helper,args,match,kind,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,null,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes) 			throws AccessException;1372363092;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the_constructor_<li>An in-exact match where the types we are looking for are subtypes of those_defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the_constructor, according to the registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typename)__			Constructor[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor>() {_				@Override_				public int compare(Constructor c1, Constructor c2) {_					int c1pl = c1.getParameterTypes().length__					int c2pl = c2.getParameterTypes().length__					return (new Integer(c1pl)).compareTo(c2pl)__				}_			})___			Constructor closeMatch = null__			int[] argsToConvert = null__			Constructor matchRequiringConversion = null___			for (Constructor ctor : ctors) {_				Class[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_						return new ReflectiveConstructorExecutor(ctor, null)__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_						closeMatch = ctor__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_						argsToConvert = matchInfo.argsRequiringConversion__						matchRequiringConversion = ctor__					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,typename,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,typename,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,constructor,close,match,null,int,args,to,convert,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,constructor,executor,ctor,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,close,match,ctor,else,if,match,info,kind,reflection,helper,args,match,kind,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,null,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes) 			throws AccessException;1385412762;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the_constructor_<li>An in-exact match where the types we are looking for are subtypes of those_defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the_constructor, according to the registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typename)__			Constructor<?>[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor<?>>() {_				@Override_				public int compare(Constructor<?> c1, Constructor<?> c2) {_					int c1pl = c1.getParameterTypes().length__					int c2pl = c2.getParameterTypes().length__					return (new Integer(c1pl)).compareTo(c2pl)__				}_			})___			Constructor<?> closeMatch = null__			int[] argsToConvert = null__			Constructor<?> matchRequiringConversion = null___			for (Constructor<?> ctor : ctors) {_				Class<?>[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_						return new ReflectiveConstructorExecutor(ctor, null)__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_						closeMatch = ctor__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_						argsToConvert = matchInfo.argsRequiringConversion__						matchRequiringConversion = ctor__					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,typename,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,typename,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,constructor,close,match,null,int,args,to,convert,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,constructor,executor,ctor,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,close,match,ctor,else,if,match,info,kind,reflection,helper,args,match,kind,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,null,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes) 			throws AccessException;1389789410;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the_constructor_<li>An in-exact match where the types we are looking for are subtypes of those_defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the_constructor, according to the registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typename)__			Constructor<?>[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor<?>>() {_				@Override_				public int compare(Constructor<?> c1, Constructor<?> c2) {_					int c1pl = c1.getParameterTypes().length__					int c2pl = c2.getParameterTypes().length__					return (new Integer(c1pl)).compareTo(c2pl)__				}_			})___			Constructor<?> closeMatch = null___			for (Constructor<?> ctor : ctors) {_				Class<?>[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= paramTypes.length - 1) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_						return new ReflectiveConstructorExecutor(ctor)__					}_					else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE ||_							matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_						closeMatch = ctor__					}_				}_			}__			return (closeMatch != null ? new ReflectiveConstructorExecutor(closeMatch) : null)__		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,typename,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,typename,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,constructor,close,match,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,constructor,executor,ctor,else,if,match,info,kind,reflection,helper,args,match,kind,close,match,info,kind,reflection,helper,args,match,kind,close,match,ctor,return,close,match,null,new,reflective,constructor,executor,close,match,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes) 			throws AccessException;1389796100;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor, according to the_registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typename)__			Constructor<?>[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor<?>>() {_				@Override_				public int compare(Constructor<?> c1, Constructor<?> c2) {_					int c1pl = c1.getParameterTypes().length__					int c2pl = c2.getParameterTypes().length__					return (new Integer(c1pl)).compareTo(c2pl)__				}_			})___			Constructor<?> closeMatch = null___			for (Constructor<?> ctor : ctors) {_				Class<?>[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= paramTypes.length - 1) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.isExactMatch()) {_						return new ReflectiveConstructorExecutor(ctor)__					}_					else if (matchInfo.isCloseMatch() || matchInfo.isMatchRequiringConversion()) {_						closeMatch = ctor__					}_				}_			}__			return (closeMatch != null ? new ReflectiveConstructorExecutor(closeMatch) : null)__		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,typename,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,typename,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,constructor,close,match,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,constructor,executor,ctor,else,if,match,info,is,close,match,match,info,is,match,requiring,conversion,close,match,ctor,return,close,match,null,new,reflective,constructor,executor,close,match,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes) 			throws AccessException;1390506741;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor, according to the_registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typename, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typename)__			Constructor<?>[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor<?>>() {_				@Override_				public int compare(Constructor<?> c1, Constructor<?> c2) {_					int c1pl = c1.getParameterTypes().length__					int c2pl = c2.getParameterTypes().length__					return (new Integer(c1pl)).compareTo(c2pl)__				}_			})___			Constructor<?> closeMatch = null__			Constructor<?> matchRequiringConversion = null___			for (Constructor<?> ctor : ctors) {_				Class<?>[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= paramTypes.length - 1) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.isExactMatch()) {_						return new ReflectiveConstructorExecutor(ctor)__					}_					else if (matchInfo.isCloseMatch()) {_						closeMatch = ctor__					}_					else if (matchInfo.isMatchRequiringConversion()) {_						matchRequiringConversion = ctor__					}_				}_			}__			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,typename,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,typename,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,constructor,close,match,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,constructor,executor,ctor,else,if,match,info,is,close,match,close,match,ctor,else,if,match,info,is,match,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typeName, List<TypeDescriptor> argumentTypes) 			throws AccessException;1414498942;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor, according to the_registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typeName, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typeName)__			Constructor<?>[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor<?>>() {_				@Override_				public int compare(Constructor<?> c1, Constructor<?> c2) {_					int c1pl = c1.getParameterTypes().length__					int c2pl = c2.getParameterTypes().length__					return (c1pl < c2pl ? -1 : (c1pl > c2pl ? 1 : 0))__				}_			})___			Constructor<?> closeMatch = null__			Constructor<?> matchRequiringConversion = null___			for (Constructor<?> ctor : ctors) {_				Class<?>[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= paramTypes.length - 1) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.isExactMatch()) {_						return new ReflectiveConstructorExecutor(ctor)__					}_					else if (matchInfo.isCloseMatch()) {_						closeMatch = ctor__					}_					else if (matchInfo.isMatchRequiringConversion()) {_						matchRequiringConversion = ctor__					}_				}_			}__			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,type,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,type,name,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,c1pl,c2pl,1,c1pl,c2pl,1,0,constructor,close,match,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,constructor,executor,ctor,else,if,match,info,is,close,match,close,match,ctor,else,if,match,info,is,match,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typeName, List<TypeDescriptor> argumentTypes) 			throws AccessException;1467730834;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor, according to the_registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typeName, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typeName)__			Constructor<?>[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor<?>>() {_				@Override_				public int compare(Constructor<?> c1, Constructor<?> c2) {_					int c1pl = c1.getParameterTypes().length__					int c2pl = c2.getParameterTypes().length__					return (c1pl < c2pl ? -1 : (c1pl > c2pl ? 1 : 0))__				}_			})___			Constructor<?> closeMatch = null__			Constructor<?> matchRequiringConversion = null___			for (Constructor<?> ctor : ctors) {_				Class<?>[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= paramTypes.length - 1) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.isExactMatch()) {_						return new ReflectiveConstructorExecutor(ctor)__					}_					else if (matchInfo.isCloseMatch()) {_						closeMatch = ctor__					}_					else if (matchInfo.isMatchRequiringConversion()) {_						matchRequiringConversion = ctor__					}_				}_			}__			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,type,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,type,name,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,c1pl,c2pl,1,c1pl,c2pl,1,0,constructor,close,match,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,constructor,executor,ctor,else,if,match,info,is,close,match,close,match,ctor,else,if,match,info,is,match,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typeName, List<TypeDescriptor> argumentTypes) 			throws AccessException;1467846264;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor, according to the_registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typeName, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typeName)__			Constructor<?>[] ctors = type.getConstructors()___			Arrays.sort(ctors, new Comparator<Constructor<?>>() {_				@Override_				public int compare(Constructor<?> c1, Constructor<?> c2) {_					int c1pl = c1.getParameterCount()__					int c2pl = c2.getParameterCount()__					return (c1pl < c2pl ? -1 : (c1pl > c2pl ? 1 : 0))__				}_			})___			Constructor<?> closeMatch = null__			Constructor<?> matchRequiringConversion = null___			for (Constructor<?> ctor : ctors) {_				Class<?>[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= paramTypes.length - 1) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.isExactMatch()) {_						return new ReflectiveConstructorExecutor(ctor)__					}_					else if (matchInfo.isCloseMatch()) {_						closeMatch = ctor__					}_					else if (matchInfo.isMatchRequiringConversion()) {_						matchRequiringConversion = ctor__					}_				}_			}__			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,type,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,type,name,constructor,ctors,type,get,constructors,arrays,sort,ctors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,int,c1pl,c1,get,parameter,count,int,c2pl,c2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0,constructor,close,match,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,constructor,executor,ctor,else,if,match,info,is,close,match,close,match,ctor,else,if,match,info,is,match,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typeName, List<TypeDescriptor> argumentTypes) 			throws AccessException;1496837955;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor, according to the_registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typeName, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typeName)__			Constructor<?>[] ctors = type.getConstructors()___			Arrays.sort(ctors, (c1, c2) -> {_				int c1pl = c1.getParameterCount()__				int c2pl = c2.getParameterCount()__				return (c1pl < c2pl ? -1 : (c1pl > c2pl ? 1 : 0))__			})___			Constructor<?> closeMatch = null__			Constructor<?> matchRequiringConversion = null___			for (Constructor<?> ctor : ctors) {_				Class<?>[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= paramTypes.length - 1) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.isExactMatch()) {_						return new ReflectiveConstructorExecutor(ctor)__					}_					else if (matchInfo.isCloseMatch()) {_						closeMatch = ctor__					}_					else if (matchInfo.isMatchRequiringConversion()) {_						matchRequiringConversion = ctor__					}_				}_			}__			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,type,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,type,name,constructor,ctors,type,get,constructors,arrays,sort,ctors,c1,c2,int,c1pl,c1,get,parameter,count,int,c2pl,c2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0,constructor,close,match,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,constructor,executor,ctor,else,if,match,info,is,close,match,close,match,ctor,else,if,match,info,is,match,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
ReflectiveConstructorResolver -> @Override 	public ConstructorExecutor resolve(EvaluationContext context, String typeName, List<TypeDescriptor> argumentTypes) 			throws AccessException;1497341594;Locate a constructor on the type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor, according to the_registered type converter._</ol>;@Override_	public ConstructorExecutor resolve(EvaluationContext context, String typeName, List<TypeDescriptor> argumentTypes)_			throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = context.getTypeLocator().findType(typeName)__			Constructor<?>[] ctors = type.getConstructors()___			Arrays.sort(ctors, (c1, c2) -> {_				int c1pl = c1.getParameterCount()__				int c2pl = c2.getParameterCount()__				return (c1pl < c2pl ? -1 : (c1pl > c2pl ? 1 : 0))__			})___			Constructor<?> closeMatch = null__			Constructor<?> matchRequiringConversion = null___			for (Constructor<?> ctor : ctors) {_				Class<?>[] paramTypes = ctor.getParameterTypes()__				List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__				for (int i = 0_ i < paramTypes.length_ i++) {_					paramDescriptors.add(new TypeDescriptor(new MethodParameter(ctor, i)))__				}_				ReflectionHelper.ArgumentsMatchInfo matchInfo = null__				if (ctor.isVarArgs() && argumentTypes.size() >= paramTypes.length - 1) {_					_					_					_					_					_					_					matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__				}_				else if (paramTypes.length == argumentTypes.size()) {_					_					matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__				}_				if (matchInfo != null) {_					if (matchInfo.isExactMatch()) {_						return new ReflectiveConstructorExecutor(ctor)__					}_					else if (matchInfo.isCloseMatch()) {_						closeMatch = ctor__					}_					else if (matchInfo.isMatchRequiringConversion()) {_						matchRequiringConversion = ctor__					}_				}_			}__			if (closeMatch != null) {_				return new ReflectiveConstructorExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				return new ReflectiveConstructorExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve constructor", ex)__		}_	};locate,a,constructor,on,the,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,constructor,executor,resolve,evaluation,context,context,string,type,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,context,get,type,locator,find,type,type,name,constructor,ctors,type,get,constructors,arrays,sort,ctors,c1,c2,int,c1pl,c1,get,parameter,count,int,c2pl,c2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0,constructor,close,match,null,constructor,match,requiring,conversion,null,for,constructor,ctor,ctors,class,param,types,ctor,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,ctor,i,reflection,helper,arguments,match,info,match,info,null,if,ctor,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,constructor,executor,ctor,else,if,match,info,is,close,match,close,match,ctor,else,if,match,info,is,match,requiring,conversion,match,requiring,conversion,ctor,if,close,match,null,return,new,reflective,constructor,executor,close,match,else,if,match,requiring,conversion,null,return,new,reflective,constructor,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,constructor,ex
