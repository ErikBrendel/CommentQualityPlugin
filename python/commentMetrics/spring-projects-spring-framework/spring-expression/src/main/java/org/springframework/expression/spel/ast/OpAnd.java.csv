commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {     if (!getBooleanValue(state, getLeftOperand())) {         // no need to evaluate right operand         return BooleanTypedValue.FALSE.     }     return BooleanTypedValue.forValue(getBooleanValue(state, getRightOperand())). }
false;private;2;11;;private boolean getBooleanValue(ExpressionState state, SpelNodeImpl operand) {     try {         Boolean value = operand.getValue(state, Boolean.class).         assertValueNotNull(value).         return value.     } catch (SpelEvaluationException ex) {         ex.setPosition(operand.getStartPosition()).         throw ex.     } }
false;private;1;5;;private void assertValueNotNull(@Nullable Boolean value) {     if (value == null) {         throw new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, "null", "boolean").     } }
false;public;0;8;;@Override public boolean isCompilable() {     SpelNodeImpl left = getLeftOperand().     SpelNodeImpl right = getRightOperand().     return (left.isCompilable() && right.isCompilable() && CodeFlow.isBooleanCompatible(left.exitTypeDescriptor) && CodeFlow.isBooleanCompatible(right.exitTypeDescriptor)). }
false;public;2;20;;@Override public void generateCode(MethodVisitor mv, CodeFlow cf) {     // Pseudo: if (!leftOperandValue) { result=false. } else { result=rightOperandValue. }     Label elseTarget = new Label().     Label endOfIf = new Label().     cf.enterCompilationScope().     getLeftOperand().generateCode(mv, cf).     cf.unboxBooleanIfNecessary(mv).     cf.exitCompilationScope().     mv.visitJumpInsn(IFNE, elseTarget).     // FALSE     mv.visitLdcInsn(0).     mv.visitJumpInsn(GOTO, endOfIf).     mv.visitLabel(elseTarget).     cf.enterCompilationScope().     getRightOperand().generateCode(mv, cf).     cf.unboxBooleanIfNecessary(mv).     cf.exitCompilationScope().     mv.visitLabel(endOfIf).     cf.pushDescriptor(this.exitTypeDescriptor). }
