commented;modifiers;parameterAmount;loc;comment;code
true;public;1;35;/**  * Check the first operand matches the regex specified as the second operand.  * @param state the expression state  * @return {@code true} if the first operand matches the regex specified as the  * second operand, otherwise {@code false}  * @throws EvaluationException if there is a problem evaluating the expression  * (e.g. the regex is invalid)  */ ;/**  * Check the first operand matches the regex specified as the second operand.  * @param state the expression state  * @return {@code true} if the first operand matches the regex specified as the  * second operand, otherwise {@code false}  * @throws EvaluationException if there is a problem evaluating the expression  * (e.g. the regex is invalid)  */ @Override public BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {     SpelNodeImpl leftOp = getLeftOperand().     SpelNodeImpl rightOp = getRightOperand().     String left = leftOp.getValue(state, String.class).     Object right = getRightOperand().getValue(state).     if (left == null) {         throw new SpelEvaluationException(leftOp.getStartPosition(), SpelMessage.INVALID_FIRST_OPERAND_FOR_MATCHES_OPERATOR, (Object) null).     }     if (!(right instanceof String)) {         throw new SpelEvaluationException(rightOp.getStartPosition(), SpelMessage.INVALID_SECOND_OPERAND_FOR_MATCHES_OPERATOR, right).     }     try {         String rightString = (String) right.         Pattern pattern = this.patternCache.get(rightString).         if (pattern == null) {             pattern = Pattern.compile(rightString).             this.patternCache.putIfAbsent(rightString, pattern).         }         Matcher matcher = pattern.matcher(new MatcherInput(left, new AccessCount())).         return BooleanTypedValue.forValue(matcher.matches()).     } catch (PatternSyntaxException ex) {         throw new SpelEvaluationException(rightOp.getStartPosition(), ex, SpelMessage.INVALID_PATTERN, right).     } catch (IllegalStateException ex) {         throw new SpelEvaluationException(rightOp.getStartPosition(), ex, SpelMessage.FLAWED_PATTERN, right).     } }
false;public;0;5;;public void check() throws IllegalStateException {     if (this.count++ > PATTERN_ACCESS_THRESHOLD) {         throw new IllegalStateException("Pattern access threshold exceeded").     } }
false;public;1;4;;public char charAt(int index) {     this.access.check().     return this.value.charAt(index). }
false;public;2;3;;public CharSequence subSequence(int start, int end) {     return new MatcherInput(this.value.subSequence(start, end), this.access). }
false;public;0;3;;public int length() {     return this.value.length(). }
false;public;0;4;;@Override public String toString() {     return this.value.toString(). }
