# id;timestamp;commentText;codeText;commentWords;codeWords
AstUtils -> public static List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors);1351041784;Determines the set of property resolvers that should be used to try and access a property on the specified target_type. The resolvers are considered to be in an ordered list, however in the returned list any that are exact_matches for the input target type (as opposed to 'general' resolvers that could work for any type) are placed at_the start of the list. In addition, there are specific resolvers that exactly name the class in question and_resolvers that name a specific class but it is a supertype of the class we have. These are put at the end of the_specific resolvers set and will be tried after exactly matching accessors but before generic accessors.__@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;public static List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors) {_		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) { _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					int pos = 0__					for (Class<?> clazz : targets) {_						if (clazz == targetType) { _							specificAccessors.add(pos++, resolver)__						}_						else if (clazz.isAssignableFrom(targetType)) { _							_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;public,static,list,property,accessor,get,property,accessors,to,try,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,int,pos,0,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,pos,resolver,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
AstUtils -> public static List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors);1356735495;Determines the set of property resolvers that should be used to try and access a property on the specified target_type. The resolvers are considered to be in an ordered list, however in the returned list any that are exact_matches for the input target type (as opposed to 'general' resolvers that could work for any type) are placed at_the start of the list. In addition, there are specific resolvers that exactly name the class in question and_resolvers that name a specific class but it is a supertype of the class we have. These are put at the end of the_specific resolvers set and will be tried after exactly matching accessors but before generic accessors.__@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;public static List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors) {_		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) { _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					int pos = 0__					for (Class<?> clazz : targets) {_						if (clazz == targetType) { _							specificAccessors.add(pos++, resolver)__						}_						else if (clazz.isAssignableFrom(targetType)) { _							_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;public,static,list,property,accessor,get,property,accessors,to,try,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,int,pos,0,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,pos,resolver,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
AstUtils -> public static List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors);1372363092;Determines the set of property resolvers that should be used to try and access a_property on the specified target type. The resolvers are considered to be in an_ordered list, however in the returned list any that are exact matches for the input_target type (as opposed to 'general' resolvers that could work for any type) are_placed at the start of the list. In addition, there are specific resolvers that_exactly name the class in question and resolvers that name a specific class but it_is a supertype of the class we have. These are put at the end of the specific_resolvers set and will be tried after exactly matching accessors but before generic_accessors._@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;public static List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors) {_		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) { _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					int pos = 0__					for (Class<?> clazz : targets) {_						if (clazz == targetType) { _							specificAccessors.add(pos++, resolver)__						}_						else if (clazz.isAssignableFrom(targetType)) { _							_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;public,static,list,property,accessor,get,property,accessors,to,try,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,int,pos,0,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,pos,resolver,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
AstUtils -> public static List<PropertyAccessor> getPropertyAccessorsToTry( 			Class<?> targetType, List<PropertyAccessor> propertyAccessors);1412630983;Determines the set of property resolvers that should be used to try and access a_property on the specified target type. The resolvers are considered to be in an_ordered list, however in the returned list any that are exact matches for the input_target type (as opposed to 'general' resolvers that could work for any type) are_placed at the start of the list. In addition, there are specific resolvers that_exactly name the class in question and resolvers that name a specific class but it_is a supertype of the class we have. These are put at the end of the specific resolvers_set and will be tried after exactly matching accessors but before generic accessors._@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;public static List<PropertyAccessor> getPropertyAccessorsToTry(_			Class<?> targetType, List<PropertyAccessor> propertyAccessors) {__		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {  _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					int pos = 0__					for (Class<?> clazz : targets) {_						if (clazz == targetType) {  _							specificAccessors.add(pos++, resolver)__						}_						else if (clazz.isAssignableFrom(targetType)) {  _							_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new LinkedList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;public,static,list,property,accessor,get,property,accessors,to,try,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,int,pos,0,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,pos,resolver,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,linked,list,property,accessor,resolvers,add,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
AstUtils -> public static List<PropertyAccessor> getPropertyAccessorsToTry( 			Class<?> targetType, List<PropertyAccessor> propertyAccessors);1467730834;Determines the set of property resolvers that should be used to try and access a_property on the specified target type. The resolvers are considered to be in an_ordered list, however in the returned list any that are exact matches for the input_target type (as opposed to 'general' resolvers that could work for any type) are_placed at the start of the list. In addition, there are specific resolvers that_exactly name the class in question and resolvers that name a specific class but it_is a supertype of the class we have. These are put at the end of the specific resolvers_set and will be tried after exactly matching accessors but before generic accessors._@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;public static List<PropertyAccessor> getPropertyAccessorsToTry(_			Class<?> targetType, List<PropertyAccessor> propertyAccessors) {__		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {  _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					int pos = 0__					for (Class<?> clazz : targets) {_						if (clazz == targetType) {  _							specificAccessors.add(pos++, resolver)__						}_						else if (clazz.isAssignableFrom(targetType)) {  _							_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new LinkedList<>()__		resolvers.addAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;public,static,list,property,accessor,get,property,accessors,to,try,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,int,pos,0,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,pos,resolver,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,linked,list,resolvers,add,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
AstUtils -> public static List<PropertyAccessor> getPropertyAccessorsToTry( 			@Nullable Class<?> targetType, List<PropertyAccessor> propertyAccessors);1496837955;Determines the set of property resolvers that should be used to try and access a_property on the specified target type. The resolvers are considered to be in an_ordered list, however in the returned list any that are exact matches for the input_target type (as opposed to 'general' resolvers that could work for any type) are_placed at the start of the list. In addition, there are specific resolvers that_exactly name the class in question and resolvers that name a specific class but it_is a supertype of the class we have. These are put at the end of the specific resolvers_set and will be tried after exactly matching accessors but before generic accessors._@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;public static List<PropertyAccessor> getPropertyAccessorsToTry(_			@Nullable Class<?> targetType, List<PropertyAccessor> propertyAccessors) {__		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {  _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					int pos = 0__					for (Class<?> clazz : targets) {_						if (clazz == targetType) {  _							specificAccessors.add(pos++, resolver)__						}_						else if (clazz.isAssignableFrom(targetType)) {  _							_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new LinkedList<>()__		resolvers.addAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;public,static,list,property,accessor,get,property,accessors,to,try,nullable,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,int,pos,0,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,pos,resolver,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,linked,list,resolvers,add,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
AstUtils -> public static List<PropertyAccessor> getPropertyAccessorsToTry( 			@Nullable Class<?> targetType, List<PropertyAccessor> propertyAccessors);1531945062;Determines the set of property resolvers that should be used to try and access a_property on the specified target type. The resolvers are considered to be in an_ordered list, however in the returned list any that are exact matches for the input_target type (as opposed to 'general' resolvers that could work for any type) are_placed at the start of the list. In addition, there are specific resolvers that_exactly name the class in question and resolvers that name a specific class but it_is a supertype of the class we have. These are put at the end of the specific resolvers_set and will be tried after exactly matching accessors but before generic accessors._@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;public static List<PropertyAccessor> getPropertyAccessorsToTry(_			@Nullable Class<?> targetType, List<PropertyAccessor> propertyAccessors) {__		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {  _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					int pos = 0__					for (Class<?> clazz : targets) {_						if (clazz == targetType) {  _							specificAccessors.add(pos++, resolver)__						}_						else if (clazz.isAssignableFrom(targetType)) {  _							_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>(specificAccessors.size() + generalAccessors.size())__		resolvers.addAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;public,static,list,property,accessor,get,property,accessors,to,try,nullable,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,int,pos,0,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,pos,resolver,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,specific,accessors,size,general,accessors,size,resolvers,add,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
