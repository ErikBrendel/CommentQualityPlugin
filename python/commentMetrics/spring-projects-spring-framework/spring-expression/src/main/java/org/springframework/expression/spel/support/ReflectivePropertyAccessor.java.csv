commented;modifiers;parameterAmount;loc;comment;code
true;public;0;5;/**  * Returns {@code null} which means this is a general purpose accessor.  */ ;/**  * Returns {@code null} which means this is a general purpose accessor.  */ @Override @Nullable public Class<?>[] getSpecificTargetClasses() {     return null. }
false;public;3;38;;@Override public boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {     if (target == null) {         return false.     }     Class<?> type = (target instanceof Class ? (Class<?>) target : target.getClass()).     if (type.isArray() && name.equals("length")) {         return true.     }     PropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class).     if (this.readerCache.containsKey(cacheKey)) {         return true.     }     Method method = findGetterForProperty(name, type, target).     if (method != null) {         // Treat it like a property...         // The readerCache will only contain gettable properties (let's not worry about setters for now).         Property property = new Property(type, method, null).         TypeDescriptor typeDescriptor = new TypeDescriptor(property).         this.readerCache.put(cacheKey, new InvokerPair(method, typeDescriptor)).         this.typeDescriptorCache.put(cacheKey, typeDescriptor).         return true.     } else {         Field field = findField(name, type, target).         if (field != null) {             TypeDescriptor typeDescriptor = new TypeDescriptor(field).             this.readerCache.put(cacheKey, new InvokerPair(field, typeDescriptor)).             this.typeDescriptorCache.put(cacheKey, typeDescriptor).             return true.         }     }     return false. }
false;public;3;66;;@Override public TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {     Assert.state(target != null, "Target must not be null").     Class<?> type = (target instanceof Class ? (Class<?>) target : target.getClass()).     if (type.isArray() && name.equals("length")) {         if (target instanceof Class) {             throw new AccessException("Cannot access length on array class itself").         }         return new TypedValue(Array.getLength(target)).     }     PropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class).     InvokerPair invoker = this.readerCache.get(cacheKey).     this.lastReadInvokerPair = invoker.     if (invoker == null || invoker.member instanceof Method) {         Method method = (Method) (invoker != null ? invoker.member : null).         if (method == null) {             method = findGetterForProperty(name, type, target).             if (method != null) {                 // Treat it like a property...                 // The readerCache will only contain gettable properties (let's not worry about setters for now).                 Property property = new Property(type, method, null).                 TypeDescriptor typeDescriptor = new TypeDescriptor(property).                 invoker = new InvokerPair(method, typeDescriptor).                 this.lastReadInvokerPair = invoker.                 this.readerCache.put(cacheKey, invoker).             }         }         if (method != null) {             try {                 ReflectionUtils.makeAccessible(method).                 Object value = method.invoke(target).                 return new TypedValue(value, invoker.typeDescriptor.narrow(value)).             } catch (Exception ex) {                 throw new AccessException("Unable to access property '" + name + "' through getter method", ex).             }         }     }     if (invoker == null || invoker.member instanceof Field) {         Field field = (Field) (invoker == null ? null : invoker.member).         if (field == null) {             field = findField(name, type, target).             if (field != null) {                 invoker = new InvokerPair(field, new TypeDescriptor(field)).                 this.lastReadInvokerPair = invoker.                 this.readerCache.put(cacheKey, invoker).             }         }         if (field != null) {             try {                 ReflectionUtils.makeAccessible(field).                 Object value = field.get(target).                 return new TypedValue(value, invoker.typeDescriptor.narrow(value)).             } catch (Exception ex) {                 throw new AccessException("Unable to access field '" + name + "'", ex).             }         }     }     throw new AccessException("Neither getter method nor field found for property '" + name + "'"). }
false;public;3;32;;@Override public boolean canWrite(EvaluationContext context, @Nullable Object target, String name) throws AccessException {     if (!this.allowWrite || target == null) {         return false.     }     Class<?> type = (target instanceof Class ? (Class<?>) target : target.getClass()).     PropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class).     if (this.writerCache.containsKey(cacheKey)) {         return true.     }     Method method = findSetterForProperty(name, type, target).     if (method != null) {         // Treat it like a property         Property property = new Property(type, null, method).         TypeDescriptor typeDescriptor = new TypeDescriptor(property).         this.writerCache.put(cacheKey, method).         this.typeDescriptorCache.put(cacheKey, typeDescriptor).         return true.     } else {         Field field = findField(name, type, target).         if (field != null) {             this.writerCache.put(cacheKey, field).             this.typeDescriptorCache.put(cacheKey, new TypeDescriptor(field)).             return true.         }     }     return false. }
false;public;4;71;;@Override public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) throws AccessException {     if (!this.allowWrite) {         throw new AccessException("PropertyAccessor for property '" + name + "' on target [" + target + "] does not allow write operations").     }     Assert.state(target != null, "Target must not be null").     Class<?> type = (target instanceof Class ? (Class<?>) target : target.getClass()).     Object possiblyConvertedNewValue = newValue.     TypeDescriptor typeDescriptor = getTypeDescriptor(context, target, name).     if (typeDescriptor != null) {         try {             possiblyConvertedNewValue = context.getTypeConverter().convertValue(newValue, TypeDescriptor.forObject(newValue), typeDescriptor).         } catch (EvaluationException evaluationException) {             throw new AccessException("Type conversion failure", evaluationException).         }     }     PropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class).     Member cachedMember = this.writerCache.get(cacheKey).     if (cachedMember == null || cachedMember instanceof Method) {         Method method = (Method) cachedMember.         if (method == null) {             method = findSetterForProperty(name, type, target).             if (method != null) {                 cachedMember = method.                 this.writerCache.put(cacheKey, cachedMember).             }         }         if (method != null) {             try {                 ReflectionUtils.makeAccessible(method).                 method.invoke(target, possiblyConvertedNewValue).                 return.             } catch (Exception ex) {                 throw new AccessException("Unable to access property '" + name + "' through setter method", ex).             }         }     }     if (cachedMember == null || cachedMember instanceof Field) {         Field field = (Field) cachedMember.         if (field == null) {             field = findField(name, type, target).             if (field != null) {                 cachedMember = field.                 this.writerCache.put(cacheKey, cachedMember).             }         }         if (field != null) {             try {                 ReflectionUtils.makeAccessible(field).                 field.set(target, possiblyConvertedNewValue).                 return.             } catch (Exception ex) {                 throw new AccessException("Unable to access field '" + name + "'", ex).             }         }     }     throw new AccessException("Neither setter method nor field found for property '" + name + "'"). }
true;public;0;6;/**  * Get the last read invoker pair.  * @deprecated as of 4.3.15 since it is not used within the framework anymore  */ ;/**  * Get the last read invoker pair.  * @deprecated as of 4.3.15 since it is not used within the framework anymore  */ @Deprecated @Nullable public Member getLastReadInvokerPair() {     InvokerPair lastReadInvoker = this.lastReadInvokerPair.     return (lastReadInvoker != null ? lastReadInvoker.member : null). }
false;private;3;22;;@Nullable private TypeDescriptor getTypeDescriptor(EvaluationContext context, Object target, String name) {     Class<?> type = (target instanceof Class ? (Class<?>) target : target.getClass()).     if (type.isArray() && name.equals("length")) {         return TypeDescriptor.valueOf(Integer.TYPE).     }     PropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class).     TypeDescriptor typeDescriptor = this.typeDescriptorCache.get(cacheKey).     if (typeDescriptor == null) {         // Attempt to populate the cache entry         try {             if (canRead(context, target, name) || canWrite(context, target, name)) {                 typeDescriptor = this.typeDescriptorCache.get(cacheKey).             }         } catch (AccessException ex) {         // Continue with null type descriptor         }     }     return typeDescriptor. }
false;private;3;8;;@Nullable private Method findGetterForProperty(String propertyName, Class<?> clazz, Object target) {     Method method = findGetterForProperty(propertyName, clazz, target instanceof Class).     if (method == null && target instanceof Class) {         method = findGetterForProperty(propertyName, target.getClass(), false).     }     return method. }
false;private;3;8;;@Nullable private Method findSetterForProperty(String propertyName, Class<?> clazz, Object target) {     Method method = findSetterForProperty(propertyName, clazz, target instanceof Class).     if (method == null && target instanceof Class) {         method = findSetterForProperty(propertyName, target.getClass(), false).     }     return method. }
true;protected;3;10;/**  * Find a getter method for the specified property.  */ ;/**  * Find a getter method for the specified property.  */ @Nullable protected Method findGetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic) {     Method method = findMethodForProperty(getPropertyMethodSuffixes(propertyName), "get", clazz, mustBeStatic, 0, ANY_TYPES).     if (method == null) {         method = findMethodForProperty(getPropertyMethodSuffixes(propertyName), "is", clazz, mustBeStatic, 0, BOOLEAN_TYPES).     }     return method. }
true;protected;3;5;/**  * Find a setter method for the specified property.  */ ;/**  * Find a setter method for the specified property.  */ @Nullable protected Method findSetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic) {     return findMethodForProperty(getPropertyMethodSuffixes(propertyName), "set", clazz, mustBeStatic, 1, ANY_TYPES). }
false;private;6;17;;@Nullable private Method findMethodForProperty(String[] methodSuffixes, String prefix, Class<?> clazz, boolean mustBeStatic, int numberOfParams, Set<Class<?>> requiredReturnTypes) {     Method[] methods = getSortedMethods(clazz).     for (String methodSuffix : methodSuffixes) {         for (Method method : methods) {             if (isCandidateForProperty(method, clazz) && method.getName().equals(prefix + methodSuffix) && method.getParameterCount() == numberOfParams && (!mustBeStatic || Modifier.isStatic(method.getModifiers())) && (requiredReturnTypes.isEmpty() || requiredReturnTypes.contains(method.getReturnType()))) {                 return method.             }         }     }     return null. }
true;protected;2;3;/**  * Determine whether the given {@code Method} is a candidate for property access  * on an instance of the given target class.  * <p>The default implementation considers any method as a candidate, even for  * non-user-declared properties on the {@link Object} base class.  * @param method the Method to evaluate  * @param targetClass the concrete target class that is being introspected  * @since 4.3.15  */ ;/**  * Determine whether the given {@code Method} is a candidate for property access  * on an instance of the given target class.  * <p>The default implementation considers any method as a candidate, even for  * non-user-declared properties on the {@link Object} base class.  * @param method the Method to evaluate  * @param targetClass the concrete target class that is being introspected  * @since 4.3.15  */ protected boolean isCandidateForProperty(Method method, Class<?> targetClass) {     return true. }
true;private;1;7;/**  * Return class methods ordered with non-bridge methods appearing higher.  */ ;/**  * Return class methods ordered with non-bridge methods appearing higher.  */ private Method[] getSortedMethods(Class<?> clazz) {     return this.sortedMethodsCache.computeIfAbsent(clazz, key -> {         Method[] methods = key.getMethods().         Arrays.sort(methods, (o1, o2) -> (o1.isBridge() == o2.isBridge() ? 0 : (o1.isBridge() ? 1 : -1))).         return methods.     }). }
true;protected;1;7;/**  * Return the method suffixes for a given property name. The default implementation  * uses JavaBean conventions with additional support for properties of the form 'xY'  * where the method 'getXY()' is used in preference to the JavaBean convention of  * 'getxY()'.  */ ;/**  * Return the method suffixes for a given property name. The default implementation  * uses JavaBean conventions with additional support for properties of the form 'xY'  * where the method 'getXY()' is used in preference to the JavaBean convention of  * 'getxY()'.  */ protected String[] getPropertyMethodSuffixes(String propertyName) {     String suffix = getPropertyMethodSuffix(propertyName).     if (suffix.length() > 0 && Character.isUpperCase(suffix.charAt(0))) {         return new String[] { suffix }.     }     return new String[] { suffix, StringUtils.capitalize(suffix) }. }
true;protected;1;6;/**  * Return the method suffix for a given property name. The default implementation  * uses JavaBean conventions.  */ ;/**  * Return the method suffix for a given property name. The default implementation  * uses JavaBean conventions.  */ protected String getPropertyMethodSuffix(String propertyName) {     if (propertyName.length() > 1 && Character.isUpperCase(propertyName.charAt(1))) {         return propertyName.     }     return StringUtils.capitalize(propertyName). }
false;private;3;8;;@Nullable private Field findField(String name, Class<?> clazz, Object target) {     Field field = findField(name, clazz, target instanceof Class).     if (field == null && target instanceof Class) {         field = findField(name, target.getClass(), false).     }     return field. }
true;protected;3;24;/**  * Find a field of a certain name on a specified class.  */ ;/**  * Find a field of a certain name on a specified class.  */ @Nullable protected Field findField(String name, Class<?> clazz, boolean mustBeStatic) {     Field[] fields = clazz.getFields().     for (Field field : fields) {         if (field.getName().equals(name) && (!mustBeStatic || Modifier.isStatic(field.getModifiers()))) {             return field.         }     }     // although it shouldn't be necessary - however, see SPR-10125.     if (clazz.getSuperclass() != null) {         Field field = findField(name, clazz.getSuperclass(), mustBeStatic).         if (field != null) {             return field.         }     }     for (Class<?> implementedInterface : clazz.getInterfaces()) {         Field field = findField(name, implementedInterface, mustBeStatic).         if (field != null) {             return field.         }     }     return null. }
true;public;3;45;/**  * Attempt to create an optimized property accessor tailored for a property of a  * particular name on a particular class. The general ReflectivePropertyAccessor  * will always work but is not optimal due to the need to lookup which reflective  * member (method/field) to use each time read() is called. This method will just  * return the ReflectivePropertyAccessor instance if it is unable to build a more  * optimal accessor.  * <p>Note: An optimal accessor is currently only usable for read attempts.  * Do not call this method if you need a read-write accessor.  * @see OptimalPropertyAccessor  */ ;/**  * Attempt to create an optimized property accessor tailored for a property of a  * particular name on a particular class. The general ReflectivePropertyAccessor  * will always work but is not optimal due to the need to lookup which reflective  * member (method/field) to use each time read() is called. This method will just  * return the ReflectivePropertyAccessor instance if it is unable to build a more  * optimal accessor.  * <p>Note: An optimal accessor is currently only usable for read attempts.  * Do not call this method if you need a read-write accessor.  * @see OptimalPropertyAccessor  */ public PropertyAccessor createOptimalAccessor(EvaluationContext context, @Nullable Object target, String name) {     // Don't be clever for arrays or a null target...     if (target == null) {         return this.     }     Class<?> clazz = (target instanceof Class ? (Class<?>) target : target.getClass()).     if (clazz.isArray()) {         return this.     }     PropertyCacheKey cacheKey = new PropertyCacheKey(clazz, name, target instanceof Class).     InvokerPair invocationTarget = this.readerCache.get(cacheKey).     if (invocationTarget == null || invocationTarget.member instanceof Method) {         Method method = (Method) (invocationTarget != null ? invocationTarget.member : null).         if (method == null) {             method = findGetterForProperty(name, clazz, target).             if (method != null) {                 invocationTarget = new InvokerPair(method, new TypeDescriptor(new MethodParameter(method, -1))).                 ReflectionUtils.makeAccessible(method).                 this.readerCache.put(cacheKey, invocationTarget).             }         }         if (method != null) {             return new OptimalPropertyAccessor(invocationTarget).         }     }     if (invocationTarget == null || invocationTarget.member instanceof Field) {         Field field = (invocationTarget != null ? (Field) invocationTarget.member : null).         if (field == null) {             field = findField(name, clazz, target instanceof Class).             if (field != null) {                 invocationTarget = new InvokerPair(field, new TypeDescriptor(field)).                 ReflectionUtils.makeAccessible(field).                 this.readerCache.put(cacheKey, invocationTarget).             }         }         if (field != null) {             return new OptimalPropertyAccessor(invocationTarget).         }     }     return this. }
false;public;1;12;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof PropertyCacheKey)) {         return false.     }     PropertyCacheKey otherKey = (PropertyCacheKey) other.     return (this.clazz == otherKey.clazz && this.property.equals(otherKey.property) && this.targetIsClass == otherKey.targetIsClass). }
false;public;0;4;;@Override public int hashCode() {     return (this.clazz.hashCode() * 29 + this.property.hashCode()). }
false;public;0;5;;@Override public String toString() {     return "CacheKey [clazz=" + this.clazz.getName() + ", property=" + this.property + ", " + this.property + ", targetIsClass=" + this.targetIsClass + "]". }
false;public;1;8;;@Override public int compareTo(PropertyCacheKey other) {     int result = this.clazz.getName().compareTo(other.clazz.getName()).     if (result == 0) {         result = this.property.compareTo(other.property).     }     return result. }
false;public;0;5;;@Override @Nullable public Class<?>[] getSpecificTargetClasses() {     throw new UnsupportedOperationException("Should not be called on an OptimalPropertyAccessor"). }
false;public;3;24;;@Override public boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {     if (target == null) {         return false.     }     Class<?> type = (target instanceof Class ? (Class<?>) target : target.getClass()).     if (type.isArray()) {         return false.     }     if (this.member instanceof Method) {         Method method = (Method) this.member.         String getterName = "get" + StringUtils.capitalize(name).         if (getterName.equals(method.getName())) {             return true.         }         getterName = "is" + StringUtils.capitalize(name).         return getterName.equals(method.getName()).     } else {         Field field = (Field) this.member.         return field.getName().equals(name).     } }
false;public;3;25;;@Override public TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {     if (this.member instanceof Method) {         Method method = (Method) this.member.         try {             ReflectionUtils.makeAccessible(method).             Object value = method.invoke(target).             return new TypedValue(value, this.typeDescriptor.narrow(value)).         } catch (Exception ex) {             throw new AccessException("Unable to access property '" + name + "' through getter method", ex).         }     } else {         Field field = (Field) this.member.         try {             ReflectionUtils.makeAccessible(field).             Object value = field.get(target).             return new TypedValue(value, this.typeDescriptor.narrow(value)).         } catch (Exception ex) {             throw new AccessException("Unable to access field '" + name + "'", ex).         }     } }
false;public;3;4;;@Override public boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {     throw new UnsupportedOperationException("Should not be called on an OptimalPropertyAccessor"). }
false;public;4;4;;@Override public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) {     throw new UnsupportedOperationException("Should not be called on an OptimalPropertyAccessor"). }
false;public;0;5;;@Override public boolean isCompilable() {     return (Modifier.isPublic(this.member.getModifiers()) && Modifier.isPublic(this.member.getDeclaringClass().getModifiers())). }
false;public;0;9;;@Override public Class<?> getPropertyType() {     if (this.member instanceof Method) {         return ((Method) this.member).getReturnType().     } else {         return ((Field) this.member).getType().     } }
false;public;3;31;;@Override public void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {     boolean isStatic = Modifier.isStatic(this.member.getModifiers()).     String descriptor = cf.lastDescriptor().     String classDesc = this.member.getDeclaringClass().getName().replace('.', '/').     if (!isStatic) {         if (descriptor == null) {             cf.loadTarget(mv).         }         if (descriptor == null || !classDesc.equals(descriptor.substring(1))) {             mv.visitTypeInsn(CHECKCAST, classDesc).         }     } else {         if (descriptor != null) {             // A static field/method call will not consume what is on the stack,             // it needs to be popped off.             mv.visitInsn(POP).         }     }     if (this.member instanceof Method) {         mv.visitMethodInsn((isStatic ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, this.member.getName(), CodeFlow.createSignatureDescriptor((Method) this.member), false).     } else {         mv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, this.member.getName(), CodeFlow.toJvmDescriptor(((Field) this.member).getType())).     } }
