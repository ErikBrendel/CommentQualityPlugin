# id;timestamp;commentText;codeText;commentWords;codeWords
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1328020251;Helper that parses given expression string using the configured parser. The expression string can contain any_number of expressions all contained in "${...}" markers. For instance: "foo${expr0}bar${expr1}". The static_pieces of text will also be returned as Expressions that just return that static piece of text. As a result,_evaluating all returned expressions and concatenating the results produces the complete evaluated string._Unwrapping is only done of the outermost delimiters found, so the string 'hello ${foo${abc}}' would break into_the pieces 'hello ' and 'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem._The parsing is aware of the structure of an embedded expression.  It assumes that parentheses '(',_square brackets '[' and curly brackets '}' must be in pairs within the expression unless they are within a_string literal and a string literal starts and terminates with a single quote '.__@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<Expression>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix,startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(createLiteralExpression(context,expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(prefix,suffix,expressionString,afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex, "No ending suffix '" + suffix +_							"' for expression starting at character " + prefixIndex + ": " +_							expressionString.substring(prefixIndex))__				}_				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex, "No expression defined within delimiter '" +_							prefix + suffix + "' at character " + prefixIndex)__				} else {_					String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__					expr = expr.trim()__					if (expr.length()==0) {_						throw new ParseException(expressionString, prefixIndex, "No expression defined within delimiter '" +_								prefix + suffix + "' at character " + prefixIndex)__					}_					expressions.add(doParseExpression(expr, context))__					startIdx = suffixIndex + suffix.length()__				}_			} else {_				_				expressions.add(createLiteralExpression(context,expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,expression,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,prefix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,else,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,length,0,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1355313310;Helper that parses given expression string using the configured parser. The expression string can contain any_number of expressions all contained in "${...}" markers. For instance: "foo${expr0}bar${expr1}". The static_pieces of text will also be returned as Expressions that just return that static piece of text. As a result,_evaluating all returned expressions and concatenating the results produces the complete evaluated string._Unwrapping is only done of the outermost delimiters found, so the string 'hello ${foo${abc}}' would break into_the pieces 'hello ' and 'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem._The parsing is aware of the structure of an embedded expression.  It assumes that parentheses '(',_square brackets '[' and curly brackets '}' must be in pairs within the expression unless they are within a_string literal and a string literal starts and terminates with a single quote '.__@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<Expression>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix,startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(createLiteralExpression(context,expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(prefix,suffix,expressionString,afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex, "No ending suffix '" + suffix +_							"' for expression starting at character " + prefixIndex + ": " +_							expressionString.substring(prefixIndex))__				}_				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex, "No expression defined within delimiter '" +_							prefix + suffix + "' at character " + prefixIndex)__				} else {_					String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__					expr = expr.trim()__					if (expr.length()==0) {_						throw new ParseException(expressionString, prefixIndex, "No expression defined within delimiter '" +_								prefix + suffix + "' at character " + prefixIndex)__					}_					expressions.add(doParseExpression(expr, context))__					startIdx = suffixIndex + suffix.length()__				}_			} else {_				_				expressions.add(createLiteralExpression(context,expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,expression,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,prefix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,else,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,length,0,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1356735495;Helper that parses given expression string using the configured parser. The expression string can contain any_number of expressions all contained in "${...}" markers. For instance: "foo${expr0}bar${expr1}". The static_pieces of text will also be returned as Expressions that just return that static piece of text. As a result,_evaluating all returned expressions and concatenating the results produces the complete evaluated string._Unwrapping is only done of the outermost delimiters found, so the string 'hello ${foo${abc}}' would break into_the pieces 'hello ' and 'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem._The parsing is aware of the structure of an embedded expression.  It assumes that parentheses '(',_square brackets '[' and curly brackets '}' must be in pairs within the expression unless they are within a_string literal and a string literal starts and terminates with a single quote '.__@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<Expression>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix,startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(createLiteralExpression(context,expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(prefix,suffix,expressionString,afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex, "No ending suffix '" + suffix +_							"' for expression starting at character " + prefixIndex + ": " +_							expressionString.substring(prefixIndex))__				}_				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex, "No expression defined within delimiter '" +_							prefix + suffix + "' at character " + prefixIndex)__				} else {_					String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__					expr = expr.trim()__					if (expr.length()==0) {_						throw new ParseException(expressionString, prefixIndex, "No expression defined within delimiter '" +_								prefix + suffix + "' at character " + prefixIndex)__					}_					expressions.add(doParseExpression(expr, context))__					startIdx = suffixIndex + suffix.length()__				}_			} else {_				_				expressions.add(createLiteralExpression(context,expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,expression,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,prefix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,else,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,length,0,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1357119239;Helper that parses given expression string using the configured parser. The expression string can contain any_number of expressions all contained in "${...}" markers. For instance: "foo${expr0}bar${expr1}". The static_pieces of text will also be returned as Expressions that just return that static piece of text. As a result,_evaluating all returned expressions and concatenating the results produces the complete evaluated string._Unwrapping is only done of the outermost delimiters found, so the string 'hello ${foo${abc}}' would break into_the pieces 'hello ' and 'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem._The parsing is aware of the structure of an embedded expression.  It assumes that parentheses '(',_square brackets '[' and curly brackets '}' must be in pairs within the expression unless they are within a_string literal and a string literal starts and terminates with a single quote '.__@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<Expression>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix,startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(createLiteralExpression(context,expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(prefix,suffix,expressionString,afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex, "No ending suffix '" + suffix +_							"' for expression starting at character " + prefixIndex + ": " +_							expressionString.substring(prefixIndex))__				}_				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex, "No expression defined within delimiter '" +_							prefix + suffix + "' at character " + prefixIndex)__				} else {_					String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__					expr = expr.trim()__					if (expr.length()==0) {_						throw new ParseException(expressionString, prefixIndex, "No expression defined within delimiter '" +_								prefix + suffix + "' at character " + prefixIndex)__					}_					expressions.add(doParseExpression(expr, context))__					startIdx = suffixIndex + suffix.length()__				}_			} else {_				_				expressions.add(createLiteralExpression(context,expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,expression,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,prefix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,else,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,length,0,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1368482696;Helper that parses given expression string using the configured parser. The expression string can contain any_number of expressions all contained in "${...}" markers. For instance: "foo${expr0}bar${expr1}". The static_pieces of text will also be returned as Expressions that just return that static piece of text. As a result,_evaluating all returned expressions and concatenating the results produces the complete evaluated string._Unwrapping is only done of the outermost delimiters found, so the string 'hello ${foo${abc}}' would break into_the pieces 'hello ' and 'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem._The parsing is aware of the structure of an embedded expression.  It assumes that parentheses '(',_square brackets '[' and curly brackets '}' must be in pairs within the expression unless they are within a_string literal and a string literal starts and terminates with a single quote '.__@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<Expression>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix,startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(createLiteralExpression(context,expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(prefix,suffix,expressionString,afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex, "No ending suffix '" + suffix +_							"' for expression starting at character " + prefixIndex + ": " +_							expressionString.substring(prefixIndex))__				}_				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex, "No expression defined within delimiter '" +_							prefix + suffix + "' at character " + prefixIndex)__				} else {_					String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__					expr = expr.trim()__					if (expr.length()==0) {_						throw new ParseException(expressionString, prefixIndex, "No expression defined within delimiter '" +_								prefix + suffix + "' at character " + prefixIndex)__					}_					expressions.add(doParseExpression(expr, context))__					startIdx = suffixIndex + suffix.length()__				}_			} else {_				_				expressions.add(createLiteralExpression(context,expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,expression,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,prefix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,else,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,length,0,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1487773939;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(new LiteralExpression(expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(suffix, expressionString, afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix + "' for expression starting at character " +_							prefixIndex + ": " + expressionString.substring(prefixIndex))__				}__				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}__				String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__				expr = expr.trim()___				if (expr.isEmpty()) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}__				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(new LiteralExpression(expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,new,literal,expression,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,is,empty,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,new,literal,expression,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1496259743;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(new LiteralExpression(expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(suffix, expressionString, afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix + "' for expression starting at character " +_							prefixIndex + ": " + expressionString.substring(prefixIndex))__				}__				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}__				String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__				expr = expr.trim()___				if (expr.isEmpty()) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}__				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(new LiteralExpression(expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,new,literal,expression,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,is,empty,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,new,literal,expression,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1496837955;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(new LiteralExpression(expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(suffix, expressionString, afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix + "' for expression starting at character " +_							prefixIndex + ": " + expressionString.substring(prefixIndex))__				}__				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}__				String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__				expr = expr.trim()___				if (expr.isEmpty()) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}__				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(new LiteralExpression(expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,new,literal,expression,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,is,empty,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,new,literal,expression,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1500984761;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(new LiteralExpression(expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(suffix, expressionString, afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix + "' for expression starting at character " +_							prefixIndex + ": " + expressionString.substring(prefixIndex))__				}__				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}__				String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__				expr = expr.trim()___				if (expr.isEmpty()) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}__				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(new LiteralExpression(expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,new,literal,expression,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,is,empty,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,new,literal,expression,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1506468851;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0___		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(new LiteralExpression(expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(suffix, expressionString, afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix + "' for expression starting at character " +_							prefixIndex + ": " + expressionString.substring(prefixIndex))__				}_				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}_				String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__				expr = expr.trim()__				if (expr.isEmpty()) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}_				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(new LiteralExpression(expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}__		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,new,literal,expression,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,is,empty,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,new,literal,expression,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1518380146;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0___		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(new LiteralExpression(expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(suffix, expressionString, afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix + "' for expression starting at character " +_							prefixIndex + ": " + expressionString.substring(prefixIndex))__				}_				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}_				String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__				expr = expr.trim()__				if (expr.isEmpty()) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}_				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(new LiteralExpression(expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}__		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,new,literal,expression,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,is,empty,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,new,literal,expression,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1519295386;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new LinkedList<>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0___		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(new LiteralExpression(expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(suffix, expressionString, afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix + "' for expression starting at character " +_							prefixIndex + ": " + expressionString.substring(prefixIndex))__				}_				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}_				String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__				expr = expr.trim()__				if (expr.isEmpty()) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}_				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(new LiteralExpression(expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}__		return expressions.toArray(new Expression[0])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,new,literal,expression,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,is,empty,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,new,literal,expression,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,0
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException;1531945062;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {_		List<Expression> expressions = new ArrayList<>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0___		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(new LiteralExpression(expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(suffix, expressionString, afterPrefixIndex)__				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix + "' for expression starting at character " +_							prefixIndex + ": " + expressionString.substring(prefixIndex))__				}_				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}_				String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex)__				expr = expr.trim()__				if (expr.isEmpty()) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix +_							"' at character " + prefixIndex)__				}_				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(new LiteralExpression(expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}__		return expressions.toArray(new Expression[0])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,array,list,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,new,literal,expression,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,is,empty,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,new,literal,expression,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,0
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString,int pos,String suffix);1328020251;Return true if the specified suffix can be found at the supplied position in the supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string_@return;private boolean isSuffixHere(String expressionString,int pos,String suffix) {_		int suffixPosition = 0__		for (int i=0_i<suffix.length() && pos<expressionString.length()_i++) {_			if (expressionString.charAt(pos++)!=suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition!=suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string,return;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString,int pos,String suffix);1355313310;Return true if the specified suffix can be found at the supplied position in the supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString,int pos,String suffix) {_		int suffixPosition = 0__		for (int i=0_i<suffix.length() && pos<expressionString.length()_i++) {_			if (expressionString.charAt(pos++)!=suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition!=suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString,int pos,String suffix);1356735495;Return true if the specified suffix can be found at the supplied position in the supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString,int pos,String suffix) {_		int suffixPosition = 0__		for (int i=0_i<suffix.length() && pos<expressionString.length()_i++) {_			if (expressionString.charAt(pos++)!=suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition!=suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString,int pos,String suffix);1357119239;Return true if the specified suffix can be found at the supplied position in the supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString,int pos,String suffix) {_		int suffixPosition = 0__		for (int i=0_i<suffix.length() && pos<expressionString.length()_i++) {_			if (expressionString.charAt(pos++)!=suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition!=suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString,int pos,String suffix);1368482696;Return true if the specified suffix can be found at the supplied position in the supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString,int pos,String suffix) {_		int suffixPosition = 0__		for (int i=0_i<suffix.length() && pos<expressionString.length()_i++) {_			if (expressionString.charAt(pos++)!=suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition!=suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) 			throws ParseException;1372363092;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context)_			throws ParseException {_		List<Expression> expressions = new LinkedList<Expression>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(createLiteralExpression(context,_							expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(prefix, suffix,_						expressionString, afterPrefixIndex)___				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix_									+ "' for expression starting at character "_									+ prefixIndex + ": "_									+ expressionString.substring(prefixIndex))__				}__				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix_									+ "' at character " + prefixIndex)__				}__				String expr = expressionString.substring(prefixIndex + prefix.length(),_						suffixIndex)__				expr = expr.trim()___				if (expr.length() == 0) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix_									+ "' at character " + prefixIndex)__				}__				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(createLiteralExpression(context,_						expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,expression,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,prefix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,length,0,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) 			throws ParseException;1391877039;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context)_			throws ParseException {_		List<Expression> expressions = new LinkedList<Expression>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(createLiteralExpression(context,_							expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(prefix, suffix,_						expressionString, afterPrefixIndex)___				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix_									+ "' for expression starting at character "_									+ prefixIndex + ": "_									+ expressionString.substring(prefixIndex))__				}__				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix_									+ "' at character " + prefixIndex)__				}__				String expr = expressionString.substring(prefixIndex + prefix.length(),_						suffixIndex)__				expr = expr.trim()___				if (expr.length() == 0) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix_									+ "' at character " + prefixIndex)__				}__				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(createLiteralExpression(context,_						expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,expression,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,prefix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,length,0,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) 			throws ParseException;1467730834;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context)_			throws ParseException {_		List<Expression> expressions = new LinkedList<>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(createLiteralExpression(context,_							expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(prefix, suffix,_						expressionString, afterPrefixIndex)___				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix_									+ "' for expression starting at character "_									+ prefixIndex + ": "_									+ expressionString.substring(prefixIndex))__				}__				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix_									+ "' at character " + prefixIndex)__				}__				String expr = expressionString.substring(prefixIndex + prefix.length(),_						suffixIndex)__				expr = expr.trim()___				if (expr.length() == 0) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix_									+ "' at character " + prefixIndex)__				}__				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(createLiteralExpression(context,_						expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,prefix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,length,0,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private Expression[] parseExpressions(String expressionString, ParserContext context) 			throws ParseException;1487760984;Helper that parses given expression string using the configured parser. The_expression string can contain any number of expressions all contained in "${...}"_markers. For instance: "foo${expr0}bar${expr1}". The static pieces of text will_also be returned as Expressions that just return that static piece of text. As a_result, evaluating all returned expressions and concatenating the results produces_the complete evaluated string. Unwrapping is only done of the outermost delimiters_found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and_'foo${abc}'. This means that expression languages that used ${..} as part of their_functionality are supported without any problem. The parsing is aware of the_structure of an embedded expression. It assumes that parentheses '(', square_brackets '[' and curly brackets '}' must be in pairs within the expression unless_they are within a string literal and a string literal starts and terminates with a_single quote '._@param expressionString the expression string_@return the parsed expressions_@throws ParseException when the expressions cannot be parsed;private Expression[] parseExpressions(String expressionString, ParserContext context)_			throws ParseException {_		List<Expression> expressions = new LinkedList<>()__		String prefix = context.getExpressionPrefix()__		String suffix = context.getExpressionSuffix()__		int startIdx = 0__		while (startIdx < expressionString.length()) {_			int prefixIndex = expressionString.indexOf(prefix, startIdx)__			if (prefixIndex >= startIdx) {_				_				if (prefixIndex > startIdx) {_					expressions.add(createLiteralExpression(context,_							expressionString.substring(startIdx, prefixIndex)))__				}_				int afterPrefixIndex = prefixIndex + prefix.length()__				int suffixIndex = skipToCorrectEndSuffix(prefix, suffix,_						expressionString, afterPrefixIndex)___				if (suffixIndex == -1) {_					throw new ParseException(expressionString, prefixIndex,_							"No ending suffix '" + suffix_									+ "' for expression starting at character "_									+ prefixIndex + ": "_									+ expressionString.substring(prefixIndex))__				}__				if (suffixIndex == afterPrefixIndex) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix_									+ "' at character " + prefixIndex)__				}__				String expr = expressionString.substring(prefixIndex + prefix.length(),_						suffixIndex)__				expr = expr.trim()___				if (expr.isEmpty()) {_					throw new ParseException(expressionString, prefixIndex,_							"No expression defined within delimiter '" + prefix + suffix_									+ "' at character " + prefixIndex)__				}__				expressions.add(doParseExpression(expr, context))__				startIdx = suffixIndex + suffix.length()__			}_			else {_				_				expressions.add(createLiteralExpression(context,_						expressionString.substring(startIdx)))__				startIdx = expressionString.length()__			}_		}_		return expressions.toArray(new Expression[expressions.size()])__	};helper,that,parses,given,expression,string,using,the,configured,parser,the,expression,string,can,contain,any,number,of,expressions,all,contained,in,markers,for,instance,foo,expr0,bar,expr1,the,static,pieces,of,text,will,also,be,returned,as,expressions,that,just,return,that,static,piece,of,text,as,a,result,evaluating,all,returned,expressions,and,concatenating,the,results,produces,the,complete,evaluated,string,unwrapping,is,only,done,of,the,outermost,delimiters,found,so,the,string,hello,foo,abc,would,break,into,the,pieces,hello,and,foo,abc,this,means,that,expression,languages,that,used,as,part,of,their,functionality,are,supported,without,any,problem,the,parsing,is,aware,of,the,structure,of,an,embedded,expression,it,assumes,that,parentheses,square,brackets,and,curly,brackets,must,be,in,pairs,within,the,expression,unless,they,are,within,a,string,literal,and,a,string,literal,starts,and,terminates,with,a,single,quote,param,expression,string,the,expression,string,return,the,parsed,expressions,throws,parse,exception,when,the,expressions,cannot,be,parsed;private,expression,parse,expressions,string,expression,string,parser,context,context,throws,parse,exception,list,expression,expressions,new,linked,list,string,prefix,context,get,expression,prefix,string,suffix,context,get,expression,suffix,int,start,idx,0,while,start,idx,expression,string,length,int,prefix,index,expression,string,index,of,prefix,start,idx,if,prefix,index,start,idx,if,prefix,index,start,idx,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,prefix,index,int,after,prefix,index,prefix,index,prefix,length,int,suffix,index,skip,to,correct,end,suffix,prefix,suffix,expression,string,after,prefix,index,if,suffix,index,1,throw,new,parse,exception,expression,string,prefix,index,no,ending,suffix,suffix,for,expression,starting,at,character,prefix,index,expression,string,substring,prefix,index,if,suffix,index,after,prefix,index,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,string,expr,expression,string,substring,prefix,index,prefix,length,suffix,index,expr,expr,trim,if,expr,is,empty,throw,new,parse,exception,expression,string,prefix,index,no,expression,defined,within,delimiter,prefix,suffix,at,character,prefix,index,expressions,add,do,parse,expression,expr,context,start,idx,suffix,index,suffix,length,else,expressions,add,create,literal,expression,context,expression,string,substring,start,idx,start,idx,expression,string,length,return,expressions,to,array,new,expression,expressions,size
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String prefix, String suffix, 			String expressionString, int afterPrefixIndex) throws ParseException;1372363092;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param prefix the prefix_@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String prefix, String suffix,_			String expressionString, int afterPrefixIndex) throws ParseException {_		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<Bracket>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '"_								+ ch + "' at position " + pos + " without an opening '"_								+ Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '"_								+ ch + "' at position " + pos_								+ " but most recent opening is '" + p.bracket_								+ "' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position "_										+ pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '"_					+ Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket_					+ "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,prefix,the,prefix,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,prefix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,bracket,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String prefix, String suffix, 			String expressionString, int afterPrefixIndex) throws ParseException;1391877039;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param prefix the prefix_@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String prefix, String suffix,_			String expressionString, int afterPrefixIndex) throws ParseException {_		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<Bracket>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '"_								+ ch + "' at position " + pos + " without an opening '"_								+ Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '"_								+ ch + "' at position " + pos_								+ " but most recent opening is '" + p.bracket_								+ "' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position "_										+ pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '"_					+ Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket_					+ "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,prefix,the,prefix,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,prefix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,bracket,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String prefix, String suffix, 			String expressionString, int afterPrefixIndex) throws ParseException;1467730834;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param prefix the prefix_@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String prefix, String suffix,_			String expressionString, int afterPrefixIndex) throws ParseException {_		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '"_								+ ch + "' at position " + pos + " without an opening '"_								+ Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '"_								+ ch + "' at position " + pos_								+ " but most recent opening is '" + p.bracket_								+ "' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position "_										+ pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '"_					+ Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket_					+ "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,prefix,the,prefix,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,prefix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String prefix, String suffix, 			String expressionString, int afterPrefixIndex) throws ParseException;1487760984;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param prefix the prefix_@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String prefix, String suffix,_			String expressionString, int afterPrefixIndex) throws ParseException {_		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '"_								+ ch + "' at position " + pos + " without an opening '"_								+ Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '"_								+ ch + "' at position " + pos_								+ " but most recent opening is '" + p.bracket_								+ "' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position "_										+ pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '"_					+ Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket_					+ "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,prefix,the,prefix,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,prefix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, ParserContext context) 			throws ParseException_;1328020251;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, ParserContext context) 			throws ParseException_;1355313310;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, ParserContext context) 			throws ParseException_;1356735495;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, ParserContext context) 			throws ParseException_;1357119239;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, ParserContext context) 			throws ParseException_;1368482696;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, ParserContext context) 			throws ParseException_;1487773939;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1372363092;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1391877039;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1467730834;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1487760984;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1487773939;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1496259743;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1496837955;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1500984761;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1506468851;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1518380146;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1519295386;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> private boolean isSuffixHere(String expressionString, int pos, String suffix);1531945062;Return true if the specified suffix can be found at the supplied position in the_supplied expression string._@param expressionString the expression string which may contain the suffix_@param pos the start position at which to check for the suffix_@param suffix the suffix string;private boolean isSuffixHere(String expressionString, int pos, String suffix) {_		int suffixPosition = 0__		for (int i = 0_ i < suffix.length() && pos < expressionString.length()_ i++) {_			if (expressionString.charAt(pos++) != suffix.charAt(suffixPosition++)) {_				return false__			}_		}_		if (suffixPosition != suffix.length()) {_			_			return false__		}_		return true__	};return,true,if,the,specified,suffix,can,be,found,at,the,supplied,position,in,the,supplied,expression,string,param,expression,string,the,expression,string,which,may,contain,the,suffix,param,pos,the,start,position,at,which,to,check,for,the,suffix,param,suffix,the,suffix,string;private,boolean,is,suffix,here,string,expression,string,int,pos,string,suffix,int,suffix,position,0,for,int,i,0,i,suffix,length,pos,expression,string,length,i,if,expression,string,char,at,pos,suffix,char,at,suffix,position,return,false,if,suffix,position,suffix,length,return,false,return,true
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context) 			throws ParseException_;1496259743;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,nullable,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context) 			throws ParseException_;1496837955;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,nullable,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context) 			throws ParseException_;1500984761;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,nullable,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context) 			throws ParseException_;1506468851;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,nullable,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context) 			throws ParseException_;1518380146;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,nullable,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context) 			throws ParseException_;1519295386;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,nullable,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context) 			throws ParseException_;1531945062;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context)_			throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,nullable,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String prefix, String suffix, String expressionString, int afterPrefixIndex) throws ParseException;1328020251;Copes with nesting, for example '${...${...}}' where the correct end for the first ${ is the final }.__@param prefix the prefix_@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String prefix, String suffix, String expressionString, int afterPrefixIndex) throws ParseException {_		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix,afterPrefixIndex)__		if (nextSuffix ==-1 ) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<Bracket>()__		while (pos<maxlen) {_			if (isSuffixHere(expressionString,pos,suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_			case '{': case '[': case '(':_				stack.push(new Bracket(ch,pos))__				break__			case '}':case ']':case ')':_				if (stack.isEmpty()) {_					throw new ParseException(expressionString, pos, "Found closing '"+ch+"' at position "+pos+" without an opening '"+Bracket.theOpenBracketFor(ch)+"'")__				}_				Bracket p = stack.pop()__				if (!p.compatibleWithCloseBracket(ch)) {_					throw new ParseException(expressionString, pos, "Found closing '"+ch+"' at position "+pos+" but most recent opening is '"+p.bracket+"' at position "+p.pos)__				}_				break__			case '\'':_			case '"':_				_				int endLiteral = expressionString.indexOf(ch,pos+1)__				if (endLiteral==-1) {_					throw new ParseException(expressionString, pos, "Found non terminating string literal starting at position "+pos)__				}_				pos=endLiteral__				break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '"+Bracket.theCloseBracketFor(p.bracket)+"' for '"+p.bracket+"' at position "+p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,prefix,the,prefix,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,prefix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,bracket,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String prefix, String suffix, String expressionString, int afterPrefixIndex) throws ParseException;1355313310;Copes with nesting, for example '${...${...}}' where the correct end for the first ${ is the final }.__@param prefix the prefix_@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String prefix, String suffix, String expressionString, int afterPrefixIndex) throws ParseException {_		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix,afterPrefixIndex)__		if (nextSuffix ==-1 ) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<Bracket>()__		while (pos<maxlen) {_			if (isSuffixHere(expressionString,pos,suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_			case '{': case '[': case '(':_				stack.push(new Bracket(ch,pos))__				break__			case '}':case ']':case ')':_				if (stack.isEmpty()) {_					throw new ParseException(expressionString, pos, "Found closing '"+ch+"' at position "+pos+" without an opening '"+Bracket.theOpenBracketFor(ch)+"'")__				}_				Bracket p = stack.pop()__				if (!p.compatibleWithCloseBracket(ch)) {_					throw new ParseException(expressionString, pos, "Found closing '"+ch+"' at position "+pos+" but most recent opening is '"+p.bracket+"' at position "+p.pos)__				}_				break__			case '\'':_			case '"':_				_				int endLiteral = expressionString.indexOf(ch,pos+1)__				if (endLiteral==-1) {_					throw new ParseException(expressionString, pos, "Found non terminating string literal starting at position "+pos)__				}_				pos=endLiteral__				break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '"+Bracket.theCloseBracketFor(p.bracket)+"' for '"+p.bracket+"' at position "+p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,prefix,the,prefix,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,prefix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,bracket,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String prefix, String suffix, String expressionString, int afterPrefixIndex) throws ParseException;1356735495;Copes with nesting, for example '${...${...}}' where the correct end for the first ${ is the final }.__@param prefix the prefix_@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String prefix, String suffix, String expressionString, int afterPrefixIndex) throws ParseException {_		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix,afterPrefixIndex)__		if (nextSuffix ==-1 ) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<Bracket>()__		while (pos<maxlen) {_			if (isSuffixHere(expressionString,pos,suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_			case '{': case '[': case '(':_				stack.push(new Bracket(ch,pos))__				break__			case '}':case ']':case ')':_				if (stack.isEmpty()) {_					throw new ParseException(expressionString, pos, "Found closing '"+ch+"' at position "+pos+" without an opening '"+Bracket.theOpenBracketFor(ch)+"'")__				}_				Bracket p = stack.pop()__				if (!p.compatibleWithCloseBracket(ch)) {_					throw new ParseException(expressionString, pos, "Found closing '"+ch+"' at position "+pos+" but most recent opening is '"+p.bracket+"' at position "+p.pos)__				}_				break__			case '\'':_			case '"':_				_				int endLiteral = expressionString.indexOf(ch,pos+1)__				if (endLiteral==-1) {_					throw new ParseException(expressionString, pos, "Found non terminating string literal starting at position "+pos)__				}_				pos=endLiteral__				break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '"+Bracket.theCloseBracketFor(p.bracket)+"' for '"+p.bracket+"' at position "+p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,prefix,the,prefix,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,prefix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,bracket,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String prefix, String suffix, String expressionString, int afterPrefixIndex) throws ParseException;1357119239;Copes with nesting, for example '${...${...}}' where the correct end for the first ${ is the final }.__@param prefix the prefix_@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String prefix, String suffix, String expressionString, int afterPrefixIndex) throws ParseException {_		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix,afterPrefixIndex)__		if (nextSuffix ==-1 ) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<Bracket>()__		while (pos<maxlen) {_			if (isSuffixHere(expressionString,pos,suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_			case '{': case '[': case '(':_				stack.push(new Bracket(ch,pos))__				break__			case '}':case ']':case ')':_				if (stack.isEmpty()) {_					throw new ParseException(expressionString, pos, "Found closing '"+ch+"' at position "+pos+" without an opening '"+Bracket.theOpenBracketFor(ch)+"'")__				}_				Bracket p = stack.pop()__				if (!p.compatibleWithCloseBracket(ch)) {_					throw new ParseException(expressionString, pos, "Found closing '"+ch+"' at position "+pos+" but most recent opening is '"+p.bracket+"' at position "+p.pos)__				}_				break__			case '\'':_			case '"':_				_				int endLiteral = expressionString.indexOf(ch,pos+1)__				if (endLiteral==-1) {_					throw new ParseException(expressionString, pos, "Found non terminating string literal starting at position "+pos)__				}_				pos=endLiteral__				break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '"+Bracket.theCloseBracketFor(p.bracket)+"' for '"+p.bracket+"' at position "+p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,prefix,the,prefix,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,prefix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,bracket,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String prefix, String suffix, String expressionString, int afterPrefixIndex) throws ParseException;1368482696;Copes with nesting, for example '${...${...}}' where the correct end for the first ${ is the final }.__@param prefix the prefix_@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String prefix, String suffix, String expressionString, int afterPrefixIndex) throws ParseException {_		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix,afterPrefixIndex)__		if (nextSuffix ==-1 ) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<Bracket>()__		while (pos<maxlen) {_			if (isSuffixHere(expressionString,pos,suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_			case '{': case '[': case '(':_				stack.push(new Bracket(ch,pos))__				break__			case '}':case ']':case ')':_				if (stack.isEmpty()) {_					throw new ParseException(expressionString, pos, "Found closing '"+ch+"' at position "+pos+" without an opening '"+Bracket.theOpenBracketFor(ch)+"'")__				}_				Bracket p = stack.pop()__				if (!p.compatibleWithCloseBracket(ch)) {_					throw new ParseException(expressionString, pos, "Found closing '"+ch+"' at position "+pos+" but most recent opening is '"+p.bracket+"' at position "+p.pos)__				}_				break__			case '\'':_			case '"':_				_				int endLiteral = expressionString.indexOf(ch,pos+1)__				if (endLiteral==-1) {_					throw new ParseException(expressionString, pos, "Found non terminating string literal starting at position "+pos)__				}_				pos=endLiteral__				break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '"+Bracket.theCloseBracketFor(p.bracket)+"' for '"+p.bracket+"' at position "+p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,prefix,the,prefix,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,prefix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,bracket,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex) 			throws ParseException;1487773939;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex)_			throws ParseException {__		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " without an opening '" +_								Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " but most recent opening is '" + p.bracket +_								"' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position " + pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '" +_					Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket + "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex) 			throws ParseException;1496259743;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex)_			throws ParseException {__		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " without an opening '" +_								Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " but most recent opening is '" + p.bracket +_								"' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position " + pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '" +_					Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket + "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex) 			throws ParseException;1496837955;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex)_			throws ParseException {__		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " without an opening '" +_								Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " but most recent opening is '" + p.bracket +_								"' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position " + pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '" +_					Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket + "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex) 			throws ParseException;1500984761;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex)_			throws ParseException {__		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " without an opening '" +_								Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " but most recent opening is '" + p.bracket +_								"' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position " + pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '" +_					Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket + "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex) 			throws ParseException;1506468851;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex)_			throws ParseException {__		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Stack<Bracket> stack = new Stack<>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " without an opening '" +_								Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " but most recent opening is '" + p.bracket +_								"' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position " + pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '" +_					Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket + "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,stack,bracket,stack,new,stack,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex) 			throws ParseException;1518380146;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex)_			throws ParseException {__		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Deque<Bracket> stack = new ArrayDeque<>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " without an opening '" +_								Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " but most recent opening is '" + p.bracket +_								"' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position " + pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '" +_					Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket + "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,deque,bracket,stack,new,array,deque,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex) 			throws ParseException;1519295386;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex)_			throws ParseException {__		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Deque<Bracket> stack = new ArrayDeque<>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " without an opening '" +_								Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " but most recent opening is '" + p.bracket +_								"' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position " + pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '" +_					Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket + "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,deque,bracket,stack,new,array,deque,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex) 			throws ParseException;1531945062;Copes with nesting, for example '${...${...}}' where the correct end for the first_${ is the final }._@param suffix the suffix_@param expressionString the expression string_@param afterPrefixIndex the most recently found prefix location for which the_matching end suffix is being sought_@return the position of the correct matching nextSuffix or -1 if none can be found;private int skipToCorrectEndSuffix(String suffix, String expressionString, int afterPrefixIndex)_			throws ParseException {__		_		_		_		int pos = afterPrefixIndex__		int maxlen = expressionString.length()__		int nextSuffix = expressionString.indexOf(suffix, afterPrefixIndex)__		if (nextSuffix == -1) {_			return -1_ _		}_		Deque<Bracket> stack = new ArrayDeque<>()__		while (pos < maxlen) {_			if (isSuffixHere(expressionString, pos, suffix) && stack.isEmpty()) {_				break__			}_			char ch = expressionString.charAt(pos)__			switch (ch) {_				case '{':_				case '[':_				case '(':_					stack.push(new Bracket(ch, pos))__					break__				case '}':_				case ']':_				case ')':_					if (stack.isEmpty()) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " without an opening '" +_								Bracket.theOpenBracketFor(ch) + "'")__					}_					Bracket p = stack.pop()__					if (!p.compatibleWithCloseBracket(ch)) {_						throw new ParseException(expressionString, pos, "Found closing '" + ch +_								"' at position " + pos + " but most recent opening is '" + p.bracket +_								"' at position " + p.pos)__					}_					break__				case '\'':_				case '"':_					_					int endLiteral = expressionString.indexOf(ch, pos + 1)__					if (endLiteral == -1) {_						throw new ParseException(expressionString, pos,_								"Found non terminating string literal starting at position " + pos)__					}_					pos = endLiteral__					break__			}_			pos++__		}_		if (!stack.isEmpty()) {_			Bracket p = stack.pop()__			throw new ParseException(expressionString, p.pos, "Missing closing '" +_					Bracket.theCloseBracketFor(p.bracket) + "' for '" + p.bracket + "' at position " + p.pos)__		}_		if (!isSuffixHere(expressionString, pos, suffix)) {_			return -1__		}_		return pos__	};copes,with,nesting,for,example,where,the,correct,end,for,the,first,is,the,final,param,suffix,the,suffix,param,expression,string,the,expression,string,param,after,prefix,index,the,most,recently,found,prefix,location,for,which,the,matching,end,suffix,is,being,sought,return,the,position,of,the,correct,matching,next,suffix,or,1,if,none,can,be,found;private,int,skip,to,correct,end,suffix,string,suffix,string,expression,string,int,after,prefix,index,throws,parse,exception,int,pos,after,prefix,index,int,maxlen,expression,string,length,int,next,suffix,expression,string,index,of,suffix,after,prefix,index,if,next,suffix,1,return,1,deque,bracket,stack,new,array,deque,while,pos,maxlen,if,is,suffix,here,expression,string,pos,suffix,stack,is,empty,break,char,ch,expression,string,char,at,pos,switch,ch,case,case,case,stack,push,new,bracket,ch,pos,break,case,case,case,if,stack,is,empty,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,without,an,opening,bracket,the,open,bracket,for,ch,bracket,p,stack,pop,if,p,compatible,with,close,bracket,ch,throw,new,parse,exception,expression,string,pos,found,closing,ch,at,position,pos,but,most,recent,opening,is,p,bracket,at,position,p,pos,break,case,case,int,end,literal,expression,string,index,of,ch,pos,1,if,end,literal,1,throw,new,parse,exception,expression,string,pos,found,non,terminating,string,literal,starting,at,position,pos,pos,end,literal,break,pos,if,stack,is,empty,bracket,p,stack,pop,throw,new,parse,exception,expression,string,p,pos,missing,closing,bracket,the,close,bracket,for,p,bracket,for,p,bracket,at,position,p,pos,if,is,suffix,here,expression,string,pos,suffix,return,1,return,pos
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, 			ParserContext context) throws ParseException_;1372363092;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString,_			ParserContext context) throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, 			ParserContext context) throws ParseException_;1391877039;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString,_			ParserContext context) throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, 			ParserContext context) throws ParseException_;1467730834;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString,_			ParserContext context) throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,parser,context,context,throws,parse,exception
TemplateAwareExpressionParser -> protected abstract Expression doParseExpression(String expressionString, 			ParserContext context) throws ParseException_;1487760984;Actually parse the expression string and return an Expression object._@param expressionString the raw expression string to parse_@param context a context for influencing this expression parsing routine (optional)_@return an evaluator for the parsed expression_@throws ParseException an exception occurred during parsing;protected abstract Expression doParseExpression(String expressionString,_			ParserContext context) throws ParseException_;actually,parse,the,expression,string,and,return,an,expression,object,param,expression,string,the,raw,expression,string,to,parse,param,context,a,context,for,influencing,this,expression,parsing,routine,optional,return,an,evaluator,for,the,parsed,expression,throws,parse,exception,an,exception,occurred,during,parsing;protected,abstract,expression,do,parse,expression,string,expression,string,parser,context,context,throws,parse,exception
