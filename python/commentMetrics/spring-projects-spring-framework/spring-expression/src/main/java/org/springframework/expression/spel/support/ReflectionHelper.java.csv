# id;timestamp;commentText;codeText;commentWords;codeWords
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, Object possibleArray);1414174302;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (type.isArray()) {_			Class<?> componentType = type.getComponentType()__			if (componentType.isPrimitive()) {_				if (componentType == Boolean.TYPE) {_					return value instanceof Boolean && _							((boolean[])possibleArray)[0] == (Boolean)value__				} _				else if (componentType == Double.TYPE) {_					return value instanceof Double && _							((double[])possibleArray)[0] == (Double)value__				} _				else if (componentType == Float.TYPE) {_					return value instanceof Float && _							((float[])possibleArray)[0] == (Float)value__				} _				else if (componentType == Integer.TYPE) {_					return value instanceof Integer && _							((int[])possibleArray)[0] == (Integer)value__				} _				else if (componentType == Long.TYPE) {_					return value instanceof Long && _							((long[])possibleArray)[0] == (Long)value__				} _				else if (componentType == Short.TYPE) {_					return value instanceof Short && _							((short[])possibleArray)[0] == (Short)value__				} _				else if (componentType == Character.TYPE) {_					return value instanceof Character && _							((char[])possibleArray)[0] == (Character)value__				} _				else if (componentType == Byte.TYPE) {_					return value instanceof Byte && _							((byte[])possibleArray)[0] == (Byte)value__				} _			}_			else {_				return ((Object[])possibleArray)[0] == value__			}_		}_		return false__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,class,component,type,type,get,component,type,if,component,type,is,primitive,if,component,type,boolean,type,return,value,instanceof,boolean,boolean,possible,array,0,boolean,value,else,if,component,type,double,type,return,value,instanceof,double,double,possible,array,0,double,value,else,if,component,type,float,type,return,value,instanceof,float,float,possible,array,0,float,value,else,if,component,type,integer,type,return,value,instanceof,integer,int,possible,array,0,integer,value,else,if,component,type,long,type,return,value,instanceof,long,long,possible,array,0,long,value,else,if,component,type,short,type,return,value,instanceof,short,short,possible,array,0,short,value,else,if,component,type,character,type,return,value,instanceof,character,char,possible,array,0,character,value,else,if,component,type,byte,type,return,value,instanceof,byte,byte,possible,array,0,byte,value,else,return,object,possible,array,0,value,return,false
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, Object possibleArray);1419274456;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, Object possibleArray);1425759378;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, Object possibleArray);1426108143;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, Object possibleArray);1449965678;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, Object possibleArray);1467844672;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, Object possibleArray);1473796721;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, Object possibleArray);1495868221;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, Object possibleArray);1496242568;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1405011154;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does not repackage the arguments_into a form suitable for the varargs invocation_@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = null__		boolean conversionOccurred = false__		if (method.isVarArgs()) {_			Class<?>[] paramTypes = method.getParameterTypes()__			varargsPosition = paramTypes.length - 1__			conversionOccurred = true__		}_		for (int argPos = 0_ argPos < arguments.length_ argPos++) {_			TypeDescriptor targetType__			if (varargsPosition != null && argPos >= varargsPosition) {_				MethodParameter methodParam = new MethodParameter(method, varargsPosition)__				targetType = TypeDescriptor.nested(methodParam, 1)__			}_			else {_				targetType = new TypeDescriptor(new MethodParameter(method, argPos))__			}_			try {_				Object argument = arguments[argPos]__				if (argument != null && !targetType.getObjectType().isInstance(argument)) {_					if (converter == null) {_						throw new SpelEvaluationException(_								SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType)__					}_					arguments[argPos] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[argPos])__				}_			}_			catch (EvaluationException ex) {_				_				if (ex instanceof SpelEvaluationException) {_					throw (SpelEvaluationException)ex__				}_				else {_					throw new SpelEvaluationException(ex,_							SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPos].getClass().getName(), targetType)__				}_			}_		}_		return conversionOccurred__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,null,boolean,conversion,occurred,false,if,method,is,var,args,class,param,types,method,get,parameter,types,varargs,position,param,types,length,1,conversion,occurred,true,for,int,arg,pos,0,arg,pos,arguments,length,arg,pos,type,descriptor,target,type,if,varargs,position,null,arg,pos,varargs,position,method,parameter,method,param,new,method,parameter,method,varargs,position,target,type,type,descriptor,nested,method,param,1,else,target,type,new,type,descriptor,new,method,parameter,method,arg,pos,try,object,argument,arguments,arg,pos,if,argument,null,target,type,get,object,type,is,instance,argument,if,converter,null,throw,new,spel,evaluation,exception,spel,message,argument,get,class,get,name,target,type,arguments,arg,pos,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,arg,pos,catch,evaluation,exception,ex,if,ex,instanceof,spel,evaluation,exception,throw,spel,evaluation,exception,ex,else,throw,new,spel,evaluation,exception,ex,spel,message,arguments,arg,pos,get,class,get,name,target,type,return,conversion,occurred
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1413486529;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does not repackage the arguments_into a form suitable for the varargs invocation_@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = null__		boolean conversionOccurred = false__		if (method.isVarArgs()) {_			Class<?>[] paramTypes = method.getParameterTypes()__			varargsPosition = paramTypes.length - 1__		}_		for (int argPos = 0_ argPos < arguments.length_ argPos++) {_			TypeDescriptor targetType__			if (varargsPosition != null && argPos >= varargsPosition) {_				MethodParameter methodParam = new MethodParameter(method, varargsPosition)__				targetType = TypeDescriptor.nested(methodParam, 1)__			}_			else {_				targetType = new TypeDescriptor(new MethodParameter(method, argPos))__			}_			try {_				Object argument = arguments[argPos]__				if (argument != null && !targetType.getObjectType().isInstance(argument)) {_					if (converter == null) {_						throw new SpelEvaluationException(_								SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType)__					}_					arguments[argPos] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[argPos])__				}_			}_			catch (EvaluationException ex) {_				_				if (ex instanceof SpelEvaluationException) {_					throw (SpelEvaluationException)ex__				}_				else {_					throw new SpelEvaluationException(ex,_							SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPos].getClass().getName(), targetType)__				}_			}_		}_		return conversionOccurred__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,null,boolean,conversion,occurred,false,if,method,is,var,args,class,param,types,method,get,parameter,types,varargs,position,param,types,length,1,for,int,arg,pos,0,arg,pos,arguments,length,arg,pos,type,descriptor,target,type,if,varargs,position,null,arg,pos,varargs,position,method,parameter,method,param,new,method,parameter,method,varargs,position,target,type,type,descriptor,nested,method,param,1,else,target,type,new,type,descriptor,new,method,parameter,method,arg,pos,try,object,argument,arguments,arg,pos,if,argument,null,target,type,get,object,type,is,instance,argument,if,converter,null,throw,new,spel,evaluation,exception,spel,message,argument,get,class,get,name,target,type,arguments,arg,pos,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,arg,pos,catch,evaluation,exception,ex,if,ex,instanceof,spel,evaluation,exception,throw,spel,evaluation,exception,ex,else,throw,new,spel,evaluation,exception,ex,spel,message,arguments,arg,pos,get,class,get,name,target,type,return,conversion,occurred
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1413907042;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does not repackage the arguments_into a form suitable for the varargs invocation_@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = null__		boolean conversionOccurred = false__		if (method.isVarArgs()) {_			Class<?>[] paramTypes = method.getParameterTypes()__			varargsPosition = paramTypes.length - 1__		}_		for (int argPos = 0_ argPos < arguments.length_ argPos++) {_			TypeDescriptor targetType__			if (varargsPosition != null && argPos >= varargsPosition) {_				MethodParameter methodParam = new MethodParameter(method, varargsPosition)__				targetType = TypeDescriptor.nested(methodParam, 1)__			}_			else {_				targetType = new TypeDescriptor(new MethodParameter(method, argPos))__			}_			try {_				Object argument = arguments[argPos]__				if (argument != null && !targetType.getObjectType().isInstance(argument)) {_					if (converter == null) {_						throw new SpelEvaluationException(_								SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType)__					}_					arguments[argPos] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[argPos])__				}_			}_			catch (EvaluationException ex) {_				_				if (ex instanceof SpelEvaluationException) {_					throw (SpelEvaluationException)ex__				}_				else {_					throw new SpelEvaluationException(ex,_							SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPos].getClass().getName(), targetType)__				}_			}_		}_		return conversionOccurred__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,null,boolean,conversion,occurred,false,if,method,is,var,args,class,param,types,method,get,parameter,types,varargs,position,param,types,length,1,for,int,arg,pos,0,arg,pos,arguments,length,arg,pos,type,descriptor,target,type,if,varargs,position,null,arg,pos,varargs,position,method,parameter,method,param,new,method,parameter,method,varargs,position,target,type,type,descriptor,nested,method,param,1,else,target,type,new,type,descriptor,new,method,parameter,method,arg,pos,try,object,argument,arguments,arg,pos,if,argument,null,target,type,get,object,type,is,instance,argument,if,converter,null,throw,new,spel,evaluation,exception,spel,message,argument,get,class,get,name,target,type,arguments,arg,pos,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,arg,pos,catch,evaluation,exception,ex,if,ex,instanceof,spel,evaluation,exception,throw,spel,evaluation,exception,ex,else,throw,new,spel,evaluation,exception,ex,spel,message,arguments,arg,pos,get,class,get,name,target,type,return,conversion,occurred
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1414174302;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = method.isVarArgs() ? method.getParameterTypes().length-1:null__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,types,length,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1419274456;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = method.isVarArgs() ? method.getParameterTypes().length-1:null__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,types,length,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1425759378;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = method.isVarArgs() ? method.getParameterTypes().length-1:null__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,types,length,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1426108143;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = method.isVarArgs() ? method.getParameterTypes().length-1:null__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,types,length,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1495868221;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to_take into account that a type may be transformed into a different type by the_converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1496242568;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to_take into account that a type may be transformed into a different type by the_converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1496837955;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to_take into account that a type may be transformed into a different type by the_converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(!CollectionUtils.isEmpty(expectedArgTypes),_				"Expected arguments must at least include one array (the varargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			TypeDescriptor elementDesc = varargsDesc.getElementTypeDescriptor()__			Assert.state(elementDesc != null, "No element type")__			Class<?> varargsParamType = elementDesc.getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,collection,utils,is,empty,expected,arg,types,expected,arguments,must,at,least,include,one,array,the,varargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,type,descriptor,element,desc,varargs,desc,get,element,type,descriptor,assert,state,element,desc,null,no,element,type,class,varargs,param,type,element,desc,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1522307598;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to_take into account that a type may be transformed into a different type by the_converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(!CollectionUtils.isEmpty(expectedArgTypes),_				"Expected arguments must at least include one array (the varargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			TypeDescriptor elementDesc = varargsDesc.getElementTypeDescriptor()__			Assert.state(elementDesc != null, "No element type")__			Class<?> varargsParamType = elementDesc.getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,collection,utils,is,empty,expected,arg,types,expected,arguments,must,at,least,include,one,array,the,varargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,type,descriptor,element,desc,varargs,desc,get,element,type,descriptor,assert,state,element,desc,null,no,element,type,class,varargs,param,type,element,desc,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1525211306;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to_take into account that a type may be transformed into a different type by the_converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(!CollectionUtils.isEmpty(expectedArgTypes),_				"Expected arguments must at least include one array (the varargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			TypeDescriptor elementDesc = varargsDesc.getElementTypeDescriptor()__			Assert.state(elementDesc != null, "No element type")__			Class<?> varargsParamType = elementDesc.getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,collection,utils,is,empty,expected,arg,types,expected,arguments,must,at,least,include,one,array,the,varargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,type,descriptor,element,desc,varargs,desc,get,element,type,descriptor,assert,state,element,desc,null,no,element,type,class,varargs,param,type,element,desc,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1530174524;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to_take into account that a type may be transformed into a different type by the_converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(!CollectionUtils.isEmpty(expectedArgTypes),_				"Expected arguments must at least include one array (the varargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			TypeDescriptor elementDesc = varargsDesc.getElementTypeDescriptor()__			Assert.state(elementDesc != null, "No element type")__			Class<?> varargsParamType = elementDesc.getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,collection,utils,is,empty,expected,arg,types,expected,arguments,must,at,least,include,one,array,the,varargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,type,descriptor,element,desc,varargs,desc,get,element,type,descriptor,assert,state,element,desc,null,no,element,type,class,varargs,param,type,element,desc,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1495868221;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to take_into account that a type may be transformed into a different type by the converter._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1496242568;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to take_into account that a type may be transformed into a different type by the converter._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1496837955;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to take_into account that a type may be transformed into a different type by the converter._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			_			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else if (!expectedArg.equals(suppliedArg))  {_				if (suppliedArg.isAssignableTo(expectedArg)) {_					if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_						match = ArgumentsMatchKind.CLOSE__					}_				}_				else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_					match = ArgumentsMatchKind.REQUIRES_CONVERSION__				}_				else {_					match = null__				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1522307598;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to take_into account that a type may be transformed into a different type by the converter._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			_			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else if (!expectedArg.equals(suppliedArg))  {_				if (suppliedArg.isAssignableTo(expectedArg)) {_					if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_						match = ArgumentsMatchKind.CLOSE__					}_				}_				else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_					match = ArgumentsMatchKind.REQUIRES_CONVERSION__				}_				else {_					match = null__				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1525211306;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to take_into account that a type may be transformed into a different type by the converter._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			_			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else if (!expectedArg.equals(suppliedArg))  {_				if (suppliedArg.isAssignableTo(expectedArg)) {_					if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_						match = ArgumentsMatchKind.CLOSE__					}_				}_				else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_					match = ArgumentsMatchKind.REQUIRES_CONVERSION__				}_				else {_					match = null__				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> @Nullable 	static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1530174524;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to take_into account that a type may be transformed into a different type by the converter._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;@Nullable_	static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			_			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else if (!expectedArg.equals(suppliedArg))  {_				if (suppliedArg.isAssignableTo(expectedArg)) {_					if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_						match = ArgumentsMatchKind.CLOSE__					}_				}_				else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_					match = ArgumentsMatchKind.REQUIRES_CONVERSION__				}_				else {_					match = null__				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;nullable,static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			Integer varargsPosition) throws EvaluationException;1405011154;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_@return true if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			Integer varargsPosition) throws EvaluationException {_		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				arguments[varargsPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[varargsPosition])__			}_			else {_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,return,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,arguments,varargs,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,varargs,position,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			Integer varargsPosition) throws EvaluationException;1413486529;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_@return true if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			Integer varargsPosition) throws EvaluationException {_		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				arguments[varargsPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[varargsPosition])__			}_			else {_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,return,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,arguments,varargs,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,varargs,position,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			Integer varargsPosition) throws EvaluationException;1413907042;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_@return true if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			Integer varargsPosition) throws EvaluationException {_		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				if (!looksLikeSimpleArrayPackaging(sourceType, targetType)) {_					conversionOccurred |= (argument != arguments[varargsPosition])__				}_			}_			else {_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,return,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,looks,like,simple,array,packaging,source,type,target,type,conversion,occurred,argument,arguments,varargs,position,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			Integer varargsPosition) throws EvaluationException;1414174302;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any (null if not varargs)_@return true if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			Integer varargsPosition) throws EvaluationException {_		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] && _					!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,null,if,not,varargs,return,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			Integer varargsPosition) throws EvaluationException;1419274456;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any (null if not varargs)_@return true if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			Integer varargsPosition) throws EvaluationException {_		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] &&_						!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,null,if,not,varargs,return,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			Integer varargsPosition) throws EvaluationException;1425759378;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any (null if not varargs)_@return true if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			Integer varargsPosition) throws EvaluationException {_		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] &&_						!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,null,if,not,varargs,return,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			Integer varargsPosition) throws EvaluationException;1426108143;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_({@code null} if not varargs)_@return {@code true} if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			Integer varargsPosition) throws EvaluationException {__		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] &&_						!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,code,null,if,not,varargs,return,code,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			Integer varargsPosition) throws EvaluationException;1449965678;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_({@code null} if not varargs)_@return {@code true} if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			Integer varargsPosition) throws EvaluationException {__		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] &&_						!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,code,null,if,not,varargs,return,code,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			Integer varargsPosition) throws EvaluationException;1389789410;Takes an input set of argument values and, following the positions specified in the int array,_it converts them to the types specified as the required parameter types. The arguments are_converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_@throws EvaluationException if a problem occurs during conversion;static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			Integer varargsPosition) throws EvaluationException {__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_		}_		else {_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				arguments[varargsPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_			else {_				TypeDescriptor targetType = TypeDescriptor.nested(methodParam, 1)__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_		}_	};takes,an,input,set,of,argument,values,and,following,the,positions,specified,in,the,int,array,it,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,void,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,integer,varargs,position,throws,evaluation,exception,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,arguments,varargs,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,type,descriptor,target,type,type,descriptor,nested,method,param,1,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type
ReflectionHelper -> static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			Integer varargsPosition) throws EvaluationException;1389796100;Takes an input set of argument values and, following the positions specified in the int array,_it converts them to the types specified as the required parameter types. The arguments are_converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_@throws EvaluationException if a problem occurs during conversion;static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			Integer varargsPosition) throws EvaluationException {__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_		}_		else {_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				arguments[varargsPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_			else {_				TypeDescriptor targetType = TypeDescriptor.nested(methodParam, 1)__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_		}_	};takes,an,input,set,of,argument,values,and,following,the,positions,specified,in,the,int,array,it,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,void,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,integer,varargs,position,throws,evaluation,exception,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,arguments,varargs,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,type,descriptor,target,type,type,descriptor,nested,method,param,1,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type
ReflectionHelper -> static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			Integer varargsPosition) throws EvaluationException;1394055372;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_@throws EvaluationException if a problem occurs during conversion;static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			Integer varargsPosition) throws EvaluationException {__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_		}_		else {_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				arguments[varargsPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_			else {_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_		}_	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,void,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,integer,varargs,position,throws,evaluation,exception,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,arguments,varargs,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable, 			@Nullable Integer varargsPosition) throws EvaluationException;1496242568;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param executable the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_({@code null} if not varargs)_@return {@code true} if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,_			@Nullable Integer varargsPosition) throws EvaluationException {__		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] &&_						!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,executable,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,code,null,if,not,varargs,return,code,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,executable,executable,nullable,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,executable,executable,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable, 			@Nullable Integer varargsPosition) throws EvaluationException;1496837955;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param executable the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_({@code null} if not varargs)_@return {@code true} if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,_			@Nullable Integer varargsPosition) throws EvaluationException {__		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] &&_						!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				Assert.state(targetType != null, "No element type")__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,executable,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,code,null,if,not,varargs,return,code,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,executable,executable,nullable,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,executable,executable,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,assert,state,target,type,null,no,element,type,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable, 			@Nullable Integer varargsPosition) throws EvaluationException;1522307598;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param executable the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_({@code null} if not varargs)_@return {@code true} if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,_			@Nullable Integer varargsPosition) throws EvaluationException {__		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] &&_						!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				Assert.state(targetType != null, "No element type")__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,executable,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,code,null,if,not,varargs,return,code,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,executable,executable,nullable,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,executable,executable,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,assert,state,target,type,null,no,element,type,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable, 			@Nullable Integer varargsPosition) throws EvaluationException;1525211306;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param executable the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_({@code null} if not varargs)_@return {@code true} if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,_			@Nullable Integer varargsPosition) throws EvaluationException {__		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] &&_						!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				Assert.state(targetType != null, "No element type")__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,executable,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,code,null,if,not,varargs,return,code,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,executable,executable,nullable,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,executable,executable,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,assert,state,target,type,null,no,element,type,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable, 			@Nullable Integer varargsPosition) throws EvaluationException;1530174524;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param executable the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_({@code null} if not varargs)_@return {@code true} if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,_			@Nullable Integer varargsPosition) throws EvaluationException {__		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] &&_						!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				Assert.state(targetType != null, "No element type")__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,executable,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,code,null,if,not,varargs,return,code,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,executable,executable,nullable,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,executable,executable,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,assert,state,target,type,null,no,element,type,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1385412762;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] == null ? null : args[argumentCount - 1].getClass())) {_			int arraySize = 0_ _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			for (int i = 0_ i < newArgs.length - 1_ i++) {_				newArgs[i] = args[i]__			}_			_			_			Class<?> componentType = requiredParameterTypes[parameterCount-1].getComponentType()__			if (componentType.isPrimitive()) {_				if (componentType == Integer.TYPE) {_					int[] repackagedArguments = (int[]) Array.newInstance(componentType,_							arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Integer) args[parameterCount + i - 1]).intValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Float.TYPE) {_					float[] repackagedArguments = (float[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Float) args[parameterCount + i - 1]).floatValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Double.TYPE) {_					double[] repackagedArguments = (double[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Double) args[parameterCount + i - 1]).doubleValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Short.TYPE) {_					short[] repackagedArguments = (short[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Short) args[parameterCount + i - 1]).shortValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Character.TYPE) {_					char[] repackagedArguments = (char[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Character) args[parameterCount + i - 1]).charValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Byte.TYPE) {_					byte[] repackagedArguments = (byte[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Byte) args[parameterCount + i - 1]).byteValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Boolean.TYPE) {_					boolean[] repackagedArguments = (boolean[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Boolean) args[parameterCount + i - 1]).booleanValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Long.TYPE) {_					long[] repackagedArguments = (long[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Long) args[parameterCount + i - 1]).longValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_			}_			else {_				Object[] repackagedArguments = (Object[]) Array.newInstance(_						componentType, arraySize)__				_				for (int i = 0_ i < arraySize_ i++) {_					repackagedArguments[i] = args[parameterCount + i - 1]__				}_				newArgs[newArgs.length - 1] = repackagedArguments__			}_			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,null,args,argument,count,1,get,class,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,for,int,i,0,i,new,args,length,1,i,new,args,i,args,i,class,component,type,required,parameter,types,parameter,count,1,get,component,type,if,component,type,is,primitive,if,component,type,integer,type,int,repackaged,arguments,int,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,integer,args,parameter,count,i,1,int,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,float,type,float,repackaged,arguments,float,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,float,args,parameter,count,i,1,float,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,double,type,double,repackaged,arguments,double,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,double,args,parameter,count,i,1,double,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,short,type,short,repackaged,arguments,short,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,short,args,parameter,count,i,1,short,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,character,type,char,repackaged,arguments,char,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,character,args,parameter,count,i,1,char,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,byte,type,byte,repackaged,arguments,byte,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,byte,args,parameter,count,i,1,byte,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,boolean,type,boolean,repackaged,arguments,boolean,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,boolean,args,parameter,count,i,1,boolean,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,long,type,long,repackaged,arguments,long,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,long,args,parameter,count,i,1,long,value,new,args,new,args,length,1,repackaged,arguments,else,object,repackaged,arguments,object,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,args,parameter,count,i,1,new,args,new,args,length,1,repackaged,arguments,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1389789410;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] == null ? null : args[argumentCount - 1].getClass())) {_			int arraySize = 0_ _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount-1].getComponentType()__			if (componentType.isPrimitive()) {_				if (componentType == Integer.TYPE) {_					int[] repackagedArguments = (int[]) Array.newInstance(componentType,_							arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Integer) args[parameterCount + i - 1]).intValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Float.TYPE) {_					float[] repackagedArguments = (float[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Float) args[parameterCount + i - 1]).floatValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Double.TYPE) {_					double[] repackagedArguments = (double[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Double) args[parameterCount + i - 1]).doubleValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Short.TYPE) {_					short[] repackagedArguments = (short[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Short) args[parameterCount + i - 1]).shortValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Character.TYPE) {_					char[] repackagedArguments = (char[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Character) args[parameterCount + i - 1]).charValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Byte.TYPE) {_					byte[] repackagedArguments = (byte[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Byte) args[parameterCount + i - 1]).byteValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Boolean.TYPE) {_					boolean[] repackagedArguments = (boolean[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Boolean) args[parameterCount + i - 1]).booleanValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Long.TYPE) {_					long[] repackagedArguments = (long[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Long) args[parameterCount + i - 1]).longValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_			}_			else {_				Object[] repackagedArguments = (Object[]) Array.newInstance(componentType, arraySize)__				_				System.arraycopy(args, parameterCount - 1, repackagedArguments, 0, arraySize)__				newArgs[newArgs.length - 1] = repackagedArguments__			}_			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,null,args,argument,count,1,get,class,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,if,component,type,is,primitive,if,component,type,integer,type,int,repackaged,arguments,int,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,integer,args,parameter,count,i,1,int,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,float,type,float,repackaged,arguments,float,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,float,args,parameter,count,i,1,float,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,double,type,double,repackaged,arguments,double,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,double,args,parameter,count,i,1,double,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,short,type,short,repackaged,arguments,short,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,short,args,parameter,count,i,1,short,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,character,type,char,repackaged,arguments,char,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,character,args,parameter,count,i,1,char,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,byte,type,byte,repackaged,arguments,byte,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,byte,args,parameter,count,i,1,byte,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,boolean,type,boolean,repackaged,arguments,boolean,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,boolean,args,parameter,count,i,1,boolean,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,long,type,long,repackaged,arguments,long,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,long,args,parameter,count,i,1,long,value,new,args,new,args,length,1,repackaged,arguments,else,object,repackaged,arguments,object,array,new,instance,component,type,array,size,system,arraycopy,args,parameter,count,1,repackaged,arguments,0,array,size,new,args,new,args,length,1,repackaged,arguments,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1389796100;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1394055372;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1405011154;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1413486529;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1413907042;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1414174302;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length__		_		if (parameterCount == args.length) {_			_		}_		else if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,else,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1419274456;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is (int, String[]) because the second parameter was declared String..._then if arguments is [1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to_match the expected parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1425759378;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is (int, String[]) because the second parameter was declared String..._then if arguments is [1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to_match the expected parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1426108143;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is {@code (int, String[])} because the second parameter_was declared {@code String...}, then if arguments is {@code [1,"a","b"]} then it must be_repackaged as {@code [1,new String[]{"a","b"}]} in order to match the expected types._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,code,int,string,because,the,second,parameter,was,declared,code,string,then,if,arguments,is,code,1,a,b,then,it,must,be,repackaged,as,code,1,new,string,a,b,in,order,to,match,the,expected,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1449965678;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is {@code (int, String[])} because the second parameter_was declared {@code String...}, then if arguments is {@code [1,"a","b"]} then it must be_repackaged as {@code [1,new String[]{"a","b"}]} in order to match the expected types._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,code,int,string,because,the,second,parameter,was,declared,code,string,then,if,arguments,is,code,1,a,b,then,it,must,be,repackaged,as,code,1,new,string,a,b,in,order,to,match,the,expected,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1467844672;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is {@code (int, String[])} because the second parameter_was declared {@code String...}, then if arguments is {@code [1,"a","b"]} then it must be_repackaged as {@code [1,new String[]{"a","b"}]} in order to match the expected types._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,code,int,string,because,the,second,parameter,was,declared,code,string,then,if,arguments,is,code,1,a,b,then,it,must,be,repackaged,as,code,1,new,string,a,b,in,order,to,match,the,expected,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1473796721;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is {@code (int, String[])} because the second parameter_was declared {@code String...}, then if arguments is {@code [1,"a","b"]} then it must be_repackaged as {@code [1,new String[]{"a","b"}]} in order to match the expected types._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,code,int,string,because,the,second,parameter,was,declared,code,string,then,if,arguments,is,code,1,a,b,then,it,must,be,repackaged,as,code,1,new,string,a,b,in,order,to,match,the,expected,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1495868221;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is {@code (int, String[])} because the second parameter_was declared {@code String...}, then if arguments is {@code [1,"a","b"]} then it must be_repackaged as {@code [1,new String[]{"a","b"}]} in order to match the expected types._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,code,int,string,because,the,second,parameter,was,declared,code,string,then,if,arguments,is,code,1,a,b,then,it,must,be,repackaged,as,code,1,new,string,a,b,in,order,to,match,the,expected,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1496242568;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is {@code (int, String[])} because the second parameter_was declared {@code String...}, then if arguments is {@code [1,"a","b"]} then it must be_repackaged as {@code [1,new String[]{"a","b"}]} in order to match the expected types._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,code,int,string,because,the,second,parameter,was,declared,code,string,then,if,arguments,is,code,1,a,b,then,it,must,be,repackaged,as,code,1,new,string,a,b,in,order,to,match,the,expected,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1496837955;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is {@code (int, String[])} because the second parameter_was declared {@code String...}, then if arguments is {@code [1,"a","b"]} then it must be_repackaged as {@code [1,new String[]{"a","b"}]} in order to match the expected types._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,code,int,string,because,the,second,parameter,was,declared,code,string,then,if,arguments,is,code,1,a,b,then,it,must,be,repackaged,as,code,1,new,string,a,b,in,order,to,match,the,expected,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1522307598;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is {@code (int, String[])} because the second parameter_was declared {@code String...}, then if arguments is {@code [1,"a","b"]} then it must be_repackaged as {@code [1,new String[]{"a","b"}]} in order to match the expected types._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,code,int,string,because,the,second,parameter,was,declared,code,string,then,if,arguments,is,code,1,a,b,then,it,must,be,repackaged,as,code,1,new,string,a,b,in,order,to,match,the,expected,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1525211306;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is {@code (int, String[])} because the second parameter_was declared {@code String...}, then if arguments is {@code [1,"a","b"]} then it must be_repackaged as {@code [1,new String[]{"a","b"}]} in order to match the expected types._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,code,int,string,because,the,second,parameter,was,declared,code,string,then,if,arguments,is,code,1,a,b,then,it,must,be,repackaged,as,code,1,new,string,a,b,in,order,to,match,the,expected,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args);1530174524;Package up the arguments so that they correctly match what is expected in parameterTypes._For example, if parameterTypes is {@code (int, String[])} because the second parameter_was declared {@code String...}, then if arguments is {@code [1,"a","b"]} then it must be_repackaged as {@code [1,new String[]{"a","b"}]} in order to match the expected types._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {__			int arraySize = 0_  _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1)___			_			_			Class<?> componentType = requiredParameterTypes[parameterCount - 1].getComponentType()__			Object repackagedArgs = Array.newInstance(componentType, arraySize)__			for (int i = 0_ i < arraySize_ i++) {_				Array.set(repackagedArgs, i, args[parameterCount - 1 + i])__			}_			newArgs[newArgs.length - 1] = repackagedArgs__			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,code,int,string,because,the,second,parameter,was,declared,code,string,then,if,arguments,is,code,1,a,b,then,it,must,be,repackaged,as,code,1,new,string,a,b,in,order,to,match,the,expected,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,args,argument,count,1,get,class,null,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,system,arraycopy,args,0,new,args,0,new,args,length,1,class,component,type,required,parameter,types,parameter,count,1,get,component,type,object,repackaged,args,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,array,set,repackaged,args,i,args,parameter,count,1,i,new,args,new,args,length,1,repackaged,args,return,new,args,return,args
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1328020251;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {_ _		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")__		_		ArgsMatchKind match = ArgsMatchKind.EXACT__		List<Integer> argsRequiringConversion = null___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						if (argsRequiringConversion == null) {_							argsRequiringConversion = new ArrayList<Integer>()__						}_						argsRequiringConversion.add(i)__						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			Class varargsParameterType = expectedArgTypes.get(expectedArgTypes.size() - 1).getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParameterType.isPrimitive()) {_						match = null__					}					_				} else {_					if (varargsParameterType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParameterType, suppliedArg.getType())) {_							if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_								match = ArgsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParameterType))) {_							if (argsRequiringConversion == null) {_								argsRequiringConversion = new ArrayList<Integer>()__							}_							argsRequiringConversion.add(i)__							match = ArgsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		if (match == null) {_			return null__		}_		else {_			if (match == ArgsMatchKind.REQUIRES_CONVERSION) {_				int[] argsArray = new int[argsRequiringConversion.size()]__				for (int i = 0_ i < argsRequiringConversion.size()_ i++) {_					argsArray[i] = argsRequiringConversion.get(i)__				}_				return new ArgumentsMatchInfo(match, argsArray)__			}_			else {_				return new ArgumentsMatchInfo(match)__			}_		}_	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,args,match,kind,match,args,match,kind,exact,list,integer,args,requiring,conversion,null,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,class,varargs,parameter,type,expected,arg,types,get,expected,arg,types,size,1,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,parameter,type,is,primitive,match,null,else,if,varargs,parameter,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,parameter,type,supplied,arg,get,type,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,parameter,type,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,else,if,match,args,match,kind,int,args,array,new,int,args,requiring,conversion,size,for,int,i,0,i,args,requiring,conversion,size,i,args,array,i,args,requiring,conversion,get,i,return,new,arguments,match,info,match,args,array,else,return,new,arguments,match,info,match
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1356735495;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgsMatchKind match = ArgsMatchKind.EXACT__		List<Integer> argsRequiringConversion = null___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						if (argsRequiringConversion == null) {_							argsRequiringConversion = new ArrayList<Integer>()__						}_						argsRequiringConversion.add(i)__						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			Class varargsParameterType = expectedArgTypes.get(expectedArgTypes.size() - 1).getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParameterType.isPrimitive()) {_						match = null__					}_				} else {_					if (varargsParameterType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParameterType, suppliedArg.getType())) {_							if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_								match = ArgsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParameterType))) {_							if (argsRequiringConversion == null) {_								argsRequiringConversion = new ArrayList<Integer>()__							}_							argsRequiringConversion.add(i)__							match = ArgsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		if (match == null) {_			return null__		}_		else {_			if (match == ArgsMatchKind.REQUIRES_CONVERSION) {_				int[] argsArray = new int[argsRequiringConversion.size()]__				for (int i = 0_ i < argsRequiringConversion.size()_ i++) {_					argsArray[i] = argsRequiringConversion.get(i)__				}_				return new ArgumentsMatchInfo(match, argsArray)__			}_			else {_				return new ArgumentsMatchInfo(match)__			}_		}_	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,args,match,kind,match,args,match,kind,exact,list,integer,args,requiring,conversion,null,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,class,varargs,parameter,type,expected,arg,types,get,expected,arg,types,size,1,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,parameter,type,is,primitive,match,null,else,if,varargs,parameter,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,parameter,type,supplied,arg,get,type,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,parameter,type,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,else,if,match,args,match,kind,int,args,array,new,int,args,requiring,conversion,size,for,int,i,0,i,args,requiring,conversion,size,i,args,array,i,args,requiring,conversion,get,i,return,new,arguments,match,info,match,args,array,else,return,new,arguments,match,info,match
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1368482696;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgsMatchKind match = ArgsMatchKind.EXACT__		List<Integer> argsRequiringConversion = null___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						if (argsRequiringConversion == null) {_							argsRequiringConversion = new ArrayList<Integer>()__						}_						argsRequiringConversion.add(i)__						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			Class varargsParameterType = expectedArgTypes.get(expectedArgTypes.size() - 1).getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParameterType.isPrimitive()) {_						match = null__					}_				} else {_					if (varargsParameterType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParameterType, suppliedArg.getType())) {_							if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_								match = ArgsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParameterType))) {_							if (argsRequiringConversion == null) {_								argsRequiringConversion = new ArrayList<Integer>()__							}_							argsRequiringConversion.add(i)__							match = ArgsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		if (match == null) {_			return null__		}_		else {_			if (match == ArgsMatchKind.REQUIRES_CONVERSION) {_				int[] argsArray = new int[argsRequiringConversion.size()]__				for (int i = 0_ i < argsRequiringConversion.size()_ i++) {_					argsArray[i] = argsRequiringConversion.get(i)__				}_				return new ArgumentsMatchInfo(match, argsArray)__			}_			else {_				return new ArgumentsMatchInfo(match)__			}_		}_	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,args,match,kind,match,args,match,kind,exact,list,integer,args,requiring,conversion,null,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,class,varargs,parameter,type,expected,arg,types,get,expected,arg,types,size,1,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,parameter,type,is,primitive,match,null,else,if,varargs,parameter,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,parameter,type,supplied,arg,get,type,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,parameter,type,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,else,if,match,args,match,kind,int,args,array,new,int,args,requiring,conversion,size,for,int,i,0,i,args,requiring,conversion,size,i,args,array,i,args,requiring,conversion,get,i,return,new,arguments,match,info,match,args,array,else,return,new,arguments,match,info,match
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1372363092;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgsMatchKind match = ArgsMatchKind.EXACT__		List<Integer> argsRequiringConversion = null___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						if (argsRequiringConversion == null) {_							argsRequiringConversion = new ArrayList<Integer>()__						}_						argsRequiringConversion.add(i)__						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			Class varargsParameterType = expectedArgTypes.get(expectedArgTypes.size() - 1).getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParameterType.isPrimitive()) {_						match = null__					}_				} else {_					if (varargsParameterType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParameterType, suppliedArg.getType())) {_							if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_								match = ArgsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParameterType))) {_							if (argsRequiringConversion == null) {_								argsRequiringConversion = new ArrayList<Integer>()__							}_							argsRequiringConversion.add(i)__							match = ArgsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		if (match == null) {_			return null__		}_		else {_			if (match == ArgsMatchKind.REQUIRES_CONVERSION) {_				int[] argsArray = new int[argsRequiringConversion.size()]__				for (int i = 0_ i < argsRequiringConversion.size()_ i++) {_					argsArray[i] = argsRequiringConversion.get(i)__				}_				return new ArgumentsMatchInfo(match, argsArray)__			}_			else {_				return new ArgumentsMatchInfo(match)__			}_		}_	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,args,match,kind,match,args,match,kind,exact,list,integer,args,requiring,conversion,null,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,class,varargs,parameter,type,expected,arg,types,get,expected,arg,types,size,1,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,parameter,type,is,primitive,match,null,else,if,varargs,parameter,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,parameter,type,supplied,arg,get,type,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,parameter,type,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,else,if,match,args,match,kind,int,args,array,new,int,args,requiring,conversion,size,for,int,i,0,i,args,requiring,conversion,size,i,args,array,i,args,requiring,conversion,get,i,return,new,arguments,match,info,match,args,array,else,return,new,arguments,match,info,match
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1385412762;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgsMatchKind match = ArgsMatchKind.EXACT__		List<Integer> argsRequiringConversion = null___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						if (argsRequiringConversion == null) {_							argsRequiringConversion = new ArrayList<Integer>()__						}_						argsRequiringConversion.add(i)__						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			Class<?> varargsParameterType = expectedArgTypes.get(expectedArgTypes.size() - 1).getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParameterType.isPrimitive()) {_						match = null__					}_				} else {_					if (varargsParameterType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParameterType, suppliedArg.getType())) {_							if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_								match = ArgsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParameterType))) {_							if (argsRequiringConversion == null) {_								argsRequiringConversion = new ArrayList<Integer>()__							}_							argsRequiringConversion.add(i)__							match = ArgsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		if (match == null) {_			return null__		}_		else {_			if (match == ArgsMatchKind.REQUIRES_CONVERSION) {_				int[] argsArray = new int[argsRequiringConversion.size()]__				for (int i = 0_ i < argsRequiringConversion.size()_ i++) {_					argsArray[i] = argsRequiringConversion.get(i)__				}_				return new ArgumentsMatchInfo(match, argsArray)__			}_			else {_				return new ArgumentsMatchInfo(match)__			}_		}_	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,args,match,kind,match,args,match,kind,exact,list,integer,args,requiring,conversion,null,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,class,varargs,parameter,type,expected,arg,types,get,expected,arg,types,size,1,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,parameter,type,is,primitive,match,null,else,if,varargs,parameter,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,parameter,type,supplied,arg,get,type,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,parameter,type,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,else,if,match,args,match,kind,int,args,array,new,int,args,requiring,conversion,size,for,int,i,0,i,args,requiring,conversion,size,i,args,array,i,args,requiring,conversion,get,i,return,new,arguments,match,info,match,args,array,else,return,new,arguments,match,info,match
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1389789410;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgsMatchKind match = ArgsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			Class<?> varargsParamType = expectedArgTypes.get(expectedArgTypes.size() - 1).getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_								match = ArgsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,args,match,kind,match,args,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,args,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,class,varargs,param,type,expected,arg,types,get,expected,arg,types,size,1,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,args,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1389796100;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			Class<?> varargsParamType = expectedArgTypes.get(expectedArgTypes.size() - 1).getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,class,varargs,param,type,expected,arg,types,get,expected,arg,types,size,1,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1394055372;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1405011154;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1413486529;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1413907042;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1414174302;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1419274456;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1425759378;Compare argument arrays and return information about whether they match. A supplied type converter and_conversionAllowed flag allow for matches to take into account that a type may be transformed into a different_type by the converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1426108143;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to_take into account that a type may be transformed into a different type by the_converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1449965678;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to_take into account that a type may be transformed into a different type by the_converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1467844672;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to_take into account that a type may be transformed into a different type by the_converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArgumentsVarargs( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1473796721;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to_take into account that a type may be transformed into a different type by the_converter. This variant of compareArguments also allows for a varargs match._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;static ArgumentsMatchInfo compareArgumentsVarargs(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.size() > 0,_				"Expected arguments must at least include one array (the vargargs parameter)")__		Assert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),_				"Final expected argument should be array type (the varargs parameter)")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT___		__		_		int argCountUpToVarargs = expectedArgTypes.size() - 1__		for (int i = 0_ i < argCountUpToVarargs && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (suppliedArg == null) {_				if (expectedArg.isPrimitive()) {_					match = null__				}_			}_			else {_				if (!expectedArg.equals(suppliedArg)) {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}__		_		if (match == null) {_			return null__		}__		if (suppliedArgTypes.size() == expectedArgTypes.size() &&_				expectedArgTypes.get(expectedArgTypes.size() - 1).equals(_						suppliedArgTypes.get(suppliedArgTypes.size() - 1))) {_			_			_		}_		else {_			_			_			TypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1)__			Class<?> varargsParamType = varargsDesc.getElementTypeDescriptor().getType()___			_			for (int i = expectedArgTypes.size() - 1_ i < suppliedArgTypes.size()_ i++) {_				TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__				if (suppliedArg == null) {_					if (varargsParamType.isPrimitive()) {_						match = null__					}_				}_				else {_					if (varargsParamType != suppliedArg.getType()) {_						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {_							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_								match = ArgumentsMatchKind.CLOSE__							}_						}_						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {_							match = ArgumentsMatchKind.REQUIRES_CONVERSION__						}_						else {_							match = null__						}_					}_				}_			}_		}__		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,this,variant,of,compare,arguments,also,allows,for,a,varargs,match,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,varargs,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,null,expected,arg,types,size,0,expected,arguments,must,at,least,include,one,array,the,vargargs,parameter,assert,is,true,expected,arg,types,get,expected,arg,types,size,1,is,array,final,expected,argument,should,be,array,type,the,varargs,parameter,arguments,match,kind,match,arguments,match,kind,exact,int,arg,count,up,to,varargs,expected,arg,types,size,1,for,int,i,0,i,arg,count,up,to,varargs,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,expected,arg,equals,supplied,arg,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,if,match,null,return,null,if,supplied,arg,types,size,expected,arg,types,size,expected,arg,types,get,expected,arg,types,size,1,equals,supplied,arg,types,get,supplied,arg,types,size,1,else,type,descriptor,varargs,desc,expected,arg,types,get,expected,arg,types,size,1,class,varargs,param,type,varargs,desc,get,element,type,descriptor,get,type,for,int,i,expected,arg,types,size,1,i,supplied,arg,types,size,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,if,supplied,arg,null,if,varargs,param,type,is,primitive,match,null,else,if,varargs,param,type,supplied,arg,get,type,if,class,utils,is,assignable,varargs,param,type,supplied,arg,get,type,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,type,descriptor,value,of,varargs,param,type,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class[] requiredParameterTypes, Object... args);1328020251;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] == null ? null : args[argumentCount - 1].getClass())) {_			int arraySize = 0_ _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}_			_			_			Object[] newArgs = new Object[parameterCount]__			for (int i = 0_ i < newArgs.length - 1_ i++) {_				newArgs[i] = args[i]__			}_			_			_			Class<?> componentType = requiredParameterTypes[parameterCount-1].getComponentType()__			if (componentType.isPrimitive()) {_				if (componentType==Integer.TYPE) {_					int[] repackagedArguments = (int[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Integer)args[parameterCount + i - 1]).intValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Float.TYPE) {_					float[] repackagedArguments = (float[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Float)args[parameterCount + i - 1]).floatValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Double.TYPE) {_					double[] repackagedArguments = (double[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Double)args[parameterCount + i - 1]).doubleValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Short.TYPE) {_					short[] repackagedArguments = (short[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Short)args[parameterCount + i - 1]).shortValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Character.TYPE) {_					char[] repackagedArguments = (char[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Character)args[parameterCount + i - 1]).charValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Byte.TYPE) {_					byte[] repackagedArguments = (byte[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Byte)args[parameterCount + i - 1]).byteValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Boolean.TYPE) {_					boolean[] repackagedArguments = (boolean[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Boolean)args[parameterCount + i - 1]).booleanValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Long.TYPE) {_					long[] repackagedArguments = (long[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Long)args[parameterCount + i - 1]).longValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_			} else {_			  Object[] repackagedArguments = (Object[]) Array.newInstance(componentType, arraySize)__				_				for (int i = 0_ i < arraySize_ i++) {_					repackagedArguments[i] = args[parameterCount + i - 1]__				}_				newArgs[newArgs.length - 1] = repackagedArguments__			}_			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,null,args,argument,count,1,get,class,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,for,int,i,0,i,new,args,length,1,i,new,args,i,args,i,class,component,type,required,parameter,types,parameter,count,1,get,component,type,if,component,type,is,primitive,if,component,type,integer,type,int,repackaged,arguments,int,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,integer,args,parameter,count,i,1,int,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,float,type,float,repackaged,arguments,float,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,float,args,parameter,count,i,1,float,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,double,type,double,repackaged,arguments,double,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,double,args,parameter,count,i,1,double,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,short,type,short,repackaged,arguments,short,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,short,args,parameter,count,i,1,short,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,character,type,char,repackaged,arguments,char,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,character,args,parameter,count,i,1,char,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,byte,type,byte,repackaged,arguments,byte,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,byte,args,parameter,count,i,1,byte,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,boolean,type,boolean,repackaged,arguments,boolean,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,boolean,args,parameter,count,i,1,boolean,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,long,type,long,repackaged,arguments,long,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,long,args,parameter,count,i,1,long,value,new,args,new,args,length,1,repackaged,arguments,else,object,repackaged,arguments,object,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,args,parameter,count,i,1,new,args,new,args,length,1,repackaged,arguments,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class[] requiredParameterTypes, Object... args);1356735495;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] == null ? null : args[argumentCount - 1].getClass())) {_			int arraySize = 0_ _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			for (int i = 0_ i < newArgs.length - 1_ i++) {_				newArgs[i] = args[i]__			}_			_			_			Class<?> componentType = requiredParameterTypes[parameterCount-1].getComponentType()__			if (componentType.isPrimitive()) {_				if (componentType==Integer.TYPE) {_					int[] repackagedArguments = (int[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Integer)args[parameterCount + i - 1]).intValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Float.TYPE) {_					float[] repackagedArguments = (float[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Float)args[parameterCount + i - 1]).floatValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Double.TYPE) {_					double[] repackagedArguments = (double[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Double)args[parameterCount + i - 1]).doubleValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Short.TYPE) {_					short[] repackagedArguments = (short[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Short)args[parameterCount + i - 1]).shortValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Character.TYPE) {_					char[] repackagedArguments = (char[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Character)args[parameterCount + i - 1]).charValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Byte.TYPE) {_					byte[] repackagedArguments = (byte[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Byte)args[parameterCount + i - 1]).byteValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Boolean.TYPE) {_					boolean[] repackagedArguments = (boolean[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Boolean)args[parameterCount + i - 1]).booleanValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Long.TYPE) {_					long[] repackagedArguments = (long[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Long)args[parameterCount + i - 1]).longValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_			} else {_			  Object[] repackagedArguments = (Object[]) Array.newInstance(componentType, arraySize)__				_				for (int i = 0_ i < arraySize_ i++) {_					repackagedArguments[i] = args[parameterCount + i - 1]__				}_				newArgs[newArgs.length - 1] = repackagedArguments__			}_			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,null,args,argument,count,1,get,class,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,for,int,i,0,i,new,args,length,1,i,new,args,i,args,i,class,component,type,required,parameter,types,parameter,count,1,get,component,type,if,component,type,is,primitive,if,component,type,integer,type,int,repackaged,arguments,int,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,integer,args,parameter,count,i,1,int,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,float,type,float,repackaged,arguments,float,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,float,args,parameter,count,i,1,float,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,double,type,double,repackaged,arguments,double,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,double,args,parameter,count,i,1,double,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,short,type,short,repackaged,arguments,short,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,short,args,parameter,count,i,1,short,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,character,type,char,repackaged,arguments,char,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,character,args,parameter,count,i,1,char,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,byte,type,byte,repackaged,arguments,byte,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,byte,args,parameter,count,i,1,byte,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,boolean,type,boolean,repackaged,arguments,boolean,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,boolean,args,parameter,count,i,1,boolean,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,long,type,long,repackaged,arguments,long,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,long,args,parameter,count,i,1,long,value,new,args,new,args,length,1,repackaged,arguments,else,object,repackaged,arguments,object,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,args,parameter,count,i,1,new,args,new,args,length,1,repackaged,arguments,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class[] requiredParameterTypes, Object... args);1368482696;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] == null ? null : args[argumentCount - 1].getClass())) {_			int arraySize = 0_ _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			for (int i = 0_ i < newArgs.length - 1_ i++) {_				newArgs[i] = args[i]__			}_			_			_			Class<?> componentType = requiredParameterTypes[parameterCount-1].getComponentType()__			if (componentType.isPrimitive()) {_				if (componentType==Integer.TYPE) {_					int[] repackagedArguments = (int[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Integer)args[parameterCount + i - 1]).intValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Float.TYPE) {_					float[] repackagedArguments = (float[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Float)args[parameterCount + i - 1]).floatValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Double.TYPE) {_					double[] repackagedArguments = (double[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Double)args[parameterCount + i - 1]).doubleValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Short.TYPE) {_					short[] repackagedArguments = (short[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Short)args[parameterCount + i - 1]).shortValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Character.TYPE) {_					char[] repackagedArguments = (char[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Character)args[parameterCount + i - 1]).charValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Byte.TYPE) {_					byte[] repackagedArguments = (byte[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Byte)args[parameterCount + i - 1]).byteValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Boolean.TYPE) {_					boolean[] repackagedArguments = (boolean[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Boolean)args[parameterCount + i - 1]).booleanValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				} else if(componentType==Long.TYPE) {_					long[] repackagedArguments = (long[]) Array.newInstance(componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Long)args[parameterCount + i - 1]).longValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_			} else {_			  Object[] repackagedArguments = (Object[]) Array.newInstance(componentType, arraySize)__				_				for (int i = 0_ i < arraySize_ i++) {_					repackagedArguments[i] = args[parameterCount + i - 1]__				}_				newArgs[newArgs.length - 1] = repackagedArguments__			}_			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,null,args,argument,count,1,get,class,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,for,int,i,0,i,new,args,length,1,i,new,args,i,args,i,class,component,type,required,parameter,types,parameter,count,1,get,component,type,if,component,type,is,primitive,if,component,type,integer,type,int,repackaged,arguments,int,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,integer,args,parameter,count,i,1,int,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,float,type,float,repackaged,arguments,float,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,float,args,parameter,count,i,1,float,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,double,type,double,repackaged,arguments,double,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,double,args,parameter,count,i,1,double,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,short,type,short,repackaged,arguments,short,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,short,args,parameter,count,i,1,short,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,character,type,char,repackaged,arguments,char,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,character,args,parameter,count,i,1,char,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,byte,type,byte,repackaged,arguments,byte,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,byte,args,parameter,count,i,1,byte,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,boolean,type,boolean,repackaged,arguments,boolean,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,boolean,args,parameter,count,i,1,boolean,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,long,type,long,repackaged,arguments,long,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,long,args,parameter,count,i,1,long,value,new,args,new,args,length,1,repackaged,arguments,else,object,repackaged,arguments,object,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,args,parameter,count,i,1,new,args,new,args,length,1,repackaged,arguments,return,new,args,return,args
ReflectionHelper -> public static Object[] setupArgumentsForVarargsInvocation(Class[] requiredParameterTypes, Object... args);1372363092;Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if_parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is_[1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected_parameterTypes._@param requiredParameterTypes the types of the parameters for the invocation_@param args the arguments to be setup ready for the invocation_@return a repackaged array of arguments where any varargs setup has been done;public static Object[] setupArgumentsForVarargsInvocation(Class[] requiredParameterTypes, Object... args) {_		_		int parameterCount = requiredParameterTypes.length__		int argumentCount = args.length___		_		if (parameterCount != args.length ||_				requiredParameterTypes[parameterCount - 1] !=_						(args[argumentCount - 1] == null ? null : args[argumentCount - 1].getClass())) {_			int arraySize = 0_ _			if (argumentCount >= parameterCount) {_				arraySize = argumentCount - (parameterCount - 1)__			}__			_			Object[] newArgs = new Object[parameterCount]__			for (int i = 0_ i < newArgs.length - 1_ i++) {_				newArgs[i] = args[i]__			}_			_			_			Class<?> componentType = requiredParameterTypes[parameterCount-1].getComponentType()__			if (componentType.isPrimitive()) {_				if (componentType == Integer.TYPE) {_					int[] repackagedArguments = (int[]) Array.newInstance(componentType,_							arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Integer) args[parameterCount + i - 1]).intValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Float.TYPE) {_					float[] repackagedArguments = (float[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Float) args[parameterCount + i - 1]).floatValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Double.TYPE) {_					double[] repackagedArguments = (double[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Double) args[parameterCount + i - 1]).doubleValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Short.TYPE) {_					short[] repackagedArguments = (short[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Short) args[parameterCount + i - 1]).shortValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Character.TYPE) {_					char[] repackagedArguments = (char[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Character) args[parameterCount + i - 1]).charValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Byte.TYPE) {_					byte[] repackagedArguments = (byte[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Byte) args[parameterCount + i - 1]).byteValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Boolean.TYPE) {_					boolean[] repackagedArguments = (boolean[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Boolean) args[parameterCount + i - 1]).booleanValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_				else if (componentType == Long.TYPE) {_					long[] repackagedArguments = (long[]) Array.newInstance(_							componentType, arraySize)__					for (int i = 0_ i < arraySize_ i++) {_						repackagedArguments[i] = ((Long) args[parameterCount + i - 1]).longValue()__					}_					newArgs[newArgs.length - 1] = repackagedArguments__				}_			}_			else {_				Object[] repackagedArguments = (Object[]) Array.newInstance(_						componentType, arraySize)__				_				for (int i = 0_ i < arraySize_ i++) {_					repackagedArguments[i] = args[parameterCount + i - 1]__				}_				newArgs[newArgs.length - 1] = repackagedArguments__			}_			return newArgs__		}_		return args__	};package,up,the,arguments,so,that,they,correctly,match,what,is,expected,in,parameter,types,for,example,if,parameter,types,is,int,string,because,the,second,parameter,was,declared,string,then,if,arguments,is,1,a,b,then,it,must,be,repackaged,as,1,new,string,a,b,in,order,to,match,the,expected,parameter,types,param,required,parameter,types,the,types,of,the,parameters,for,the,invocation,param,args,the,arguments,to,be,setup,ready,for,the,invocation,return,a,repackaged,array,of,arguments,where,any,varargs,setup,has,been,done;public,static,object,setup,arguments,for,varargs,invocation,class,required,parameter,types,object,args,int,parameter,count,required,parameter,types,length,int,argument,count,args,length,if,parameter,count,args,length,required,parameter,types,parameter,count,1,args,argument,count,1,null,null,args,argument,count,1,get,class,int,array,size,0,if,argument,count,parameter,count,array,size,argument,count,parameter,count,1,object,new,args,new,object,parameter,count,for,int,i,0,i,new,args,length,1,i,new,args,i,args,i,class,component,type,required,parameter,types,parameter,count,1,get,component,type,if,component,type,is,primitive,if,component,type,integer,type,int,repackaged,arguments,int,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,integer,args,parameter,count,i,1,int,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,float,type,float,repackaged,arguments,float,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,float,args,parameter,count,i,1,float,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,double,type,double,repackaged,arguments,double,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,double,args,parameter,count,i,1,double,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,short,type,short,repackaged,arguments,short,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,short,args,parameter,count,i,1,short,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,character,type,char,repackaged,arguments,char,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,character,args,parameter,count,i,1,char,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,byte,type,byte,repackaged,arguments,byte,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,byte,args,parameter,count,i,1,byte,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,boolean,type,boolean,repackaged,arguments,boolean,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,boolean,args,parameter,count,i,1,boolean,value,new,args,new,args,length,1,repackaged,arguments,else,if,component,type,long,type,long,repackaged,arguments,long,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,long,args,parameter,count,i,1,long,value,new,args,new,args,length,1,repackaged,arguments,else,object,repackaged,arguments,object,array,new,instance,component,type,array,size,for,int,i,0,i,array,size,i,repackaged,arguments,i,args,parameter,count,i,1,new,args,new,args,length,1,repackaged,arguments,return,new,args,return,args
ReflectionHelper -> public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1389789410;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does not repackage the arguments_into a form suitable for the varargs invocation_@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@throws SpelEvaluationException if there is a problem with conversion;public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = null__		if (method.isVarArgs()) {_			Class<?>[] paramTypes = method.getParameterTypes()__			varargsPosition = paramTypes.length - 1__		}_		for (int argPos = 0_ argPos < arguments.length_ argPos++) {_			TypeDescriptor targetType__			if (varargsPosition != null && argPos >= varargsPosition) {_				MethodParameter methodParam = new MethodParameter(method, varargsPosition)__				targetType = TypeDescriptor.nested(methodParam, 1)__			}_			else {_				targetType = new TypeDescriptor(new MethodParameter(method, argPos))__			}_			try {_				Object argument = arguments[argPos]__				if (argument != null && !targetType.getObjectType().isInstance(argument)) {_					if (converter == null) {_						throw new SpelEvaluationException(_								SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType)__					}_					arguments[argPos] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_			catch (EvaluationException ex) {_				_				if (ex instanceof SpelEvaluationException) {_					throw (SpelEvaluationException)ex__				}_				else {_					throw new SpelEvaluationException(ex,_							SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPos].getClass().getName(), targetType)__				}_			}_		}_	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,void,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,null,if,method,is,var,args,class,param,types,method,get,parameter,types,varargs,position,param,types,length,1,for,int,arg,pos,0,arg,pos,arguments,length,arg,pos,type,descriptor,target,type,if,varargs,position,null,arg,pos,varargs,position,method,parameter,method,param,new,method,parameter,method,varargs,position,target,type,type,descriptor,nested,method,param,1,else,target,type,new,type,descriptor,new,method,parameter,method,arg,pos,try,object,argument,arguments,arg,pos,if,argument,null,target,type,get,object,type,is,instance,argument,if,converter,null,throw,new,spel,evaluation,exception,spel,message,argument,get,class,get,name,target,type,arguments,arg,pos,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,catch,evaluation,exception,ex,if,ex,instanceof,spel,evaluation,exception,throw,spel,evaluation,exception,ex,else,throw,new,spel,evaluation,exception,ex,spel,message,arguments,arg,pos,get,class,get,name,target,type
ReflectionHelper -> public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1389796100;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does not repackage the arguments_into a form suitable for the varargs invocation_@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@throws SpelEvaluationException if there is a problem with conversion;public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = null__		if (method.isVarArgs()) {_			Class<?>[] paramTypes = method.getParameterTypes()__			varargsPosition = paramTypes.length - 1__		}_		for (int argPos = 0_ argPos < arguments.length_ argPos++) {_			TypeDescriptor targetType__			if (varargsPosition != null && argPos >= varargsPosition) {_				MethodParameter methodParam = new MethodParameter(method, varargsPosition)__				targetType = TypeDescriptor.nested(methodParam, 1)__			}_			else {_				targetType = new TypeDescriptor(new MethodParameter(method, argPos))__			}_			try {_				Object argument = arguments[argPos]__				if (argument != null && !targetType.getObjectType().isInstance(argument)) {_					if (converter == null) {_						throw new SpelEvaluationException(_								SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType)__					}_					arguments[argPos] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_			catch (EvaluationException ex) {_				_				if (ex instanceof SpelEvaluationException) {_					throw (SpelEvaluationException)ex__				}_				else {_					throw new SpelEvaluationException(ex,_							SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPos].getClass().getName(), targetType)__				}_			}_		}_	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,void,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,null,if,method,is,var,args,class,param,types,method,get,parameter,types,varargs,position,param,types,length,1,for,int,arg,pos,0,arg,pos,arguments,length,arg,pos,type,descriptor,target,type,if,varargs,position,null,arg,pos,varargs,position,method,parameter,method,param,new,method,parameter,method,varargs,position,target,type,type,descriptor,nested,method,param,1,else,target,type,new,type,descriptor,new,method,parameter,method,arg,pos,try,object,argument,arguments,arg,pos,if,argument,null,target,type,get,object,type,is,instance,argument,if,converter,null,throw,new,spel,evaluation,exception,spel,message,argument,get,class,get,name,target,type,arguments,arg,pos,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,catch,evaluation,exception,ex,if,ex,instanceof,spel,evaluation,exception,throw,spel,evaluation,exception,ex,else,throw,new,spel,evaluation,exception,ex,spel,message,arguments,arg,pos,get,class,get,name,target,type
ReflectionHelper -> public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1394055372;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does not repackage the arguments_into a form suitable for the varargs invocation_@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@throws SpelEvaluationException if there is a problem with conversion;public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = null__		if (method.isVarArgs()) {_			Class<?>[] paramTypes = method.getParameterTypes()__			varargsPosition = paramTypes.length - 1__		}_		for (int argPos = 0_ argPos < arguments.length_ argPos++) {_			TypeDescriptor targetType__			if (varargsPosition != null && argPos >= varargsPosition) {_				MethodParameter methodParam = new MethodParameter(method, varargsPosition)__				targetType = TypeDescriptor.nested(methodParam, 1)__			}_			else {_				targetType = new TypeDescriptor(new MethodParameter(method, argPos))__			}_			try {_				Object argument = arguments[argPos]__				if (argument != null && !targetType.getObjectType().isInstance(argument)) {_					if (converter == null) {_						throw new SpelEvaluationException(_								SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType)__					}_					arguments[argPos] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_			catch (EvaluationException ex) {_				_				if (ex instanceof SpelEvaluationException) {_					throw (SpelEvaluationException)ex__				}_				else {_					throw new SpelEvaluationException(ex,_							SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPos].getClass().getName(), targetType)__				}_			}_		}_	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,void,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,null,if,method,is,var,args,class,param,types,method,get,parameter,types,varargs,position,param,types,length,1,for,int,arg,pos,0,arg,pos,arguments,length,arg,pos,type,descriptor,target,type,if,varargs,position,null,arg,pos,varargs,position,method,parameter,method,param,new,method,parameter,method,varargs,position,target,type,type,descriptor,nested,method,param,1,else,target,type,new,type,descriptor,new,method,parameter,method,arg,pos,try,object,argument,arguments,arg,pos,if,argument,null,target,type,get,object,type,is,instance,argument,if,converter,null,throw,new,spel,evaluation,exception,spel,message,argument,get,class,get,name,target,type,arguments,arg,pos,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,catch,evaluation,exception,ex,if,ex,instanceof,spel,evaluation,exception,throw,spel,evaluation,exception,ex,else,throw,new,spel,evaluation,exception,ex,spel,message,arguments,arg,pos,get,class,get,name,target,type
ReflectionHelper -> public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1328020251;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does not repackage the arguments_into a form suitable for the varargs invocation_@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@throws SpelEvaluationException if there is a problem with conversion;public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = null__		if (method.isVarArgs()) {_			Class[] paramTypes = method.getParameterTypes()__			varargsPosition = paramTypes.length - 1__		}_		for (int argPosition = 0_ argPosition < arguments.length_ argPosition++) {_			TypeDescriptor targetType__			if (varargsPosition != null && argPosition >= varargsPosition) {_				MethodParameter methodParam = new MethodParameter(method, varargsPosition)__				targetType = TypeDescriptor.nested(methodParam, 1)__			}_			else {_				targetType = new TypeDescriptor(new MethodParameter(method, argPosition))__			}_			try {_				Object argument = arguments[argPosition]__				if (argument != null && !targetType.getObjectType().isInstance(argument)) {_					if (converter == null) {_						throw new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType)__					}_					arguments[argPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_			catch (EvaluationException ex) {_				_				if (ex instanceof SpelEvaluationException) {_					throw (SpelEvaluationException)ex__				}_				else {_					throw new SpelEvaluationException(ex, SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPosition].getClass().getName(), targetType)__				}_			}_		}_	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,void,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,null,if,method,is,var,args,class,param,types,method,get,parameter,types,varargs,position,param,types,length,1,for,int,arg,position,0,arg,position,arguments,length,arg,position,type,descriptor,target,type,if,varargs,position,null,arg,position,varargs,position,method,parameter,method,param,new,method,parameter,method,varargs,position,target,type,type,descriptor,nested,method,param,1,else,target,type,new,type,descriptor,new,method,parameter,method,arg,position,try,object,argument,arguments,arg,position,if,argument,null,target,type,get,object,type,is,instance,argument,if,converter,null,throw,new,spel,evaluation,exception,spel,message,argument,get,class,get,name,target,type,arguments,arg,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,catch,evaluation,exception,ex,if,ex,instanceof,spel,evaluation,exception,throw,spel,evaluation,exception,ex,else,throw,new,spel,evaluation,exception,ex,spel,message,arguments,arg,position,get,class,get,name,target,type
ReflectionHelper -> public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1356735495;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does not repackage the arguments_into a form suitable for the varargs invocation_@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@throws SpelEvaluationException if there is a problem with conversion;public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = null__		if (method.isVarArgs()) {_			Class[] paramTypes = method.getParameterTypes()__			varargsPosition = paramTypes.length - 1__		}_		for (int argPosition = 0_ argPosition < arguments.length_ argPosition++) {_			TypeDescriptor targetType__			if (varargsPosition != null && argPosition >= varargsPosition) {_				MethodParameter methodParam = new MethodParameter(method, varargsPosition)__				targetType = TypeDescriptor.nested(methodParam, 1)__			}_			else {_				targetType = new TypeDescriptor(new MethodParameter(method, argPosition))__			}_			try {_				Object argument = arguments[argPosition]__				if (argument != null && !targetType.getObjectType().isInstance(argument)) {_					if (converter == null) {_						throw new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType)__					}_					arguments[argPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_			catch (EvaluationException ex) {_				_				if (ex instanceof SpelEvaluationException) {_					throw (SpelEvaluationException)ex__				}_				else {_					throw new SpelEvaluationException(ex, SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPosition].getClass().getName(), targetType)__				}_			}_		}_	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,void,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,null,if,method,is,var,args,class,param,types,method,get,parameter,types,varargs,position,param,types,length,1,for,int,arg,position,0,arg,position,arguments,length,arg,position,type,descriptor,target,type,if,varargs,position,null,arg,position,varargs,position,method,parameter,method,param,new,method,parameter,method,varargs,position,target,type,type,descriptor,nested,method,param,1,else,target,type,new,type,descriptor,new,method,parameter,method,arg,position,try,object,argument,arguments,arg,position,if,argument,null,target,type,get,object,type,is,instance,argument,if,converter,null,throw,new,spel,evaluation,exception,spel,message,argument,get,class,get,name,target,type,arguments,arg,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,catch,evaluation,exception,ex,if,ex,instanceof,spel,evaluation,exception,throw,spel,evaluation,exception,ex,else,throw,new,spel,evaluation,exception,ex,spel,message,arguments,arg,position,get,class,get,name,target,type
ReflectionHelper -> public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1368482696;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does not repackage the arguments_into a form suitable for the varargs invocation_@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@throws SpelEvaluationException if there is a problem with conversion;public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = null__		if (method.isVarArgs()) {_			Class[] paramTypes = method.getParameterTypes()__			varargsPosition = paramTypes.length - 1__		}_		for (int argPosition = 0_ argPosition < arguments.length_ argPosition++) {_			TypeDescriptor targetType__			if (varargsPosition != null && argPosition >= varargsPosition) {_				MethodParameter methodParam = new MethodParameter(method, varargsPosition)__				targetType = TypeDescriptor.nested(methodParam, 1)__			}_			else {_				targetType = new TypeDescriptor(new MethodParameter(method, argPosition))__			}_			try {_				Object argument = arguments[argPosition]__				if (argument != null && !targetType.getObjectType().isInstance(argument)) {_					if (converter == null) {_						throw new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType)__					}_					arguments[argPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_			catch (EvaluationException ex) {_				_				if (ex instanceof SpelEvaluationException) {_					throw (SpelEvaluationException)ex__				}_				else {_					throw new SpelEvaluationException(ex, SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPosition].getClass().getName(), targetType)__				}_			}_		}_	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,void,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,null,if,method,is,var,args,class,param,types,method,get,parameter,types,varargs,position,param,types,length,1,for,int,arg,position,0,arg,position,arguments,length,arg,position,type,descriptor,target,type,if,varargs,position,null,arg,position,varargs,position,method,parameter,method,param,new,method,parameter,method,varargs,position,target,type,type,descriptor,nested,method,param,1,else,target,type,new,type,descriptor,new,method,parameter,method,arg,position,try,object,argument,arguments,arg,position,if,argument,null,target,type,get,object,type,is,instance,argument,if,converter,null,throw,new,spel,evaluation,exception,spel,message,argument,get,class,get,name,target,type,arguments,arg,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,catch,evaluation,exception,ex,if,ex,instanceof,spel,evaluation,exception,throw,spel,evaluation,exception,ex,else,throw,new,spel,evaluation,exception,ex,spel,message,arguments,arg,position,get,class,get,name,target,type
ReflectionHelper -> public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1372363092;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does not repackage the arguments_into a form suitable for the varargs invocation_@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@throws SpelEvaluationException if there is a problem with conversion;public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = null__		if (method.isVarArgs()) {_			Class[] paramTypes = method.getParameterTypes()__			varargsPosition = paramTypes.length - 1__		}_		for (int argPosition = 0_ argPosition < arguments.length_ argPosition++) {_			TypeDescriptor targetType__			if (varargsPosition != null && argPosition >= varargsPosition) {_				MethodParameter methodParam = new MethodParameter(method, varargsPosition)__				targetType = TypeDescriptor.nested(methodParam, 1)__			}_			else {_				targetType = new TypeDescriptor(new MethodParameter(method, argPosition))__			}_			try {_				Object argument = arguments[argPosition]__				if (argument != null && !targetType.getObjectType().isInstance(argument)) {_					if (converter == null) {_						throw new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType)__					}_					arguments[argPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_			catch (EvaluationException ex) {_				_				if (ex instanceof SpelEvaluationException) {_					throw (SpelEvaluationException)ex__				}_				else {_					throw new SpelEvaluationException(ex, SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPosition].getClass().getName(), targetType)__				}_			}_		}_	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,void,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,null,if,method,is,var,args,class,param,types,method,get,parameter,types,varargs,position,param,types,length,1,for,int,arg,position,0,arg,position,arguments,length,arg,position,type,descriptor,target,type,if,varargs,position,null,arg,position,varargs,position,method,parameter,method,param,new,method,parameter,method,varargs,position,target,type,type,descriptor,nested,method,param,1,else,target,type,new,type,descriptor,new,method,parameter,method,arg,position,try,object,argument,arguments,arg,position,if,argument,null,target,type,get,object,type,is,instance,argument,if,converter,null,throw,new,spel,evaluation,exception,spel,message,argument,get,class,get,name,target,type,arguments,arg,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,catch,evaluation,exception,ex,if,ex,instanceof,spel,evaluation,exception,throw,spel,evaluation,exception,ex,else,throw,new,spel,evaluation,exception,ex,spel,message,arguments,arg,position,get,class,get,name,target,type
ReflectionHelper -> public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException;1385412762;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does not repackage the arguments_into a form suitable for the varargs invocation_@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@throws SpelEvaluationException if there is a problem with conversion;public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {_		Integer varargsPosition = null__		if (method.isVarArgs()) {_			Class<?>[] paramTypes = method.getParameterTypes()__			varargsPosition = paramTypes.length - 1__		}_		for (int argPosition = 0_ argPosition < arguments.length_ argPosition++) {_			TypeDescriptor targetType__			if (varargsPosition != null && argPosition >= varargsPosition) {_				MethodParameter methodParam = new MethodParameter(method, varargsPosition)__				targetType = TypeDescriptor.nested(methodParam, 1)__			}_			else {_				targetType = new TypeDescriptor(new MethodParameter(method, argPosition))__			}_			try {_				Object argument = arguments[argPosition]__				if (argument != null && !targetType.getObjectType().isInstance(argument)) {_					if (converter == null) {_						throw new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType)__					}_					arguments[argPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_			catch (EvaluationException ex) {_				_				if (ex instanceof SpelEvaluationException) {_					throw (SpelEvaluationException)ex__				}_				else {_					throw new SpelEvaluationException(ex, SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPosition].getClass().getName(), targetType)__				}_			}_		}_	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,void,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,null,if,method,is,var,args,class,param,types,method,get,parameter,types,varargs,position,param,types,length,1,for,int,arg,position,0,arg,position,arguments,length,arg,position,type,descriptor,target,type,if,varargs,position,null,arg,position,varargs,position,method,parameter,method,param,new,method,parameter,method,varargs,position,target,type,type,descriptor,nested,method,param,1,else,target,type,new,type,descriptor,new,method,parameter,method,arg,position,try,object,argument,arguments,arg,position,if,argument,null,target,type,get,object,type,is,instance,argument,if,converter,null,throw,new,spel,evaluation,exception,spel,message,argument,get,class,get,name,target,type,arguments,arg,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,catch,evaluation,exception,ex,if,ex,instanceof,spel,evaluation,exception,throw,spel,evaluation,exception,ex,else,throw,new,spel,evaluation,exception,ex,spel,message,arguments,arg,position,get,class,get,name,target,type
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1328020251;Compare argument arrays and return information about whether they match. A supplied type converter_and conversionAllowed flag allow for matches to take into account that a type may be transformed_into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgsMatchKind match = ArgsMatchKind.EXACT__		List<Integer> argsRequiringConversion = null__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						} _					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						if (argsRequiringConversion == null) {_							argsRequiringConversion = new ArrayList<Integer>()__						}_						argsRequiringConversion.add(i)__						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		if (match == null) {_			return null__		}_		else {_			if (match == ArgsMatchKind.REQUIRES_CONVERSION) {_				int[] argsArray = new int[argsRequiringConversion.size()]__				for (int i = 0_ i < argsRequiringConversion.size()_ i++) {_					argsArray[i] = argsRequiringConversion.get(i)__				}_				return new ArgumentsMatchInfo(match, argsArray)__			}_			else {_				return new ArgumentsMatchInfo(match)__			}_		}_	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,args,match,kind,match,args,match,kind,exact,list,integer,args,requiring,conversion,null,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,else,if,match,args,match,kind,int,args,array,new,int,args,requiring,conversion,size,for,int,i,0,i,args,requiring,conversion,size,i,args,array,i,args,requiring,conversion,get,i,return,new,arguments,match,info,match,args,array,else,return,new,arguments,match,info,match
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1356735495;Compare argument arrays and return information about whether they match. A supplied type converter_and conversionAllowed flag allow for matches to take into account that a type may be transformed_into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgsMatchKind match = ArgsMatchKind.EXACT__		List<Integer> argsRequiringConversion = null__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						if (argsRequiringConversion == null) {_							argsRequiringConversion = new ArrayList<Integer>()__						}_						argsRequiringConversion.add(i)__						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		if (match == null) {_			return null__		}_		else {_			if (match == ArgsMatchKind.REQUIRES_CONVERSION) {_				int[] argsArray = new int[argsRequiringConversion.size()]__				for (int i = 0_ i < argsRequiringConversion.size()_ i++) {_					argsArray[i] = argsRequiringConversion.get(i)__				}_				return new ArgumentsMatchInfo(match, argsArray)__			}_			else {_				return new ArgumentsMatchInfo(match)__			}_		}_	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,args,match,kind,match,args,match,kind,exact,list,integer,args,requiring,conversion,null,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,else,if,match,args,match,kind,int,args,array,new,int,args,requiring,conversion,size,for,int,i,0,i,args,requiring,conversion,size,i,args,array,i,args,requiring,conversion,get,i,return,new,arguments,match,info,match,args,array,else,return,new,arguments,match,info,match
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1368482696;Compare argument arrays and return information about whether they match. A supplied type converter_and conversionAllowed flag allow for matches to take into account that a type may be transformed_into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgsMatchKind match = ArgsMatchKind.EXACT__		List<Integer> argsRequiringConversion = null__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						if (argsRequiringConversion == null) {_							argsRequiringConversion = new ArrayList<Integer>()__						}_						argsRequiringConversion.add(i)__						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		if (match == null) {_			return null__		}_		else {_			if (match == ArgsMatchKind.REQUIRES_CONVERSION) {_				int[] argsArray = new int[argsRequiringConversion.size()]__				for (int i = 0_ i < argsRequiringConversion.size()_ i++) {_					argsArray[i] = argsRequiringConversion.get(i)__				}_				return new ArgumentsMatchInfo(match, argsArray)__			}_			else {_				return new ArgumentsMatchInfo(match)__			}_		}_	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,args,match,kind,match,args,match,kind,exact,list,integer,args,requiring,conversion,null,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,else,if,match,args,match,kind,int,args,array,new,int,args,requiring,conversion,size,for,int,i,0,i,args,requiring,conversion,size,i,args,array,i,args,requiring,conversion,get,i,return,new,arguments,match,info,match,args,array,else,return,new,arguments,match,info,match
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1372363092;Compare argument arrays and return information about whether they match. A supplied_type converter and conversionAllowed flag allow for matches to take into account_that a type may be transformed into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of_invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was_not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgsMatchKind match = ArgsMatchKind.EXACT__		List<Integer> argsRequiringConversion = null__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						if (argsRequiringConversion == null) {_							argsRequiringConversion = new ArrayList<Integer>()__						}_						argsRequiringConversion.add(i)__						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		if (match == null) {_			return null__		}_		else {_			if (match == ArgsMatchKind.REQUIRES_CONVERSION) {_				int[] argsArray = new int[argsRequiringConversion.size()]__				for (int i = 0_ i < argsRequiringConversion.size()_ i++) {_					argsArray[i] = argsRequiringConversion.get(i)__				}_				return new ArgumentsMatchInfo(match, argsArray)__			}_			else {_				return new ArgumentsMatchInfo(match)__			}_		}_	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,args,match,kind,match,args,match,kind,exact,list,integer,args,requiring,conversion,null,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,else,if,match,args,match,kind,int,args,array,new,int,args,requiring,conversion,size,for,int,i,0,i,args,requiring,conversion,size,i,args,array,i,args,requiring,conversion,get,i,return,new,arguments,match,info,match,args,array,else,return,new,arguments,match,info,match
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1385412762;Compare argument arrays and return information about whether they match. A supplied_type converter and conversionAllowed flag allow for matches to take into account_that a type may be transformed into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of_invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was_not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgsMatchKind match = ArgsMatchKind.EXACT__		List<Integer> argsRequiringConversion = null__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						if (argsRequiringConversion == null) {_							argsRequiringConversion = new ArrayList<Integer>()__						}_						argsRequiringConversion.add(i)__						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		if (match == null) {_			return null__		}_		else {_			if (match == ArgsMatchKind.REQUIRES_CONVERSION) {_				int[] argsArray = new int[argsRequiringConversion.size()]__				for (int i = 0_ i < argsRequiringConversion.size()_ i++) {_					argsArray[i] = argsRequiringConversion.get(i)__				}_				return new ArgumentsMatchInfo(match, argsArray)__			}_			else {_				return new ArgumentsMatchInfo(match)__			}_		}_	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,args,match,kind,match,args,match,kind,exact,list,integer,args,requiring,conversion,null,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,if,args,requiring,conversion,null,args,requiring,conversion,new,array,list,integer,args,requiring,conversion,add,i,match,args,match,kind,else,match,null,if,match,null,return,null,else,if,match,args,match,kind,int,args,array,new,int,args,requiring,conversion,size,for,int,i,0,i,args,requiring,conversion,size,i,args,array,i,args,requiring,conversion,get,i,return,new,arguments,match,info,match,args,array,else,return,new,arguments,match,info,match
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1389789410;Compare argument arrays and return information about whether they match. A supplied_type converter and conversionAllowed flag allow for matches to take into account_that a type may be transformed into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgsMatchKind match = ArgsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgsMatchKind.REQUIRES_CONVERSION) {_							match = ArgsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,args,match,kind,match,args,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,args,match,kind,match,args,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,args,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1389796100;Compare argument arrays and return information about whether they match. A supplied_type converter and conversionAllowed flag allow for matches to take into account_that a type may be transformed into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1394055372;Compare argument arrays and return information about whether they match. A supplied_type converter and conversionAllowed flag allow for matches to take into account_that a type may be transformed into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1405011154;Compare argument arrays and return information about whether they match. A supplied_type converter and conversionAllowed flag allow for matches to take into account_that a type may be transformed into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1413486529;Compare argument arrays and return information about whether they match. A supplied_type converter and conversionAllowed flag allow for matches to take into account_that a type may be transformed into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1413907042;Compare argument arrays and return information about whether they match. A supplied_type converter and conversionAllowed flag allow for matches to take into account_that a type may be transformed into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1414174302;Compare argument arrays and return information about whether they match. A supplied_type converter and conversionAllowed flag allow for matches to take into account_that a type may be transformed into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1419274456;Compare argument arrays and return information about whether they match. A supplied_type converter and conversionAllowed flag allow for matches to take into account_that a type may be transformed into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1425759378;Compare argument arrays and return information about whether they match. A supplied_type converter and conversionAllowed flag allow for matches to take into account_that a type may be transformed into a different type by the converter._@param expectedArgTypes the array of types the method/constructor is expecting_@param suppliedArgTypes the array of types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was or null if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,array,of,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,array,of,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1426108143;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to take_into account that a type may be transformed into a different type by the converter._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1449965678;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to take_into account that a type may be transformed into a different type by the converter._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1467844672;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to take_into account that a type may be transformed into a different type by the converter._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> static ArgumentsMatchInfo compareArguments( 			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter);1473796721;Compare argument arrays and return information about whether they match._A supplied type converter and conversionAllowed flag allow for matches to take_into account that a type may be transformed into a different type by the converter._@param expectedArgTypes the types the method/constructor is expecting_@param suppliedArgTypes the types that are being supplied at the point of invocation_@param typeConverter a registered type converter_@return a MatchInfo object indicating what kind of match it was,_or {@code null} if it was not a match;static ArgumentsMatchInfo compareArguments(_			List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {__		Assert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),_				"Expected argument types and supplied argument types should be arrays of same length")___		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT__		for (int i = 0_ i < expectedArgTypes.size() && match != null_ i++) {_			TypeDescriptor suppliedArg = suppliedArgTypes.get(i)__			TypeDescriptor expectedArg = expectedArgTypes.get(i)__			if (!expectedArg.equals(suppliedArg)) {_				_				if (suppliedArg == null) {_					if (expectedArg.isPrimitive()) {_						match = null__					}_				}_				else {_					if (suppliedArg.isAssignableTo(expectedArg)) {_						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {_							match = ArgumentsMatchKind.CLOSE__						}_					}_					else if (typeConverter.canConvert(suppliedArg, expectedArg)) {_						match = ArgumentsMatchKind.REQUIRES_CONVERSION__					}_					else {_						match = null__					}_				}_			}_		}_		return (match != null ? new ArgumentsMatchInfo(match) : null)__	};compare,argument,arrays,and,return,information,about,whether,they,match,a,supplied,type,converter,and,conversion,allowed,flag,allow,for,matches,to,take,into,account,that,a,type,may,be,transformed,into,a,different,type,by,the,converter,param,expected,arg,types,the,types,the,method,constructor,is,expecting,param,supplied,arg,types,the,types,that,are,being,supplied,at,the,point,of,invocation,param,type,converter,a,registered,type,converter,return,a,match,info,object,indicating,what,kind,of,match,it,was,or,code,null,if,it,was,not,a,match;static,arguments,match,info,compare,arguments,list,type,descriptor,expected,arg,types,list,type,descriptor,supplied,arg,types,type,converter,type,converter,assert,is,true,expected,arg,types,size,supplied,arg,types,size,expected,argument,types,and,supplied,argument,types,should,be,arrays,of,same,length,arguments,match,kind,match,arguments,match,kind,exact,for,int,i,0,i,expected,arg,types,size,match,null,i,type,descriptor,supplied,arg,supplied,arg,types,get,i,type,descriptor,expected,arg,expected,arg,types,get,i,if,expected,arg,equals,supplied,arg,if,supplied,arg,null,if,expected,arg,is,primitive,match,null,else,if,supplied,arg,is,assignable,to,expected,arg,if,match,arguments,match,kind,match,arguments,match,kind,close,else,if,type,converter,can,convert,supplied,arg,expected,arg,match,arguments,match,kind,else,match,null,return,match,null,new,arguments,match,info,match,null
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray);1496837955;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,nullable,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray);1522307598;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,nullable,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray);1525211306;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,nullable,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> private static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray);1530174524;Check if the supplied value is the first entry in the array represented by the possibleArray value._@param value the value to check for in the array_@param possibleArray an array object that may have the supplied value as the first element_@return true if the supplied value is the first entry in the array;private static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray) {_		if (possibleArray == null) {_			return false__		}_		Class<?> type = possibleArray.getClass()__		if (!type.isArray() || Array.getLength(possibleArray) == 0 ||_				!ClassUtils.isAssignableValue(type.getComponentType(), value)) {_			return false__		}_		Object arrayValue = Array.get(possibleArray, 0)__		return (type.getComponentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value)__	};check,if,the,supplied,value,is,the,first,entry,in,the,array,represented,by,the,possible,array,value,param,value,the,value,to,check,for,in,the,array,param,possible,array,an,array,object,that,may,have,the,supplied,value,as,the,first,element,return,true,if,the,supplied,value,is,the,first,entry,in,the,array;private,static,boolean,is,first,entry,in,array,object,value,nullable,object,possible,array,if,possible,array,null,return,false,class,type,possible,array,get,class,if,type,is,array,array,get,length,possible,array,0,class,utils,is,assignable,value,type,get,component,type,value,return,false,object,array,value,array,get,possible,array,0,return,type,get,component,type,is,primitive,array,value,equals,value,array,value,value
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1449965678;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = (method.isVarArgs() ? method.getParameterTypes().length - 1 : null)__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,types,length,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1467844672;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null)__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,count,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1473796721;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null)__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,count,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1495868221;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null)__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,count,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1496242568;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null)__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,count,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1496837955;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null)__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,count,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1522307598;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null)__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,count,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1525211306;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null)__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,count,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) 			throws SpelEvaluationException;1530174524;Convert a supplied set of arguments into the requested types. If the parameterTypes are related to_a varargs method then the final entry in the parameterTypes array is going to be an array itself whose_component type should be used as the conversion target for extraneous arguments. (For example, if the_parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both_the boolean and float must be converted to strings). This method does *not* repackage the arguments_into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that._@param converter the converter to use for type conversions_@param arguments the arguments to convert to the requested parameter types_@param method the target Method_@return true if some kind of conversion occurred on the argument_@throws SpelEvaluationException if there is a problem with conversion;public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)_			throws SpelEvaluationException {__		Integer varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null)__		return convertArguments(converter, arguments, method, varargsPosition)__	};convert,a,supplied,set,of,arguments,into,the,requested,types,if,the,parameter,types,are,related,to,a,varargs,method,then,the,final,entry,in,the,parameter,types,array,is,going,to,be,an,array,itself,whose,component,type,should,be,used,as,the,conversion,target,for,extraneous,arguments,for,example,if,the,parameter,types,are,integer,string,and,the,input,arguments,are,integer,boolean,float,then,both,the,boolean,and,float,must,be,converted,to,strings,this,method,does,not,repackage,the,arguments,into,a,form,suitable,for,the,varargs,invocation,a,subsequent,call,to,setup,arguments,for,varargs,invocation,handles,that,param,converter,the,converter,to,use,for,type,conversions,param,arguments,the,arguments,to,convert,to,the,requested,parameter,types,param,method,the,target,method,return,true,if,some,kind,of,conversion,occurred,on,the,argument,throws,spel,evaluation,exception,if,there,is,a,problem,with,conversion;public,static,boolean,convert,all,arguments,type,converter,converter,object,arguments,method,method,throws,spel,evaluation,exception,integer,varargs,position,method,is,var,args,method,get,parameter,count,1,null,return,convert,arguments,converter,arguments,method,varargs,position
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1328020251;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0,max=paramTypes.size()_ i < max_ i++) {_			TypeDescriptor argType = argTypes.get(i)__			TypeDescriptor paramType = paramTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			if (!ClassUtils.isAssignable(paramType.getClass(), argType.getClass())) {_				return Integer.MAX_VALUE__			}_			if (argType != null) {_				Class paramTypeClazz = paramType.getType()__				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__			    }_				Class superClass = argType.getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,max,param,types,size,i,max,i,type,descriptor,arg,type,arg,types,get,i,type,descriptor,param,type,param,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,if,class,utils,is,assignable,param,type,get,class,arg,type,get,class,return,integer,if,arg,type,null,class,param,type,clazz,param,type,get,type,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1356735495;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0,max=paramTypes.size()_ i < max_ i++) {_			TypeDescriptor argType = argTypes.get(i)__			TypeDescriptor paramType = paramTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			if (!ClassUtils.isAssignable(paramType.getClass(), argType.getClass())) {_				return Integer.MAX_VALUE__			}_			if (argType != null) {_				Class paramTypeClazz = paramType.getType()__				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class superClass = argType.getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,max,param,types,size,i,max,i,type,descriptor,arg,type,arg,types,get,i,type,descriptor,param,type,param,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,if,class,utils,is,assignable,param,type,get,class,arg,type,get,class,return,integer,if,arg,type,null,class,param,type,clazz,param,type,get,type,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1368482696;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0,max=paramTypes.size()_ i < max_ i++) {_			TypeDescriptor argType = argTypes.get(i)__			TypeDescriptor paramType = paramTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			if (!ClassUtils.isAssignable(paramType.getClass(), argType.getClass())) {_				return Integer.MAX_VALUE__			}_			if (argType != null) {_				Class paramTypeClazz = paramType.getType()__				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class superClass = argType.getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,max,param,types,size,i,max,i,type,descriptor,arg,type,arg,types,get,i,type,descriptor,param,type,param,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,if,class,utils,is,assignable,param,type,get,class,arg,type,get,class,return,integer,if,arg,type,null,class,param,type,clazz,param,type,get,type,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1372363092;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0,max=paramTypes.size()_ i < max_ i++) {_			TypeDescriptor argType = argTypes.get(i)__			TypeDescriptor paramType = paramTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			if (!ClassUtils.isAssignable(paramType.getClass(), argType.getClass())) {_				return Integer.MAX_VALUE__			}_			if (argType != null) {_				Class paramTypeClazz = paramType.getType()__				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class superClass = argType.getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,max,param,types,size,i,max,i,type,descriptor,arg,type,arg,types,get,i,type,descriptor,param,type,param,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,if,class,utils,is,assignable,param,type,get,class,arg,type,get,class,return,integer,if,arg,type,null,class,param,type,clazz,param,type,get,type,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1385412762;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0,max=paramTypes.size()_ i < max_ i++) {_			TypeDescriptor argType = argTypes.get(i)__			TypeDescriptor paramType = paramTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			if (!ClassUtils.isAssignable(paramType.getClass(), argType.getClass())) {_				return Integer.MAX_VALUE__			}_			if (argType != null) {_				Class<?> paramTypeClazz = paramType.getType()__				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,max,param,types,size,i,max,i,type,descriptor,arg,type,arg,types,get,i,type,descriptor,param,type,param,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,if,class,utils,is,assignable,param,type,get,class,arg,type,get,class,return,integer,if,arg,type,null,class,param,type,clazz,param,type,get,type,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1389789410;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = argTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,arg,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1389796100;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = argTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,arg,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1394055372;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = argTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,arg,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1405011154;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = argTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,arg,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1413486529;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = argTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,arg,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1413907042;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = argTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,arg,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1414174302;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = argTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,arg,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1419274456;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = argTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,arg,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1425759378;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = argTypes.get(i)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,arg,types,get,i,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1426108143;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,i,arg,types,size,arg,types,get,i,null,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1449965678;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,i,arg,types,size,arg,types,get,i,null,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1467844672;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,i,arg,types,size,arg,types,get,i,null,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1473796721;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,i,arg,types,size,arg,types,get,i,null,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1495868221;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,i,arg,types,size,arg,types,get,i,null,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1496242568;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,i,arg,types,size,arg,types,get,i,null,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1496837955;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,i,arg,types,size,arg,types,get,i,null,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1522307598;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,i,arg,types,size,arg,types,get,i,null,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1525211306;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,i,arg,types,size,arg,types,get,i,null,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes);1530174524;Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.;public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {_		int result = 0__		for (int i = 0_ i < paramTypes.size()_ i++) {_			TypeDescriptor paramType = paramTypes.get(i)__			TypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null)__			if (argType == null) {_				if (paramType.isPrimitive()) {_					return Integer.MAX_VALUE__				}_			}_			else {_				Class<?> paramTypeClazz = paramType.getType()__				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {_					return Integer.MAX_VALUE__				}_				if (paramTypeClazz.isPrimitive()) {_					paramTypeClazz = Object.class__				}_				Class<?> superClass = argType.getType().getSuperclass()__				while (superClass != null) {_					if (paramTypeClazz.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramTypeClazz.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};based,on,link,method,invoker,get,type,difference,weight,class,object,but,operates,on,type,descriptors;public,static,int,get,type,difference,weight,list,type,descriptor,param,types,list,type,descriptor,arg,types,int,result,0,for,int,i,0,i,param,types,size,i,type,descriptor,param,type,param,types,get,i,type,descriptor,arg,type,i,arg,types,size,arg,types,get,i,null,if,arg,type,null,if,param,type,is,primitive,return,integer,else,class,param,type,clazz,param,type,get,type,if,class,utils,is,assignable,param,type,clazz,arg,type,get,type,return,integer,if,param,type,clazz,is,primitive,param,type,clazz,object,class,class,super,class,arg,type,get,type,get,superclass,while,super,class,null,if,param,type,clazz,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,clazz,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,clazz,is,interface,result,result,1,return,result
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable, 			Integer varargsPosition) throws EvaluationException;1467844672;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param executable the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_({@code null} if not varargs)_@return {@code true} if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,_			Integer varargsPosition) throws EvaluationException {__		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] &&_						!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,executable,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,code,null,if,not,varargs,return,code,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,executable,executable,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,executable,executable,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable, 			Integer varargsPosition) throws EvaluationException;1473796721;Takes an input set of argument values and converts them to the types specified as the_required parameter types. The arguments are converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param executable the target Method or Constructor_@param varargsPosition the known position of the varargs argument, if any_({@code null} if not varargs)_@return {@code true} if some kind of conversion occurred on an argument_@throws EvaluationException if a problem occurs during conversion;static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,_			Integer varargsPosition) throws EvaluationException {__		boolean conversionOccurred = false__		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_		}_		else {_			_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				conversionOccurred |= (argument != arguments[i])__			}_			MethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				TypeDescriptor sourceType = TypeDescriptor.forObject(argument)__				arguments[varargsPosition] = converter.convertValue(argument, sourceType, targetType)__				_				_				_				_				if (argument != arguments[varargsPosition] &&_						!isFirstEntryInArray(argument, arguments[varargsPosition])) {_					conversionOccurred = true_ _				}_			}_			else {_				_				TypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor()__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__					conversionOccurred |= (argument != arguments[i])__				}_			}_		}_		return conversionOccurred__	};takes,an,input,set,of,argument,values,and,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,executable,the,target,method,or,constructor,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,code,null,if,not,varargs,return,code,true,if,some,kind,of,conversion,occurred,on,an,argument,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,boolean,convert,arguments,type,converter,converter,object,arguments,executable,executable,integer,varargs,position,throws,evaluation,exception,boolean,conversion,occurred,false,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,executable,executable,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,method,parameter,method,param,method,parameter,for,executable,executable,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,type,descriptor,source,type,type,descriptor,for,object,argument,arguments,varargs,position,converter,convert,value,argument,source,type,target,type,if,argument,arguments,varargs,position,is,first,entry,in,array,argument,arguments,varargs,position,conversion,occurred,true,else,type,descriptor,target,type,new,type,descriptor,method,param,get,element,type,descriptor,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,conversion,occurred,argument,arguments,i,return,conversion,occurred
ReflectionHelper -> static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			int[] argumentsRequiringConversion, Integer varargsPosition) throws EvaluationException;1328020251;Takes an input set of argument values and, following the positions specified in the int array,_it converts them to the types specified as the required parameter types. The arguments are_converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param argumentsRequiringConversion details which of the input arguments for sure need conversion_@param varargsPosition the known position of the varargs argument, if any_@throws EvaluationException if a problem occurs during conversion;static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			int[] argumentsRequiringConversion, Integer varargsPosition) throws EvaluationException {_		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_		} else {_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)_				_			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				TypeDescriptor targetType = new TypeDescriptor(methodParam)_				_				Object argument = arguments[varargsPosition]__				arguments[varargsPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)_					_			} else {_				TypeDescriptor targetType = TypeDescriptor.nested(methodParam, 1)__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)_					_				}_			}_		}_	};takes,an,input,set,of,argument,values,and,following,the,positions,specified,in,the,int,array,it,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,arguments,requiring,conversion,details,which,of,the,input,arguments,for,sure,need,conversion,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,void,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,int,arguments,requiring,conversion,integer,varargs,position,throws,evaluation,exception,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,arguments,varargs,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,type,descriptor,target,type,type,descriptor,nested,method,param,1,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type
ReflectionHelper -> static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			int[] argumentsRequiringConversion, Integer varargsPosition) throws EvaluationException;1356735495;Takes an input set of argument values and, following the positions specified in the int array,_it converts them to the types specified as the required parameter types. The arguments are_converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param argumentsRequiringConversion details which of the input arguments for sure need conversion_@param varargsPosition the known position of the varargs argument, if any_@throws EvaluationException if a problem occurs during conversion;static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			int[] argumentsRequiringConversion, Integer varargsPosition) throws EvaluationException {_		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_		} else {_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				arguments[varargsPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			} else {_				TypeDescriptor targetType = TypeDescriptor.nested(methodParam, 1)__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_		}_	};takes,an,input,set,of,argument,values,and,following,the,positions,specified,in,the,int,array,it,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,arguments,requiring,conversion,details,which,of,the,input,arguments,for,sure,need,conversion,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,void,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,int,arguments,requiring,conversion,integer,varargs,position,throws,evaluation,exception,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,arguments,varargs,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,type,descriptor,target,type,type,descriptor,nested,method,param,1,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type
ReflectionHelper -> static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			int[] argumentsRequiringConversion, Integer varargsPosition) throws EvaluationException;1368482696;Takes an input set of argument values and, following the positions specified in the int array,_it converts them to the types specified as the required parameter types. The arguments are_converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param argumentsRequiringConversion details which of the input arguments for sure need conversion_@param varargsPosition the known position of the varargs argument, if any_@throws EvaluationException if a problem occurs during conversion;static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			int[] argumentsRequiringConversion, Integer varargsPosition) throws EvaluationException {_		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_		} else {_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				arguments[varargsPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			} else {_				TypeDescriptor targetType = TypeDescriptor.nested(methodParam, 1)__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_		}_	};takes,an,input,set,of,argument,values,and,following,the,positions,specified,in,the,int,array,it,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,arguments,requiring,conversion,details,which,of,the,input,arguments,for,sure,need,conversion,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,void,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,int,arguments,requiring,conversion,integer,varargs,position,throws,evaluation,exception,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,arguments,varargs,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,type,descriptor,target,type,type,descriptor,nested,method,param,1,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type
ReflectionHelper -> static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			int[] argumentsRequiringConversion, Integer varargsPosition) throws EvaluationException;1372363092;Takes an input set of argument values and, following the positions specified in the int array,_it converts them to the types specified as the required parameter types. The arguments are_converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param argumentsRequiringConversion details which of the input arguments for sure need conversion_@param varargsPosition the known position of the varargs argument, if any_@throws EvaluationException if a problem occurs during conversion;static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			int[] argumentsRequiringConversion, Integer varargsPosition) throws EvaluationException {_		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_		} else {_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				arguments[varargsPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			} else {_				TypeDescriptor targetType = TypeDescriptor.nested(methodParam, 1)__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_		}_	};takes,an,input,set,of,argument,values,and,following,the,positions,specified,in,the,int,array,it,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,arguments,requiring,conversion,details,which,of,the,input,arguments,for,sure,need,conversion,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,void,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,int,arguments,requiring,conversion,integer,varargs,position,throws,evaluation,exception,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,arguments,varargs,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,type,descriptor,target,type,type,descriptor,nested,method,param,1,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type
ReflectionHelper -> static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor, 			int[] argumentsRequiringConversion, Integer varargsPosition) throws EvaluationException;1385412762;Takes an input set of argument values and, following the positions specified in the int array,_it converts them to the types specified as the required parameter types. The arguments are_converted 'in-place' in the input array._@param converter the type converter to use for attempting conversions_@param arguments the actual arguments that need conversion_@param methodOrCtor the target Method or Constructor_@param argumentsRequiringConversion details which of the input arguments for sure need conversion_@param varargsPosition the known position of the varargs argument, if any_@throws EvaluationException if a problem occurs during conversion;static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,_			int[] argumentsRequiringConversion, Integer varargsPosition) throws EvaluationException {_		if (varargsPosition == null) {_			for (int i = 0_ i < arguments.length_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_		} else {_			for (int i = 0_ i < varargsPosition_ i++) {_				TypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i))__				Object argument = arguments[i]__				arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			}_			MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition)__			if (varargsPosition == arguments.length - 1) {_				TypeDescriptor targetType = new TypeDescriptor(methodParam)__				Object argument = arguments[varargsPosition]__				arguments[varargsPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__			} else {_				TypeDescriptor targetType = TypeDescriptor.nested(methodParam, 1)__				for (int i = varargsPosition_ i < arguments.length_ i++) {_					Object argument = arguments[i]__					arguments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType)__				}_			}_		}_	};takes,an,input,set,of,argument,values,and,following,the,positions,specified,in,the,int,array,it,converts,them,to,the,types,specified,as,the,required,parameter,types,the,arguments,are,converted,in,place,in,the,input,array,param,converter,the,type,converter,to,use,for,attempting,conversions,param,arguments,the,actual,arguments,that,need,conversion,param,method,or,ctor,the,target,method,or,constructor,param,arguments,requiring,conversion,details,which,of,the,input,arguments,for,sure,need,conversion,param,varargs,position,the,known,position,of,the,varargs,argument,if,any,throws,evaluation,exception,if,a,problem,occurs,during,conversion;static,void,convert,arguments,type,converter,converter,object,arguments,object,method,or,ctor,int,arguments,requiring,conversion,integer,varargs,position,throws,evaluation,exception,if,varargs,position,null,for,int,i,0,i,arguments,length,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,for,int,i,0,i,varargs,position,i,type,descriptor,target,type,new,type,descriptor,method,parameter,for,method,or,constructor,method,or,ctor,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,method,parameter,method,param,method,parameter,for,method,or,constructor,method,or,ctor,varargs,position,if,varargs,position,arguments,length,1,type,descriptor,target,type,new,type,descriptor,method,param,object,argument,arguments,varargs,position,arguments,varargs,position,converter,convert,value,argument,type,descriptor,for,object,argument,target,type,else,type,descriptor,target,type,type,descriptor,nested,method,param,1,for,int,i,varargs,position,i,arguments,length,i,object,argument,arguments,i,arguments,i,converter,convert,value,argument,type,descriptor,for,object,argument,target,type
