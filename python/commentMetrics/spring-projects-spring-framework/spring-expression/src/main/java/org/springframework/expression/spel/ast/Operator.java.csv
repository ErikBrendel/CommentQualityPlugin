# id;timestamp;commentText;codeText;commentWords;codeWords
Operator -> public static boolean equalityCheck(EvaluationContext context, Object left, Object right);1478083559;Perform an equality check for the given operand values._<p>This method is not just used for reflective comparisons in subclasses_but also from compiled expression code, which is why it needs to be_declared as {@code public static} here._@param context the current evaluation context_@param left the left-hand operand value_@param right the right-hand operand value;public static boolean equalityCheck(EvaluationContext context, Object left, Object right) {_		if (left instanceof Number && right instanceof Number) {_			Number leftNumber = (Number) left__			Number rightNumber = (Number) right___			if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {_				BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class)__				BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class)__				return (leftBigDecimal == null ? rightBigDecimal == null : leftBigDecimal.compareTo(rightBigDecimal) == 0)__			}_			else if (leftNumber instanceof Double || rightNumber instanceof Double) {_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_			else if (leftNumber instanceof Float || rightNumber instanceof Float) {_				return (leftNumber.floatValue() == rightNumber.floatValue())__			}_			else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {_				BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class)__				BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class)__				return (leftBigInteger == null ? rightBigInteger == null : leftBigInteger.compareTo(rightBigInteger) == 0)__			}_			else if (leftNumber instanceof Long || rightNumber instanceof Long) {_				return (leftNumber.longValue() == rightNumber.longValue())__			}_			else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {_				return (leftNumber.intValue() == rightNumber.intValue())__			}_			else if (leftNumber instanceof Short || rightNumber instanceof Short) {_				return (leftNumber.shortValue() == rightNumber.shortValue())__			}_			else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {_				return (leftNumber.byteValue() == rightNumber.byteValue())__			}_			else {_				_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_		}__		if (left instanceof CharSequence && right instanceof CharSequence) {_			return left.toString().equals(right.toString())__		}__		if (ObjectUtils.nullSafeEquals(left, right)) {_			return true__		}__		if (left instanceof Comparable && right instanceof Comparable) {_			Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass())__			if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {_				return (context.getTypeComparator().compare(left, right) == 0)__			}_		}__		return false__	};perform,an,equality,check,for,the,given,operand,values,p,this,method,is,not,just,used,for,reflective,comparisons,in,subclasses,but,also,from,compiled,expression,code,which,is,why,it,needs,to,be,declared,as,code,public,static,here,param,context,the,current,evaluation,context,param,left,the,left,hand,operand,value,param,right,the,right,hand,operand,value;public,static,boolean,equality,check,evaluation,context,context,object,left,object,right,if,left,instanceof,number,right,instanceof,number,number,left,number,number,left,number,right,number,number,right,if,left,number,instanceof,big,decimal,right,number,instanceof,big,decimal,big,decimal,left,big,decimal,number,utils,convert,number,to,target,class,left,number,big,decimal,class,big,decimal,right,big,decimal,number,utils,convert,number,to,target,class,right,number,big,decimal,class,return,left,big,decimal,null,right,big,decimal,null,left,big,decimal,compare,to,right,big,decimal,0,else,if,left,number,instanceof,double,right,number,instanceof,double,return,left,number,double,value,right,number,double,value,else,if,left,number,instanceof,float,right,number,instanceof,float,return,left,number,float,value,right,number,float,value,else,if,left,number,instanceof,big,integer,right,number,instanceof,big,integer,big,integer,left,big,integer,number,utils,convert,number,to,target,class,left,number,big,integer,class,big,integer,right,big,integer,number,utils,convert,number,to,target,class,right,number,big,integer,class,return,left,big,integer,null,right,big,integer,null,left,big,integer,compare,to,right,big,integer,0,else,if,left,number,instanceof,long,right,number,instanceof,long,return,left,number,long,value,right,number,long,value,else,if,left,number,instanceof,integer,right,number,instanceof,integer,return,left,number,int,value,right,number,int,value,else,if,left,number,instanceof,short,right,number,instanceof,short,return,left,number,short,value,right,number,short,value,else,if,left,number,instanceof,byte,right,number,instanceof,byte,return,left,number,byte,value,right,number,byte,value,else,return,left,number,double,value,right,number,double,value,if,left,instanceof,char,sequence,right,instanceof,char,sequence,return,left,to,string,equals,right,to,string,if,object,utils,null,safe,equals,left,right,return,true,if,left,instanceof,comparable,right,instanceof,comparable,class,ancestor,class,utils,determine,common,ancestor,left,get,class,right,get,class,if,ancestor,null,comparable,class,is,assignable,from,ancestor,return,context,get,type,comparator,compare,left,right,0,return,false
Operator -> public static boolean equalityCheck(EvaluationContext context, Object left, Object right);1485810955;Perform an equality check for the given operand values._<p>This method is not just used for reflective comparisons in subclasses_but also from compiled expression code, which is why it needs to be_declared as {@code public static} here._@param context the current evaluation context_@param left the left-hand operand value_@param right the right-hand operand value;public static boolean equalityCheck(EvaluationContext context, Object left, Object right) {_		if (left instanceof Number && right instanceof Number) {_			Number leftNumber = (Number) left__			Number rightNumber = (Number) right___			if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {_				BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class)__				BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class)__				return (leftBigDecimal == null ? rightBigDecimal == null : leftBigDecimal.compareTo(rightBigDecimal) == 0)__			}_			else if (leftNumber instanceof Double || rightNumber instanceof Double) {_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_			else if (leftNumber instanceof Float || rightNumber instanceof Float) {_				return (leftNumber.floatValue() == rightNumber.floatValue())__			}_			else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {_				BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class)__				BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class)__				return (leftBigInteger == null ? rightBigInteger == null : leftBigInteger.compareTo(rightBigInteger) == 0)__			}_			else if (leftNumber instanceof Long || rightNumber instanceof Long) {_				return (leftNumber.longValue() == rightNumber.longValue())__			}_			else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {_				return (leftNumber.intValue() == rightNumber.intValue())__			}_			else if (leftNumber instanceof Short || rightNumber instanceof Short) {_				return (leftNumber.shortValue() == rightNumber.shortValue())__			}_			else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {_				return (leftNumber.byteValue() == rightNumber.byteValue())__			}_			else {_				_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_		}__		if (left instanceof CharSequence && right instanceof CharSequence) {_			return left.toString().equals(right.toString())__		}__		if (ObjectUtils.nullSafeEquals(left, right)) {_			return true__		}__		if (left instanceof Comparable && right instanceof Comparable) {_			Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass())__			if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {_				return (context.getTypeComparator().compare(left, right) == 0)__			}_		}__		return false__	};perform,an,equality,check,for,the,given,operand,values,p,this,method,is,not,just,used,for,reflective,comparisons,in,subclasses,but,also,from,compiled,expression,code,which,is,why,it,needs,to,be,declared,as,code,public,static,here,param,context,the,current,evaluation,context,param,left,the,left,hand,operand,value,param,right,the,right,hand,operand,value;public,static,boolean,equality,check,evaluation,context,context,object,left,object,right,if,left,instanceof,number,right,instanceof,number,number,left,number,number,left,number,right,number,number,right,if,left,number,instanceof,big,decimal,right,number,instanceof,big,decimal,big,decimal,left,big,decimal,number,utils,convert,number,to,target,class,left,number,big,decimal,class,big,decimal,right,big,decimal,number,utils,convert,number,to,target,class,right,number,big,decimal,class,return,left,big,decimal,null,right,big,decimal,null,left,big,decimal,compare,to,right,big,decimal,0,else,if,left,number,instanceof,double,right,number,instanceof,double,return,left,number,double,value,right,number,double,value,else,if,left,number,instanceof,float,right,number,instanceof,float,return,left,number,float,value,right,number,float,value,else,if,left,number,instanceof,big,integer,right,number,instanceof,big,integer,big,integer,left,big,integer,number,utils,convert,number,to,target,class,left,number,big,integer,class,big,integer,right,big,integer,number,utils,convert,number,to,target,class,right,number,big,integer,class,return,left,big,integer,null,right,big,integer,null,left,big,integer,compare,to,right,big,integer,0,else,if,left,number,instanceof,long,right,number,instanceof,long,return,left,number,long,value,right,number,long,value,else,if,left,number,instanceof,integer,right,number,instanceof,integer,return,left,number,int,value,right,number,int,value,else,if,left,number,instanceof,short,right,number,instanceof,short,return,left,number,short,value,right,number,short,value,else,if,left,number,instanceof,byte,right,number,instanceof,byte,return,left,number,byte,value,right,number,byte,value,else,return,left,number,double,value,right,number,double,value,if,left,instanceof,char,sequence,right,instanceof,char,sequence,return,left,to,string,equals,right,to,string,if,object,utils,null,safe,equals,left,right,return,true,if,left,instanceof,comparable,right,instanceof,comparable,class,ancestor,class,utils,determine,common,ancestor,left,get,class,right,get,class,if,ancestor,null,comparable,class,is,assignable,from,ancestor,return,context,get,type,comparator,compare,left,right,0,return,false
Operator -> public static boolean equalityCheck(EvaluationContext context, Object left, Object right);1495868221;Perform an equality check for the given operand values._<p>This method is not just used for reflective comparisons in subclasses_but also from compiled expression code, which is why it needs to be_declared as {@code public static} here._@param context the current evaluation context_@param left the left-hand operand value_@param right the right-hand operand value;public static boolean equalityCheck(EvaluationContext context, Object left, Object right) {_		if (left instanceof Number && right instanceof Number) {_			Number leftNumber = (Number) left__			Number rightNumber = (Number) right___			if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {_				BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class)__				BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class)__				return (leftBigDecimal == null ? rightBigDecimal == null : leftBigDecimal.compareTo(rightBigDecimal) == 0)__			}_			else if (leftNumber instanceof Double || rightNumber instanceof Double) {_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_			else if (leftNumber instanceof Float || rightNumber instanceof Float) {_				return (leftNumber.floatValue() == rightNumber.floatValue())__			}_			else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {_				BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class)__				BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class)__				return (leftBigInteger == null ? rightBigInteger == null : leftBigInteger.compareTo(rightBigInteger) == 0)__			}_			else if (leftNumber instanceof Long || rightNumber instanceof Long) {_				return (leftNumber.longValue() == rightNumber.longValue())__			}_			else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {_				return (leftNumber.intValue() == rightNumber.intValue())__			}_			else if (leftNumber instanceof Short || rightNumber instanceof Short) {_				return (leftNumber.shortValue() == rightNumber.shortValue())__			}_			else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {_				return (leftNumber.byteValue() == rightNumber.byteValue())__			}_			else {_				_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_		}__		if (left instanceof CharSequence && right instanceof CharSequence) {_			return left.toString().equals(right.toString())__		}__		if (ObjectUtils.nullSafeEquals(left, right)) {_			return true__		}__		if (left instanceof Comparable && right instanceof Comparable) {_			Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass())__			if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {_				return (context.getTypeComparator().compare(left, right) == 0)__			}_		}__		return false__	};perform,an,equality,check,for,the,given,operand,values,p,this,method,is,not,just,used,for,reflective,comparisons,in,subclasses,but,also,from,compiled,expression,code,which,is,why,it,needs,to,be,declared,as,code,public,static,here,param,context,the,current,evaluation,context,param,left,the,left,hand,operand,value,param,right,the,right,hand,operand,value;public,static,boolean,equality,check,evaluation,context,context,object,left,object,right,if,left,instanceof,number,right,instanceof,number,number,left,number,number,left,number,right,number,number,right,if,left,number,instanceof,big,decimal,right,number,instanceof,big,decimal,big,decimal,left,big,decimal,number,utils,convert,number,to,target,class,left,number,big,decimal,class,big,decimal,right,big,decimal,number,utils,convert,number,to,target,class,right,number,big,decimal,class,return,left,big,decimal,null,right,big,decimal,null,left,big,decimal,compare,to,right,big,decimal,0,else,if,left,number,instanceof,double,right,number,instanceof,double,return,left,number,double,value,right,number,double,value,else,if,left,number,instanceof,float,right,number,instanceof,float,return,left,number,float,value,right,number,float,value,else,if,left,number,instanceof,big,integer,right,number,instanceof,big,integer,big,integer,left,big,integer,number,utils,convert,number,to,target,class,left,number,big,integer,class,big,integer,right,big,integer,number,utils,convert,number,to,target,class,right,number,big,integer,class,return,left,big,integer,null,right,big,integer,null,left,big,integer,compare,to,right,big,integer,0,else,if,left,number,instanceof,long,right,number,instanceof,long,return,left,number,long,value,right,number,long,value,else,if,left,number,instanceof,integer,right,number,instanceof,integer,return,left,number,int,value,right,number,int,value,else,if,left,number,instanceof,short,right,number,instanceof,short,return,left,number,short,value,right,number,short,value,else,if,left,number,instanceof,byte,right,number,instanceof,byte,return,left,number,byte,value,right,number,byte,value,else,return,left,number,double,value,right,number,double,value,if,left,instanceof,char,sequence,right,instanceof,char,sequence,return,left,to,string,equals,right,to,string,if,object,utils,null,safe,equals,left,right,return,true,if,left,instanceof,comparable,right,instanceof,comparable,class,ancestor,class,utils,determine,common,ancestor,left,get,class,right,get,class,if,ancestor,null,comparable,class,is,assignable,from,ancestor,return,context,get,type,comparator,compare,left,right,0,return,false
Operator -> @Override 	public String toStringAST();1328020251;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder()__		sb.append("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1356735495;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder()__		sb.append("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1372363092;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder()__		sb.append("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1385064520;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder()__		sb.append("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1385073193;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder()__		sb.append("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1398115780;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder()__		sb.append("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1405011154;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder()__		sb.append("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1405514506;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder()__		sb.append("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1406656976;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder()__		sb.append("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1412630983;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1477938285;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1478032943;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1478083559;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1485810955;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1495868221;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1496837955;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1497341594;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1498780456;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1518260959;String format for all operators is the same '(' [operand] [operator] [operand] ')';@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1530174524;String format for all operators is the same_{@code '(' [operand] [operator] [operand] ')'}.;@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,code,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1530174524;String format for all operators is the same_{@code '(' [operand] [operator] [operand] ')'}.;@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,code,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1535712082;String format for all operators is the same_{@code '(' [operand] [operator] [operand] ')'}.;@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,code,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> @Override 	public String toStringAST();1548712256;String format for all operators is the same_{@code '(' [operand] [operator] [operand] ')'}.;@Override_	public String toStringAST() {_		StringBuilder sb = new StringBuilder("(")__		sb.append(getChild(0).toStringAST())__		for (int i = 1_ i < getChildCount()_ i++) {_			sb.append(" ").append(getOperatorName()).append(" ")__			sb.append(getChild(i).toStringAST())__		}_		sb.append(")")__		return sb.toString()__	};string,format,for,all,operators,is,the,same,code,operand,operator,operand;override,public,string,to,string,ast,string,builder,sb,new,string,builder,sb,append,get,child,0,to,string,ast,for,int,i,1,i,get,child,count,i,sb,append,append,get,operator,name,append,sb,append,get,child,i,to,string,ast,sb,append,return,sb,to,string
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1412630983;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		String leftDesc = getLeftOperand().exitTypeDescriptor__		String rightDesc = getRightOperand().exitTypeDescriptor__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(leftDesc, rightDesc,_				this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType__		_		getLeftOperand().generateCode(mv, cf)__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		cf.enterCompilationScope()__		getRightOperand().generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType=='D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType=='F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType=='J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType=='I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor "+leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,string,left,desc,get,left,operand,exit,type,descriptor,string,right,desc,get,right,operand,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,get,left,operand,generate,code,mv,cf,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,get,right,operand,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1477938285;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		String leftDesc = getLeftOperand().exitTypeDescriptor__		String rightDesc = getRightOperand().exitTypeDescriptor__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  _		_		getLeftOperand().generateCode(mv, cf)__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		cf.enterCompilationScope()__		getRightOperand().generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,string,left,desc,get,left,operand,exit,type,descriptor,string,right,desc,get,right,operand,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,get,left,operand,generate,code,mv,cf,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,get,right,operand,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1478032943;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		String leftDesc = getLeftOperand().exitTypeDescriptor__		String rightDesc = getRightOperand().exitTypeDescriptor__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  _		_		cf.enterCompilationScope()__		getLeftOperand().generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		cf.enterCompilationScope()__		getRightOperand().generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,string,left,desc,get,left,operand,exit,type,descriptor,string,right,desc,get,right,operand,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,get,left,operand,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,get,right,operand,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1478083559;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		String leftDesc = getLeftOperand().exitTypeDescriptor__		String rightDesc = getRightOperand().exitTypeDescriptor__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  _		_		cf.enterCompilationScope()__		getLeftOperand().generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		cf.enterCompilationScope()__		getRightOperand().generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,string,left,desc,get,left,operand,exit,type,descriptor,string,right,desc,get,right,operand,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,get,left,operand,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,get,right,operand,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1485810955;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		String leftDesc = getLeftOperand().exitTypeDescriptor__		String rightDesc = getRightOperand().exitTypeDescriptor__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  _		_		cf.enterCompilationScope()__		getLeftOperand().generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		cf.enterCompilationScope()__		getRightOperand().generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,string,left,desc,get,left,operand,exit,type,descriptor,string,right,desc,get,right,operand,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,get,left,operand,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,get,right,operand,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1495868221;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		String leftDesc = getLeftOperand().exitTypeDescriptor__		String rightDesc = getRightOperand().exitTypeDescriptor__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  _		_		cf.enterCompilationScope()__		getLeftOperand().generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		cf.enterCompilationScope()__		getRightOperand().generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,string,left,desc,get,left,operand,exit,type,descriptor,string,right,desc,get,right,operand,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,get,left,operand,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,get,right,operand,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1496837955;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		SpelNodeImpl left = getLeftOperand()__		SpelNodeImpl right = getRightOperand()__		String leftDesc = left.exitTypeDescriptor__		String rightDesc = right.exitTypeDescriptor__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  _		_		cf.enterCompilationScope()__		left.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		cf.enterCompilationScope()__		right.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,spel,node,impl,left,get,left,operand,spel,node,impl,right,get,right,operand,string,left,desc,left,exit,type,descriptor,string,right,desc,right,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,left,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,right,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1497341594;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		SpelNodeImpl left = getLeftOperand()__		SpelNodeImpl right = getRightOperand()__		String leftDesc = left.exitTypeDescriptor__		String rightDesc = right.exitTypeDescriptor__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  _		_		cf.enterCompilationScope()__		left.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		cf.enterCompilationScope()__		right.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,spel,node,impl,left,get,left,operand,spel,node,impl,right,get,right,operand,string,left,desc,left,exit,type,descriptor,string,right,desc,right,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,left,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,right,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1498780456;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		SpelNodeImpl left = getLeftOperand()__		SpelNodeImpl right = getRightOperand()__		String leftDesc = left.exitTypeDescriptor__		String rightDesc = right.exitTypeDescriptor__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  _		_		cf.enterCompilationScope()__		left.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		cf.enterCompilationScope()__		right.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,spel,node,impl,left,get,left,operand,spel,node,impl,right,get,right,operand,string,left,desc,left,exit,type,descriptor,string,right,desc,right,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,left,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,right,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1518260959;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		SpelNodeImpl left = getLeftOperand()__		SpelNodeImpl right = getRightOperand()__		String leftDesc = left.exitTypeDescriptor__		String rightDesc = right.exitTypeDescriptor__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  _		_		cf.enterCompilationScope()__		left.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		cf.enterCompilationScope()__		right.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,spel,node,impl,left,get,left,operand,spel,node,impl,right,get,right,operand,string,left,desc,left,exit,type,descriptor,string,right,desc,right,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,left,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,right,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1530174524;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		SpelNodeImpl left = getLeftOperand()__		SpelNodeImpl right = getRightOperand()__		String leftDesc = left.exitTypeDescriptor__		String rightDesc = right.exitTypeDescriptor__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  _		_		cf.enterCompilationScope()__		left.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		cf.enterCompilationScope()__		right.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,spel,node,impl,left,get,left,operand,spel,node,impl,right,get,right,operand,string,left,desc,left,exit,type,descriptor,string,right,desc,right,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,left,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,right,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1530174524;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		SpelNodeImpl left = getLeftOperand()__		SpelNodeImpl right = getRightOperand()__		String leftDesc = left.exitTypeDescriptor__		String rightDesc = right.exitTypeDescriptor___		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  __		cf.enterCompilationScope()__		left.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}__		cf.enterCompilationScope()__		right.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,spel,node,impl,left,get,left,operand,spel,node,impl,right,get,right,operand,string,left,desc,left,exit,type,descriptor,string,right,desc,right,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,left,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,right,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1535712082;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		SpelNodeImpl left = getLeftOperand()__		SpelNodeImpl right = getRightOperand()__		String leftDesc = left.exitTypeDescriptor__		String rightDesc = right.exitTypeDescriptor___		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  __		cf.enterCompilationScope()__		left.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}__		cf.enterCompilationScope()__		right.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,spel,node,impl,left,get,left,operand,spel,node,impl,right,get,right,operand,string,left,desc,left,exit,type,descriptor,string,right,desc,right,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,left,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,right,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2);1548712256;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {_		SpelNodeImpl left = getLeftOperand()__		SpelNodeImpl right = getRightOperand()__		String leftDesc = left.exitTypeDescriptor__		String rightDesc = right.exitTypeDescriptor___		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(_				leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor)__		char targetType = dc.compatibleType_  __		cf.enterCompilationScope()__		left.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}__		cf.enterCompilationScope()__		right.generateCode(mv, cf)__		cf.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}__		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType == 'D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'F') {_			mv.visitInsn(FCMPG)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'J') {_			mv.visitInsn(LCMP)__			mv.visitJumpInsn(compInstruction1, elseTarget)__		}_		else if (targetType == 'I') {_			mv.visitJumpInsn(compInstruction2, elseTarget)__		}_		else {_			throw new IllegalStateException("Unexpected descriptor " + leftDesc)__		}__		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		cf.pushDescriptor("Z")__	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,cf,int,comp,instruction1,int,comp,instruction2,spel,node,impl,left,get,left,operand,spel,node,impl,right,get,right,operand,string,left,desc,left,exit,type,descriptor,string,right,desc,right,exit,type,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,this,left,actual,descriptor,this,right,actual,descriptor,char,target,type,dc,compatible,type,cf,enter,compilation,scope,left,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,cf,enter,compilation,scope,right,generate,code,mv,cf,cf,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,comp,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,comp,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,cf,push,descriptor,z
Operator -> public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right);1496837955;Perform an equality check for the given operand values._<p>This method is not just used for reflective comparisons in subclasses_but also from compiled expression code, which is why it needs to be_declared as {@code public static} here._@param context the current evaluation context_@param left the left-hand operand value_@param right the right-hand operand value;public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {_		if (left instanceof Number && right instanceof Number) {_			Number leftNumber = (Number) left__			Number rightNumber = (Number) right___			if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {_				BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class)__				BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class)__				return (leftBigDecimal.compareTo(rightBigDecimal) == 0)__			}_			else if (leftNumber instanceof Double || rightNumber instanceof Double) {_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_			else if (leftNumber instanceof Float || rightNumber instanceof Float) {_				return (leftNumber.floatValue() == rightNumber.floatValue())__			}_			else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {_				BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class)__				BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class)__				return (leftBigInteger.compareTo(rightBigInteger) == 0)__			}_			else if (leftNumber instanceof Long || rightNumber instanceof Long) {_				return (leftNumber.longValue() == rightNumber.longValue())__			}_			else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {_				return (leftNumber.intValue() == rightNumber.intValue())__			}_			else if (leftNumber instanceof Short || rightNumber instanceof Short) {_				return (leftNumber.shortValue() == rightNumber.shortValue())__			}_			else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {_				return (leftNumber.byteValue() == rightNumber.byteValue())__			}_			else {_				_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_		}__		if (left instanceof CharSequence && right instanceof CharSequence) {_			return left.toString().equals(right.toString())__		}__		if (ObjectUtils.nullSafeEquals(left, right)) {_			return true__		}__		if (left instanceof Comparable && right instanceof Comparable) {_			Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass())__			if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {_				return (context.getTypeComparator().compare(left, right) == 0)__			}_		}__		return false__	};perform,an,equality,check,for,the,given,operand,values,p,this,method,is,not,just,used,for,reflective,comparisons,in,subclasses,but,also,from,compiled,expression,code,which,is,why,it,needs,to,be,declared,as,code,public,static,here,param,context,the,current,evaluation,context,param,left,the,left,hand,operand,value,param,right,the,right,hand,operand,value;public,static,boolean,equality,check,evaluation,context,context,nullable,object,left,nullable,object,right,if,left,instanceof,number,right,instanceof,number,number,left,number,number,left,number,right,number,number,right,if,left,number,instanceof,big,decimal,right,number,instanceof,big,decimal,big,decimal,left,big,decimal,number,utils,convert,number,to,target,class,left,number,big,decimal,class,big,decimal,right,big,decimal,number,utils,convert,number,to,target,class,right,number,big,decimal,class,return,left,big,decimal,compare,to,right,big,decimal,0,else,if,left,number,instanceof,double,right,number,instanceof,double,return,left,number,double,value,right,number,double,value,else,if,left,number,instanceof,float,right,number,instanceof,float,return,left,number,float,value,right,number,float,value,else,if,left,number,instanceof,big,integer,right,number,instanceof,big,integer,big,integer,left,big,integer,number,utils,convert,number,to,target,class,left,number,big,integer,class,big,integer,right,big,integer,number,utils,convert,number,to,target,class,right,number,big,integer,class,return,left,big,integer,compare,to,right,big,integer,0,else,if,left,number,instanceof,long,right,number,instanceof,long,return,left,number,long,value,right,number,long,value,else,if,left,number,instanceof,integer,right,number,instanceof,integer,return,left,number,int,value,right,number,int,value,else,if,left,number,instanceof,short,right,number,instanceof,short,return,left,number,short,value,right,number,short,value,else,if,left,number,instanceof,byte,right,number,instanceof,byte,return,left,number,byte,value,right,number,byte,value,else,return,left,number,double,value,right,number,double,value,if,left,instanceof,char,sequence,right,instanceof,char,sequence,return,left,to,string,equals,right,to,string,if,object,utils,null,safe,equals,left,right,return,true,if,left,instanceof,comparable,right,instanceof,comparable,class,ancestor,class,utils,determine,common,ancestor,left,get,class,right,get,class,if,ancestor,null,comparable,class,is,assignable,from,ancestor,return,context,get,type,comparator,compare,left,right,0,return,false
Operator -> public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right);1497341594;Perform an equality check for the given operand values._<p>This method is not just used for reflective comparisons in subclasses_but also from compiled expression code, which is why it needs to be_declared as {@code public static} here._@param context the current evaluation context_@param left the left-hand operand value_@param right the right-hand operand value;public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {_		if (left instanceof Number && right instanceof Number) {_			Number leftNumber = (Number) left__			Number rightNumber = (Number) right___			if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {_				BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class)__				BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class)__				return (leftBigDecimal.compareTo(rightBigDecimal) == 0)__			}_			else if (leftNumber instanceof Double || rightNumber instanceof Double) {_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_			else if (leftNumber instanceof Float || rightNumber instanceof Float) {_				return (leftNumber.floatValue() == rightNumber.floatValue())__			}_			else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {_				BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class)__				BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class)__				return (leftBigInteger.compareTo(rightBigInteger) == 0)__			}_			else if (leftNumber instanceof Long || rightNumber instanceof Long) {_				return (leftNumber.longValue() == rightNumber.longValue())__			}_			else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {_				return (leftNumber.intValue() == rightNumber.intValue())__			}_			else if (leftNumber instanceof Short || rightNumber instanceof Short) {_				return (leftNumber.shortValue() == rightNumber.shortValue())__			}_			else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {_				return (leftNumber.byteValue() == rightNumber.byteValue())__			}_			else {_				_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_		}__		if (left instanceof CharSequence && right instanceof CharSequence) {_			return left.toString().equals(right.toString())__		}__		if (ObjectUtils.nullSafeEquals(left, right)) {_			return true__		}__		if (left instanceof Comparable && right instanceof Comparable) {_			Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass())__			if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {_				return (context.getTypeComparator().compare(left, right) == 0)__			}_		}__		return false__	};perform,an,equality,check,for,the,given,operand,values,p,this,method,is,not,just,used,for,reflective,comparisons,in,subclasses,but,also,from,compiled,expression,code,which,is,why,it,needs,to,be,declared,as,code,public,static,here,param,context,the,current,evaluation,context,param,left,the,left,hand,operand,value,param,right,the,right,hand,operand,value;public,static,boolean,equality,check,evaluation,context,context,nullable,object,left,nullable,object,right,if,left,instanceof,number,right,instanceof,number,number,left,number,number,left,number,right,number,number,right,if,left,number,instanceof,big,decimal,right,number,instanceof,big,decimal,big,decimal,left,big,decimal,number,utils,convert,number,to,target,class,left,number,big,decimal,class,big,decimal,right,big,decimal,number,utils,convert,number,to,target,class,right,number,big,decimal,class,return,left,big,decimal,compare,to,right,big,decimal,0,else,if,left,number,instanceof,double,right,number,instanceof,double,return,left,number,double,value,right,number,double,value,else,if,left,number,instanceof,float,right,number,instanceof,float,return,left,number,float,value,right,number,float,value,else,if,left,number,instanceof,big,integer,right,number,instanceof,big,integer,big,integer,left,big,integer,number,utils,convert,number,to,target,class,left,number,big,integer,class,big,integer,right,big,integer,number,utils,convert,number,to,target,class,right,number,big,integer,class,return,left,big,integer,compare,to,right,big,integer,0,else,if,left,number,instanceof,long,right,number,instanceof,long,return,left,number,long,value,right,number,long,value,else,if,left,number,instanceof,integer,right,number,instanceof,integer,return,left,number,int,value,right,number,int,value,else,if,left,number,instanceof,short,right,number,instanceof,short,return,left,number,short,value,right,number,short,value,else,if,left,number,instanceof,byte,right,number,instanceof,byte,return,left,number,byte,value,right,number,byte,value,else,return,left,number,double,value,right,number,double,value,if,left,instanceof,char,sequence,right,instanceof,char,sequence,return,left,to,string,equals,right,to,string,if,object,utils,null,safe,equals,left,right,return,true,if,left,instanceof,comparable,right,instanceof,comparable,class,ancestor,class,utils,determine,common,ancestor,left,get,class,right,get,class,if,ancestor,null,comparable,class,is,assignable,from,ancestor,return,context,get,type,comparator,compare,left,right,0,return,false
Operator -> public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right);1498780456;Perform an equality check for the given operand values._<p>This method is not just used for reflective comparisons in subclasses_but also from compiled expression code, which is why it needs to be_declared as {@code public static} here._@param context the current evaluation context_@param left the left-hand operand value_@param right the right-hand operand value;public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {_		if (left instanceof Number && right instanceof Number) {_			Number leftNumber = (Number) left__			Number rightNumber = (Number) right___			if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {_				BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class)__				BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class)__				return (leftBigDecimal.compareTo(rightBigDecimal) == 0)__			}_			else if (leftNumber instanceof Double || rightNumber instanceof Double) {_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_			else if (leftNumber instanceof Float || rightNumber instanceof Float) {_				return (leftNumber.floatValue() == rightNumber.floatValue())__			}_			else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {_				BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class)__				BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class)__				return (leftBigInteger.compareTo(rightBigInteger) == 0)__			}_			else if (leftNumber instanceof Long || rightNumber instanceof Long) {_				return (leftNumber.longValue() == rightNumber.longValue())__			}_			else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {_				return (leftNumber.intValue() == rightNumber.intValue())__			}_			else if (leftNumber instanceof Short || rightNumber instanceof Short) {_				return (leftNumber.shortValue() == rightNumber.shortValue())__			}_			else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {_				return (leftNumber.byteValue() == rightNumber.byteValue())__			}_			else {_				_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_		}__		if (left instanceof CharSequence && right instanceof CharSequence) {_			return left.toString().equals(right.toString())__		}__		if (ObjectUtils.nullSafeEquals(left, right)) {_			return true__		}__		if (left instanceof Comparable && right instanceof Comparable) {_			Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass())__			if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {_				return (context.getTypeComparator().compare(left, right) == 0)__			}_		}__		return false__	};perform,an,equality,check,for,the,given,operand,values,p,this,method,is,not,just,used,for,reflective,comparisons,in,subclasses,but,also,from,compiled,expression,code,which,is,why,it,needs,to,be,declared,as,code,public,static,here,param,context,the,current,evaluation,context,param,left,the,left,hand,operand,value,param,right,the,right,hand,operand,value;public,static,boolean,equality,check,evaluation,context,context,nullable,object,left,nullable,object,right,if,left,instanceof,number,right,instanceof,number,number,left,number,number,left,number,right,number,number,right,if,left,number,instanceof,big,decimal,right,number,instanceof,big,decimal,big,decimal,left,big,decimal,number,utils,convert,number,to,target,class,left,number,big,decimal,class,big,decimal,right,big,decimal,number,utils,convert,number,to,target,class,right,number,big,decimal,class,return,left,big,decimal,compare,to,right,big,decimal,0,else,if,left,number,instanceof,double,right,number,instanceof,double,return,left,number,double,value,right,number,double,value,else,if,left,number,instanceof,float,right,number,instanceof,float,return,left,number,float,value,right,number,float,value,else,if,left,number,instanceof,big,integer,right,number,instanceof,big,integer,big,integer,left,big,integer,number,utils,convert,number,to,target,class,left,number,big,integer,class,big,integer,right,big,integer,number,utils,convert,number,to,target,class,right,number,big,integer,class,return,left,big,integer,compare,to,right,big,integer,0,else,if,left,number,instanceof,long,right,number,instanceof,long,return,left,number,long,value,right,number,long,value,else,if,left,number,instanceof,integer,right,number,instanceof,integer,return,left,number,int,value,right,number,int,value,else,if,left,number,instanceof,short,right,number,instanceof,short,return,left,number,short,value,right,number,short,value,else,if,left,number,instanceof,byte,right,number,instanceof,byte,return,left,number,byte,value,right,number,byte,value,else,return,left,number,double,value,right,number,double,value,if,left,instanceof,char,sequence,right,instanceof,char,sequence,return,left,to,string,equals,right,to,string,if,object,utils,null,safe,equals,left,right,return,true,if,left,instanceof,comparable,right,instanceof,comparable,class,ancestor,class,utils,determine,common,ancestor,left,get,class,right,get,class,if,ancestor,null,comparable,class,is,assignable,from,ancestor,return,context,get,type,comparator,compare,left,right,0,return,false
Operator -> public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right);1518260959;Perform an equality check for the given operand values._<p>This method is not just used for reflective comparisons in subclasses_but also from compiled expression code, which is why it needs to be_declared as {@code public static} here._@param context the current evaluation context_@param left the left-hand operand value_@param right the right-hand operand value;public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {_		if (left instanceof Number && right instanceof Number) {_			Number leftNumber = (Number) left__			Number rightNumber = (Number) right___			if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {_				BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class)__				BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class)__				return (leftBigDecimal.compareTo(rightBigDecimal) == 0)__			}_			else if (leftNumber instanceof Double || rightNumber instanceof Double) {_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_			else if (leftNumber instanceof Float || rightNumber instanceof Float) {_				return (leftNumber.floatValue() == rightNumber.floatValue())__			}_			else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {_				BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class)__				BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class)__				return (leftBigInteger.compareTo(rightBigInteger) == 0)__			}_			else if (leftNumber instanceof Long || rightNumber instanceof Long) {_				return (leftNumber.longValue() == rightNumber.longValue())__			}_			else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {_				return (leftNumber.intValue() == rightNumber.intValue())__			}_			else if (leftNumber instanceof Short || rightNumber instanceof Short) {_				return (leftNumber.shortValue() == rightNumber.shortValue())__			}_			else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {_				return (leftNumber.byteValue() == rightNumber.byteValue())__			}_			else {_				_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_		}__		if (left instanceof CharSequence && right instanceof CharSequence) {_			return left.toString().equals(right.toString())__		}__		if (ObjectUtils.nullSafeEquals(left, right)) {_			return true__		}__		if (left instanceof Comparable && right instanceof Comparable) {_			Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass())__			if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {_				return (context.getTypeComparator().compare(left, right) == 0)__			}_		}__		return false__	};perform,an,equality,check,for,the,given,operand,values,p,this,method,is,not,just,used,for,reflective,comparisons,in,subclasses,but,also,from,compiled,expression,code,which,is,why,it,needs,to,be,declared,as,code,public,static,here,param,context,the,current,evaluation,context,param,left,the,left,hand,operand,value,param,right,the,right,hand,operand,value;public,static,boolean,equality,check,evaluation,context,context,nullable,object,left,nullable,object,right,if,left,instanceof,number,right,instanceof,number,number,left,number,number,left,number,right,number,number,right,if,left,number,instanceof,big,decimal,right,number,instanceof,big,decimal,big,decimal,left,big,decimal,number,utils,convert,number,to,target,class,left,number,big,decimal,class,big,decimal,right,big,decimal,number,utils,convert,number,to,target,class,right,number,big,decimal,class,return,left,big,decimal,compare,to,right,big,decimal,0,else,if,left,number,instanceof,double,right,number,instanceof,double,return,left,number,double,value,right,number,double,value,else,if,left,number,instanceof,float,right,number,instanceof,float,return,left,number,float,value,right,number,float,value,else,if,left,number,instanceof,big,integer,right,number,instanceof,big,integer,big,integer,left,big,integer,number,utils,convert,number,to,target,class,left,number,big,integer,class,big,integer,right,big,integer,number,utils,convert,number,to,target,class,right,number,big,integer,class,return,left,big,integer,compare,to,right,big,integer,0,else,if,left,number,instanceof,long,right,number,instanceof,long,return,left,number,long,value,right,number,long,value,else,if,left,number,instanceof,integer,right,number,instanceof,integer,return,left,number,int,value,right,number,int,value,else,if,left,number,instanceof,short,right,number,instanceof,short,return,left,number,short,value,right,number,short,value,else,if,left,number,instanceof,byte,right,number,instanceof,byte,return,left,number,byte,value,right,number,byte,value,else,return,left,number,double,value,right,number,double,value,if,left,instanceof,char,sequence,right,instanceof,char,sequence,return,left,to,string,equals,right,to,string,if,object,utils,null,safe,equals,left,right,return,true,if,left,instanceof,comparable,right,instanceof,comparable,class,ancestor,class,utils,determine,common,ancestor,left,get,class,right,get,class,if,ancestor,null,comparable,class,is,assignable,from,ancestor,return,context,get,type,comparator,compare,left,right,0,return,false
Operator -> public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right);1530174524;Perform an equality check for the given operand values._<p>This method is not just used for reflective comparisons in subclasses_but also from compiled expression code, which is why it needs to be_declared as {@code public static} here._@param context the current evaluation context_@param left the left-hand operand value_@param right the right-hand operand value;public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {_		if (left instanceof Number && right instanceof Number) {_			Number leftNumber = (Number) left__			Number rightNumber = (Number) right___			if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {_				BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class)__				BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class)__				return (leftBigDecimal.compareTo(rightBigDecimal) == 0)__			}_			else if (leftNumber instanceof Double || rightNumber instanceof Double) {_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_			else if (leftNumber instanceof Float || rightNumber instanceof Float) {_				return (leftNumber.floatValue() == rightNumber.floatValue())__			}_			else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {_				BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class)__				BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class)__				return (leftBigInteger.compareTo(rightBigInteger) == 0)__			}_			else if (leftNumber instanceof Long || rightNumber instanceof Long) {_				return (leftNumber.longValue() == rightNumber.longValue())__			}_			else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {_				return (leftNumber.intValue() == rightNumber.intValue())__			}_			else if (leftNumber instanceof Short || rightNumber instanceof Short) {_				return (leftNumber.shortValue() == rightNumber.shortValue())__			}_			else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {_				return (leftNumber.byteValue() == rightNumber.byteValue())__			}_			else {_				_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_		}__		if (left instanceof CharSequence && right instanceof CharSequence) {_			return left.toString().equals(right.toString())__		}__		if (ObjectUtils.nullSafeEquals(left, right)) {_			return true__		}__		if (left instanceof Comparable && right instanceof Comparable) {_			Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass())__			if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {_				return (context.getTypeComparator().compare(left, right) == 0)__			}_		}__		return false__	};perform,an,equality,check,for,the,given,operand,values,p,this,method,is,not,just,used,for,reflective,comparisons,in,subclasses,but,also,from,compiled,expression,code,which,is,why,it,needs,to,be,declared,as,code,public,static,here,param,context,the,current,evaluation,context,param,left,the,left,hand,operand,value,param,right,the,right,hand,operand,value;public,static,boolean,equality,check,evaluation,context,context,nullable,object,left,nullable,object,right,if,left,instanceof,number,right,instanceof,number,number,left,number,number,left,number,right,number,number,right,if,left,number,instanceof,big,decimal,right,number,instanceof,big,decimal,big,decimal,left,big,decimal,number,utils,convert,number,to,target,class,left,number,big,decimal,class,big,decimal,right,big,decimal,number,utils,convert,number,to,target,class,right,number,big,decimal,class,return,left,big,decimal,compare,to,right,big,decimal,0,else,if,left,number,instanceof,double,right,number,instanceof,double,return,left,number,double,value,right,number,double,value,else,if,left,number,instanceof,float,right,number,instanceof,float,return,left,number,float,value,right,number,float,value,else,if,left,number,instanceof,big,integer,right,number,instanceof,big,integer,big,integer,left,big,integer,number,utils,convert,number,to,target,class,left,number,big,integer,class,big,integer,right,big,integer,number,utils,convert,number,to,target,class,right,number,big,integer,class,return,left,big,integer,compare,to,right,big,integer,0,else,if,left,number,instanceof,long,right,number,instanceof,long,return,left,number,long,value,right,number,long,value,else,if,left,number,instanceof,integer,right,number,instanceof,integer,return,left,number,int,value,right,number,int,value,else,if,left,number,instanceof,short,right,number,instanceof,short,return,left,number,short,value,right,number,short,value,else,if,left,number,instanceof,byte,right,number,instanceof,byte,return,left,number,byte,value,right,number,byte,value,else,return,left,number,double,value,right,number,double,value,if,left,instanceof,char,sequence,right,instanceof,char,sequence,return,left,to,string,equals,right,to,string,if,object,utils,null,safe,equals,left,right,return,true,if,left,instanceof,comparable,right,instanceof,comparable,class,ancestor,class,utils,determine,common,ancestor,left,get,class,right,get,class,if,ancestor,null,comparable,class,is,assignable,from,ancestor,return,context,get,type,comparator,compare,left,right,0,return,false
Operator -> public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right);1530174524;Perform an equality check for the given operand values._<p>This method is not just used for reflective comparisons in subclasses_but also from compiled expression code, which is why it needs to be_declared as {@code public static} here._@param context the current evaluation context_@param left the left-hand operand value_@param right the right-hand operand value;public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {_		if (left instanceof Number && right instanceof Number) {_			Number leftNumber = (Number) left__			Number rightNumber = (Number) right___			if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {_				BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class)__				BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class)__				return (leftBigDecimal.compareTo(rightBigDecimal) == 0)__			}_			else if (leftNumber instanceof Double || rightNumber instanceof Double) {_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_			else if (leftNumber instanceof Float || rightNumber instanceof Float) {_				return (leftNumber.floatValue() == rightNumber.floatValue())__			}_			else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {_				BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class)__				BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class)__				return (leftBigInteger.compareTo(rightBigInteger) == 0)__			}_			else if (leftNumber instanceof Long || rightNumber instanceof Long) {_				return (leftNumber.longValue() == rightNumber.longValue())__			}_			else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {_				return (leftNumber.intValue() == rightNumber.intValue())__			}_			else if (leftNumber instanceof Short || rightNumber instanceof Short) {_				return (leftNumber.shortValue() == rightNumber.shortValue())__			}_			else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {_				return (leftNumber.byteValue() == rightNumber.byteValue())__			}_			else {_				_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_		}__		if (left instanceof CharSequence && right instanceof CharSequence) {_			return left.toString().equals(right.toString())__		}__		if (ObjectUtils.nullSafeEquals(left, right)) {_			return true__		}__		if (left instanceof Comparable && right instanceof Comparable) {_			Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass())__			if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {_				return (context.getTypeComparator().compare(left, right) == 0)__			}_		}__		return false__	};perform,an,equality,check,for,the,given,operand,values,p,this,method,is,not,just,used,for,reflective,comparisons,in,subclasses,but,also,from,compiled,expression,code,which,is,why,it,needs,to,be,declared,as,code,public,static,here,param,context,the,current,evaluation,context,param,left,the,left,hand,operand,value,param,right,the,right,hand,operand,value;public,static,boolean,equality,check,evaluation,context,context,nullable,object,left,nullable,object,right,if,left,instanceof,number,right,instanceof,number,number,left,number,number,left,number,right,number,number,right,if,left,number,instanceof,big,decimal,right,number,instanceof,big,decimal,big,decimal,left,big,decimal,number,utils,convert,number,to,target,class,left,number,big,decimal,class,big,decimal,right,big,decimal,number,utils,convert,number,to,target,class,right,number,big,decimal,class,return,left,big,decimal,compare,to,right,big,decimal,0,else,if,left,number,instanceof,double,right,number,instanceof,double,return,left,number,double,value,right,number,double,value,else,if,left,number,instanceof,float,right,number,instanceof,float,return,left,number,float,value,right,number,float,value,else,if,left,number,instanceof,big,integer,right,number,instanceof,big,integer,big,integer,left,big,integer,number,utils,convert,number,to,target,class,left,number,big,integer,class,big,integer,right,big,integer,number,utils,convert,number,to,target,class,right,number,big,integer,class,return,left,big,integer,compare,to,right,big,integer,0,else,if,left,number,instanceof,long,right,number,instanceof,long,return,left,number,long,value,right,number,long,value,else,if,left,number,instanceof,integer,right,number,instanceof,integer,return,left,number,int,value,right,number,int,value,else,if,left,number,instanceof,short,right,number,instanceof,short,return,left,number,short,value,right,number,short,value,else,if,left,number,instanceof,byte,right,number,instanceof,byte,return,left,number,byte,value,right,number,byte,value,else,return,left,number,double,value,right,number,double,value,if,left,instanceof,char,sequence,right,instanceof,char,sequence,return,left,to,string,equals,right,to,string,if,object,utils,null,safe,equals,left,right,return,true,if,left,instanceof,comparable,right,instanceof,comparable,class,ancestor,class,utils,determine,common,ancestor,left,get,class,right,get,class,if,ancestor,null,comparable,class,is,assignable,from,ancestor,return,context,get,type,comparator,compare,left,right,0,return,false
Operator -> public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right);1535712082;Perform an equality check for the given operand values._<p>This method is not just used for reflective comparisons in subclasses_but also from compiled expression code, which is why it needs to be_declared as {@code public static} here._@param context the current evaluation context_@param left the left-hand operand value_@param right the right-hand operand value;public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {_		if (left instanceof Number && right instanceof Number) {_			Number leftNumber = (Number) left__			Number rightNumber = (Number) right___			if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {_				BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class)__				BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class)__				return (leftBigDecimal.compareTo(rightBigDecimal) == 0)__			}_			else if (leftNumber instanceof Double || rightNumber instanceof Double) {_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_			else if (leftNumber instanceof Float || rightNumber instanceof Float) {_				return (leftNumber.floatValue() == rightNumber.floatValue())__			}_			else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {_				BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class)__				BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class)__				return (leftBigInteger.compareTo(rightBigInteger) == 0)__			}_			else if (leftNumber instanceof Long || rightNumber instanceof Long) {_				return (leftNumber.longValue() == rightNumber.longValue())__			}_			else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {_				return (leftNumber.intValue() == rightNumber.intValue())__			}_			else if (leftNumber instanceof Short || rightNumber instanceof Short) {_				return (leftNumber.shortValue() == rightNumber.shortValue())__			}_			else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {_				return (leftNumber.byteValue() == rightNumber.byteValue())__			}_			else {_				_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_		}__		if (left instanceof CharSequence && right instanceof CharSequence) {_			return left.toString().equals(right.toString())__		}__		if (left instanceof Boolean && right instanceof Boolean) {_			return left.equals(right)__		}__		if (ObjectUtils.nullSafeEquals(left, right)) {_			return true__		}__		if (left instanceof Comparable && right instanceof Comparable) {_			Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass())__			if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {_				return (context.getTypeComparator().compare(left, right) == 0)__			}_		}__		return false__	};perform,an,equality,check,for,the,given,operand,values,p,this,method,is,not,just,used,for,reflective,comparisons,in,subclasses,but,also,from,compiled,expression,code,which,is,why,it,needs,to,be,declared,as,code,public,static,here,param,context,the,current,evaluation,context,param,left,the,left,hand,operand,value,param,right,the,right,hand,operand,value;public,static,boolean,equality,check,evaluation,context,context,nullable,object,left,nullable,object,right,if,left,instanceof,number,right,instanceof,number,number,left,number,number,left,number,right,number,number,right,if,left,number,instanceof,big,decimal,right,number,instanceof,big,decimal,big,decimal,left,big,decimal,number,utils,convert,number,to,target,class,left,number,big,decimal,class,big,decimal,right,big,decimal,number,utils,convert,number,to,target,class,right,number,big,decimal,class,return,left,big,decimal,compare,to,right,big,decimal,0,else,if,left,number,instanceof,double,right,number,instanceof,double,return,left,number,double,value,right,number,double,value,else,if,left,number,instanceof,float,right,number,instanceof,float,return,left,number,float,value,right,number,float,value,else,if,left,number,instanceof,big,integer,right,number,instanceof,big,integer,big,integer,left,big,integer,number,utils,convert,number,to,target,class,left,number,big,integer,class,big,integer,right,big,integer,number,utils,convert,number,to,target,class,right,number,big,integer,class,return,left,big,integer,compare,to,right,big,integer,0,else,if,left,number,instanceof,long,right,number,instanceof,long,return,left,number,long,value,right,number,long,value,else,if,left,number,instanceof,integer,right,number,instanceof,integer,return,left,number,int,value,right,number,int,value,else,if,left,number,instanceof,short,right,number,instanceof,short,return,left,number,short,value,right,number,short,value,else,if,left,number,instanceof,byte,right,number,instanceof,byte,return,left,number,byte,value,right,number,byte,value,else,return,left,number,double,value,right,number,double,value,if,left,instanceof,char,sequence,right,instanceof,char,sequence,return,left,to,string,equals,right,to,string,if,left,instanceof,boolean,right,instanceof,boolean,return,left,equals,right,if,object,utils,null,safe,equals,left,right,return,true,if,left,instanceof,comparable,right,instanceof,comparable,class,ancestor,class,utils,determine,common,ancestor,left,get,class,right,get,class,if,ancestor,null,comparable,class,is,assignable,from,ancestor,return,context,get,type,comparator,compare,left,right,0,return,false
Operator -> public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right);1548712256;Perform an equality check for the given operand values._<p>This method is not just used for reflective comparisons in subclasses_but also from compiled expression code, which is why it needs to be_declared as {@code public static} here._@param context the current evaluation context_@param left the left-hand operand value_@param right the right-hand operand value;public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {_		if (left instanceof Number && right instanceof Number) {_			Number leftNumber = (Number) left__			Number rightNumber = (Number) right___			if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {_				BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class)__				BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class)__				return (leftBigDecimal.compareTo(rightBigDecimal) == 0)__			}_			else if (leftNumber instanceof Double || rightNumber instanceof Double) {_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_			else if (leftNumber instanceof Float || rightNumber instanceof Float) {_				return (leftNumber.floatValue() == rightNumber.floatValue())__			}_			else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {_				BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class)__				BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class)__				return (leftBigInteger.compareTo(rightBigInteger) == 0)__			}_			else if (leftNumber instanceof Long || rightNumber instanceof Long) {_				return (leftNumber.longValue() == rightNumber.longValue())__			}_			else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {_				return (leftNumber.intValue() == rightNumber.intValue())__			}_			else if (leftNumber instanceof Short || rightNumber instanceof Short) {_				return (leftNumber.shortValue() == rightNumber.shortValue())__			}_			else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {_				return (leftNumber.byteValue() == rightNumber.byteValue())__			}_			else {_				_				return (leftNumber.doubleValue() == rightNumber.doubleValue())__			}_		}__		if (left instanceof CharSequence && right instanceof CharSequence) {_			return left.toString().equals(right.toString())__		}__		if (left instanceof Boolean && right instanceof Boolean) {_			return left.equals(right)__		}__		if (ObjectUtils.nullSafeEquals(left, right)) {_			return true__		}__		if (left instanceof Comparable && right instanceof Comparable) {_			Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass())__			if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {_				return (context.getTypeComparator().compare(left, right) == 0)__			}_		}__		return false__	};perform,an,equality,check,for,the,given,operand,values,p,this,method,is,not,just,used,for,reflective,comparisons,in,subclasses,but,also,from,compiled,expression,code,which,is,why,it,needs,to,be,declared,as,code,public,static,here,param,context,the,current,evaluation,context,param,left,the,left,hand,operand,value,param,right,the,right,hand,operand,value;public,static,boolean,equality,check,evaluation,context,context,nullable,object,left,nullable,object,right,if,left,instanceof,number,right,instanceof,number,number,left,number,number,left,number,right,number,number,right,if,left,number,instanceof,big,decimal,right,number,instanceof,big,decimal,big,decimal,left,big,decimal,number,utils,convert,number,to,target,class,left,number,big,decimal,class,big,decimal,right,big,decimal,number,utils,convert,number,to,target,class,right,number,big,decimal,class,return,left,big,decimal,compare,to,right,big,decimal,0,else,if,left,number,instanceof,double,right,number,instanceof,double,return,left,number,double,value,right,number,double,value,else,if,left,number,instanceof,float,right,number,instanceof,float,return,left,number,float,value,right,number,float,value,else,if,left,number,instanceof,big,integer,right,number,instanceof,big,integer,big,integer,left,big,integer,number,utils,convert,number,to,target,class,left,number,big,integer,class,big,integer,right,big,integer,number,utils,convert,number,to,target,class,right,number,big,integer,class,return,left,big,integer,compare,to,right,big,integer,0,else,if,left,number,instanceof,long,right,number,instanceof,long,return,left,number,long,value,right,number,long,value,else,if,left,number,instanceof,integer,right,number,instanceof,integer,return,left,number,int,value,right,number,int,value,else,if,left,number,instanceof,short,right,number,instanceof,short,return,left,number,short,value,right,number,short,value,else,if,left,number,instanceof,byte,right,number,instanceof,byte,return,left,number,byte,value,right,number,byte,value,else,return,left,number,double,value,right,number,double,value,if,left,instanceof,char,sequence,right,instanceof,char,sequence,return,left,to,string,equals,right,to,string,if,left,instanceof,boolean,right,instanceof,boolean,return,left,equals,right,if,object,utils,null,safe,equals,left,right,return,true,if,left,instanceof,comparable,right,instanceof,comparable,class,ancestor,class,utils,determine,common,ancestor,left,get,class,right,get,class,if,ancestor,null,comparable,class,is,assignable,from,ancestor,return,context,get,type,comparator,compare,left,right,0,return,false
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor, 				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor);1412630983;Returns an object that indicates whether the input descriptors are compatible. A declared descriptor_is what could statically be determined (e.g. from looking at the return value of a property accessor_method) whilst an actual descriptor is the type of an actual object that was returned, which may differ._For generic types with unbound type variables the declared descriptor discovered may be 'Object' but_from the actual descriptor it is possible to observe that the objects are really numeric values (e.g._ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor,_				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			_			_			if (!leftNumeric && !ld.equals(leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !rd.equals(rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}_			_			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}		_		};returns,an,object,that,indicates,whether,the,input,descriptors,are,compatible,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,string,left,declared,descriptor,string,right,declared,descriptor,string,left,actual,descriptor,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,ld,equals,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,rd,equals,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor, 				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor);1477938285;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor,_				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			_			_			if (!leftNumeric && !ld.equals(leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !rd.equals(rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}_			_			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}		_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,string,left,declared,descriptor,string,right,declared,descriptor,string,left,actual,descriptor,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,ld,equals,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,rd,equals,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor, 				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor);1478032943;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor,_				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			_			_			if (!leftNumeric && !ld.equals(leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !rd.equals(rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}_			_			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}		_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,string,left,declared,descriptor,string,right,declared,descriptor,string,left,actual,descriptor,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,ld,equals,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,rd,equals,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor, 				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor);1478083559;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor,_				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			_			_			if (!leftNumeric && !ld.equals(leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !rd.equals(rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}_			_			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}		_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,string,left,declared,descriptor,string,right,declared,descriptor,string,left,actual,descriptor,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,ld,equals,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,rd,equals,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor, 				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor);1485810955;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor,_				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			_			_			if (!leftNumeric && !ld.equals(leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !rd.equals(rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}_			_			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}		_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,string,left,declared,descriptor,string,right,declared,descriptor,string,left,actual,descriptor,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,ld,equals,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,rd,equals,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor, 				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor);1495868221;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor,_				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			_			_			if (!leftNumeric && !ld.equals(leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !rd.equals(rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}_			_			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}		_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,string,left,declared,descriptor,string,right,declared,descriptor,string,left,actual,descriptor,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,ld,equals,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,rd,equals,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor, 				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor);1496837955;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor,_				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			_			_			if (!leftNumeric && !ld.equals(leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !rd.equals(rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}_			_			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}		_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,string,left,declared,descriptor,string,right,declared,descriptor,string,left,actual,descriptor,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,ld,equals,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,rd,equals,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor, 				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor);1497341594;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(String leftDeclaredDescriptor,_				String rightDeclaredDescriptor, String leftActualDescriptor, String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			_			_			if (!leftNumeric && !ld.equals(leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !rd.equals(rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}_			_			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}		_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,string,left,declared,descriptor,string,right,declared,descriptor,string,left,actual,descriptor,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,ld,equals,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,rd,equals,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow codeflow, int compareInstruction1, 			int compareInstruction2);1405011154;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow codeflow, int compareInstruction1,_			int compareInstruction2) {_		String leftDesc = getLeftOperand().getExitDescriptor()__		String rightDesc = getRightOperand().getExitDescriptor()__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		char targetType = CodeFlow.toPrimitiveTargetDesc(leftDesc)__		_		getLeftOperand().generateCode(mv, codeflow)__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, false)__		}_	_		getRightOperand().generateCode(mv, codeflow)__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, false)__		}_		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType=='D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compareInstruction1, elseTarget)__		}_		else if (targetType=='F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compareInstruction1, elseTarget)__		}_		else if (targetType=='J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compareInstruction1, elseTarget)__		}_		else if (targetType=='I') {_			mv.visitJumpInsn(compareInstruction2, elseTarget)_		_		}_		else {_			throw new IllegalStateException("Unexpected descriptor "+leftDesc)__		}_		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		codeflow.pushDescriptor("Z")_	_	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,codeflow,int,compare,instruction1,int,compare,instruction2,string,left,desc,get,left,operand,get,exit,descriptor,string,right,desc,get,right,operand,get,exit,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,char,target,type,code,flow,to,primitive,target,desc,left,desc,get,left,operand,generate,code,mv,codeflow,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,false,get,right,operand,generate,code,mv,codeflow,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,false,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,compare,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,compare,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,compare,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,compare,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,codeflow,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow codeflow, int compareInstruction1, 			int compareInstruction2);1405514506;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow codeflow, int compareInstruction1,_			int compareInstruction2) {_		String leftDesc = getLeftOperand().getExitDescriptor()__		String rightDesc = getRightOperand().getExitDescriptor()__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		char targetType = CodeFlow.toPrimitiveTargetDesc(leftDesc)__		_		getLeftOperand().generateCode(mv, codeflow)__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, false)__		}_	_		getRightOperand().generateCode(mv, codeflow)__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, false)__		}_		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType=='D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compareInstruction1, elseTarget)__		}_		else if (targetType=='F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compareInstruction1, elseTarget)__		}_		else if (targetType=='J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compareInstruction1, elseTarget)__		}_		else if (targetType=='I') {_			mv.visitJumpInsn(compareInstruction2, elseTarget)_		_		}_		else {_			throw new IllegalStateException("Unexpected descriptor "+leftDesc)__		}_		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		codeflow.pushDescriptor("Z")_	_	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,codeflow,int,compare,instruction1,int,compare,instruction2,string,left,desc,get,left,operand,get,exit,descriptor,string,right,desc,get,right,operand,get,exit,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,char,target,type,code,flow,to,primitive,target,desc,left,desc,get,left,operand,generate,code,mv,codeflow,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,false,get,right,operand,generate,code,mv,codeflow,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,false,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,compare,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,compare,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,compare,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,compare,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,codeflow,push,descriptor,z
Operator -> protected void generateComparisonCode(MethodVisitor mv, CodeFlow codeflow, int compareInstruction1, 			int compareInstruction2);1406656976;Numeric comparison operators share very similar generated code, only differing in_two comparison instructions.;protected void generateComparisonCode(MethodVisitor mv, CodeFlow codeflow, int compareInstruction1,_			int compareInstruction2) {_		String leftDesc = getLeftOperand().getExitDescriptor()__		String rightDesc = getRightOperand().getExitDescriptor()__		_		boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc)__		boolean unboxRight = !CodeFlow.isPrimitive(rightDesc)__		DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(leftDesc, rightDesc, leftActualDescriptor, rightActualDescriptor)__		char targetType = dc.compatibleType__		_		getLeftOperand().generateCode(mv, codeflow)__		if (unboxLeft) {_			CodeFlow.insertUnboxInsns(mv, targetType, leftDesc)__		}_	_		codeflow.enterCompilationScope()__		getRightOperand().generateCode(mv, codeflow)__		codeflow.exitCompilationScope()__		if (unboxRight) {_			CodeFlow.insertUnboxInsns(mv, targetType, rightDesc)__		}_		_		Label elseTarget = new Label()__		Label endOfIf = new Label()__		if (targetType=='D') {_			mv.visitInsn(DCMPG)__			mv.visitJumpInsn(compareInstruction1, elseTarget)__		}_		else if (targetType=='F') {_			mv.visitInsn(FCMPG)_		_			mv.visitJumpInsn(compareInstruction1, elseTarget)__		}_		else if (targetType=='J') {_			mv.visitInsn(LCMP)_		_			mv.visitJumpInsn(compareInstruction1, elseTarget)__		}_		else if (targetType=='I') {_			mv.visitJumpInsn(compareInstruction2, elseTarget)_		_		}_		else {_			throw new IllegalStateException("Unexpected descriptor "+leftDesc)__		}_		_		mv.visitInsn(ICONST_1)__		mv.visitJumpInsn(GOTO,endOfIf)__		mv.visitLabel(elseTarget)__		mv.visitInsn(ICONST_0)__		mv.visitLabel(endOfIf)__		codeflow.pushDescriptor("Z")_	_	};numeric,comparison,operators,share,very,similar,generated,code,only,differing,in,two,comparison,instructions;protected,void,generate,comparison,code,method,visitor,mv,code,flow,codeflow,int,compare,instruction1,int,compare,instruction2,string,left,desc,get,left,operand,get,exit,descriptor,string,right,desc,get,right,operand,get,exit,descriptor,boolean,unbox,left,code,flow,is,primitive,left,desc,boolean,unbox,right,code,flow,is,primitive,right,desc,descriptor,comparison,dc,descriptor,comparison,check,numeric,compatibility,left,desc,right,desc,left,actual,descriptor,right,actual,descriptor,char,target,type,dc,compatible,type,get,left,operand,generate,code,mv,codeflow,if,unbox,left,code,flow,insert,unbox,insns,mv,target,type,left,desc,codeflow,enter,compilation,scope,get,right,operand,generate,code,mv,codeflow,codeflow,exit,compilation,scope,if,unbox,right,code,flow,insert,unbox,insns,mv,target,type,right,desc,label,else,target,new,label,label,end,of,if,new,label,if,target,type,d,mv,visit,insn,dcmpg,mv,visit,jump,insn,compare,instruction1,else,target,else,if,target,type,f,mv,visit,insn,fcmpg,mv,visit,jump,insn,compare,instruction1,else,target,else,if,target,type,j,mv,visit,insn,lcmp,mv,visit,jump,insn,compare,instruction1,else,target,else,if,target,type,i,mv,visit,jump,insn,compare,instruction2,else,target,else,throw,new,illegal,state,exception,unexpected,descriptor,left,desc,mv,visit,insn,mv,visit,jump,insn,goto,end,of,if,mv,visit,label,else,target,mv,visit,insn,mv,visit,label,end,of,if,codeflow,push,descriptor,z
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility( 				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor, 				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor);1498780456;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(_				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,_				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			_			_			if (!leftNumeric && !ObjectUtils.nullSafeEquals(ld, leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !ObjectUtils.nullSafeEquals(rd, rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}_			_			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}		_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,nullable,string,left,declared,descriptor,nullable,string,right,declared,descriptor,nullable,string,left,actual,descriptor,nullable,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,object,utils,null,safe,equals,ld,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,object,utils,null,safe,equals,rd,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility( 				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor, 				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor);1518260959;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(_				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,_				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			_			_			if (!leftNumeric && !ObjectUtils.nullSafeEquals(ld, leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !ObjectUtils.nullSafeEquals(rd, rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}_			_			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}		_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,nullable,string,left,declared,descriptor,nullable,string,right,declared,descriptor,nullable,string,left,actual,descriptor,nullable,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,object,utils,null,safe,equals,ld,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,object,utils,null,safe,equals,rd,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility( 				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor, 				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor);1530174524;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(_				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,_				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			_			_			if (!leftNumeric && !ObjectUtils.nullSafeEquals(ld, leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !ObjectUtils.nullSafeEquals(rd, rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}_			_			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}		_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,nullable,string,left,declared,descriptor,nullable,string,right,declared,descriptor,nullable,string,left,actual,descriptor,nullable,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,object,utils,null,safe,equals,ld,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,object,utils,null,safe,equals,rd,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility( 				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor, 				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor);1530174524;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(_				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,_				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)___			_			if (!leftNumeric && !ObjectUtils.nullSafeEquals(ld, leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !ObjectUtils.nullSafeEquals(rd, rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}__			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,nullable,string,left,declared,descriptor,nullable,string,right,declared,descriptor,nullable,string,left,actual,descriptor,nullable,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,object,utils,null,safe,equals,ld,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,object,utils,null,safe,equals,rd,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility( 				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor, 				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor);1535712082;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(_				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,_				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)___			_			if (!leftNumeric && !ObjectUtils.nullSafeEquals(ld, leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !ObjectUtils.nullSafeEquals(rd, rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}__			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,nullable,string,left,declared,descriptor,nullable,string,right,declared,descriptor,nullable,string,left,actual,descriptor,nullable,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,object,utils,null,safe,equals,ld,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,object,utils,null,safe,equals,rd,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
Operator -> DescriptorComparison -> public static DescriptorComparison checkNumericCompatibility( 				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor, 				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor);1548712256;Return an object that indicates whether the input descriptors are compatible._<p>A declared descriptor is what could statically be determined (e.g. from looking_at the return value of a property accessor method) whilst an actual descriptor_is the type of an actual object that was returned, which may differ._<p>For generic types with unbound type variables, the declared descriptor_discovered may be 'Object' but from the actual descriptor it is possible to_observe that the objects are really numeric values (e.g. ints)._@param leftDeclaredDescriptor the statically determinable left descriptor_@param rightDeclaredDescriptor the statically determinable right descriptor_@param leftActualDescriptor the dynamic/runtime left object descriptor_@param rightActualDescriptor the dynamic/runtime right object descriptor_@return a DescriptorComparison object indicating the type of compatibility, if any;public static DescriptorComparison checkNumericCompatibility(_				@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,_				@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor) {__			String ld = leftDeclaredDescriptor__			String rd = rightDeclaredDescriptor___			boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)___			_			if (!leftNumeric && !ObjectUtils.nullSafeEquals(ld, leftActualDescriptor)) {_				ld = leftActualDescriptor__				leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld)__			}_			if (!rightNumeric && !ObjectUtils.nullSafeEquals(rd, rightActualDescriptor)) {_				rd = rightActualDescriptor__				rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd)__			}__			if (leftNumeric && rightNumeric) {_				if (CodeFlow.areBoxingCompatible(ld, rd)) {_					return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld))__				}_				else {_					return DescriptorComparison.INCOMPATIBLE_NUMBERS__				}_			}_			else {_				return DescriptorComparison.NOT_NUMBERS__			}_		};return,an,object,that,indicates,whether,the,input,descriptors,are,compatible,p,a,declared,descriptor,is,what,could,statically,be,determined,e,g,from,looking,at,the,return,value,of,a,property,accessor,method,whilst,an,actual,descriptor,is,the,type,of,an,actual,object,that,was,returned,which,may,differ,p,for,generic,types,with,unbound,type,variables,the,declared,descriptor,discovered,may,be,object,but,from,the,actual,descriptor,it,is,possible,to,observe,that,the,objects,are,really,numeric,values,e,g,ints,param,left,declared,descriptor,the,statically,determinable,left,descriptor,param,right,declared,descriptor,the,statically,determinable,right,descriptor,param,left,actual,descriptor,the,dynamic,runtime,left,object,descriptor,param,right,actual,descriptor,the,dynamic,runtime,right,object,descriptor,return,a,descriptor,comparison,object,indicating,the,type,of,compatibility,if,any;public,static,descriptor,comparison,check,numeric,compatibility,nullable,string,left,declared,descriptor,nullable,string,right,declared,descriptor,nullable,string,left,actual,descriptor,nullable,string,right,actual,descriptor,string,ld,left,declared,descriptor,string,rd,right,declared,descriptor,boolean,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,boolean,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,object,utils,null,safe,equals,ld,left,actual,descriptor,ld,left,actual,descriptor,left,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,ld,if,right,numeric,object,utils,null,safe,equals,rd,right,actual,descriptor,rd,right,actual,descriptor,right,numeric,code,flow,is,primitive,or,unboxable,supported,number,or,boolean,rd,if,left,numeric,right,numeric,if,code,flow,are,boxing,compatible,ld,rd,return,new,descriptor,comparison,true,true,code,flow,to,primitive,target,desc,ld,else,return,descriptor,comparison,else,return,descriptor,comparison
