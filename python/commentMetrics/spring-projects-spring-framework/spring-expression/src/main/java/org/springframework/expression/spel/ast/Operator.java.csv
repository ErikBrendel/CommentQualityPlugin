commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public SpelNodeImpl getLeftOperand() {     return this.children[0]. }
false;public;0;3;;public SpelNodeImpl getRightOperand() {     return this.children[1]. }
false;public,final;0;3;;public final String getOperatorName() {     return this.operatorName. }
true;public;0;11;/**  * String format for all operators is the same  * {@code '(' [operand] [operator] [operand] ')'}.  */ ;/**  * String format for all operators is the same  * {@code '(' [operand] [operator] [operand] ')'}.  */ @Override public String toStringAST() {     StringBuilder sb = new StringBuilder("(").     sb.append(getChild(0).toStringAST()).     for (int i = 1. i < getChildCount(). i++) {         sb.append(" ").append(getOperatorName()).append(" ").         sb.append(getChild(i).toStringAST()).     }     sb.append(")").     return sb.toString(). }
false;protected;0;14;;protected boolean isCompilableOperatorUsingNumerics() {     SpelNodeImpl left = getLeftOperand().     SpelNodeImpl right = getRightOperand().     if (!left.isCompilable() || !right.isCompilable()) {         return false.     }     // Supported operand types for equals (at the moment)     String leftDesc = left.exitTypeDescriptor.     String rightDesc = right.exitTypeDescriptor.     DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor).     return (dc.areNumbers && dc.areCompatible). }
true;protected;4;56;/**  * Numeric comparison operators share very similar generated code, only differing in  * two comparison instructions.  */ ;/**  * Numeric comparison operators share very similar generated code, only differing in  * two comparison instructions.  */ protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {     SpelNodeImpl left = getLeftOperand().     SpelNodeImpl right = getRightOperand().     String leftDesc = left.exitTypeDescriptor.     String rightDesc = right.exitTypeDescriptor.     boolean unboxLeft = !CodeFlow.isPrimitive(leftDesc).     boolean unboxRight = !CodeFlow.isPrimitive(rightDesc).     DescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(leftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor).     // CodeFlow.toPrimitiveTargetDesc(leftDesc).     char targetType = dc.compatibleType.     cf.enterCompilationScope().     left.generateCode(mv, cf).     cf.exitCompilationScope().     if (unboxLeft) {         CodeFlow.insertUnboxInsns(mv, targetType, leftDesc).     }     cf.enterCompilationScope().     right.generateCode(mv, cf).     cf.exitCompilationScope().     if (unboxRight) {         CodeFlow.insertUnboxInsns(mv, targetType, rightDesc).     }     // assert: SpelCompiler.boxingCompatible(leftDesc, rightDesc)     Label elseTarget = new Label().     Label endOfIf = new Label().     if (targetType == 'D') {         mv.visitInsn(DCMPG).         mv.visitJumpInsn(compInstruction1, elseTarget).     } else if (targetType == 'F') {         mv.visitInsn(FCMPG).         mv.visitJumpInsn(compInstruction1, elseTarget).     } else if (targetType == 'J') {         mv.visitInsn(LCMP).         mv.visitJumpInsn(compInstruction1, elseTarget).     } else if (targetType == 'I') {         mv.visitJumpInsn(compInstruction2, elseTarget).     } else {         throw new IllegalStateException("Unexpected descriptor " + leftDesc).     }     // Other numbers are not yet supported (isCompilable will not have returned true)     mv.visitInsn(ICONST_1).     mv.visitJumpInsn(GOTO, endOfIf).     mv.visitLabel(elseTarget).     mv.visitInsn(ICONST_0).     mv.visitLabel(endOfIf).     cf.pushDescriptor("Z"). }
true;public,static;3;60;/**  * Perform an equality check for the given operand values.  * <p>This method is not just used for reflective comparisons in subclasses  * but also from compiled expression code, which is why it needs to be  * declared as {@code public static} here.  * @param context the current evaluation context  * @param left the left-hand operand value  * @param right the right-hand operand value  */ ;/**  * Perform an equality check for the given operand values.  * <p>This method is not just used for reflective comparisons in subclasses  * but also from compiled expression code, which is why it needs to be  * declared as {@code public static} here.  * @param context the current evaluation context  * @param left the left-hand operand value  * @param right the right-hand operand value  */ public static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {     if (left instanceof Number && right instanceof Number) {         Number leftNumber = (Number) left.         Number rightNumber = (Number) right.         if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {             BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class).             BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class).             return (leftBigDecimal.compareTo(rightBigDecimal) == 0).         } else if (leftNumber instanceof Double || rightNumber instanceof Double) {             return (leftNumber.doubleValue() == rightNumber.doubleValue()).         } else if (leftNumber instanceof Float || rightNumber instanceof Float) {             return (leftNumber.floatValue() == rightNumber.floatValue()).         } else if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {             BigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class).             BigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class).             return (leftBigInteger.compareTo(rightBigInteger) == 0).         } else if (leftNumber instanceof Long || rightNumber instanceof Long) {             return (leftNumber.longValue() == rightNumber.longValue()).         } else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {             return (leftNumber.intValue() == rightNumber.intValue()).         } else if (leftNumber instanceof Short || rightNumber instanceof Short) {             return (leftNumber.shortValue() == rightNumber.shortValue()).         } else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {             return (leftNumber.byteValue() == rightNumber.byteValue()).         } else {             // Unknown Number subtypes -> best guess is double comparison             return (leftNumber.doubleValue() == rightNumber.doubleValue()).         }     }     if (left instanceof CharSequence && right instanceof CharSequence) {         return left.toString().equals(right.toString()).     }     if (left instanceof Boolean && right instanceof Boolean) {         return left.equals(right).     }     if (ObjectUtils.nullSafeEquals(left, right)) {         return true.     }     if (left instanceof Comparable && right instanceof Comparable) {         Class<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass()).         if (ancestor != null && Comparable.class.isAssignableFrom(ancestor)) {             return (context.getTypeComparator().compare(left, right) == 0).         }     }     return false. }
true;public,static;4;32;/**  * Return an object that indicates whether the input descriptors are compatible.  * <p>A declared descriptor is what could statically be determined (e.g. from looking  * at the return value of a property accessor method) whilst an actual descriptor  * is the type of an actual object that was returned, which may differ.  * <p>For generic types with unbound type variables, the declared descriptor  * discovered may be 'Object' but from the actual descriptor it is possible to  * observe that the objects are really numeric values (e.g. ints).  * @param leftDeclaredDescriptor the statically determinable left descriptor  * @param rightDeclaredDescriptor the statically determinable right descriptor  * @param leftActualDescriptor the dynamic/runtime left object descriptor  * @param rightActualDescriptor the dynamic/runtime right object descriptor  * @return a DescriptorComparison object indicating the type of compatibility, if any  */ ;/**  * Return an object that indicates whether the input descriptors are compatible.  * <p>A declared descriptor is what could statically be determined (e.g. from looking  * at the return value of a property accessor method) whilst an actual descriptor  * is the type of an actual object that was returned, which may differ.  * <p>For generic types with unbound type variables, the declared descriptor  * discovered may be 'Object' but from the actual descriptor it is possible to  * observe that the objects are really numeric values (e.g. ints).  * @param leftDeclaredDescriptor the statically determinable left descriptor  * @param rightDeclaredDescriptor the statically determinable right descriptor  * @param leftActualDescriptor the dynamic/runtime left object descriptor  * @param rightActualDescriptor the dynamic/runtime right object descriptor  * @return a DescriptorComparison object indicating the type of compatibility, if any  */ public static DescriptorComparison checkNumericCompatibility(@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor, @Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor) {     String ld = leftDeclaredDescriptor.     String rd = rightDeclaredDescriptor.     boolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld).     boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd).     // If the declared descriptors aren't providing the information, try the actual descriptors     if (!leftNumeric && !ObjectUtils.nullSafeEquals(ld, leftActualDescriptor)) {         ld = leftActualDescriptor.         leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld).     }     if (!rightNumeric && !ObjectUtils.nullSafeEquals(rd, rightActualDescriptor)) {         rd = rightActualDescriptor.         rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd).     }     if (leftNumeric && rightNumeric) {         if (CodeFlow.areBoxingCompatible(ld, rd)) {             return new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld)).         } else {             return DescriptorComparison.INCOMPATIBLE_NUMBERS.         }     } else {         return DescriptorComparison.NOT_NUMBERS.     } }
