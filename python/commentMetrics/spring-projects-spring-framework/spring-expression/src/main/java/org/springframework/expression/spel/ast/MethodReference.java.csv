commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;3;;public final String getName() {     return this.name. }
false;protected;1;9;;@Override protected ValueRef getValueRef(ExpressionState state) throws EvaluationException {     Object[] arguments = getArguments(state).     if (state.getActiveContextObject().getValue() == null) {         throwIfNotNullSafe(getArgumentTypes(arguments)).         return ValueRef.NullValueRef.INSTANCE.     }     return new MethodValueRef(state, arguments). }
false;public;1;10;;@Override public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {     EvaluationContext evaluationContext = state.getEvaluationContext().     Object value = state.getActiveContextObject().getValue().     TypeDescriptor targetType = state.getActiveContextObject().getTypeDescriptor().     Object[] arguments = getArguments(state).     TypedValue result = getValueInternal(evaluationContext, value, targetType, arguments).     updateExitTypeDescriptor().     return result. }
false;private;4;49;;private TypedValue getValueInternal(EvaluationContext evaluationContext, @Nullable Object value, @Nullable TypeDescriptor targetType, Object[] arguments) {     List<TypeDescriptor> argumentTypes = getArgumentTypes(arguments).     if (value == null) {         throwIfNotNullSafe(argumentTypes).         return TypedValue.NULL.     }     MethodExecutor executorToUse = getCachedExecutor(evaluationContext, value, targetType, argumentTypes).     if (executorToUse != null) {         try {             return executorToUse.execute(evaluationContext, value, arguments).         } catch (AccessException ex) {             // Two reasons this can occur:             // 1. the method invoked actually threw a real exception             // 2. the method invoked was not passed the arguments it expected and             // has become 'stale'             // In the first case we should not retry, in the second case we should see             // if there is a better suited method.             // To determine the situation, the AccessException will contain a cause.             // If the cause is an InvocationTargetException, a user exception was             // thrown inside the method. Otherwise the method could not be invoked.             throwSimpleExceptionIfPossible(value, ex).             // At this point we know it wasn't a user problem so worth a retry if a             // better candidate can be found.             this.cachedExecutor = null.         }     }     // either there was no accessor or it no longer existed     executorToUse = findAccessorForMethod(argumentTypes, value, evaluationContext).     this.cachedExecutor = new CachedMethodExecutor(executorToUse, (value instanceof Class ? (Class<?>) value : null), targetType, argumentTypes).     try {         return executorToUse.execute(evaluationContext, value, arguments).     } catch (AccessException ex) {         // Same unwrapping exception handling as above in above catch block         throwSimpleExceptionIfPossible(value, ex).         throw new SpelEvaluationException(getStartPosition(), ex, SpelMessage.EXCEPTION_DURING_METHOD_INVOCATION, this.name, value.getClass().getName(), ex.getMessage()).     } }
false;private;1;7;;private void throwIfNotNullSafe(List<TypeDescriptor> argumentTypes) {     if (!this.nullSafe) {         throw new SpelEvaluationException(getStartPosition(), SpelMessage.METHOD_CALL_ON_NULL_OBJECT_NOT_ALLOWED, FormatHelper.formatMethodForMessage(this.name, argumentTypes)).     } }
false;private;1;14;;private Object[] getArguments(ExpressionState state) {     Object[] arguments = new Object[getChildCount()].     for (int i = 0. i < arguments.length. i++) {         // Make the root object the active context again for evaluating the parameter expressions         try {             state.pushActiveContextObject(state.getScopeRootContextObject()).             arguments[i] = this.children[i].getValueInternal(state).getValue().         } finally {             state.popActiveContextObject().         }     }     return arguments. }
false;private;1;7;;private List<TypeDescriptor> getArgumentTypes(Object... arguments) {     List<TypeDescriptor> descriptors = new ArrayList<>(arguments.length).     for (Object argument : arguments) {         descriptors.add(TypeDescriptor.forObject(argument)).     }     return Collections.unmodifiableList(descriptors). }
false;private;4;17;;@Nullable private MethodExecutor getCachedExecutor(EvaluationContext evaluationContext, Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes) {     List<MethodResolver> methodResolvers = evaluationContext.getMethodResolvers().     if (methodResolvers.size() != 1 || !(methodResolvers.get(0) instanceof ReflectiveMethodResolver)) {         // Not a default ReflectiveMethodResolver - don't know whether caching is valid         return null.     }     CachedMethodExecutor executorToCheck = this.cachedExecutor.     if (executorToCheck != null && executorToCheck.isSuitable(value, target, argumentTypes)) {         return executorToCheck.get().     }     this.cachedExecutor = null.     return null. }
false;private;3;30;;private MethodExecutor findAccessorForMethod(List<TypeDescriptor> argumentTypes, Object targetObject, EvaluationContext evaluationContext) throws SpelEvaluationException {     AccessException accessException = null.     List<MethodResolver> methodResolvers = evaluationContext.getMethodResolvers().     for (MethodResolver methodResolver : methodResolvers) {         try {             MethodExecutor methodExecutor = methodResolver.resolve(evaluationContext, targetObject, this.name, argumentTypes).             if (methodExecutor != null) {                 return methodExecutor.             }         } catch (AccessException ex) {             accessException = ex.             break.         }     }     String method = FormatHelper.formatMethodForMessage(this.name, argumentTypes).     String className = FormatHelper.formatClassNameForMessage(targetObject instanceof Class ? ((Class<?>) targetObject) : targetObject.getClass()).     if (accessException != null) {         throw new SpelEvaluationException(getStartPosition(), accessException, SpelMessage.PROBLEM_LOCATING_METHOD, method, className).     } else {         throw new SpelEvaluationException(getStartPosition(), SpelMessage.METHOD_NOT_FOUND, method, className).     } }
true;private;2;11;/**  * Decode the AccessException, throwing a lightweight evaluation exception or,  * if the cause was a RuntimeException, throw the RuntimeException directly.  */ ;/**  * Decode the AccessException, throwing a lightweight evaluation exception or,  * if the cause was a RuntimeException, throw the RuntimeException directly.  */ private void throwSimpleExceptionIfPossible(Object value, AccessException ex) {     if (ex.getCause() instanceof InvocationTargetException) {         Throwable rootCause = ex.getCause().getCause().         if (rootCause instanceof RuntimeException) {             throw (RuntimeException) rootCause.         }         throw new ExpressionInvocationTargetException(getStartPosition(), "A problem occurred when trying to execute method '" + this.name + "' on object of type [" + value.getClass().getName() + "]", rootCause).     } }
false;private;0;14;;private void updateExitTypeDescriptor() {     CachedMethodExecutor executorToCheck = this.cachedExecutor.     if (executorToCheck != null && executorToCheck.get() instanceof ReflectiveMethodExecutor) {         Method method = ((ReflectiveMethodExecutor) executorToCheck.get()).getMethod().         String descriptor = CodeFlow.toDescriptor(method.getReturnType()).         if (this.nullSafe && CodeFlow.isPrimitive(descriptor)) {             this.originalPrimitiveExitTypeDescriptor = descriptor.             this.exitTypeDescriptor = CodeFlow.toBoxedDescriptor(descriptor).         } else {             this.exitTypeDescriptor = descriptor.         }     } }
false;public;0;8;;@Override public String toStringAST() {     StringJoiner sj = new StringJoiner(",", "(", ")").     for (int i = 0. i < getChildCount(). i++) {         sj.add(getChild(i).toStringAST()).     }     return this.name + sj.toString(). }
true;public;0;25;/**  * A method reference is compilable if it has been resolved to a reflectively accessible method  * and the child nodes (arguments to the method) are also compilable.  */ ;/**  * A method reference is compilable if it has been resolved to a reflectively accessible method  * and the child nodes (arguments to the method) are also compilable.  */ @Override public boolean isCompilable() {     CachedMethodExecutor executorToCheck = this.cachedExecutor.     if (executorToCheck == null || executorToCheck.hasProxyTarget() || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {         return false.     }     for (SpelNodeImpl child : this.children) {         if (!child.isCompilable()) {             return false.         }     }     ReflectiveMethodExecutor executor = (ReflectiveMethodExecutor) executorToCheck.get().     if (executor.didArgumentConversionOccur()) {         return false.     }     Class<?> clazz = executor.getMethod().getDeclaringClass().     if (!Modifier.isPublic(clazz.getModifiers()) && executor.getPublicDeclaringClass() == null) {         return false.     }     return true. }
false;public;2;63;;@Override public void generateCode(MethodVisitor mv, CodeFlow cf) {     CachedMethodExecutor executorToCheck = this.cachedExecutor.     if (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {         throw new IllegalStateException("No applicable cached executor found: " + executorToCheck).     }     ReflectiveMethodExecutor methodExecutor = (ReflectiveMethodExecutor) executorToCheck.get().     Method method = methodExecutor.getMethod().     boolean isStaticMethod = Modifier.isStatic(method.getModifiers()).     String descriptor = cf.lastDescriptor().     Label skipIfNull = null.     if (descriptor == null && !isStaticMethod) {         // Nothing on the stack but something is needed         cf.loadTarget(mv).     }     if ((descriptor != null || !isStaticMethod) && this.nullSafe) {         mv.visitInsn(DUP).         skipIfNull = new Label().         Label continueLabel = new Label().         mv.visitJumpInsn(IFNONNULL, continueLabel).         CodeFlow.insertCheckCast(mv, this.exitTypeDescriptor).         mv.visitJumpInsn(GOTO, skipIfNull).         mv.visitLabel(continueLabel).     }     if (descriptor != null && isStaticMethod) {         // Something on the stack when nothing is needed         mv.visitInsn(POP).     }     if (CodeFlow.isPrimitive(descriptor)) {         CodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0)).     }     String classDesc.     if (Modifier.isPublic(method.getDeclaringClass().getModifiers())) {         classDesc = method.getDeclaringClass().getName().replace('.', '/').     } else {         Class<?> publicDeclaringClass = methodExecutor.getPublicDeclaringClass().         Assert.state(publicDeclaringClass != null, "No public declaring class").         classDesc = publicDeclaringClass.getName().replace('.', '/').     }     if (!isStaticMethod && (descriptor == null || !descriptor.substring(1).equals(classDesc))) {         CodeFlow.insertCheckCast(mv, "L" + classDesc).     }     generateCodeForArguments(mv, cf, method, this.children).     mv.visitMethodInsn((isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, method.getName(), CodeFlow.createSignatureDescriptor(method), method.getDeclaringClass().isInterface()).     cf.pushDescriptor(this.exitTypeDescriptor).     if (this.originalPrimitiveExitTypeDescriptor != null) {         // The output of the accessor will be a primitive but from the block above it might be null,         // so to have a 'common stack' element at skipIfNull target we need to box the primitive         CodeFlow.insertBoxIfNecessary(mv, this.originalPrimitiveExitTypeDescriptor).     }     if (skipIfNull != null) {         mv.visitLabel(skipIfNull).     } }
false;public;0;7;;@Override public TypedValue getValue() {     TypedValue result = MethodReference.this.getValueInternal(this.evaluationContext, this.value, this.targetType, this.arguments).     updateExitTypeDescriptor().     return result. }
false;public;1;4;;@Override public void setValue(@Nullable Object newValue) {     throw new IllegalAccessError(). }
false;public;0;4;;@Override public boolean isWritable() {     return false. }
false;public;3;4;;public boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes) {     return ((this.staticClass == null || this.staticClass == value) && ObjectUtils.nullSafeEquals(this.target, target) && this.argumentTypes.equals(argumentTypes)). }
false;public;0;3;;public boolean hasProxyTarget() {     return (this.target != null && Proxy.isProxyClass(this.target.getType())). }
false;public;0;3;;public MethodExecutor get() {     return this.methodExecutor. }
