# id;timestamp;commentText;codeText;commentWords;codeWords
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) 			throws SpelEvaluationException;1412630983;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state)_			throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		if (ctorResolvers != null) {_			for (ConstructorResolver ctorResolver : ctorResolvers) {_				try {_					ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__					if (ce != null) {_						return ce__					}_				}_				catch (AccessException ex) {_					throw new SpelEvaluationException(getStartPosition(), ex,_							SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_							FormatHelper.formatMethodForMessage("", argumentTypes))__				}_			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,if,ctor,resolvers,null,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) 			throws SpelEvaluationException;1413566814;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state)_			throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		if (ctorResolvers != null) {_			for (ConstructorResolver ctorResolver : ctorResolvers) {_				try {_					ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__					if (ce != null) {_						return ce__					}_				}_				catch (AccessException ex) {_					throw new SpelEvaluationException(getStartPosition(), ex,_							SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_							FormatHelper.formatMethodForMessage("", argumentTypes))__				}_			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,if,ctor,resolvers,null,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) 			throws SpelEvaluationException;1414261335;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state)_			throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		if (ctorResolvers != null) {_			for (ConstructorResolver ctorResolver : ctorResolvers) {_				try {_					ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__					if (ce != null) {_						return ce__					}_				}_				catch (AccessException ex) {_					throw new SpelEvaluationException(getStartPosition(), ex,_							SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_							FormatHelper.formatMethodForMessage("", argumentTypes))__				}_			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,if,ctor,resolvers,null,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) 			throws SpelEvaluationException;1449965678;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state)_			throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		if (ctorResolvers != null) {_			for (ConstructorResolver ctorResolver : ctorResolvers) {_				try {_					ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__					if (ce != null) {_						return ce__					}_				}_				catch (AccessException ex) {_					throw new SpelEvaluationException(getStartPosition(), ex,_							SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_							FormatHelper.formatMethodForMessage("", argumentTypes))__				}_			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,if,ctor,resolvers,null,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) 			throws SpelEvaluationException;1467730834;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state)_			throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		if (ctorResolvers != null) {_			for (ConstructorResolver ctorResolver : ctorResolvers) {_				try {_					ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__					if (ce != null) {_						return ce__					}_				}_				catch (AccessException ex) {_					throw new SpelEvaluationException(getStartPosition(), ex,_							SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_							FormatHelper.formatMethodForMessage("", argumentTypes))__				}_			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,if,ctor,resolvers,null,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1328020251;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1356735495;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1372363092;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1405011154;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1405514506;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1412630983;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1413566814;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1414261335;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1449965678;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1467730834;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1495868221;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1496837955;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1498780456;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1515364415;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1522332300;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1530174524;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments);1530174524;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl[] dimensions, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = true__		this.dimensions = dimensions__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,dimensions,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,true,this,dimensions,dimensions
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1328020251;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1356735495;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1372363092;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1405011154;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1405514506;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1412630983;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1413566814;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1414261335;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1449965678;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1467730834;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1495868221;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1496837955;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1498780456;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1515364415;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1522332300;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1530174524;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1530174524;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> @Override 	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException;1548712256;Implements getValue() - delegating to the code for building an array or a simple type.;@Override_	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {_		if (this.isArrayConstructor) {_			return createArray(state)__		}_		else {_			return createNewInstance(state)__		}_	};implements,get,value,delegating,to,the,code,for,building,an,array,or,a,simple,type;override,public,typed,value,get,value,internal,expression,state,state,throws,evaluation,exception,if,this,is,array,constructor,return,create,array,state,else,return,create,new,instance,state
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1328020251;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1356735495;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1372363092;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1405011154;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1405514506;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1412630983;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1413566814;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1414261335;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1449965678;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1467730834;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1495868221;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1496837955;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1498780456;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1515364415;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1522332300;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1530174524;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> public ConstructorReference(int pos, SpelNodeImpl... arguments);1530174524;Create a constructor reference. The first argument is the type, the rest are the parameters to the constructor_call;public ConstructorReference(int pos, SpelNodeImpl... arguments) {_		super(pos, arguments)__		this.isArrayConstructor = false__	};create,a,constructor,reference,the,first,argument,is,the,type,the,rest,are,the,parameters,to,the,constructor,call;public,constructor,reference,int,pos,spel,node,impl,arguments,super,pos,arguments,this,is,array,constructor,false
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1328020251;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<TypeDescriptor>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ae) {_				_				_				__				_				__				_				_				_				if (ae.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ae.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					} else {_						String typename = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename, FormatHelper_										.formatMethodForMessage("", argumentTypes))__					}					_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typename = (String) this.children[0].getValueInternal(state).getValue()__		executorToUse = findExecutorForConstructor(typename, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ae) {_			throw new SpelEvaluationException(getStartPosition(), ae, SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM,_					typename, FormatHelper.formatMethodForMessage("", argumentTypes))___		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,type,descriptor,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ae,if,ae,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ae,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,typename,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,typename,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,typename,string,this,children,0,get,value,internal,state,get,value,executor,to,use,find,executor,for,constructor,typename,argument,types,state,try,this,cached,executor,executor,to,use,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ae,throw,new,spel,evaluation,exception,get,start,position,ae,spel,message,typename,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1356735495;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<TypeDescriptor>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ae) {_				_				_				__				_				__				_				_				_				if (ae.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ae.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					} else {_						String typename = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename, FormatHelper_										.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typename = (String) this.children[0].getValueInternal(state).getValue()__		executorToUse = findExecutorForConstructor(typename, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ae) {_			throw new SpelEvaluationException(getStartPosition(), ae, SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM,_					typename, FormatHelper.formatMethodForMessage("", argumentTypes))___		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,type,descriptor,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ae,if,ae,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ae,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,typename,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,typename,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,typename,string,this,children,0,get,value,internal,state,get,value,executor,to,use,find,executor,for,constructor,typename,argument,types,state,try,this,cached,executor,executor,to,use,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ae,throw,new,spel,evaluation,exception,get,start,position,ae,spel,message,typename,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1372363092;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<TypeDescriptor>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ae) {_				_				_				__				_				__				_				_				_				if (ae.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ae.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typename = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename, FormatHelper_										.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typename = (String) this.children[0].getValueInternal(state).getValue()__		executorToUse = findExecutorForConstructor(typename, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ae) {_			throw new SpelEvaluationException(getStartPosition(), ae,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,type,descriptor,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ae,if,ae,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ae,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,typename,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,typename,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,typename,string,this,children,0,get,value,internal,state,get,value,executor,to,use,find,executor,for,constructor,typename,argument,types,state,try,this,cached,executor,executor,to,use,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ae,throw,new,spel,evaluation,exception,get,start,position,ae,spel,message,typename,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1405011154;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<TypeDescriptor>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ae) {_				_				_				__				_				__				_				_				_				if (ae.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ae.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typename = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename, FormatHelper_										.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typename = (String) this.children[0].getValueInternal(state).getValue()__		executorToUse = findExecutorForConstructor(typename, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (this.cachedExecutor instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(((ReflectiveConstructorExecutor)this.cachedExecutor).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ae) {_			throw new SpelEvaluationException(getStartPosition(), ae,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,type,descriptor,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ae,if,ae,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ae,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,typename,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,typename,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,typename,string,this,children,0,get,value,internal,state,get,value,executor,to,use,find,executor,for,constructor,typename,argument,types,state,try,this,cached,executor,executor,to,use,if,this,cached,executor,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,this,cached,executor,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ae,throw,new,spel,evaluation,exception,get,start,position,ae,spel,message,typename,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1405514506;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<TypeDescriptor>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ae) {_				_				_				__				_				__				_				_				_				if (ae.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ae.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typename = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename, FormatHelper_										.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typename = (String) this.children[0].getValueInternal(state).getValue()__		executorToUse = findExecutorForConstructor(typename, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (this.cachedExecutor instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(((ReflectiveConstructorExecutor)this.cachedExecutor).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ae) {_			throw new SpelEvaluationException(getStartPosition(), ae,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,type,descriptor,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ae,if,ae,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ae,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,typename,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,typename,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,typename,string,this,children,0,get,value,internal,state,get,value,executor,to,use,find,executor,for,constructor,typename,argument,types,state,try,this,cached,executor,executor,to,use,if,this,cached,executor,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,this,cached,executor,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ae,throw,new,spel,evaluation,exception,get,start,position,ae,spel,message,typename,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1412630983;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<TypeDescriptor>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (this.cachedExecutor instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) this.cachedExecutor).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,type,descriptor,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,this,cached,executor,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,this,cached,executor,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1413566814;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<TypeDescriptor>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (this.cachedExecutor instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) this.cachedExecutor).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,type,descriptor,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,this,cached,executor,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,this,cached,executor,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1414261335;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<TypeDescriptor>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (this.cachedExecutor instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) this.cachedExecutor).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,type,descriptor,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,this,cached,executor,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,this,cached,executor,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1449965678;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<TypeDescriptor>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (this.cachedExecutor instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) this.cachedExecutor).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,type,descriptor,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,this,cached,executor,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,this,cached,executor,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1467730834;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (this.cachedExecutor instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) this.cachedExecutor).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,this,cached,executor,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,this,cached,executor,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1495868221;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (this.cachedExecutor instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) this.cachedExecutor).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,this,cached,executor,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,this,cached,executor,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1496837955;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		Assert.state(typeName != null, "No type name")__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (this.cachedExecutor instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) this.cachedExecutor).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,assert,state,type,name,null,no,type,name,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,this,cached,executor,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,this,cached,executor,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1498780456;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		Assert.state(typeName != null, "No type name")__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (executorToUse instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) executorToUse).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,assert,state,type,name,null,no,type,name,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,executor,to,use,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,executor,to,use,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1515364415;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		Assert.state(typeName != null, "No type name")__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (executorToUse instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) executorToUse).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,assert,state,type,name,null,no,type,name,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,executor,to,use,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,executor,to,use,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1522332300;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		Assert.state(typeName != null, "No type name")__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (executorToUse instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) executorToUse).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,assert,state,type,name,null,no,type,name,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,executor,to,use,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,executor,to,use,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1530174524;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		Assert.state(typeName != null, "No type name")__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (executorToUse instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) executorToUse).getConstructor().getDeclaringClass())__				_			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,assert,state,type,name,null,no,type,name,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,executor,to,use,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,executor,to,use,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1530174524;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		Assert.state(typeName != null, "No type name")__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (executorToUse instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) executorToUse).getConstructor().getDeclaringClass())___			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,assert,state,type,name,null,no,type,name,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,executor,to,use,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,executor,to,use,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createNewInstance(ExpressionState state) throws EvaluationException;1548712256;Create a new ordinary object and return it._@param state the expression state within which this expression is being evaluated_@return the new object_@throws EvaluationException if there is a problem creating the object;private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {_		Object[] arguments = new Object[getChildCount() - 1]__		List<TypeDescriptor> argumentTypes = new ArrayList<>(getChildCount() - 1)__		for (int i = 0_ i < arguments.length_ i++) {_			TypedValue childValue = this.children[i + 1].getValueInternal(state)__			Object value = childValue.getValue()__			arguments[i] = value__			argumentTypes.add(TypeDescriptor.forObject(value))__		}__		ConstructorExecutor executorToUse = this.cachedExecutor__		if (executorToUse != null) {_			try {_				return executorToUse.execute(state.getEvaluationContext(), arguments)__			}_			catch (AccessException ex) {_				_				_				__				_				__				_				_				_				if (ex.getCause() instanceof InvocationTargetException) {_					_					Throwable rootCause = ex.getCause().getCause()__					if (rootCause instanceof RuntimeException) {_						throw (RuntimeException) rootCause__					}_					else {_						String typeName = (String) this.children[0].getValueInternal(state).getValue()__						throw new SpelEvaluationException(getStartPosition(), rootCause,_								SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_								FormatHelper.formatMethodForMessage("", argumentTypes))__					}_				}__				_				this.cachedExecutor = null__			}_		}__		_		String typeName = (String) this.children[0].getValueInternal(state).getValue()__		Assert.state(typeName != null, "No type name")__		executorToUse = findExecutorForConstructor(typeName, argumentTypes, state)__		try {_			this.cachedExecutor = executorToUse__			if (executorToUse instanceof ReflectiveConstructorExecutor) {_				this.exitTypeDescriptor = CodeFlow.toDescriptor(_						((ReflectiveConstructorExecutor) executorToUse).getConstructor().getDeclaringClass())___			}_			return executorToUse.execute(state.getEvaluationContext(), arguments)__		}_		catch (AccessException ex) {_			throw new SpelEvaluationException(getStartPosition(), ex,_					SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_					FormatHelper.formatMethodForMessage("", argumentTypes))__		}_	};create,a,new,ordinary,object,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,object,throws,evaluation,exception,if,there,is,a,problem,creating,the,object;private,typed,value,create,new,instance,expression,state,state,throws,evaluation,exception,object,arguments,new,object,get,child,count,1,list,type,descriptor,argument,types,new,array,list,get,child,count,1,for,int,i,0,i,arguments,length,i,typed,value,child,value,this,children,i,1,get,value,internal,state,object,value,child,value,get,value,arguments,i,value,argument,types,add,type,descriptor,for,object,value,constructor,executor,executor,to,use,this,cached,executor,if,executor,to,use,null,try,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,if,ex,get,cause,instanceof,invocation,target,exception,throwable,root,cause,ex,get,cause,get,cause,if,root,cause,instanceof,runtime,exception,throw,runtime,exception,root,cause,else,string,type,name,string,this,children,0,get,value,internal,state,get,value,throw,new,spel,evaluation,exception,get,start,position,root,cause,spel,message,type,name,format,helper,format,method,for,message,argument,types,this,cached,executor,null,string,type,name,string,this,children,0,get,value,internal,state,get,value,assert,state,type,name,null,no,type,name,executor,to,use,find,executor,for,constructor,type,name,argument,types,state,try,this,cached,executor,executor,to,use,if,executor,to,use,instanceof,reflective,constructor,executor,this,exit,type,descriptor,code,flow,to,descriptor,reflective,constructor,executor,executor,to,use,get,constructor,get,declaring,class,return,executor,to,use,execute,state,get,evaluation,context,arguments,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typename, 			List<TypeDescriptor> argumentTypes, ExpressionState state) 			throws SpelEvaluationException;1372363092;Go through the list of registered constructor resolvers and see if any can find a constructor that takes the_specified set of arguments._@param typename the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typename,_			List<TypeDescriptor> argumentTypes, ExpressionState state)_			throws SpelEvaluationException {__		EvaluationContext eContext = state.getEvaluationContext()__		List<ConstructorResolver> cResolvers = eContext.getConstructorResolvers()__		if (cResolvers != null) {_			for (ConstructorResolver ctorResolver : cResolvers) {_				try {_					ConstructorExecutor cEx = ctorResolver.resolve(state.getEvaluationContext(), typename,_							argumentTypes)__					if (cEx != null) {_						return cEx__					}_				}_				catch (AccessException ex) {_					throw new SpelEvaluationException(getStartPosition(), ex,_							SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename,_							FormatHelper.formatMethodForMessage("", argumentTypes))__				}_			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typename, FormatHelper_				.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,typename,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,typename,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,e,context,state,get,evaluation,context,list,constructor,resolver,c,resolvers,e,context,get,constructor,resolvers,if,c,resolvers,null,for,constructor,resolver,ctor,resolver,c,resolvers,try,constructor,executor,c,ex,ctor,resolver,resolve,state,get,evaluation,context,typename,argument,types,if,c,ex,null,return,c,ex,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,typename,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,typename,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typename, 			List<TypeDescriptor> argumentTypes, ExpressionState state) 			throws SpelEvaluationException;1405011154;Go through the list of registered constructor resolvers and see if any can find a constructor that takes the_specified set of arguments._@param typename the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typename,_			List<TypeDescriptor> argumentTypes, ExpressionState state)_			throws SpelEvaluationException {__		EvaluationContext eContext = state.getEvaluationContext()__		List<ConstructorResolver> cResolvers = eContext.getConstructorResolvers()__		if (cResolvers != null) {_			for (ConstructorResolver ctorResolver : cResolvers) {_				try {_					ConstructorExecutor cEx = ctorResolver.resolve(state.getEvaluationContext(), typename,_							argumentTypes)__					if (cEx != null) {_						return cEx__					}_				}_				catch (AccessException ex) {_					throw new SpelEvaluationException(getStartPosition(), ex,_							SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename,_							FormatHelper.formatMethodForMessage("", argumentTypes))__				}_			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typename, FormatHelper_				.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,typename,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,typename,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,e,context,state,get,evaluation,context,list,constructor,resolver,c,resolvers,e,context,get,constructor,resolvers,if,c,resolvers,null,for,constructor,resolver,ctor,resolver,c,resolvers,try,constructor,executor,c,ex,ctor,resolver,resolve,state,get,evaluation,context,typename,argument,types,if,c,ex,null,return,c,ex,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,typename,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,typename,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typename, 			List<TypeDescriptor> argumentTypes, ExpressionState state) 			throws SpelEvaluationException;1405514506;Go through the list of registered constructor resolvers and see if any can find a constructor that takes the_specified set of arguments._@param typename the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typename,_			List<TypeDescriptor> argumentTypes, ExpressionState state)_			throws SpelEvaluationException {__		EvaluationContext eContext = state.getEvaluationContext()__		List<ConstructorResolver> cResolvers = eContext.getConstructorResolvers()__		if (cResolvers != null) {_			for (ConstructorResolver ctorResolver : cResolvers) {_				try {_					ConstructorExecutor cEx = ctorResolver.resolve(state.getEvaluationContext(), typename,_							argumentTypes)__					if (cEx != null) {_						return cEx__					}_				}_				catch (AccessException ex) {_					throw new SpelEvaluationException(getStartPosition(), ex,_							SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename,_							FormatHelper.formatMethodForMessage("", argumentTypes))__				}_			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typename, FormatHelper_				.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,typename,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,typename,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,e,context,state,get,evaluation,context,list,constructor,resolver,c,resolvers,e,context,get,constructor,resolvers,if,c,resolvers,null,for,constructor,resolver,ctor,resolver,c,resolvers,try,constructor,executor,c,ex,ctor,resolver,resolve,state,get,evaluation,context,typename,argument,types,if,c,ex,null,return,c,ex,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,typename,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,typename,format,helper,format,method,for,message,argument,types
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1328020251;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION, FormatHelper_							.formatClassNameForMessage(intendedArrayType.getClass()))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,get,class,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1356735495;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION, FormatHelper_							.formatClassNameForMessage(intendedArrayType.getClass()))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,get,class,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1372363092;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(intendedArrayType.getClass()))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,get,class,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1405011154;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(intendedArrayType.getClass()))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,get,class,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1405514506;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(intendedArrayType.getClass()))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,get,class,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1412630983;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(intendedArrayType.getClass()))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,get,class,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1413566814;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(intendedArrayType.getClass()))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,get,class,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1414261335;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(intendedArrayType.getClass()))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,get,class,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1449965678;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(intendedArrayType.getClass()))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,get,class,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1467730834;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(intendedArrayType.getClass()))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,get,class,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1495868221;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(intendedArrayType.getClass()))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,get,class,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1496837955;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(_							intendedArrayType != null ? intendedArrayType.getClass() : null))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			for (SpelNodeImpl dimension : this.dimensions) {_				if (dimension == null) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,null,intended,array,type,get,class,null,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1498780456;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(_							intendedArrayType != null ? intendedArrayType.getClass() : null))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			if (this.dimensions != null) {_				for (SpelNodeImpl dimension : this.dimensions) {_					if (dimension == null) {_						throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__					}_				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions == null || this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,null,intended,array,type,get,class,null,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,if,this,dimensions,null,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,null,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1515364415;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(_							intendedArrayType != null ? intendedArrayType.getClass() : null))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			if (this.dimensions != null) {_				for (SpelNodeImpl dimension : this.dimensions) {_					if (dimension == null) {_						throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__					}_				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions == null || this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,null,intended,array,type,get,class,null,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,if,this,dimensions,null,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,null,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1522332300;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(_							intendedArrayType != null ? intendedArrayType.getClass() : null))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			if (this.dimensions != null) {_				for (SpelNodeImpl dimension : this.dimensions) {_					if (dimension == null) {_						throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__					}_				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions == null || this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,null,intended,array,type,get,class,null,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,if,this,dimensions,null,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,null,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1530174524;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(_							intendedArrayType != null ? intendedArrayType.getClass() : null))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			if (this.dimensions != null) {_				for (SpelNodeImpl dimension : this.dimensions) {_					if (dimension == null) {_						throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__					}_				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions == null || this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,null,intended,array,type,get,class,null,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,if,this,dimensions,null,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,null,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1530174524;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(_							intendedArrayType != null ? intendedArrayType.getClass() : null))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			if (this.dimensions != null) {_				for (SpelNodeImpl dimension : this.dimensions) {_					if (dimension == null) {_						throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__					}_				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions == null || this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,null,intended,array,type,get,class,null,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,if,this,dimensions,null,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,null,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private TypedValue createArray(ExpressionState state) throws EvaluationException;1548712256;Create an array and return it._@param state the expression state within which this expression is being evaluated_@return the new array_@throws EvaluationException if there is a problem creating the array;private TypedValue createArray(ExpressionState state) throws EvaluationException {_		_		Object intendedArrayType = getChild(0).getValue(state)__		if (!(intendedArrayType instanceof String)) {_			throw new SpelEvaluationException(getChild(0).getStartPosition(),_					SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,_					FormatHelper.formatClassNameForMessage(_							intendedArrayType != null ? intendedArrayType.getClass() : null))__		}_		String type = (String) intendedArrayType__		Class<?> componentType__		TypeCode arrayTypeCode = TypeCode.forName(type)__		if (arrayTypeCode == TypeCode.OBJECT) {_			componentType = state.findType(type)__		}_		else {_			componentType = arrayTypeCode.getType()__		}_		Object newArray__		if (!hasInitializer()) {_			_			if (this.dimensions != null) {_				for (SpelNodeImpl dimension : this.dimensions) {_					if (dimension == null) {_						throw new SpelEvaluationException(getStartPosition(), SpelMessage.MISSING_ARRAY_DIMENSION)__					}_				}_			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()___			_			if (this.dimensions.length == 1) {_				TypedValue o = this.dimensions[0].getTypedValue(state)__				int arraySize = ExpressionUtils.toInt(typeConverter, o)__				newArray = Array.newInstance(componentType, arraySize)__			}_			else {_				_				int[] dims = new int[this.dimensions.length]__				for (int d = 0_ d < this.dimensions.length_ d++) {_					TypedValue o = this.dimensions[d].getTypedValue(state)__					dims[d] = ExpressionUtils.toInt(typeConverter, o)__				}_				newArray = Array.newInstance(componentType, dims)__			}_		}_		else {_			_			if (this.dimensions == null || this.dimensions.length > 1) {_				_				_				throw new SpelEvaluationException(getStartPosition(),_						SpelMessage.MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED)__			}_			TypeConverter typeConverter = state.getEvaluationContext().getTypeConverter()__			InlineList initializer = (InlineList) getChild(1)__			_			if (this.dimensions[0] != null) {_				TypedValue dValue = this.dimensions[0].getTypedValue(state)__				int i = ExpressionUtils.toInt(typeConverter, dValue)__				if (i != initializer.getChildCount()) {_					throw new SpelEvaluationException(getStartPosition(), SpelMessage.INITIALIZER_LENGTH_INCORRECT)__				}_			}_			_			int arraySize = initializer.getChildCount()__			newArray = Array.newInstance(componentType, arraySize)__			if (arrayTypeCode == TypeCode.OBJECT) {_				populateReferenceTypeArray(state, newArray, typeConverter, initializer, componentType)__			}_			else if (arrayTypeCode == TypeCode.BOOLEAN) {_				populateBooleanArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.BYTE) {_				populateByteArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.CHAR) {_				populateCharArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.DOUBLE) {_				populateDoubleArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.FLOAT) {_				populateFloatArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.INT) {_				populateIntArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.LONG) {_				populateLongArray(state, newArray, typeConverter, initializer)__			}_			else if (arrayTypeCode == TypeCode.SHORT) {_				populateShortArray(state, newArray, typeConverter, initializer)__			}_			else {_				throw new IllegalStateException(arrayTypeCode.name())__			}_		}_		return new TypedValue(newArray)__	};create,an,array,and,return,it,param,state,the,expression,state,within,which,this,expression,is,being,evaluated,return,the,new,array,throws,evaluation,exception,if,there,is,a,problem,creating,the,array;private,typed,value,create,array,expression,state,state,throws,evaluation,exception,object,intended,array,type,get,child,0,get,value,state,if,intended,array,type,instanceof,string,throw,new,spel,evaluation,exception,get,child,0,get,start,position,spel,message,format,helper,format,class,name,for,message,intended,array,type,null,intended,array,type,get,class,null,string,type,string,intended,array,type,class,component,type,type,code,array,type,code,type,code,for,name,type,if,array,type,code,type,code,object,component,type,state,find,type,type,else,component,type,array,type,code,get,type,object,new,array,if,has,initializer,if,this,dimensions,null,for,spel,node,impl,dimension,this,dimensions,if,dimension,null,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,if,this,dimensions,length,1,typed,value,o,this,dimensions,0,get,typed,value,state,int,array,size,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,array,size,else,int,dims,new,int,this,dimensions,length,for,int,d,0,d,this,dimensions,length,d,typed,value,o,this,dimensions,d,get,typed,value,state,dims,d,expression,utils,to,int,type,converter,o,new,array,array,new,instance,component,type,dims,else,if,this,dimensions,null,this,dimensions,length,1,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,converter,type,converter,state,get,evaluation,context,get,type,converter,inline,list,initializer,inline,list,get,child,1,if,this,dimensions,0,null,typed,value,d,value,this,dimensions,0,get,typed,value,state,int,i,expression,utils,to,int,type,converter,d,value,if,i,initializer,get,child,count,throw,new,spel,evaluation,exception,get,start,position,spel,message,int,array,size,initializer,get,child,count,new,array,array,new,instance,component,type,array,size,if,array,type,code,type,code,object,populate,reference,type,array,state,new,array,type,converter,initializer,component,type,else,if,array,type,code,type,code,boolean,populate,boolean,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,byte,populate,byte,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,char,populate,char,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,double,populate,double,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,float,populate,float,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,int,populate,int,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,long,populate,long,array,state,new,array,type,converter,initializer,else,if,array,type,code,type,code,short,populate,short,array,state,new,array,type,converter,initializer,else,throw,new,illegal,state,exception,array,type,code,name,return,new,typed,value,new,array
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typename, List<TypeDescriptor> argumentTypes, 			ExpressionState state) throws SpelEvaluationException;1328020251;Go through the list of registered constructor resolvers and see if any can find a constructor that takes the_specified set of arguments._@param typename the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typename, List<TypeDescriptor> argumentTypes,_			ExpressionState state) throws SpelEvaluationException {__		EvaluationContext eContext = state.getEvaluationContext()__		List<ConstructorResolver> cResolvers = eContext.getConstructorResolvers()__		if (cResolvers != null) {_			for (ConstructorResolver ctorResolver : cResolvers) {_				try {_					ConstructorExecutor cEx = ctorResolver.resolve(state.getEvaluationContext(), typename,_							argumentTypes)__					if (cEx != null) {_						return cEx__					}_				}_				catch (AccessException ex) {_					throw new SpelEvaluationException(getStartPosition(), ex,_							SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename,_							FormatHelper.formatMethodForMessage("", argumentTypes))__				}_			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typename, FormatHelper_				.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,typename,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,typename,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,e,context,state,get,evaluation,context,list,constructor,resolver,c,resolvers,e,context,get,constructor,resolvers,if,c,resolvers,null,for,constructor,resolver,ctor,resolver,c,resolvers,try,constructor,executor,c,ex,ctor,resolver,resolve,state,get,evaluation,context,typename,argument,types,if,c,ex,null,return,c,ex,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,typename,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,typename,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typename, List<TypeDescriptor> argumentTypes, 			ExpressionState state) throws SpelEvaluationException;1356735495;Go through the list of registered constructor resolvers and see if any can find a constructor that takes the_specified set of arguments._@param typename the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typename, List<TypeDescriptor> argumentTypes,_			ExpressionState state) throws SpelEvaluationException {__		EvaluationContext eContext = state.getEvaluationContext()__		List<ConstructorResolver> cResolvers = eContext.getConstructorResolvers()__		if (cResolvers != null) {_			for (ConstructorResolver ctorResolver : cResolvers) {_				try {_					ConstructorExecutor cEx = ctorResolver.resolve(state.getEvaluationContext(), typename,_							argumentTypes)__					if (cEx != null) {_						return cEx__					}_				}_				catch (AccessException ex) {_					throw new SpelEvaluationException(getStartPosition(), ex,_							SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typename,_							FormatHelper.formatMethodForMessage("", argumentTypes))__				}_			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typename, FormatHelper_				.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,typename,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,typename,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,e,context,state,get,evaluation,context,list,constructor,resolver,c,resolvers,e,context,get,constructor,resolvers,if,c,resolvers,null,for,constructor,resolver,ctor,resolver,c,resolvers,try,constructor,executor,c,ex,ctor,resolver,resolve,state,get,evaluation,context,typename,argument,types,if,c,ex,null,return,c,ex,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,typename,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,typename,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException;1496837955;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		for (ConstructorResolver ctorResolver : ctorResolvers) {_			try {_				ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__				if (ce != null) {_					return ce__				}_			}_			catch (AccessException ex) {_				throw new SpelEvaluationException(getStartPosition(), ex,_						SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_						FormatHelper.formatMethodForMessage("", argumentTypes))__			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException;1498780456;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		for (ConstructorResolver ctorResolver : ctorResolvers) {_			try {_				ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__				if (ce != null) {_					return ce__				}_			}_			catch (AccessException ex) {_				throw new SpelEvaluationException(getStartPosition(), ex,_						SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_						FormatHelper.formatMethodForMessage("", argumentTypes))__			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException;1515364415;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		for (ConstructorResolver ctorResolver : ctorResolvers) {_			try {_				ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__				if (ce != null) {_					return ce__				}_			}_			catch (AccessException ex) {_				throw new SpelEvaluationException(getStartPosition(), ex,_						SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_						FormatHelper.formatMethodForMessage("", argumentTypes))__			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException;1522332300;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		for (ConstructorResolver ctorResolver : ctorResolvers) {_			try {_				ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__				if (ce != null) {_					return ce__				}_			}_			catch (AccessException ex) {_				throw new SpelEvaluationException(getStartPosition(), ex,_						SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_						FormatHelper.formatMethodForMessage("", argumentTypes))__			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException;1530174524;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		for (ConstructorResolver ctorResolver : ctorResolvers) {_			try {_				ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__				if (ce != null) {_					return ce__				}_			}_			catch (AccessException ex) {_				throw new SpelEvaluationException(getStartPosition(), ex,_						SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_						FormatHelper.formatMethodForMessage("", argumentTypes))__			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException;1530174524;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		for (ConstructorResolver ctorResolver : ctorResolvers) {_			try {_				ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__				if (ce != null) {_					return ce__				}_			}_			catch (AccessException ex) {_				throw new SpelEvaluationException(getStartPosition(), ex,_						SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_						FormatHelper.formatMethodForMessage("", argumentTypes))__			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
ConstructorReference -> private ConstructorExecutor findExecutorForConstructor(String typeName, 			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException;1548712256;Go through the list of registered constructor resolvers and see if any can find a_constructor that takes the specified set of arguments._@param typeName the type trying to be constructed_@param argumentTypes the types of the arguments supplied that the constructor must take_@param state the current state of the expression_@return a reusable ConstructorExecutor that can be invoked to run the constructor or null_@throws SpelEvaluationException if there is a problem locating the constructor;private ConstructorExecutor findExecutorForConstructor(String typeName,_			List<TypeDescriptor> argumentTypes, ExpressionState state) throws SpelEvaluationException {__		EvaluationContext evalContext = state.getEvaluationContext()__		List<ConstructorResolver> ctorResolvers = evalContext.getConstructorResolvers()__		for (ConstructorResolver ctorResolver : ctorResolvers) {_			try {_				ConstructorExecutor ce = ctorResolver.resolve(state.getEvaluationContext(), typeName, argumentTypes)__				if (ce != null) {_					return ce__				}_			}_			catch (AccessException ex) {_				throw new SpelEvaluationException(getStartPosition(), ex,_						SpelMessage.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,_						FormatHelper.formatMethodForMessage("", argumentTypes))__			}_		}_		throw new SpelEvaluationException(getStartPosition(), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,_				FormatHelper.formatMethodForMessage("", argumentTypes))__	};go,through,the,list,of,registered,constructor,resolvers,and,see,if,any,can,find,a,constructor,that,takes,the,specified,set,of,arguments,param,type,name,the,type,trying,to,be,constructed,param,argument,types,the,types,of,the,arguments,supplied,that,the,constructor,must,take,param,state,the,current,state,of,the,expression,return,a,reusable,constructor,executor,that,can,be,invoked,to,run,the,constructor,or,null,throws,spel,evaluation,exception,if,there,is,a,problem,locating,the,constructor;private,constructor,executor,find,executor,for,constructor,string,type,name,list,type,descriptor,argument,types,expression,state,state,throws,spel,evaluation,exception,evaluation,context,eval,context,state,get,evaluation,context,list,constructor,resolver,ctor,resolvers,eval,context,get,constructor,resolvers,for,constructor,resolver,ctor,resolver,ctor,resolvers,try,constructor,executor,ce,ctor,resolver,resolve,state,get,evaluation,context,type,name,argument,types,if,ce,null,return,ce,catch,access,exception,ex,throw,new,spel,evaluation,exception,get,start,position,ex,spel,message,type,name,format,helper,format,method,for,message,argument,types,throw,new,spel,evaluation,exception,get,start,position,spel,message,type,name,format,helper,format,method,for,message,argument,types
