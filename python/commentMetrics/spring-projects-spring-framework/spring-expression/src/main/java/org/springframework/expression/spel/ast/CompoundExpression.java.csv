commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;35;;@Override protected ValueRef getValueRef(ExpressionState state) throws EvaluationException {     if (getChildCount() == 1) {         return this.children[0].getValueRef(state).     }     SpelNodeImpl nextNode = this.children[0].     try {         TypedValue result = nextNode.getValueInternal(state).         int cc = getChildCount().         for (int i = 1. i < cc - 1. i++) {             try {                 state.pushActiveContextObject(result).                 nextNode = this.children[i].                 result = nextNode.getValueInternal(state).             } finally {                 state.popActiveContextObject().             }         }         try {             state.pushActiveContextObject(result).             nextNode = this.children[cc - 1].             return nextNode.getValueRef(state).         } finally {             state.popActiveContextObject().         }     } catch (SpelEvaluationException ex) {         // Correct the position for the error before re-throwing         ex.setPosition(nextNode.getStartPosition()).         throw ex.     } }
true;public;1;7;/**  * Evaluates a compound expression. This involves evaluating each piece in turn and the  * return value from each piece is the active context object for the subsequent piece.  * @param state the state in which the expression is being evaluated  * @return the final value from the last piece of the compound expression  */ ;/**  * Evaluates a compound expression. This involves evaluating each piece in turn and the  * return value from each piece is the active context object for the subsequent piece.  * @param state the state in which the expression is being evaluated  * @return the final value from the last piece of the compound expression  */ @Override public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {     ValueRef ref = getValueRef(state).     TypedValue result = ref.getValue().     this.exitTypeDescriptor = this.children[this.children.length - 1].exitTypeDescriptor.     return result. }
false;public;2;4;;@Override public void setValue(ExpressionState state, @Nullable Object value) throws EvaluationException {     getValueRef(state).setValue(value). }
false;public;1;4;;@Override public boolean isWritable(ExpressionState state) throws EvaluationException {     return getValueRef(state).isWritable(). }
false;public;0;8;;@Override public String toStringAST() {     StringJoiner sj = new StringJoiner(".").     for (int i = 0. i < getChildCount(). i++) {         sj.add(getChild(i).toStringAST()).     }     return sj.toString(). }
false;public;0;9;;@Override public boolean isCompilable() {     for (SpelNodeImpl child : this.children) {         if (!child.isCompilable()) {             return false.         }     }     return true. }
false;public;2;7;;@Override public void generateCode(MethodVisitor mv, CodeFlow cf) {     for (SpelNodeImpl child : this.children) {         child.generateCode(mv, cf).     }     cf.pushDescriptor(this.exitTypeDescriptor). }
