commented;modifiers;parameterAmount;loc;comment;code
false;public;1;12;;@Override public ValueRef getValueRef(ExpressionState state) throws SpelEvaluationException {     if (this.name.equals(THIS)) {         return new ValueRef.TypedValueHolderValueRef(state.getActiveContextObject(), this).     }     if (this.name.equals(ROOT)) {         return new ValueRef.TypedValueHolderValueRef(state.getRootContextObject(), this).     }     TypedValue result = state.lookupVariable(this.name).     // a null value will mean either the value was null or the variable was not found     return new VariableRef(this.name, result, state.getEvaluationContext()). }
false;public;1;25;;@Override public TypedValue getValueInternal(ExpressionState state) throws SpelEvaluationException {     if (this.name.equals(THIS)) {         return state.getActiveContextObject().     }     if (this.name.equals(ROOT)) {         TypedValue result = state.getRootContextObject().         this.exitTypeDescriptor = CodeFlow.toDescriptorFromObject(result.getValue()).         return result.     }     TypedValue result = state.lookupVariable(this.name).     Object value = result.getValue().     if (value == null || !Modifier.isPublic(value.getClass().getModifiers())) {         // If the type is not public then when generateCode produces a checkcast to it         // then an IllegalAccessError will occur.         // If resorting to Object isn't sufficient, the hierarchy could be traversed for         // the first public type.         this.exitTypeDescriptor = "Ljava/lang/Object".     } else {         this.exitTypeDescriptor = CodeFlow.toDescriptorFromObject(value).     }     // a null value will mean either the value was null or the variable was not found     return result. }
false;public;2;4;;@Override public void setValue(ExpressionState state, @Nullable Object value) throws SpelEvaluationException {     state.setVariable(this.name, value). }
false;public;0;4;;@Override public String toStringAST() {     return "#" + this.name. }
false;public;1;4;;@Override public boolean isWritable(ExpressionState expressionState) throws SpelEvaluationException {     return !(this.name.equals(THIS) || this.name.equals(ROOT)). }
false;public;0;4;;@Override public boolean isCompilable() {     return (this.exitTypeDescriptor != null). }
false;public;2;13;;@Override public void generateCode(MethodVisitor mv, CodeFlow cf) {     if (this.name.equals(ROOT)) {         mv.visitVarInsn(ALOAD, 1).     } else {         mv.visitVarInsn(ALOAD, 2).         mv.visitLdcInsn(this.name).         mv.visitMethodInsn(INVOKEINTERFACE, "org/springframework/expression/EvaluationContext", "lookupVariable", "(Ljava/lang/String.)Ljava/lang/Object.", true).     }     CodeFlow.insertCheckCast(mv, this.exitTypeDescriptor).     cf.pushDescriptor(this.exitTypeDescriptor). }
false;public;0;4;;@Override public TypedValue getValue() {     return this.value. }
false;public;1;4;;@Override public void setValue(@Nullable Object newValue) {     this.evaluationContext.setVariable(this.name, newValue). }
false;public;0;4;;@Override public boolean isWritable() {     return true. }
