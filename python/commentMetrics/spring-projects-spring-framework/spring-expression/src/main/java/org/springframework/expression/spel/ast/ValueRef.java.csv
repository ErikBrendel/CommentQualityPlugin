commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Returns the value this ValueRef points to, it should not require expression  * component re-evaluation.  * @return the value  */ ;/**  * Returns the value this ValueRef points to, it should not require expression  * component re-evaluation.  * @return the value  */ TypedValue getValue().
true;;1;1;/**  * Sets the value this ValueRef points to, it should not require expression component  * re-evaluation.  * @param newValue the new value  */ ;/**  * Sets the value this ValueRef points to, it should not require expression component  * re-evaluation.  * @param newValue the new value  */ void setValue(@Nullable Object newValue).
true;;0;1;/**  * Indicates whether calling setValue(Object) is supported.  * @return true if setValue() is supported for this value reference.  */ ;/**  * Indicates whether calling setValue(Object) is supported.  * @return true if setValue() is supported for this value reference.  */ boolean isWritable().
false;public;0;4;;@Override public TypedValue getValue() {     return TypedValue.NULL. }
false;public;1;7;;@Override public void setValue(@Nullable Object newValue) {     // would be unfortunate.     throw new SpelEvaluationException(0, SpelMessage.NOT_ASSIGNABLE, "null"). }
false;public;0;4;;@Override public boolean isWritable() {     return false. }
false;public;0;4;;@Override public TypedValue getValue() {     return this.typedValue. }
false;public;1;5;;@Override public void setValue(@Nullable Object newValue) {     throw new SpelEvaluationException(this.node.getStartPosition(), SpelMessage.NOT_ASSIGNABLE, this.node.toStringAST()). }
false;public;0;4;;@Override public boolean isWritable() {     return false. }
