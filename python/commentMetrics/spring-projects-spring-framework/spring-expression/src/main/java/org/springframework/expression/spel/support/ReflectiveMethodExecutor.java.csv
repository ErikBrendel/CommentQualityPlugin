commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Return the original method that this executor has been configured for.  */ ;/**  * Return the original method that this executor has been configured for.  */ public final Method getMethod() {     return this.originalMethod. }
true;public;0;9;/**  * Find the first public class in the methods declaring class hierarchy that declares this method.  * Sometimes the reflective method discovery logic finds a suitable method that can easily be  * called via reflection but cannot be called from generated code when compiling the expression  * because of visibility restrictions. For example if a non-public class overrides toString(),  * this helper method will walk up the type hierarchy to find the first public type that declares  * the method (if there is one!). For toString() it may walk as far as Object.  */ ;/**  * Find the first public class in the methods declaring class hierarchy that declares this method.  * Sometimes the reflective method discovery logic finds a suitable method that can easily be  * called via reflection but cannot be called from generated code when compiling the expression  * because of visibility restrictions. For example if a non-public class overrides toString(),  * this helper method will walk up the type hierarchy to find the first public type that declares  * the method (if there is one!). For toString() it may walk as far as Object.  */ @Nullable public Class<?> getPublicDeclaringClass() {     if (!this.computedPublicDeclaringClass) {         this.publicDeclaringClass = discoverPublicDeclaringClass(this.originalMethod, this.originalMethod.getDeclaringClass()).         this.computedPublicDeclaringClass = true.     }     return this.publicDeclaringClass. }
false;private;2;16;;@Nullable private Class<?> discoverPublicDeclaringClass(Method method, Class<?> clazz) {     if (Modifier.isPublic(clazz.getModifiers())) {         try {             clazz.getDeclaredMethod(method.getName(), method.getParameterTypes()).             return clazz.         } catch (NoSuchMethodException ex) {         // Continue below...         }     }     if (clazz.getSuperclass() != null) {         return discoverPublicDeclaringClass(method, clazz.getSuperclass()).     }     return null. }
false;public;0;3;;public boolean didArgumentConversionOccur() {     return this.argumentConversionOccurred. }
false;public;3;17;;@Override public TypedValue execute(EvaluationContext context, Object target, Object... arguments) throws AccessException {     try {         this.argumentConversionOccurred = ReflectionHelper.convertArguments(context.getTypeConverter(), arguments, this.originalMethod, this.varargsPosition).         if (this.originalMethod.isVarArgs()) {             arguments = ReflectionHelper.setupArgumentsForVarargsInvocation(this.originalMethod.getParameterTypes(), arguments).         }         ReflectionUtils.makeAccessible(this.methodToInvoke).         Object value = this.methodToInvoke.invoke(target, arguments).         return new TypedValue(value, new TypeDescriptor(new MethodParameter(this.originalMethod, -1)).narrow(value)).     } catch (Exception ex) {         throw new AccessException("Problem invoking method: " + this.methodToInvoke, ex).     } }
