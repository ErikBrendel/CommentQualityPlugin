commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the evaluation context that will be used if none is specified on an evaluation call.  * @param evaluationContext the evaluation context to use  */ ;/**  * Set the evaluation context that will be used if none is specified on an evaluation call.  * @param evaluationContext the evaluation context to use  */ public void setEvaluationContext(EvaluationContext evaluationContext) {     this.evaluationContext = evaluationContext. }
true;public;0;6;/**  * Return the default evaluation context that will be used if none is supplied on an evaluation call.  * @return the default evaluation context  */ ;/**  * Return the default evaluation context that will be used if none is supplied on an evaluation call.  * @return the default evaluation context  */ public EvaluationContext getEvaluationContext() {     if (this.evaluationContext == null) {         this.evaluationContext = new StandardEvaluationContext().     }     return this.evaluationContext. }
false;public;0;4;;// implementing Expression @Override public String getExpressionString() {     return this.expression. }
false;public;0;26;;@Override @Nullable public Object getValue() throws EvaluationException {     if (this.compiledAst != null) {         try {             EvaluationContext context = getEvaluationContext().             return this.compiledAst.getValue(context.getRootObject().getValue(), context).         } catch (Throwable ex) {             // If running in mixed mode, revert to interpreted             if (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {                 this.interpretedCount.set(0).                 this.compiledAst = null.             } else {                 // Running in SpelCompilerMode.immediate mode - propagate exception to caller                 throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION).             }         }     }     ExpressionState expressionState = new ExpressionState(getEvaluationContext(), this.configuration).     Object result = this.ast.getValue(expressionState).     checkCompile(expressionState).     return result. }
false;public;1;35;;@SuppressWarnings("unchecked") @Override @Nullable public <T> T getValue(@Nullable Class<T> expectedResultType) throws EvaluationException {     if (this.compiledAst != null) {         try {             EvaluationContext context = getEvaluationContext().             Object result = this.compiledAst.getValue(context.getRootObject().getValue(), context).             if (expectedResultType == null) {                 return (T) result.             } else {                 return ExpressionUtils.convertTypedValue(getEvaluationContext(), new TypedValue(result), expectedResultType).             }         } catch (Throwable ex) {             // If running in mixed mode, revert to interpreted             if (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {                 this.interpretedCount.set(0).                 this.compiledAst = null.             } else {                 // Running in SpelCompilerMode.immediate mode - propagate exception to caller                 throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION).             }         }     }     ExpressionState expressionState = new ExpressionState(getEvaluationContext(), this.configuration).     TypedValue typedResultValue = this.ast.getTypedValue(expressionState).     checkCompile(expressionState).     return ExpressionUtils.convertTypedValue(expressionState.getEvaluationContext(), typedResultValue, expectedResultType). }
false;public;1;26;;@Override @Nullable public Object getValue(Object rootObject) throws EvaluationException {     if (this.compiledAst != null) {         try {             return this.compiledAst.getValue(rootObject, getEvaluationContext()).         } catch (Throwable ex) {             // If running in mixed mode, revert to interpreted             if (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {                 this.interpretedCount.set(0).                 this.compiledAst = null.             } else {                 // Running in SpelCompilerMode.immediate mode - propagate exception to caller                 throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION).             }         }     }     ExpressionState expressionState = new ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration).     Object result = this.ast.getValue(expressionState).     checkCompile(expressionState).     return result. }
false;public;2;35;;@SuppressWarnings("unchecked") @Override @Nullable public <T> T getValue(Object rootObject, @Nullable Class<T> expectedResultType) throws EvaluationException {     if (this.compiledAst != null) {         try {             Object result = this.compiledAst.getValue(rootObject, getEvaluationContext()).             if (expectedResultType == null) {                 return (T) result.             } else {                 return ExpressionUtils.convertTypedValue(getEvaluationContext(), new TypedValue(result), expectedResultType).             }         } catch (Throwable ex) {             // If running in mixed mode, revert to interpreted             if (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {                 this.interpretedCount.set(0).                 this.compiledAst = null.             } else {                 // Running in SpelCompilerMode.immediate mode - propagate exception to caller                 throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION).             }         }     }     ExpressionState expressionState = new ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration).     TypedValue typedResultValue = this.ast.getTypedValue(expressionState).     checkCompile(expressionState).     return ExpressionUtils.convertTypedValue(expressionState.getEvaluationContext(), typedResultValue, expectedResultType). }
false;public;1;27;;@Override @Nullable public Object getValue(EvaluationContext context) throws EvaluationException {     Assert.notNull(context, "EvaluationContext is required").     if (this.compiledAst != null) {         try {             return this.compiledAst.getValue(context.getRootObject().getValue(), context).         } catch (Throwable ex) {             // If running in mixed mode, revert to interpreted             if (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {                 this.interpretedCount.set(0).                 this.compiledAst = null.             } else {                 // Running in SpelCompilerMode.immediate mode - propagate exception to caller                 throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION).             }         }     }     ExpressionState expressionState = new ExpressionState(context, this.configuration).     Object result = this.ast.getValue(expressionState).     checkCompile(expressionState).     return result. }
false;public;2;34;;@SuppressWarnings("unchecked") @Override @Nullable public <T> T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType) throws EvaluationException {     Assert.notNull(context, "EvaluationContext is required").     if (this.compiledAst != null) {         try {             Object result = this.compiledAst.getValue(context.getRootObject().getValue(), context).             if (expectedResultType != null) {                 return ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType).             } else {                 return (T) result.             }         } catch (Throwable ex) {             // If running in mixed mode, revert to interpreted             if (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {                 this.interpretedCount.set(0).                 this.compiledAst = null.             } else {                 // Running in SpelCompilerMode.immediate mode - propagate exception to caller                 throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION).             }         }     }     ExpressionState expressionState = new ExpressionState(context, this.configuration).     TypedValue typedResultValue = this.ast.getTypedValue(expressionState).     checkCompile(expressionState).     return ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType). }
false;public;2;27;;@Override @Nullable public Object getValue(EvaluationContext context, Object rootObject) throws EvaluationException {     Assert.notNull(context, "EvaluationContext is required").     if (this.compiledAst != null) {         try {             return this.compiledAst.getValue(rootObject, context).         } catch (Throwable ex) {             // If running in mixed mode, revert to interpreted             if (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {                 this.interpretedCount.set(0).                 this.compiledAst = null.             } else {                 // Running in SpelCompilerMode.immediate mode - propagate exception to caller                 throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION).             }         }     }     ExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration).     Object result = this.ast.getValue(expressionState).     checkCompile(expressionState).     return result. }
false;public;3;36;;@SuppressWarnings("unchecked") @Override @Nullable public <T> T getValue(EvaluationContext context, Object rootObject, @Nullable Class<T> expectedResultType) throws EvaluationException {     Assert.notNull(context, "EvaluationContext is required").     if (this.compiledAst != null) {         try {             Object result = this.compiledAst.getValue(rootObject, context).             if (expectedResultType != null) {                 return ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType).             } else {                 return (T) result.             }         } catch (Throwable ex) {             // If running in mixed mode, revert to interpreted             if (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {                 this.interpretedCount.set(0).                 this.compiledAst = null.             } else {                 // Running in SpelCompilerMode.immediate mode - propagate exception to caller                 throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION).             }         }     }     ExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration).     TypedValue typedResultValue = this.ast.getTypedValue(expressionState).     checkCompile(expressionState).     return ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType). }
false;public;0;5;;@Override @Nullable public Class<?> getValueType() throws EvaluationException {     return getValueType(getEvaluationContext()). }
false;public;1;5;;@Override @Nullable public Class<?> getValueType(Object rootObject) throws EvaluationException {     return getValueType(getEvaluationContext(), rootObject). }
false;public;1;8;;@Override @Nullable public Class<?> getValueType(EvaluationContext context) throws EvaluationException {     Assert.notNull(context, "EvaluationContext is required").     ExpressionState expressionState = new ExpressionState(context, this.configuration).     TypeDescriptor typeDescriptor = this.ast.getValueInternal(expressionState).getTypeDescriptor().     return (typeDescriptor != null ? typeDescriptor.getType() : null). }
false;public;2;7;;@Override @Nullable public Class<?> getValueType(EvaluationContext context, Object rootObject) throws EvaluationException {     ExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration).     TypeDescriptor typeDescriptor = this.ast.getValueInternal(expressionState).getTypeDescriptor().     return (typeDescriptor != null ? typeDescriptor.getType() : null). }
false;public;0;5;;@Override @Nullable public TypeDescriptor getValueTypeDescriptor() throws EvaluationException {     return getValueTypeDescriptor(getEvaluationContext()). }
false;public;1;7;;@Override @Nullable public TypeDescriptor getValueTypeDescriptor(Object rootObject) throws EvaluationException {     ExpressionState expressionState = new ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration).     return this.ast.getValueInternal(expressionState).getTypeDescriptor(). }
false;public;1;7;;@Override @Nullable public TypeDescriptor getValueTypeDescriptor(EvaluationContext context) throws EvaluationException {     Assert.notNull(context, "EvaluationContext is required").     ExpressionState expressionState = new ExpressionState(context, this.configuration).     return this.ast.getValueInternal(expressionState).getTypeDescriptor(). }
false;public;2;9;;@Override @Nullable public TypeDescriptor getValueTypeDescriptor(EvaluationContext context, Object rootObject) throws EvaluationException {     Assert.notNull(context, "EvaluationContext is required").     ExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration).     return this.ast.getValueInternal(expressionState).getTypeDescriptor(). }
false;public;1;5;;@Override public boolean isWritable(Object rootObject) throws EvaluationException {     return this.ast.isWritable(new ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration)). }
false;public;1;5;;@Override public boolean isWritable(EvaluationContext context) throws EvaluationException {     Assert.notNull(context, "EvaluationContext is required").     return this.ast.isWritable(new ExpressionState(context, this.configuration)). }
false;public;2;5;;@Override public boolean isWritable(EvaluationContext context, Object rootObject) throws EvaluationException {     Assert.notNull(context, "EvaluationContext is required").     return this.ast.isWritable(new ExpressionState(context, toTypedValue(rootObject), this.configuration)). }
false;public;2;5;;@Override public void setValue(Object rootObject, @Nullable Object value) throws EvaluationException {     this.ast.setValue(new ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration), value). }
false;public;2;5;;@Override public void setValue(EvaluationContext context, @Nullable Object value) throws EvaluationException {     Assert.notNull(context, "EvaluationContext is required").     this.ast.setValue(new ExpressionState(context, this.configuration), value). }
false;public;3;7;;@Override public void setValue(EvaluationContext context, Object rootObject, @Nullable Object value) throws EvaluationException {     Assert.notNull(context, "EvaluationContext is required").     this.ast.setValue(new ExpressionState(context, toTypedValue(rootObject), this.configuration), value). }
true;private;1;17;/**  * Compile the expression if it has been evaluated more than the threshold number  * of times to trigger compilation.  * @param expressionState the expression state used to determine compilation mode  */ ;/**  * Compile the expression if it has been evaluated more than the threshold number  * of times to trigger compilation.  * @param expressionState the expression state used to determine compilation mode  */ private void checkCompile(ExpressionState expressionState) {     this.interpretedCount.incrementAndGet().     SpelCompilerMode compilerMode = expressionState.getConfiguration().getCompilerMode().     if (compilerMode != SpelCompilerMode.OFF) {         if (compilerMode == SpelCompilerMode.IMMEDIATE) {             if (this.interpretedCount.get() > 1) {                 compileExpression().             }         } else {             // compilerMode = SpelCompilerMode.MIXED             if (this.interpretedCount.get() > INTERPRETED_COUNT_THRESHOLD) {                 compileExpression().             }         }     } }
true;public;0;20;/**  * Perform expression compilation. This will only succeed once exit descriptors for all nodes have  * been determined. If the compilation fails and has failed more than 100 times the expression is  * no longer considered suitable for compilation.  */ ;/**  * Perform expression compilation. This will only succeed once exit descriptors for all nodes have  * been determined. If the compilation fails and has failed more than 100 times the expression is  * no longer considered suitable for compilation.  */ public boolean compileExpression() {     if (this.failedAttempts > FAILED_ATTEMPTS_THRESHOLD) {         // Don't try again         return false.     }     if (this.compiledAst == null) {         synchronized (this.expression) {             // Possibly compiled by another thread before this thread got into the sync block             if (this.compiledAst != null) {                 return true.             }             SpelCompiler compiler = SpelCompiler.getCompiler(this.configuration.getCompilerClassLoader()).             this.compiledAst = compiler.compile(this.ast).             if (this.compiledAst == null) {                 this.failedAttempts++.             }         }     }     return (this.compiledAst != null). }
true;public;0;5;/**  * Cause an expression to revert to being interpreted if it has been using a compiled  * form. It also resets the compilation attempt failure count (an expression is normally no  * longer considered compilable if it cannot be compiled after 100 attempts).  */ ;/**  * Cause an expression to revert to being interpreted if it has been using a compiled  * form. It also resets the compilation attempt failure count (an expression is normally no  * longer considered compilable if it cannot be compiled after 100 attempts).  */ public void revertToInterpreted() {     this.compiledAst = null.     this.interpretedCount.set(0).     this.failedAttempts = 0. }
true;public;0;3;/**  * Return the Abstract Syntax Tree for the expression.  */ ;/**  * Return the Abstract Syntax Tree for the expression.  */ public SpelNode getAST() {     return this.ast. }
true;public;0;3;/**  * Produce a string representation of the Abstract Syntax Tree for the expression.  * This should ideally look like the input expression, but properly formatted since any  * unnecessary whitespace will have been discarded during the parse of the expression.  * @return the string representation of the AST  */ ;/**  * Produce a string representation of the Abstract Syntax Tree for the expression.  * This should ideally look like the input expression, but properly formatted since any  * unnecessary whitespace will have been discarded during the parse of the expression.  * @return the string representation of the AST  */ public String toStringAST() {     return this.ast.toStringAST(). }
false;private;1;3;;private TypedValue toTypedValue(@Nullable Object object) {     return (object != null ? new TypedValue(object) : TypedValue.NULL). }
