# id;timestamp;commentText;codeText;commentWords;codeWords
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow codeflow);1405011154;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack.__@param mv the ASM MethodVisitor into which code should be generated_@param codeflow a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow codeflow) {_		throw new IllegalStateException(this.getClass().getName()+" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,codeflow,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,codeflow,throw,new,illegal,state,exception,this,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow codeflow);1405514506;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param codeflow a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow codeflow) {_		throw new IllegalStateException(this.getClass().getName()+" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,codeflow,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,codeflow,throw,new,illegal,state,exception,this,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow codeflow);1406039079;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param codeflow a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow codeflow) {_		throw new IllegalStateException(this.getClass().getName()+" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,codeflow,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,codeflow,throw,new,illegal,state,exception,this,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow codeflow);1412004923;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param codeflow a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow codeflow) {_		throw new IllegalStateException(this.getClass().getName()+" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,codeflow,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,codeflow,throw,new,illegal,state,exception,this,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> protected boolean nextChildIs(Class... clazzes);1328020251;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class... clazzes) {_		if (parent!=null) {_			SpelNodeImpl[] peers = parent.children__			for (int i=0,max=peers.length_i<max_i++) {_				if (peers[i]==this) {_					if ((i+1)>=max) {_						return false__					} else {_						Class clazz = peers[i+1].getClass()__						for (Class desiredClazz: clazzes) {_							if (clazz.equals(desiredClazz)) {_								return true__							}_						}_						return false__					}_				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,parent,null,spel,node,impl,peers,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,else,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class... clazzes);1351041784;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class... clazzes) {_		if (parent!=null) {_			SpelNodeImpl[] peers = parent.children__			for (int i=0,max=peers.length_i<max_i++) {_				if (peers[i]==this) {_					if ((i+1)>=max) {_						return false__					} else {_						Class clazz = peers[i+1].getClass()__						for (Class desiredClazz: clazzes) {_							if (clazz.equals(desiredClazz)) {_								return true__							}_						}_						return false__					}_				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,parent,null,spel,node,impl,peers,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,else,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class... clazzes);1353568585;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class... clazzes) {_		if (parent!=null) {_			SpelNodeImpl[] peers = parent.children__			for (int i=0,max=peers.length_i<max_i++) {_				if (peers[i]==this) {_					if ((i+1)>=max) {_						return false__					} else {_						Class clazz = peers[i+1].getClass()__						for (Class desiredClazz: clazzes) {_							if (clazz.equals(desiredClazz)) {_								return true__							}_						}_						return false__					}_				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,parent,null,spel,node,impl,peers,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,else,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class... clazzes);1356735495;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class... clazzes) {_		if (parent!=null) {_			SpelNodeImpl[] peers = parent.children__			for (int i=0,max=peers.length_i<max_i++) {_				if (peers[i]==this) {_					if ((i+1)>=max) {_						return false__					} else {_						Class clazz = peers[i+1].getClass()__						for (Class desiredClazz: clazzes) {_							if (clazz.equals(desiredClazz)) {_								return true__							}_						}_						return false__					}_				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,parent,null,spel,node,impl,peers,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,else,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class... clazzes);1357119239;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class... clazzes) {_		if (parent!=null) {_			SpelNodeImpl[] peers = parent.children__			for (int i=0,max=peers.length_i<max_i++) {_				if (peers[i]==this) {_					if ((i+1)>=max) {_						return false__					} else {_						Class clazz = peers[i+1].getClass()__						for (Class desiredClazz: clazzes) {_							if (clazz.equals(desiredClazz)) {_								return true__							}_						}_						return false__					}_				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,parent,null,spel,node,impl,peers,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,else,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class... clazzes);1362408075;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class... clazzes) {_		if (parent!=null) {_			SpelNodeImpl[] peers = parent.children__			for (int i=0,max=peers.length_i<max_i++) {_				if (peers[i]==this) {_					if ((i+1)>=max) {_						return false__					} else {_						Class clazz = peers[i+1].getClass()__						for (Class desiredClazz: clazzes) {_							if (clazz.equals(desiredClazz)) {_								return true__							}_						}_						return false__					}_				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,parent,null,spel,node,impl,peers,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,else,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class... clazzes);1368482696;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class... clazzes) {_		if (parent!=null) {_			SpelNodeImpl[] peers = parent.children__			for (int i=0,max=peers.length_i<max_i++) {_				if (peers[i]==this) {_					if ((i+1)>=max) {_						return false__					} else {_						Class clazz = peers[i+1].getClass()__						for (Class desiredClazz: clazzes) {_							if (clazz.equals(desiredClazz)) {_								return true__							}_						}_						return false__					}_				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,parent,null,spel,node,impl,peers,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,else,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class... clazzes);1372363092;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (peers[i] == this) {_					if ((i + 1) >= max) {_						return false__					}__					Class clazz = peers[i + 1].getClass()__					for (Class desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}__					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1412630983;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1414261335;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1449965678;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1496837955;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1498780456;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1502974979;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1506097334;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1506468851;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1515364415;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1518260959;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1530174524;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object. For_example it will include information about the type of the object currently_on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,for,example,it,will,include,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1545740520;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object, e.g._including information about the type of the object currently on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,e,g,including,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> public void generateCode(MethodVisitor mv, CodeFlow cf);1548712256;Generate the bytecode for this node into the supplied visitor. Context info about_the current expression being compiled is available in the codeflow object, e.g._including information about the type of the object currently on the stack._@param mv the ASM MethodVisitor into which code should be generated_@param cf a context object with info about what is on the stack;public void generateCode(MethodVisitor mv, CodeFlow cf) {_		throw new IllegalStateException(getClass().getName() +" has no generateCode(..) method")__	};generate,the,bytecode,for,this,node,into,the,supplied,visitor,context,info,about,the,current,expression,being,compiled,is,available,in,the,codeflow,object,e,g,including,information,about,the,type,of,the,object,currently,on,the,stack,param,mv,the,asm,method,visitor,into,which,code,should,be,generated,param,cf,a,context,object,with,info,about,what,is,on,the,stack;public,void,generate,code,method,visitor,mv,code,flow,cf,throw,new,illegal,state,exception,get,class,get,name,has,no,generate,code,method
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1414261335;Generate code that handles building the argument values for the specified method. This method will take account_of whether the invoked method is a varargs method and if it is then the argument values will be appropriately_packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>)member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childcount = arguments.length__						_			_			for (p = 0_ p < paramDescriptors.length-1_p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}_			_			SpelNodeImpl lastchild = (childcount == 0 ? null : arguments[childcount-1])_			_			String arraytype = paramDescriptors[paramDescriptors.length-1]__			_			_			if (lastchild != null && lastchild.getExitDescriptor().equals(arraytype)) {_				generateCodeForArgument(mv, cf, lastchild, paramDescriptors[p])__			}_			else {_				arraytype = arraytype.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childcount-p, arraytype)__				_				int arrayindex = 0__				while (p < childcount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arraytype)__					CodeFlow.insertArrayStore(mv, arraytype)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,childcount,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,lastchild,childcount,0,null,arguments,childcount,1,string,arraytype,param,descriptors,param,descriptors,length,1,if,lastchild,null,lastchild,get,exit,descriptor,equals,arraytype,generate,code,for,argument,mv,cf,lastchild,param,descriptors,p,else,arraytype,arraytype,substring,1,code,flow,insert,new,array,code,mv,childcount,p,arraytype,int,arrayindex,0,while,p,childcount,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,arraytype,code,flow,insert,array,store,mv,arraytype,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1449965678;Generate code that handles building the argument values for the specified method. This method will take account_of whether the invoked method is a varargs method and if it is then the argument values will be appropriately_packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>)member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childCount = arguments.length__						_			_			for (p = 0_ p < paramDescriptors.length - 1_ p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}_			_			SpelNodeImpl lastchild = (childCount == 0 ? null : arguments[childCount - 1])__			String arraytype = paramDescriptors[paramDescriptors.length - 1]__			_			_			if (lastchild != null && lastchild.getExitDescriptor().equals(arraytype)) {_				generateCodeForArgument(mv, cf, lastchild, paramDescriptors[p])__			}_			else {_				arraytype = arraytype.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childCount - p, arraytype)__				_				int arrayindex = 0__				while (p < childCount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arraytype)__					CodeFlow.insertArrayStore(mv, arraytype)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,child,count,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,lastchild,child,count,0,null,arguments,child,count,1,string,arraytype,param,descriptors,param,descriptors,length,1,if,lastchild,null,lastchild,get,exit,descriptor,equals,arraytype,generate,code,for,argument,mv,cf,lastchild,param,descriptors,p,else,arraytype,arraytype,substring,1,code,flow,insert,new,array,code,mv,child,count,p,arraytype,int,arrayindex,0,while,p,child,count,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,arraytype,code,flow,insert,array,store,mv,arraytype,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1496837955;Generate code that handles building the argument values for the specified method. This method will take account_of whether the invoked method is a varargs method and if it is then the argument values will be appropriately_packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>)member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childCount = arguments.length__						_			_			for (p = 0_ p < paramDescriptors.length - 1_ p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}_			_			SpelNodeImpl lastchild = (childCount == 0 ? null : arguments[childCount - 1])__			String arraytype = paramDescriptors[paramDescriptors.length - 1]__			_			_			if (lastchild != null && lastchild.getExitDescriptor().equals(arraytype)) {_				generateCodeForArgument(mv, cf, lastchild, paramDescriptors[p])__			}_			else {_				arraytype = arraytype.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childCount - p, arraytype)__				_				int arrayindex = 0__				while (p < childCount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arraytype)__					CodeFlow.insertArrayStore(mv, arraytype)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,child,count,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,lastchild,child,count,0,null,arguments,child,count,1,string,arraytype,param,descriptors,param,descriptors,length,1,if,lastchild,null,lastchild,get,exit,descriptor,equals,arraytype,generate,code,for,argument,mv,cf,lastchild,param,descriptors,p,else,arraytype,arraytype,substring,1,code,flow,insert,new,array,code,mv,child,count,p,arraytype,int,arrayindex,0,while,p,child,count,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,arraytype,code,flow,insert,array,store,mv,arraytype,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1498780456;Generate code that handles building the argument values for the specified method. This method will take account_of whether the invoked method is a varargs method and if it is then the argument values will be appropriately_packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>)member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childCount = arguments.length__						_			_			for (p = 0_ p < paramDescriptors.length - 1_ p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}_			_			SpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1])__			String arrayType = paramDescriptors[paramDescriptors.length - 1]__			_			_			if (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {_				generateCodeForArgument(mv, cf, lastChild, paramDescriptors[p])__			}_			else {_				arrayType = arrayType.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childCount - p, arrayType)__				_				int arrayindex = 0__				while (p < childCount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arrayType)__					CodeFlow.insertArrayStore(mv, arrayType)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,child,count,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,last,child,child,count,0,null,arguments,child,count,1,string,array,type,param,descriptors,param,descriptors,length,1,if,last,child,null,array,type,equals,last,child,get,exit,descriptor,generate,code,for,argument,mv,cf,last,child,param,descriptors,p,else,array,type,array,type,substring,1,code,flow,insert,new,array,code,mv,child,count,p,array,type,int,arrayindex,0,while,p,child,count,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,array,type,code,flow,insert,array,store,mv,array,type,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1502974979;Generate code that handles building the argument values for the specified method. This method will take account_of whether the invoked method is a varargs method and if it is then the argument values will be appropriately_packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>)member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childCount = arguments.length__						_			_			for (p = 0_ p < paramDescriptors.length - 1_ p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}_			_			SpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1])__			String arrayType = paramDescriptors[paramDescriptors.length - 1]__			_			_			if (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {_				generateCodeForArgument(mv, cf, lastChild, paramDescriptors[p])__			}_			else {_				arrayType = arrayType.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childCount - p, arrayType)__				_				int arrayindex = 0__				while (p < childCount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arrayType)__					CodeFlow.insertArrayStore(mv, arrayType)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,child,count,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,last,child,child,count,0,null,arguments,child,count,1,string,array,type,param,descriptors,param,descriptors,length,1,if,last,child,null,array,type,equals,last,child,get,exit,descriptor,generate,code,for,argument,mv,cf,last,child,param,descriptors,p,else,array,type,array,type,substring,1,code,flow,insert,new,array,code,mv,child,count,p,array,type,int,arrayindex,0,while,p,child,count,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,array,type,code,flow,insert,array,store,mv,array,type,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1506097334;Generate code that handles building the argument values for the specified method. This method will take account_of whether the invoked method is a varargs method and if it is then the argument values will be appropriately_packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>)member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childCount = arguments.length__						_			_			for (p = 0_ p < paramDescriptors.length - 1_ p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}_			_			SpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1])__			String arrayType = paramDescriptors[paramDescriptors.length - 1]__			_			_			if (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {_				generateCodeForArgument(mv, cf, lastChild, paramDescriptors[p])__			}_			else {_				arrayType = arrayType.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childCount - p, arrayType)__				_				int arrayindex = 0__				while (p < childCount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arrayType)__					CodeFlow.insertArrayStore(mv, arrayType)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,child,count,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,last,child,child,count,0,null,arguments,child,count,1,string,array,type,param,descriptors,param,descriptors,length,1,if,last,child,null,array,type,equals,last,child,get,exit,descriptor,generate,code,for,argument,mv,cf,last,child,param,descriptors,p,else,array,type,array,type,substring,1,code,flow,insert,new,array,code,mv,child,count,p,array,type,int,arrayindex,0,while,p,child,count,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,array,type,code,flow,insert,array,store,mv,array,type,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1506468851;Generate code that handles building the argument values for the specified method._This method will take account of whether the invoked method is a varargs method_and if it is then the argument values will be appropriately packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>) member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childCount = arguments.length__						_			_			for (p = 0_ p < paramDescriptors.length - 1_ p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}_			_			SpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1])__			String arrayType = paramDescriptors[paramDescriptors.length - 1]__			_			_			if (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {_				generateCodeForArgument(mv, cf, lastChild, paramDescriptors[p])__			}_			else {_				arrayType = arrayType.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childCount - p, arrayType)__				_				int arrayindex = 0__				while (p < childCount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arrayType)__					CodeFlow.insertArrayStore(mv, arrayType)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,child,count,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,last,child,child,count,0,null,arguments,child,count,1,string,array,type,param,descriptors,param,descriptors,length,1,if,last,child,null,array,type,equals,last,child,get,exit,descriptor,generate,code,for,argument,mv,cf,last,child,param,descriptors,p,else,array,type,array,type,substring,1,code,flow,insert,new,array,code,mv,child,count,p,array,type,int,arrayindex,0,while,p,child,count,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,array,type,code,flow,insert,array,store,mv,array,type,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1515364415;Generate code that handles building the argument values for the specified method._This method will take account of whether the invoked method is a varargs method_and if it is then the argument values will be appropriately packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>) member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childCount = arguments.length__						_			_			for (p = 0_ p < paramDescriptors.length - 1_ p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}_			_			SpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1])__			String arrayType = paramDescriptors[paramDescriptors.length - 1]__			_			_			if (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {_				generateCodeForArgument(mv, cf, lastChild, paramDescriptors[p])__			}_			else {_				arrayType = arrayType.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childCount - p, arrayType)__				_				int arrayindex = 0__				while (p < childCount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arrayType)__					CodeFlow.insertArrayStore(mv, arrayType)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,child,count,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,last,child,child,count,0,null,arguments,child,count,1,string,array,type,param,descriptors,param,descriptors,length,1,if,last,child,null,array,type,equals,last,child,get,exit,descriptor,generate,code,for,argument,mv,cf,last,child,param,descriptors,p,else,array,type,array,type,substring,1,code,flow,insert,new,array,code,mv,child,count,p,array,type,int,arrayindex,0,while,p,child,count,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,array,type,code,flow,insert,array,store,mv,array,type,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1518260959;Generate code that handles building the argument values for the specified method._This method will take account of whether the invoked method is a varargs method_and if it is then the argument values will be appropriately packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>) member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childCount = arguments.length__						_			_			for (p = 0_ p < paramDescriptors.length - 1_ p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}_			_			SpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1])__			String arrayType = paramDescriptors[paramDescriptors.length - 1]__			_			_			if (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {_				generateCodeForArgument(mv, cf, lastChild, paramDescriptors[p])__			}_			else {_				arrayType = arrayType.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childCount - p, arrayType)__				_				int arrayindex = 0__				while (p < childCount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arrayType)__					CodeFlow.insertArrayStore(mv, arrayType)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,child,count,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,last,child,child,count,0,null,arguments,child,count,1,string,array,type,param,descriptors,param,descriptors,length,1,if,last,child,null,array,type,equals,last,child,get,exit,descriptor,generate,code,for,argument,mv,cf,last,child,param,descriptors,p,else,array,type,array,type,substring,1,code,flow,insert,new,array,code,mv,child,count,p,array,type,int,arrayindex,0,while,p,child,count,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,array,type,code,flow,insert,array,store,mv,array,type,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1530174524;Generate code that handles building the argument values for the specified method._This method will take account of whether the invoked method is a varargs method_and if it is then the argument values will be appropriately packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>) member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childCount = arguments.length___			_			for (p = 0_ p < paramDescriptors.length - 1_ p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}__			SpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1])__			String arrayType = paramDescriptors[paramDescriptors.length - 1]__			_			_			if (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {_				generateCodeForArgument(mv, cf, lastChild, paramDescriptors[p])__			}_			else {_				arrayType = arrayType.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childCount - p, arrayType)__				_				int arrayindex = 0__				while (p < childCount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arrayType)__					CodeFlow.insertArrayStore(mv, arrayType)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,child,count,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,last,child,child,count,0,null,arguments,child,count,1,string,array,type,param,descriptors,param,descriptors,length,1,if,last,child,null,array,type,equals,last,child,get,exit,descriptor,generate,code,for,argument,mv,cf,last,child,param,descriptors,p,else,array,type,array,type,substring,1,code,flow,insert,new,array,code,mv,child,count,p,array,type,int,arrayindex,0,while,p,child,count,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,array,type,code,flow,insert,array,store,mv,array,type,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1545740520;Generate code that handles building the argument values for the specified method._This method will take account of whether the invoked method is a varargs method_and if it is then the argument values will be appropriately packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>) member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childCount = arguments.length___			_			for (p = 0_ p < paramDescriptors.length - 1_ p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}__			SpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1])__			String arrayType = paramDescriptors[paramDescriptors.length - 1]__			_			_			if (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {_				generateCodeForArgument(mv, cf, lastChild, paramDescriptors[p])__			}_			else {_				arrayType = arrayType.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childCount - p, arrayType)__				_				int arrayindex = 0__				while (p < childCount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arrayType)__					CodeFlow.insertArrayStore(mv, arrayType)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,child,count,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,last,child,child,count,0,null,arguments,child,count,1,string,array,type,param,descriptors,param,descriptors,length,1,if,last,child,null,array,type,equals,last,child,get,exit,descriptor,generate,code,for,argument,mv,cf,last,child,param,descriptors,p,else,array,type,array,type,substring,1,code,flow,insert,new,array,code,mv,child,count,p,array,type,int,arrayindex,0,while,p,child,count,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,array,type,code,flow,insert,array,store,mv,array,type,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments);1548712256;Generate code that handles building the argument values for the specified method._This method will take account of whether the invoked method is a varargs method_and if it is then the argument values will be appropriately packaged into an array._@param mv the method visitor where code should be generated_@param cf the current codeflow_@param member the method or constructor for which arguments are being setup_@param arguments the expression nodes for the expression supplied argument values;protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {_		String[] paramDescriptors = null__		boolean isVarargs = false__		if (member instanceof Constructor) {_			Constructor<?> ctor = (Constructor<?>) member__			paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes())__			isVarargs = ctor.isVarArgs()__		}_		else { _			Method method = (Method)member__			paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes())__			isVarargs = method.isVarArgs()__		}_		if (isVarargs) {_			_			_			int p = 0_ _			int childCount = arguments.length___			_			for (p = 0_ p < paramDescriptors.length - 1_ p++) {_				generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p])__			}__			SpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1])__			String arrayType = paramDescriptors[paramDescriptors.length - 1]__			_			_			if (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {_				generateCodeForArgument(mv, cf, lastChild, paramDescriptors[p])__			}_			else {_				arrayType = arrayType.substring(1)_ _				_				CodeFlow.insertNewArrayCode(mv, childCount - p, arrayType)__				_				int arrayindex = 0__				while (p < childCount) {_					SpelNodeImpl child = arguments[p]__					mv.visitInsn(DUP)__					CodeFlow.insertOptimalLoad(mv, arrayindex++)__					generateCodeForArgument(mv, cf, child, arrayType)__					CodeFlow.insertArrayStore(mv, arrayType)__					p++__				}_			}_		}_		else {_			for (int i = 0_ i < paramDescriptors.length_i++) {_				generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i])__			}_		}_	};generate,code,that,handles,building,the,argument,values,for,the,specified,method,this,method,will,take,account,of,whether,the,invoked,method,is,a,varargs,method,and,if,it,is,then,the,argument,values,will,be,appropriately,packaged,into,an,array,param,mv,the,method,visitor,where,code,should,be,generated,param,cf,the,current,codeflow,param,member,the,method,or,constructor,for,which,arguments,are,being,setup,param,arguments,the,expression,nodes,for,the,expression,supplied,argument,values;protected,static,void,generate,code,for,arguments,method,visitor,mv,code,flow,cf,member,member,spel,node,impl,arguments,string,param,descriptors,null,boolean,is,varargs,false,if,member,instanceof,constructor,constructor,ctor,constructor,member,param,descriptors,code,flow,to,descriptors,ctor,get,parameter,types,is,varargs,ctor,is,var,args,else,method,method,method,member,param,descriptors,code,flow,to,descriptors,method,get,parameter,types,is,varargs,method,is,var,args,if,is,varargs,int,p,0,int,child,count,arguments,length,for,p,0,p,param,descriptors,length,1,p,generate,code,for,argument,mv,cf,arguments,p,param,descriptors,p,spel,node,impl,last,child,child,count,0,null,arguments,child,count,1,string,array,type,param,descriptors,param,descriptors,length,1,if,last,child,null,array,type,equals,last,child,get,exit,descriptor,generate,code,for,argument,mv,cf,last,child,param,descriptors,p,else,array,type,array,type,substring,1,code,flow,insert,new,array,code,mv,child,count,p,array,type,int,arrayindex,0,while,p,child,count,spel,node,impl,child,arguments,p,mv,visit,insn,dup,code,flow,insert,optimal,load,mv,arrayindex,generate,code,for,argument,mv,cf,child,array,type,code,flow,insert,array,store,mv,array,type,p,else,for,int,i,0,i,param,descriptors,length,i,generate,code,for,argument,mv,cf,arguments,i,param,descriptors,i
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1385412762;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (peers[i] == this) {_					if ((i + 1) >= max) {_						return false__					}__					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}__					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1392410380;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (peers[i] == this) {_					if ((i + 1) >= max) {_						return false__					}__					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}__					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1405011154;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (peers[i] == this) {_					if ((i + 1) >= max) {_						return false__					}__					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}__					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1405514506;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (peers[i] == this) {_					if ((i + 1) >= max) {_						return false__					}__					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}__					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,peers,i,this,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1406039079;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1412004923;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1412630983;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1414261335;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1449965678;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1496837955;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1498780456;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1502974979;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1506097334;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1506468851;@return true if the next child is one of the specified classes;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1515364415;Return {@code true} if the next child is one of the specified classes.;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,code,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1518260959;Return {@code true} if the next child is one of the specified classes.;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,code,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... clazzes);1530174524;Return {@code true} if the next child is one of the specified classes.;protected boolean nextChildIs(Class<?>... clazzes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> clazz = peers[i + 1].getClass()__					for (Class<?> desiredClazz : clazzes) {_						if (clazz.equals(desiredClazz)) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,code,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,clazzes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,clazz,peers,i,1,get,class,for,class,desired,clazz,clazzes,if,clazz,equals,desired,clazz,return,true,return,false,return,false
SpelNodeImpl -> public boolean isCompilable();1405011154;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable.__@return true if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1405514506;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return true if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1406039079;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return true if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1412004923;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1412630983;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1414261335;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1449965678;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1496837955;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1498780456;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1502974979;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1506097334;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1506468851;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1515364415;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1518260959;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1530174524;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1545740520;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> public boolean isCompilable();1548712256;Check whether a node can be compiled to bytecode. The reasoning in each node may_be different but will typically involve checking whether the exit type descriptor_of the node is known and any relevant child nodes are compilable._@return {@code true} if this node can be compiled to bytecode;public boolean isCompilable() {_		return false__	};check,whether,a,node,can,be,compiled,to,bytecode,the,reasoning,in,each,node,may,be,different,but,will,typically,involve,checking,whether,the,exit,type,descriptor,of,the,node,is,known,and,any,relevant,child,nodes,are,compilable,return,code,true,if,this,node,can,be,compiled,to,bytecode;public,boolean,is,compilable,return,false
SpelNodeImpl -> protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc);1449965678;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		boolean primitiveOnStack = CodeFlow.isPrimitive(cf.lastDescriptor())__		_		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor().charAt(0))__		}_		else if (paramDesc.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), cf.lastDescriptor())__		}_		else if (!cf.lastDescriptor().equals(paramDesc)) {_			_			CodeFlow.insertCheckCast(mv, paramDesc)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;protected,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,desc,cf,enter,compilation,scope,argument,generate,code,mv,cf,boolean,primitive,on,stack,code,flow,is,primitive,cf,last,descriptor,if,primitive,on,stack,param,desc,char,at,0,l,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,char,at,0,else,if,param,desc,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,desc,char,at,0,cf,last,descriptor,else,if,cf,last,descriptor,equals,param,desc,code,flow,insert,check,cast,mv,param,desc,cf,exit,compilation,scope
SpelNodeImpl -> protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc);1496837955;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		String lastDesc = cf.lastDescriptor()__		Assert.state(lastDesc != null, "No last descriptor")__		boolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc)__		_		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0))__		}_		else if (paramDesc.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc)__		}_		else if (!paramDesc.equals(lastDesc)) {_			_			CodeFlow.insertCheckCast(mv, paramDesc)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;protected,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,desc,cf,enter,compilation,scope,argument,generate,code,mv,cf,string,last,desc,cf,last,descriptor,assert,state,last,desc,null,no,last,descriptor,boolean,primitive,on,stack,code,flow,is,primitive,last,desc,if,primitive,on,stack,param,desc,char,at,0,l,code,flow,insert,box,if,necessary,mv,last,desc,char,at,0,else,if,param,desc,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,desc,char,at,0,last,desc,else,if,param,desc,equals,last,desc,code,flow,insert,check,cast,mv,param,desc,cf,exit,compilation,scope
SpelNodeImpl -> protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc);1498780456;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		String lastDesc = cf.lastDescriptor()__		Assert.state(lastDesc != null, "No last descriptor")__		boolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc)__		_		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0))__		}_		else if (paramDesc.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc)__		}_		else if (!paramDesc.equals(lastDesc)) {_			_			CodeFlow.insertCheckCast(mv, paramDesc)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;protected,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,desc,cf,enter,compilation,scope,argument,generate,code,mv,cf,string,last,desc,cf,last,descriptor,assert,state,last,desc,null,no,last,descriptor,boolean,primitive,on,stack,code,flow,is,primitive,last,desc,if,primitive,on,stack,param,desc,char,at,0,l,code,flow,insert,box,if,necessary,mv,last,desc,char,at,0,else,if,param,desc,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,desc,char,at,0,last,desc,else,if,param,desc,equals,last,desc,code,flow,insert,check,cast,mv,param,desc,cf,exit,compilation,scope
SpelNodeImpl -> protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc);1502974979;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		String lastDesc = cf.lastDescriptor()__		Assert.state(lastDesc != null, "No last descriptor")__		boolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc)__		_		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0))__		}_		else if (paramDesc.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc)__		}_		else if (!paramDesc.equals(lastDesc)) {_			_			CodeFlow.insertCheckCast(mv, paramDesc)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;protected,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,desc,cf,enter,compilation,scope,argument,generate,code,mv,cf,string,last,desc,cf,last,descriptor,assert,state,last,desc,null,no,last,descriptor,boolean,primitive,on,stack,code,flow,is,primitive,last,desc,if,primitive,on,stack,param,desc,char,at,0,l,code,flow,insert,box,if,necessary,mv,last,desc,char,at,0,else,if,param,desc,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,desc,char,at,0,last,desc,else,if,param,desc,equals,last,desc,code,flow,insert,check,cast,mv,param,desc,cf,exit,compilation,scope
SpelNodeImpl -> protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc);1506097334;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		String lastDesc = cf.lastDescriptor()__		Assert.state(lastDesc != null, "No last descriptor")__		boolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc)__		_		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0))__		}_		else if (paramDesc.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc)__		}_		else if (!paramDesc.equals(lastDesc)) {_			_			CodeFlow.insertCheckCast(mv, paramDesc)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;protected,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,desc,cf,enter,compilation,scope,argument,generate,code,mv,cf,string,last,desc,cf,last,descriptor,assert,state,last,desc,null,no,last,descriptor,boolean,primitive,on,stack,code,flow,is,primitive,last,desc,if,primitive,on,stack,param,desc,char,at,0,l,code,flow,insert,box,if,necessary,mv,last,desc,char,at,0,else,if,param,desc,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,desc,char,at,0,last,desc,else,if,param,desc,equals,last,desc,code,flow,insert,check,cast,mv,param,desc,cf,exit,compilation,scope
SpelNodeImpl -> protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc);1506468851;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		String lastDesc = cf.lastDescriptor()__		Assert.state(lastDesc != null, "No last descriptor")__		boolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc)__		_		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0))__		}_		else if (paramDesc.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc)__		}_		else if (!paramDesc.equals(lastDesc)) {_			_			CodeFlow.insertCheckCast(mv, paramDesc)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;protected,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,desc,cf,enter,compilation,scope,argument,generate,code,mv,cf,string,last,desc,cf,last,descriptor,assert,state,last,desc,null,no,last,descriptor,boolean,primitive,on,stack,code,flow,is,primitive,last,desc,if,primitive,on,stack,param,desc,char,at,0,l,code,flow,insert,box,if,necessary,mv,last,desc,char,at,0,else,if,param,desc,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,desc,char,at,0,last,desc,else,if,param,desc,equals,last,desc,code,flow,insert,check,cast,mv,param,desc,cf,exit,compilation,scope
SpelNodeImpl -> protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc);1515364415;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		String lastDesc = cf.lastDescriptor()__		Assert.state(lastDesc != null, "No last descriptor")__		boolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc)__		_		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0))__		}_		else if (paramDesc.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc)__		}_		else if (!paramDesc.equals(lastDesc)) {_			_			CodeFlow.insertCheckCast(mv, paramDesc)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;protected,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,desc,cf,enter,compilation,scope,argument,generate,code,mv,cf,string,last,desc,cf,last,descriptor,assert,state,last,desc,null,no,last,descriptor,boolean,primitive,on,stack,code,flow,is,primitive,last,desc,if,primitive,on,stack,param,desc,char,at,0,l,code,flow,insert,box,if,necessary,mv,last,desc,char,at,0,else,if,param,desc,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,desc,char,at,0,last,desc,else,if,param,desc,equals,last,desc,code,flow,insert,check,cast,mv,param,desc,cf,exit,compilation,scope
SpelNodeImpl -> protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc);1518260959;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		String lastDesc = cf.lastDescriptor()__		Assert.state(lastDesc != null, "No last descriptor")__		boolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc)__		_		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0))__		}_		else if (paramDesc.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc)__		}_		else if (!paramDesc.equals(lastDesc)) {_			_			CodeFlow.insertCheckCast(mv, paramDesc)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;protected,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,desc,cf,enter,compilation,scope,argument,generate,code,mv,cf,string,last,desc,cf,last,descriptor,assert,state,last,desc,null,no,last,descriptor,boolean,primitive,on,stack,code,flow,is,primitive,last,desc,if,primitive,on,stack,param,desc,char,at,0,l,code,flow,insert,box,if,necessary,mv,last,desc,char,at,0,else,if,param,desc,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,desc,char,at,0,last,desc,else,if,param,desc,equals,last,desc,code,flow,insert,check,cast,mv,param,desc,cf,exit,compilation,scope
SpelNodeImpl -> protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc);1530174524;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		String lastDesc = cf.lastDescriptor()__		Assert.state(lastDesc != null, "No last descriptor")__		boolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc)__		_		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0))__		}_		else if (paramDesc.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc)__		}_		else if (!paramDesc.equals(lastDesc)) {_			_			CodeFlow.insertCheckCast(mv, paramDesc)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;protected,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,desc,cf,enter,compilation,scope,argument,generate,code,mv,cf,string,last,desc,cf,last,descriptor,assert,state,last,desc,null,no,last,descriptor,boolean,primitive,on,stack,code,flow,is,primitive,last,desc,if,primitive,on,stack,param,desc,char,at,0,l,code,flow,insert,box,if,necessary,mv,last,desc,char,at,0,else,if,param,desc,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,desc,char,at,0,last,desc,else,if,param,desc,equals,last,desc,code,flow,insert,check,cast,mv,param,desc,cf,exit,compilation,scope
SpelNodeImpl -> protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc);1545740520;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		String lastDesc = cf.lastDescriptor()__		Assert.state(lastDesc != null, "No last descriptor")__		boolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc)__		_		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0))__		}_		else if (paramDesc.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc)__		}_		else if (!paramDesc.equals(lastDesc)) {_			_			CodeFlow.insertCheckCast(mv, paramDesc)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;protected,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,desc,cf,enter,compilation,scope,argument,generate,code,mv,cf,string,last,desc,cf,last,descriptor,assert,state,last,desc,null,no,last,descriptor,boolean,primitive,on,stack,code,flow,is,primitive,last,desc,if,primitive,on,stack,param,desc,char,at,0,l,code,flow,insert,box,if,necessary,mv,last,desc,char,at,0,else,if,param,desc,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,desc,char,at,0,last,desc,else,if,param,desc,equals,last,desc,code,flow,insert,check,cast,mv,param,desc,cf,exit,compilation,scope
SpelNodeImpl -> protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc);1548712256;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		String lastDesc = cf.lastDescriptor()__		Assert.state(lastDesc != null, "No last descriptor")__		boolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc)__		_		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0))__		}_		else if (paramDesc.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc)__		}_		else if (!paramDesc.equals(lastDesc)) {_			_			CodeFlow.insertCheckCast(mv, paramDesc)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;protected,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,desc,cf,enter,compilation,scope,argument,generate,code,mv,cf,string,last,desc,cf,last,descriptor,assert,state,last,desc,null,no,last,descriptor,boolean,primitive,on,stack,code,flow,is,primitive,last,desc,if,primitive,on,stack,param,desc,char,at,0,l,code,flow,insert,box,if,necessary,mv,last,desc,char,at,0,else,if,param,desc,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,desc,char,at,0,last,desc,else,if,param,desc,equals,last,desc,code,flow,insert,check,cast,mv,param,desc,cf,exit,compilation,scope
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... classes);1545740520;Return {@code true} if the next child is one of the specified classes.;protected boolean nextChildIs(Class<?>... classes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> peerClass = peers[i + 1].getClass()__					for (Class<?> desiredClass : classes) {_						if (peerClass == desiredClass) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,code,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,classes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,peer,class,peers,i,1,get,class,for,class,desired,class,classes,if,peer,class,desired,class,return,true,return,false,return,false
SpelNodeImpl -> protected boolean nextChildIs(Class<?>... classes);1548712256;Return {@code true} if the next child is one of the specified classes.;protected boolean nextChildIs(Class<?>... classes) {_		if (this.parent != null) {_			SpelNodeImpl[] peers = this.parent.children__			for (int i = 0, max = peers.length_ i < max_ i++) {_				if (this == peers[i]) {_					if (i + 1 >= max) {_						return false__					}_					Class<?> peerClass = peers[i + 1].getClass()__					for (Class<?> desiredClass : classes) {_						if (peerClass == desiredClass) {_							return true__						}_					}_					return false__				}_			}_		}_		return false__	};return,code,true,if,the,next,child,is,one,of,the,specified,classes;protected,boolean,next,child,is,class,classes,if,this,parent,null,spel,node,impl,peers,this,parent,children,for,int,i,0,max,peers,length,i,max,i,if,this,peers,i,if,i,1,max,return,false,class,peer,class,peers,i,1,get,class,for,class,desired,class,classes,if,peer,class,desired,class,return,true,return,false,return,false
