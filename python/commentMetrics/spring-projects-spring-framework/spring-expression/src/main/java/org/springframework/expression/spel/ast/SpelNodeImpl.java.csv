commented;modifiers;parameterAmount;loc;comment;code
true;protected;1;20;/**  * Return {@code true} if the next child is one of the specified classes.  */ ;/**  * Return {@code true} if the next child is one of the specified classes.  */ protected boolean nextChildIs(Class<?>... classes) {     if (this.parent != null) {         SpelNodeImpl[] peers = this.parent.children.         for (int i = 0, max = peers.length. i < max. i++) {             if (this == peers[i]) {                 if (i + 1 >= max) {                     return false.                 }                 Class<?> peerClass = peers[i + 1].getClass().                 for (Class<?> desiredClass : classes) {                     if (peerClass == desiredClass) {                         return true.                     }                 }                 return false.             }         }     }     return false. }
false;public,final;1;5;;@Override @Nullable public final Object getValue(ExpressionState expressionState) throws EvaluationException {     return getValueInternal(expressionState).getValue(). }
false;public,final;1;4;;@Override public final TypedValue getTypedValue(ExpressionState expressionState) throws EvaluationException {     return getValueInternal(expressionState). }
true;public;1;4;// by default Ast nodes are not writable ;// by default Ast nodes are not writable @Override public boolean isWritable(ExpressionState expressionState) throws EvaluationException {     return false. }
false;public;2;4;;@Override public void setValue(ExpressionState expressionState, @Nullable Object newValue) throws EvaluationException {     throw new SpelEvaluationException(getStartPosition(), SpelMessage.SETVALUE_NOT_SUPPORTED, getClass()). }
false;public;1;4;;@Override public SpelNode getChild(int index) {     return this.children[index]. }
false;public;0;4;;@Override public int getChildCount() {     return this.children.length. }
false;public;1;8;;@Override @Nullable public Class<?> getObjectClass(@Nullable Object obj) {     if (obj == null) {         return null.     }     return (obj instanceof Class ? ((Class<?>) obj) : obj.getClass()). }
false;public;0;4;;@Override public int getStartPosition() {     return this.startPos. }
false;public;0;4;;@Override public int getEndPosition() {     return this.endPos. }
true;public;0;3;/**  * Check whether a node can be compiled to bytecode. The reasoning in each node may  * be different but will typically involve checking whether the exit type descriptor  * of the node is known and any relevant child nodes are compilable.  * @return {@code true} if this node can be compiled to bytecode  */ ;/**  * Check whether a node can be compiled to bytecode. The reasoning in each node may  * be different but will typically involve checking whether the exit type descriptor  * of the node is known and any relevant child nodes are compilable.  * @return {@code true} if this node can be compiled to bytecode  */ public boolean isCompilable() {     return false. }
true;public;2;3;/**  * Generate the bytecode for this node into the supplied visitor. Context info about  * the current expression being compiled is available in the codeflow object, e.g.  * including information about the type of the object currently on the stack.  * @param mv the ASM MethodVisitor into which code should be generated  * @param cf a context object with info about what is on the stack  */ ;/**  * Generate the bytecode for this node into the supplied visitor. Context info about  * the current expression being compiled is available in the codeflow object, e.g.  * including information about the type of the object currently on the stack.  * @param mv the ASM MethodVisitor into which code should be generated  * @param cf a context object with info about what is on the stack  */ public void generateCode(MethodVisitor mv, CodeFlow cf) {     throw new IllegalStateException(getClass().getName() + " has no generateCode(..) method"). }
false;public;0;4;;@Nullable public String getExitDescriptor() {     return this.exitTypeDescriptor. }
false;protected,final;2;4;;@Nullable protected final <T> T getValue(ExpressionState state, Class<T> desiredReturnType) throws EvaluationException {     return ExpressionUtils.convertTypedValue(state.getEvaluationContext(), getValueInternal(state), desiredReturnType). }
false;protected;1;3;;protected ValueRef getValueRef(ExpressionState state) throws EvaluationException {     throw new SpelEvaluationException(getStartPosition(), SpelMessage.NOT_ASSIGNABLE, toStringAST()). }
false;public,abstract;1;1;;public abstract TypedValue getValueInternal(ExpressionState expressionState) throws EvaluationException.
true;protected,static;4;53;/**  * Generate code that handles building the argument values for the specified method.  * This method will take account of whether the invoked method is a varargs method  * and if it is then the argument values will be appropriately packaged into an array.  * @param mv the method visitor where code should be generated  * @param cf the current codeflow  * @param member the method or constructor for which arguments are being setup  * @param arguments the expression nodes for the expression supplied argument values  */ ;/**  * Generate code that handles building the argument values for the specified method.  * This method will take account of whether the invoked method is a varargs method  * and if it is then the argument values will be appropriately packaged into an array.  * @param mv the method visitor where code should be generated  * @param cf the current codeflow  * @param member the method or constructor for which arguments are being setup  * @param arguments the expression nodes for the expression supplied argument values  */ protected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {     String[] paramDescriptors = null.     boolean isVarargs = false.     if (member instanceof Constructor) {         Constructor<?> ctor = (Constructor<?>) member.         paramDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes()).         isVarargs = ctor.isVarArgs().     } else {         // Method         Method method = (Method) member.         paramDescriptors = CodeFlow.toDescriptors(method.getParameterTypes()).         isVarargs = method.isVarArgs().     }     if (isVarargs) {         // The final parameter may or may not need packaging into an array, or nothing may         // have been passed to satisfy the varargs and so something needs to be built.         // Current supplied argument being processed         int p = 0.         int childCount = arguments.length.         // Fulfill all the parameter requirements except the last one         for (p = 0. p < paramDescriptors.length - 1. p++) {             generateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p]).         }         SpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1]).         String arrayType = paramDescriptors[paramDescriptors.length - 1].         // form to be passed to the method         if (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {             generateCodeForArgument(mv, cf, lastChild, paramDescriptors[p]).         } else {             // trim the leading '[', may leave other '['             arrayType = arrayType.substring(1).             // build array big enough to hold remaining arguments             CodeFlow.insertNewArrayCode(mv, childCount - p, arrayType).             // Package up the remaining arguments into the array             int arrayindex = 0.             while (p < childCount) {                 SpelNodeImpl child = arguments[p].                 mv.visitInsn(DUP).                 CodeFlow.insertOptimalLoad(mv, arrayindex++).                 generateCodeForArgument(mv, cf, child, arrayType).                 CodeFlow.insertArrayStore(mv, arrayType).                 p++.             }         }     } else {         for (int i = 0. i < paramDescriptors.length. i++) {             generateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i]).         }     } }
true;protected,static;4;19;/**  * Ask an argument to generate its bytecode and then follow it up  * with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.  */ ;/**  * Ask an argument to generate its bytecode and then follow it up  * with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.  */ protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {     cf.enterCompilationScope().     argument.generateCode(mv, cf).     String lastDesc = cf.lastDescriptor().     Assert.state(lastDesc != null, "No last descriptor").     boolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc).     // Check if need to box it for the method reference?     if (primitiveOnStack && paramDesc.charAt(0) == 'L') {         CodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0)).     } else if (paramDesc.length() == 1 && !primitiveOnStack) {         CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc).     } else if (!paramDesc.equals(lastDesc)) {         // This would be unnecessary in the case of subtyping (e.g. method takes Number but Integer passed in)         CodeFlow.insertCheckCast(mv, paramDesc).     }     cf.exitCompilationScope(). }
